(self.webpackChunktradingview = self.webpackChunktradingview || []).push([[1297], {
  20041: e => {
    e.exports = {};
  },
  17192: e => {
    e.exports = {};
  },
  69681: e => {
    e.exports = {};
  },
  73052: e => {
    e.exports = {};
  },
  15216: e => {
    e.exports = {
      "tv-spinner__container-rotate": "tv-spinner__container-rotate-aLqboHuu"
    };
  },
  10048: e => {
    e.exports = {
      container: "container-B8mkOfAH",
      inner: "inner-B8mkOfAH",
      "border-left": "border-left-B8mkOfAH",
      "border-right": "border-right-B8mkOfAH",
      "border-top": "border-top-B8mkOfAH",
      "border-bottom": "border-bottom-B8mkOfAH",
      "top-right-radius": "top-right-radius-B8mkOfAH",
      "top-left-radius": "top-left-radius-B8mkOfAH",
      "bottom-right-radius": "bottom-right-radius-B8mkOfAH",
      "bottom-left-radius": "bottom-left-radius-B8mkOfAH"
    };
  },
  20350: e => {
    e.exports = {
      screen: "screen-otjoFNF2",
      fade: "fade-otjoFNF2",
      screenfade: "screenfade-otjoFNF2"
    };
  },
  26572: e => {
    e.exports = {};
  },
  98714: e => {
    e.exports = {
      css_value_currency_label_radius: "4",
      css_wrapper_margin: "4",
      css_row_left_right_padding: "3",
      css_fade_height: "10",
      "price-axis-currency-label-wrapper": "price-axis-currency-label-wrapper-y5H41VPj",
      hidden: "hidden-y5H41VPj",
      "price-axis-currency-label": "price-axis-currency-label-y5H41VPj",
      row: "row-y5H41VPj",
      expanded: "expanded-y5H41VPj",
      "price-axis-currency-label-arrow-down": "price-axis-currency-label-arrow-down-y5H41VPj",
      "price-axis-currency-label-text": "price-axis-currency-label-text-y5H41VPj"
    };
  },
  82815: e => {
    e.exports = {};
  },
  60070: e => {
    e.exports = {};
  },
  99647: e => {
    e.exports = {
      "css-value-chart-controls-bar-height-with-border": "39px",
      "css-value-chart-controls-bar-border": "1px"
    };
  },
  43882: e => {
    e.exports = {};
  },
  95047: e => {
    e.exports = {};
  },
  25043: e => {
    e.exports = {};
  },
  91751: e => {
    e.exports = {
      "common-tooltip": "common-tooltip-EJBD96zX",
      "common-tooltip--hidden": "common-tooltip--hidden-EJBD96zX",
      "common-tooltip--horizontal": "common-tooltip--horizontal-EJBD96zX",
      "common-tooltip--farther": "common-tooltip--farther-EJBD96zX",
      "common-tooltip--vertical": "common-tooltip--vertical-EJBD96zX",
      "common-tooltip-farther": "common-tooltip-farther-EJBD96zX",
      "common-tooltip--direction_normal": "common-tooltip--direction_normal-EJBD96zX",
      "common-tooltip__body": "common-tooltip__body-EJBD96zX",
      "common-tooltip__button-container": "common-tooltip__button-container-EJBD96zX",
      "common-tooltip__body--no-buttons": "common-tooltip__body--no-buttons-EJBD96zX",
      "common-tooltip__button": "common-tooltip__button-EJBD96zX",
      "common-tooltip--direction_reversed": "common-tooltip--direction_reversed-EJBD96zX",
      "common-tooltip__ear-holder": "common-tooltip__ear-holder-EJBD96zX",
      "common-tooltip__ear-holder--below": "common-tooltip__ear-holder--below-EJBD96zX",
      "common-tooltip__ear-holder--above": "common-tooltip__ear-holder--above-EJBD96zX",
      "common-tooltip__ear-holder--before": "common-tooltip__ear-holder--before-EJBD96zX",
      "common-tooltip__ear-holder--after": "common-tooltip__ear-holder--after-EJBD96zX",
      "common-tooltip__body--with-hotkey": "common-tooltip__body--with-hotkey-EJBD96zX",
      "common-tooltip__body--width_wide": "common-tooltip__body--width_wide-EJBD96zX",
      "common-tooltip__body--width_narrow": "common-tooltip__body--width_narrow-EJBD96zX",
      "common-tooltip__body--no-padding": "common-tooltip__body--no-padding-EJBD96zX",
      "common-tooltip__hotkey-block": "common-tooltip__hotkey-block-EJBD96zX",
      "common-tooltip__hotkey-block--divider": "common-tooltip__hotkey-block--divider-EJBD96zX",
      "common-tooltip__hotkey-text": "common-tooltip__hotkey-text-EJBD96zX",
      "common-tooltip__hotkey-button": "common-tooltip__hotkey-button-EJBD96zX",
      "common-tooltip__plus-sign": "common-tooltip__plus-sign-EJBD96zX"
    };
  },
  56616: (e, t, i) => {
    "use strict";

    function s() {
      return navigator.clipboard;
    }
    function o(e) {
      return n(e, null);
    }
    function n(e, t) {
      const i = e.files && e.files.length > 0;
      if (!i && t && t.eventPhase > 0) {
        r(t, e);
        return Promise.resolve();
      }
      if (!i) {
        let t = false;
        const i = i => {
          i.stopImmediatePropagation();
          r(i, e);
          t = true;
        };
        try {
          document.addEventListener("copy", i, true);
          document.execCommand("copy");
        } finally {
          document.removeEventListener("copy", i, true);
        }
        if (t) {
          return Promise.resolve();
        }
      }
      return async function (e) {
        const t = s();
        if (!t || !t.write || !window.ClipboardItem) {
          throw new DOMException("ClipboardApi is not supported", "NotSupportedError");
        }
        const i = {};
        for (const t of e.files || []) {
          i[t.type] = t;
        }
        if (e.text) {
          i["text/plain"] = e.text;
        }
        if (e.html) {
          i["text/html"] = e.html;
        }
        return t.write([new window.ClipboardItem(i)]);
      }(e);
    }
    function r(e, t) {
      e.preventDefault();
      const i = e.clipboardData;
      if (t.text) {
        i.setData("text/plain", t.text);
      }
      if (t.html) {
        i.setData("text/html", t.html);
      }
    }
    async function a(e, t) {
      const i = s();
      if (t === "text/plain" && !i.write) {
        const t = await e;
        return i.writeText(await t.text());
      }
      if (!i || !i.write || !window.ClipboardItem) {
        throw new DOMException("ClipboardApi is not supported", "NotSupportedError");
      }
      let o = null;
      try {
        o = new window.ClipboardItem({
          [t]: e
        });
      } catch (i) {
        o = new window.ClipboardItem({
          [t]: await e
        });
      }
      if (o) {
        return i.write([o]);
      }
      throw new Error("ClipboardApi is not supported");
    }
    i.d(t, {
      copyToClipboard: () => o,
      getClipboard: () => s,
      writeImpl: () => n,
      writePromiseUsingApi: () => a
    });
  },
  93132: (e, t, i) => {
    "use strict";

    i.d(t, {
      ActionGroup: () => o
    });
    class s {
      constructor(e, t) {
        this._group = e;
        const {
          hotkey: i,
          handler: s,
          desc: o,
          isDisabled: n,
          element: r = null,
          isRepeatAccepted: a = false
        } = t;
        this.hotkey = i;
        this.handler = s;
        this.desc = o;
        this.element = r;
        this.isRepeatAccepted = a;
        this.isDisabled = n ? typeof n == "function" ? n : () => true : () => false;
      }
      destroy() {
        if (this._group) {
          this._group.remove(this);
          this._group = null;
        }
      }
    }
    class o {
      constructor(e, t) {
        this._actions = new Map();
        this._manager = e;
        this.order = t?.order ?? 0;
        this.modal = !!t && !!t.modal;
        if (t) {
          this.desc = t.desc;
        }
        if (t && t.isDisabled) {
          if (typeof t.isDisabled == "function") {
            this.isDisabled = t.isDisabled;
          } else {
            this.isDisabled = () => true;
          }
        } else {
          this.isDisabled = () => false;
        }
        this._manager.registerGroup(this);
      }
      add(e) {
        let t = this._actions.get(e.hotkey);
        if (!t) {
          t = [];
          this._actions.set(e.hotkey, t);
        }
        const i = new s(this, e);
        t.push(i);
        return i;
      }
      remove(e) {
        const t = this._actions.get(e.hotkey);
        if (!t) {
          return;
        }
        const i = t.findIndex(t => t === e);
        if (i >= 0) {
          if (t.length === 1) {
            this._actions.delete(e.hotkey);
          } else {
            t.splice(i, 1);
          }
        }
      }
      handleHotkey(e, t) {
        const i = this._actions.get(e);
        if (!i) {
          return false;
        }
        for (const s of i) {
          if ((!s.element || t.target && s.element.contains(t.target)) && !s.isDisabled(t)) {
            if (!t.repeat || !!s.isRepeatAccepted) {
              s.handler(t);
              this._callMatchedHotkeyHandler(e);
            }
            t.preventDefault();
            return true;
          }
        }
        return false;
      }
      promote() {
        this._manager.promoteGroup(this);
      }
      destroy() {
        for (const [, e] of this._actions) {
          for (const t of e) {
            t.destroy();
          }
        }
        this._actions.clear();
        this._manager.unregisterGroup(this);
      }
      static setMatchedHotkeyHandler(e) {
        o._matchedHotkeyHandler = e;
      }
      _callMatchedHotkeyHandler(e) {
        if (o._matchedHotkeyHandler) {
          o._matchedHotkeyHandler(e);
        }
      }
    }
  },
  43222: (e, t, i) => {
    "use strict";

    i.d(t, {
      ACTION_API_GROUP_ORDER: () => _,
      createGroup: () => p,
      keyboardPressedKeysState: () => u,
      pressedKeys: () => d,
      registerWindow: () => m
    });
    var s = i(91679);
    var o = i(3343);
    var n = i(54717);
    class r {
      constructor(e, t) {
        this.modifiers = e;
        this.code = t;
      }
      altOrOptionCode() {
        return this.code === "AltLeft" || this.code === "AltRight";
      }
      controlOrMetaCode() {
        if (o.isMacKeyboard) {
          return this.code === "MetaLeft" || this.code === "MetaRight" || this.code === "OSLeft" || this.code === "OSRight";
        } else {
          return this.code === "ControlLeft" || this.code === "ControlRight";
        }
      }
    }
    class a extends s.WatchedValue {
      setValue(e, t) {
        const i = this.value();
        if (t || i === undefined || i.code !== e.code || i.modifiers !== e.modifiers) {
          super.setValue(e);
        }
      }
    }
    function l(e, t) {
      return e.order + (e.modal ? t : 0);
    }
    var c = i(93132);
    const h = new class {
      constructor() {
        this._groups = [];
        this._pressedKeys = new s.WatchedValue(0);
        this._keyboardPressedKeysState = new a(new r(0));
        this._keyDownListener = e => {
          if (e.defaultPrevented) {
            return;
          }
          const t = (0, o.hashFromEvent)(e);
          this._pressedKeys.setValue(t);
          this._keyboardPressedKeysState.setValue(new r((0, o.modifiersFromEvent)(e), e.code));
          if (!(0, n.isNativeUIInteraction)(t, e.target)) {
            for (let i = this._groups.length; i-- > 0;) {
              const s = this._groups[i];
              if (!s.isDisabled()) {
                if (s.handleHotkey(t, e)) {
                  return;
                }
                if (s.modal) {
                  return;
                }
              }
            }
          }
        };
        this._keyUpListener = e => {
          const t = (0, o.hashFromEvent)(e);
          this._pressedKeys.setValue(t);
          this._keyboardPressedKeysState.setValue(new r((0, o.modifiersFromEvent)(e), ""));
        };
        this._blurEvent = () => {
          this._pressedKeys.setValue(0);
          this._keyboardPressedKeysState.setValue(new r(0, ""));
        };
        this._mouseEvent = e => {
          const t = (0, o.modifiersFromEvent)(e);
          const i = (this._pressedKeys.value() ?? 0) & 255;
          this._pressedKeys.setValue(t | i);
        };
      }
      listen(e) {
        e.addEventListener("keydown", this._keyDownListener);
        e.addEventListener("keyup", this._keyUpListener);
        e.addEventListener("blur", this._blurEvent);
        e.addEventListener("mousemove", this._mouseEvent);
      }
      unlisten(e) {
        e.removeEventListener("keydown", this._keyDownListener);
        e.removeEventListener("keyup", this._keyUpListener);
        e.removeEventListener("blur", this._blurEvent);
        e.removeEventListener("mousemove", this._mouseEvent);
      }
      registerGroup(e) {
        this._groups.push(e);
        this.sortGroups();
      }
      unregisterGroup(e) {
        for (let t = this._groups.length; t--;) {
          if (this._groups[t] === e) {
            this._groups.splice(t, 1);
          }
        }
      }
      promoteGroup(e) {
        const t = this._getModalOrderEpoch();
        const i = l(e, t);
        let s = this._groups.findIndex(e => l(e, t) === i);
        let o = 0;
        while (s < this._groups.length && l(this._groups[s], t) === i) {
          const n = this._groups[s];
          if (n === e) {
            o = 1;
          } else if (l(n, t) === i) {
            this._groups[s - o] = n;
          }
          s++;
        }
        this._groups[s - o] = e;
      }
      pressedKeys() {
        return this._pressedKeys.readonly();
      }
      keyboardPressedKeysState() {
        return this._keyboardPressedKeysState.readonly();
      }
      sortGroups() {
        const e = this._getModalOrderEpoch();
        this._groups.sort((t, i) => l(i, e) - l(t, e));
      }
      _getMinOrder() {
        return this._groups.reduce((e, t) => Math.min(e, t.order), 0);
      }
      _getModalOrderEpoch() {
        return (Math.abs(this._getMinOrder()) - 1) * -2;
      }
    }();
    const d = h.pressedKeys();
    const u = h.keyboardPressedKeysState();
    const _ = -100;
    function p(e) {
      return new c.ActionGroup(h, e);
    }
    function m(e) {
      h.listen(e);
    }
  },
  3343: (e, t, i) => {
    "use strict";

    i.d(t, {
      Modifiers: () => r,
      hashFromEvent: () => l,
      humanReadableHash: () => u,
      humanReadableModifiers: () => c,
      isMacKeyboard: () => n,
      modifiersFromEvent: () => a
    });
    var s;
    var o = i(75774);
    (function (e) {
      e[e.KeyCode = 255] = "KeyCode";
      e[e.Control = 256] = "Control";
      e[e.Alt = 512] = "Alt";
      e[e.Shift = 1024] = "Shift";
      e[e.Meta = 2048] = "Meta";
    })(s ||= {});
    const n = o.isMac || o.isIOS;
    var r;
    function a(e) {
      let t = 0;
      if (e.shiftKey) {
        t += 1024;
      }
      if (e.altKey) {
        t += 512;
      }
      if (e.ctrlKey) {
        t += 256;
      }
      if (e.metaKey) {
        t += 2048;
      }
      return t;
    }
    function l(e) {
      return a(e) | e.keyCode;
    }
    (function (e) {
      e[e.None = 0] = "None";
      e[e.Alt = 512] = "Alt";
      e[e.Shift = 1024] = "Shift";
      e[e.Mod = n ? 2048 : 256] = "Mod";
      e[e.Control = 256] = "Control";
      e[e.Meta = 2048] = "Meta";
    })(r ||= {});
    function c(e, t = !n) {
      let i = "";
      if (e & 256) {
        i += _(n ? "^" : "Ctrl", t);
      }
      if (e & 512) {
        i += _(n ? "⌥" : "Alt", t);
      }
      if (e & 1024) {
        i += _(n ? "⇧" : "Shift", t);
      }
      if (e & 2048) {
        i += _(n ? "⌘" : "Win", t);
      }
      return i;
    }
    const h = {
      9: "⇥",
      13: "↵",
      27: "Esc",
      8: n ? "⌫" : "Backspace",
      32: "Space",
      35: "End",
      36: "Home",
      37: "←",
      38: "↑",
      39: "→",
      40: "↓",
      45: "Ins",
      46: "Del",
      188: ",",
      191: "/"
    };
    const d = {
      9: "Tab",
      13: "Enter",
      27: "Esc",
      8: "Backspace",
      32: "Space",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Ins",
      46: "Del",
      188: ",",
      191: "/"
    };
    for (let e = 1; e <= 16; e++) {
      h[e + 111] = `F${e}`;
      d[e + 111] = `F${e}`;
    }
    function u(e) {
      let t = c(e);
      const i = e & 255;
      t += i in h ? h[i] : String.fromCharCode(i);
      return t;
    }
    function _(e, t) {
      return `${e}${t ? " + " : n ? " " : ""}`;
    }
  },
  54717: (e, t, i) => {
    "use strict";

    i.d(t, {
      isNativeUIInteraction: () => n,
      isTextEditingField: () => o
    });
    var s = i(3343);
    function o(e) {
      if (e.tagName === "INPUT") {
        const t = e.type;
        return t === "text" || t === "email" || t === "number" || t === "password" || t === "search" || t === "tel" || t === "url";
      }
      return e.tagName === "TEXTAREA" || e.isContentEditable;
    }
    function n(e, t) {
      if (!t) {
        return false;
      }
      const i = e & 255;
      if (i === 27 || i >>> 4 == 7) {
        return false;
      }
      switch (e ^ i) {
        case s.Modifiers.Alt:
          return (i === 38 || i === 40) && t.tagName === "SELECT" || o(t);
        case s.Modifiers.Alt + s.Modifiers.Shift:
          return o(t);
        case s.Modifiers.Mod:
          if (i === 67 || !s.isMacKeyboard && i === 45) {
            const e = t.ownerDocument && t.ownerDocument.getSelection();
            if (e && !e.isCollapsed) {
              return true;
            }
          }
          return o(t);
        case s.Modifiers.Mod + s.Modifiers.Shift:
          return i >= 33 && i <= 40 && o(t);
        case s.Modifiers.Shift:
        case 0:
          if (i === 9) {
            return !!t.ownerDocument && t !== t.ownerDocument.body && t !== t.ownerDocument.documentElement;
          } else {
            return (!function (e) {
              if (e.tagName === "BUTTON") {
                return true;
              }
              if (e.tagName === "INPUT") {
                const t = e.type;
                if (t === "submit" || t === "button" || t === "reset" || t === "checkbox" || t === "radio") {
                  return true;
                }
              }
              return false;
            }(t) || i === 13 || i === 32 || i === 9) && ("form" in t || t.isContentEditable);
          }
      }
      return false;
    }
  },
  7029: (e, t, i) => {
    "use strict";

    i.d(t, {
      t: () => s
    });
    const s = i.i18next;
  },
  19625: (e, t, i) => {
    "use strict";

    i.d(t, {
      colorsPalette: () => d,
      getHexColorByName: () => u
    });
    var s = i(23420);
    var o = i(579);
    var n = i(50151);
    const r = {
      ...s,
      ...o
    };
    const a = {};
    const l = Object.keys(r).length;
    const c = /^#(([a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i;
    function h(e, t = [], i = r) {
      const s = i[e];
      if (!s) {
        return null;
      }
      if (c.test(s)) {
        return s;
      }
      const o = s;
      t.push(e);
      if (t.indexOf(o) !== -1) {
        console.warn("Colors definitions cycled");
        return s;
      } else if (t.length > l) {
        console.warn("Too many variables-link in HEX-color search: " + t[0]);
        return null;
      } else {
        return h(o, t, i);
      }
    }
    Object.keys(r).forEach(e => {
      const t = h(e);
      a[e] = (0, n.ensureNotNull)(t);
    });
    const d = a;
    function u(e, t = d) {
      const i = t[e];
      if (!i) {
        if (c.test(e)) {
          return e;
        }
        throw new Error("No such color " + e);
      }
      return i;
    }
  },
  74991: (e, t, i) => {
    "use strict";

    i.d(t, {
      CubicBezier: () => n,
      dur: () => s,
      easingFunc: () => o
    });
    const s = 350;
    const o = {
      linear: e => e,
      easeInQuad: e => e * e,
      easeOutQuad: e => e * (2 - e),
      easeInOutQuad: e => e < 0.5 ? e * 2 * e : (4 - e * 2) * e - 1,
      easeInCubic: e => e * e * e,
      easeOutCubic: e => --e * e * e + 1,
      easeInOutCubic: e => e < 0.5 ? e * 4 * e * e : (e - 1) * (e * 2 - 2) * (e * 2 - 2) + 1,
      easeInQuart: e => e * e * e * e,
      easeOutQuart: e => 1 - --e * e * e * e,
      easeInOutQuart: e => e < 0.5 ? e * 8 * e * e * e : 1 - --e * 8 * e * e * e,
      easeInQuint: e => e * e * e * e * e,
      easeOutQuint: e => 1 + --e * e * e * e * e,
      easeInOutQuint: e => e < 0.5 ? e * 16 * e * e * e * e : 1 + --e * 16 * e * e * e * e
    };
    class n {
      constructor(e, t, i, s) {
        this._mX1 = e;
        this._mY1 = t;
        this._mX2 = i;
        this._mY2 = s;
      }
      easingFunc(e) {
        if (this._mX1 === this._mY1 && this._mX2 === this._mY2) {
          return e;
        } else {
          return this._calcBezier(this._getTForX(e));
        }
      }
      _a(e, t) {
        return 1 - t * 3 + e * 3;
      }
      _b(e, t) {
        return t * 3 - e * 6;
      }
      _c(e) {
        return e * 3;
      }
      _calcBezier(e) {
        return ((this._a(this._mY1, this._mY2) * e + this._b(this._mY1, this._mY2)) * e + this._c(this._mY1)) * e;
      }
      _getSlope(e) {
        return this._a(this._mX1, this._mX2) * 3 * e * e + this._b(this._mX1, this._mX2) * 2 * e + this._c(this._mX1);
      }
      _getTForX(e) {
        let t = e;
        for (let i = 0; i < 4; ++i) {
          const i = this._getSlope(t);
          if (i === 0) {
            return t;
          }
          t -= (this._calcBezier(t) - e) / i;
        }
        return t;
      }
    }
  },
  58096: (e, t, i) => {
    "use strict";

    i.d(t, {
      DEFAULT_SIZE: () => s,
      spinnerSizeMap: () => o
    });
    const s = "large";
    const o = {
      mini: "xsmall",
      xxsmall: "xxsmall",
      xsmall: "xsmall",
      small: "small",
      medium: "medium",
      large: "large"
    };
  },
  34811: (e, t, i) => {
    "use strict";

    i.d(t, {
      FOCUS_TRAP_DATA_ATTRIBUTE: () => s
    });
    const s = "data-focus-trap";
  },
  15754: (e, t, i) => {
    "use strict";

    i.d(t, {
      FOCUSABLE_SELECTOR: () => o,
      createScopedVisibleElementFilter: () => h,
      getActiveElementSelectors: () => c,
      isInertRoot: () => a,
      isVisibilityVisible: () => n
    });
    const s = ["button", "fieldset", "optgroup", "option", "select", "textarea", "input"];
    const o = ["button", "input", "select", "textarea", "a[href]", "audio[controls]", "video[controls]", "[tabindex=\"0\"]", "[contenteditable=\"true\"]"].map(e => s.includes(e) ? `${e}:not(:disabled)` : e).map(e => `${e}:not([tabindex="-1"])`).join(",");
    function n(e) {
      return getComputedStyle(e).visibility === "visible";
    }
    function r(e, t) {
      if (e.matches("[inert],[inert] *")) {
        return true;
      }
      let i = e;
      while (i !== t && i !== null) {
        if (l(i)) {
          return true;
        }
        i = i.parentElement;
      }
      return false;
    }
    function a(e) {
      return e.matches("[inert]") || l(e);
    }
    function l(e) {
      return getComputedStyle(e).display === "none";
    }
    function c() {
      return o;
    }
    function h(e) {
      return t => n(t) && !r(t, e);
    }
  },
  76460: (e, t, i) => {
    "use strict";

    function s(e) {
      return e.detail === 0;
    }
    i.d(t, {
      isKeyboardClick: () => s
    });
  },
  91682: (e, t, i) => {
    "use strict";

    i.d(t, {
      capitalizeFirstLetterInWord: () => u,
      decodeHTMLEntities: () => l,
      getFirstSegmentOrCodePointString: () => _,
      htmlEscape: () => c,
      removeSpaces: () => d,
      removeTags: () => h
    });
    const s = /[<"'&>]/g;
    const o = e => `&#${e.charCodeAt(0)};`;
    const n = {
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": "\"",
      "&apos;": "'",
      "&amp;": "&",
      "&#60;": "<",
      "&#62;": ">",
      "&#34;": "\"",
      "&#39;": "'",
      "&#039;": "'",
      "&#38;": "&"
    };
    const r = Object.assign({}, ...Object.entries(n).map(([e, t]) => ({
      [t]: e
    })));
    const a = new RegExp(Object.keys(n).join("|"), "g");
    new RegExp(Object.keys(r).join("|"), "g");
    function l(e) {
      return e.replace(a, e => n[e] || e);
    }
    function c(e) {
      return e.replace(s, o);
    }
    function h(e = "") {
      return e.replace(/(<([^>]+)>)/gi, "");
    }
    function d(e = "") {
      return e.replace(/\s+/g, "");
    }
    function u(e = "") {
      return e.replace(/\b\w/g, e => e.toUpperCase());
    }
    function _(e) {
      const t = Intl.Segmenter;
      if (t) {
        const i = new t(undefined, {
          granularity: "grapheme"
        });
        const [{
          segment: s
        } = {
            segment: null
          }] = i.segment(e);
        return s?.toUpperCase() ?? null;
      }
      {
        const t = e.codePointAt(0);
        if (t) {
          return String.fromCodePoint(t).toUpperCase();
        } else {
          return null;
        }
      }
    }
  },
  94194: (e, t, i) => {
    "use strict";

    i.d(t, {
      getTooltipData: () => o,
      setTooltipData: () => n
    });
    const s = new WeakMap();
    function o(e, t) {
      const i = s.get(e);
      if (i instanceof Function) {
        return i(t);
      } else {
        return i && i[t];
      }
    }
    function n(e, t, i) {
      if (i instanceof Function) {
        s.set(e, i);
        return;
      }
      const o = s.get(e);
      const n = o === undefined || o instanceof Function ? {} : o;
      n[t] = i;
      s.set(e, n);
    }
  },
  61814: (e, t, i) => {
    "use strict";

    i.d(t, {
      hotKeyDeserialize: () => n,
      hotKeySerialize: () => o
    });
    var s = i(91682);
    function o(e) {
      return (0, s.htmlEscape)(JSON.stringify(e));
    }
    function n(e) {
      return JSON.parse((0, s.decodeHTMLEntities)(e));
    }
  },
  38780: (e, t, i) => {
    "use strict";

    i.d(t, {
      hide: () => $,
      show: () => j,
      showOnElement: () => U
    });
    var s = i(32563);
    var o = i(50151);
    var n = i(26709);
    let r = 0;
    let a = 0;
    let l = 0;
    function c() {
      clearTimeout(r);
      clearTimeout(a);
      clearTimeout(l);
    }
    function h(e, t) {
      r = setTimeout(e, t);
    }
    const d = "tooltip-root-element";
    let u;
    function _() {
      const e = document.getElementById(d);
      if (e) {
        u = e;
      } else {
        u = document.createElement("div");
        u.id = d;
        document.body.appendChild(u);
      }
    }
    function p() {
      if (u) {
        u.innerHTML = "";
      }
    }
    if (document.readyState === "interactive") {
      _();
    } else {
      document.addEventListener("DOMContentLoaded", _);
    }
    var m = i(49481);
    var g = i(63273);
    i(21251);
    var f = i(14729);
    var y = i(9859);
    var v = i(49483);
    const S = {
      default: "",
      white: "theme-white",
      chart: "theme-chart",
      "round-shadow": "theme-round-shadow"
    };
    const b = Object.keys(S);
    var w;
    var C = i(94194);
    var P = i(61814);
    var T = i(91751);
    function x(e) {
      const t = function (e) {
        const t = e.hasAttribute("data-tooltip") ? e.getAttribute("data-tooltip") : e.getAttribute("title");
        if (t) {
          (0, C.setTooltipData)(e, "text", t);
          e.removeAttribute("title");
        }
        return (0, C.getTooltipData)(e, "text") || "";
      }(e);
      const i = e.getBoundingClientRect();
      const s = {
        h: i.height,
        w: i.width,
        x: i.left,
        y: i.top
      };
      const o = e.getAttribute("data-color-theme") || "";
      const n = e.classList.contains("common-tooltip-html");
      const r = parseInt(e.getAttribute("data-tooltip-delay") || "");
      const a = parseInt(e.getAttribute("data-tooltip-debounce") || "");
      let l = {
        type: "none"
      };
      if (t) {
        l = {
          type: n ? "html" : "text",
          data: t
        };
      }
      return {
        above: e.classList.contains("common-tooltip-above"),
        below: e.classList.contains("common-tooltip-below"),
        otl: e.classList.contains("common-tooltip-otl"),
        otr: e.classList.contains("common-tooltip-otr"),
        vertical: e.classList.contains("common-tooltip-vertical"),
        hotkey: e.getAttribute("data-tooltip-hotkey"),
        narrow: e.classList.contains("common-tooltip-narrow"),
        wide: e.classList.contains("common-tooltip-wide"),
        colorTheme: o,
        tooltipDelay: r,
        tooltipDebounce: a,
        rect: s,
        content: l,
        target: e
      };
    }
    function I(e) {
      const t = (0, o.ensureNotNull)(B).cloneNode(true);
      const i = N(t);
      const {
        content: s
      } = e;
      switch (s.type) {
        case "element":
          i.innerHTML = "";
          i.appendChild(s.data);
          break;
        case "html":
          i.innerHTML = s.data;
          break;
        case "text":
          if (e.hotkey) {
            const e = (0, o.ensureNotNull)(R).cloneNode(true);
            e.innerText = s.data;
            i.appendChild(e);
          } else {
            i.innerText = s.data;
          }
      }
      if (e.hotkey) {
        const t = s.type !== "none";
        const n = (0, o.ensureNotNull)(V).cloneNode(true);
        const r = (0, P.hotKeyDeserialize)(e.hotkey);
        const a = r.keys.map(e => `<span class="${T["common-tooltip__hotkey-button"]}">${e}</span>`);
        n.innerHTML = function (e, t) {
          const i = /{\d}|{hotkey_\d}/gi;
          return e.replace(i, e => {
            const i = Number(e.match(/\d/));
            return t[i];
          });
        }(r.text, a).replace(/\s\+\s/g, `<span class="${T["common-tooltip__plus-sign"]}">+</span>`);
        i.classList.add(T["common-tooltip__body--with-hotkey"]);
        if (t) {
          n.classList.add(T["common-tooltip__hotkey-block--divider"]);
        }
        i.appendChild(n);
      }
      t.addEventListener("contextmenu", f.preventDefault);
      return t;
    }
    function M(e, t) {
      const i = t.rect;
      if (!i) {
        return;
      }
      (function (e, t) {
        const i = b.includes(t) ? S[t] : "";
        e.classList.remove(...b.map(e => S[e]).filter(e => !!e));
        if (i && !e.classList.contains(i)) {
          e.classList.add(i);
        }
      })(e, t.colorTheme || "default");
      if (t.addClass) {
        e.classList.add(t.addClass);
      }
      const s = N(e);
      const o = e.querySelector(`.${T["common-tooltip__button-container"]}`);
      s.classList.toggle(T["common-tooltip__body--width_wide"], Boolean(t.wide));
      s.classList.toggle(T["common-tooltip__body--no-padding"], Boolean(t.noPadding));
      s.classList.toggle(T["common-tooltip__body--width_narrow"], Boolean(t.narrow));
      s.classList.toggle(T["common-tooltip__body--no-buttons"], true);
      s.style.left = L(0);
      s.style.width = L(s.clientWidth + (Boolean(t.noPadding) ? 0 : 2));
      const n = document.body.clientWidth;
      const r = v.CheckMobile.iOS() || v.CheckMobile.Android() || (0, v.supportTouch)() && (0, v.isMac)() ? window.innerHeight : document.body.clientHeight;
      const a = t.vertical;
      const l = t.extendMargin || a && i.w < 20 || !a && i.h < 20;
      e.classList.toggle(T["common-tooltip--farther"], l);
      e.classList.toggle(T["common-tooltip--vertical"], a);
      e.classList.toggle(T["common-tooltip--horizontal"], !a);
      const c = function (e) {
        return e.querySelector(`.${T["common-tooltip__ear-holder"]}`);
      }(e);
      const h = e.offsetHeight;
      if (a) {
        const a = 10;
        const l = r - 10;
        const d = 12;
        const u = a + d;
        const _ = l - d;
        const p = (0, y.clamp)(i.y + i.h / 2, u, _) - h / 2;
        const m = p + h;
        e.style.left = L(i.x + i.w);
        e.style.top = L(p);
        if (p < a) {
          s.style.top = o.style.top = L(a - p);
        } else if (m > l) {
          s.style.top = o.style.top = L(l - m);
        }
        const {
          right: f
        } = (e.querySelector(":last-child") || s).getBoundingClientRect();
        const v = f + 10 > n;
        e.classList.toggle(T["common-tooltip--direction_reversed"], v);
        e.classList.toggle(T["common-tooltip--direction_normal"], !v);
        let S = v ? "after" : "before";
        if ((0, g.isRtl)()) {
          S = t.otr ? "after" : S;
          S = t.otl ? "before" : S;
        } else {
          S = t.otr ? "before" : S;
          S = t.otl ? "after" : S;
        }
        c.classList.toggle(T["common-tooltip__ear-holder--before"], S === "before");
        c.classList.toggle(T["common-tooltip__ear-holder--after"], S === "after");
        if (S === "after") {
          e.style.left = "auto";
          e.style.right = L(n - i.x);
        }
      } else {
        const a = i.x - (s.offsetWidth - i.w) / 2;
        const l = n - e.offsetWidth - 20 <= 0 ? (n - e.offsetWidth) / 2 : 10;
        const d = n - l - e.offsetWidth;
        const u = Math.max(l, Math.min(a, d));
        e.style.left = L(u);
        const _ = d < a;
        e.classList.toggle(T["common-tooltip--direction_reversed"], _);
        e.classList.toggle(T["common-tooltip--direction_normal"], !_);
        const p = function (e, t, i, s) {
          if (e.above) {
            if (O(t, s)) {
              return "above";
            } else {
              return "below";
            }
          }
          if (e.below) {
            if (function (e, t, i) {
              return i.y + i.h + t + 10 < e;
            }(t, i, s)) {
              return "below";
            } else {
              return "above";
            }
          }
          if (O(i, s)) {
            return "above";
          } else {
            return "below";
          }
        }(t, r, h, i);
        if (p === "above") {
          e.style.bottom = L(r - i.y);
        } else {
          e.style.top = L(i.y + i.h);
        }
        c.classList.add(p === "above" ? T["common-tooltip__ear-holder--above"] : T["common-tooltip__ear-holder--below"]);
        const {
          left: m
        } = s.getBoundingClientRect();
        let g = Math.trunc(i.x + i.w / 2 - (m + s.clientWidth / 2));
        e.style.left = L(u + g);
        e.style.width = L(s.clientWidth + o.clientWidth);
        g = _ ? Math.max(0, g) : Math.min(0, g);
        o.style.left = L(-g);
        s.style.left = L(-g);
      }
    }
    function A(e) {
      e.classList.toggle(T["common-tooltip--hidden"], true);
    }
    function L(e) {
      return `${Math.floor(e)}px`;
    }
    (function (e) {
      e[e.ViewportPadding = 10] = "ViewportPadding";
    })(w ||= {});
    const k = `\n\t<div id="common-tooltip-wrapper" class="${T["common-tooltip"]}">\n\t\t<div class="${T["common-tooltip__ear-holder"]}" >\n\t\t\t<div class="${T["common-tooltip__body"]} js-tooltip-body"></div>\n\t\t</div>\n\t\t<div class="${T["common-tooltip__button-container"]}"></div>\n\t</div>\n`;
    const D = `\n\t<div class="${T["common-tooltip__hotkey-block"]}"></div>\n`;
    const E = `\n\t<div class="${T["common-tooltip__hotkey-text"]}"></div>\n`;
    const B = (0, m.parseHtmlElement)(k);
    const V = (0, m.parseHtmlElement)(D);
    const R = (0, m.parseHtmlElement)(E);
    function N(e) {
      return e.querySelector(`.${T["common-tooltip__body"]}`);
    }
    function O(e, t) {
      return 10 + e < t.y;
    }
    let F = false;
    let W = null;
    let H = null;
    if (!s.mobiletouch) {
      document.addEventListener("mouseover", G, true);
      document.addEventListener("focus", function (e) {
        const t = e.target;
        if (!(t instanceof HTMLElement) || !t.closest("[data-tooltip-show-on-focus=\"true\"]") || !t.matches(":focus-visible")) {
          return;
        }
        G(e, true);
      }, {
        capture: true
      });
      document.addEventListener("active-descendant-focus", function (e) {
        if (e.target instanceof HTMLElement) {
          G(e, true);
        }
      }, {
        capture: true
      });
    }
    const z = new MutationObserver(() => {
      if (W && W.options.target) {
        let e;
        e = "isConnected" in W.options.target ? W.options.target.isConnected : document.body.contains(W.options.target);
        if (!e) {
          $();
        }
      }
    });
    const U = (e, t = {}) => {
      const {
        content: i,
        ...s
      } = Z(t);
      const o = x(e);
      const n = Object.assign(o, s);
      if (i.type !== "none") {
        n.content = i;
      }
      return (n.content.type !== "none" || !!n.hotkey) && (n.target = e, j(n), true);
    };
    const j = e => {
      const t = Z(e);
      const i = I(t);
      var s;
      W = {
        options: t,
        element: i
      };
      s = i;
      p();
      if (u) {
        u.appendChild(s);
      }
      c();
      if (!F) {
        A(i);
        h(() => K(i), function (e) {
          if (typeof e.tooltipDelay != "number" || isNaN(e.tooltipDelay)) {
            return 500;
          } else {
            return e.tooltipDelay;
          }
        }(t));
        return;
      }
      const {
        tooltipDebounce: o
      } = e;
      if (typeof o != "number" || isNaN(o)) {
        K(i);
      } else {
        h(() => K(i), o);
      }
    };
    function G(e, t) {
      if ("sourceCapabilities" in e && e.sourceCapabilities?.firesTouchEvents) {
        return;
      }
      const i = function (e, t, i) {
        const s = [];
        while (e && e !== t) {
          if (e.classList && e.classList.contains(i)) {
            s.push(e);
          }
          e = e.parentElement || Y(e.parentNode);
        }
        return s;
      }(e.target, e.currentTarget, "apply-common-tooltip");
      for (const s of i) {
        if (e instanceof MouseEvent) {
          if ("buttons" in e) {
            if (e.buttons & 1) {
              continue;
            }
          } else if (e.which === 1) {
            continue;
          }
        }
        const i = () => U(s);
        if (i()) {
          const e = e => o(null, true);
          const o = (n, r = false) => {
            s.removeEventListener("common-tooltip-update", i);
            s.removeEventListener("mouseleave", o);
            s.removeEventListener("mousedown", o);
            document.removeEventListener("scroll", e, {
              capture: true
            });
            if (t) {
              s.removeEventListener("blur", o);
              s.removeEventListener("active-descendant-blur", o);
            }
            if (H) {
              H.destroy();
              H = null;
            }
            $(r);
          };
          s.addEventListener("common-tooltip-update", i);
          s.addEventListener("mouseleave", o);
          s.addEventListener("mousedown", o);
          document.addEventListener("scroll", e, {
            capture: true
          });
          if (t) {
            s.addEventListener("blur", o);
            s.addEventListener("active-descendant-blur", o);
          }
          if (H === null) {
            H = (0, n.createGroup)({
              desc: "Tooltip"
            });
            H.add({
              desc: "Hide",
              hotkey: 27,
              handler: o
            });
          }
          break;
        }
      }
    }
    function q() {
      p();
      F = false;
      W = null;
    }
    const $ = (e, t) => {
      c();
      (0, o.ensureNotNull)(z).disconnect();
      if (!W) {
        return;
      }
      if (!e && !F) {
        return;
      }
      const {
        element: i,
        options: s
      } = W;
      const n = () => {
        i.removeEventListener("mouseleave", n);
        A(i);
        if (e) {
          q();
        } else {
          l = setTimeout(() => {
            q();
          }, 250);
        }
        t?.();
      };
      var r;
      var h;
      if (s.tooltipHideDelay) {
        r = () => {
          if (i.querySelector(":hover")) {
            i.addEventListener("mouseleave", n);
          } else {
            n();
          }
        };
        h = s.tooltipHideDelay;
        a = setTimeout(r, h);
      } else {
        n();
      }
    };
    function K(e) {
      const {
        options: t
      } = (0, o.ensureNotNull)(W);
      M(e, t);
      (function (e) {
        e.classList.toggle(T["common-tooltip--hidden"], false);
      })(e);
      (0, o.ensureNotNull)(z).observe(document, {
        childList: true,
        subtree: true
      });
      F = true;
      if (t.forceHideOnMove) {
        const e = () => {
          document.removeEventListener("mousemove", e);
          document.removeEventListener("touchmove", e);
          $();
        };
        document.addEventListener("mousemove", e);
        document.addEventListener("touchmove", e);
      }
    }
    function Y(e) {
      return e && (e.nodeType === Node.ELEMENT_NODE ? e : null);
    }
    function Z(e) {
      if (function (e) {
        return "content" in e;
      }(e)) {
        return e;
      }
      const {
        inner: t,
        html: i,
        text: s,
        ...o
      } = e;
      let n = {
        type: "none"
      };
      if (t) {
        n = {
          type: "element",
          data: t
        };
      }
      if (s) {
        n = {
          type: i ? "html" : "text",
          data: s
        };
      }
      return {
        content: n,
        ...o
      };
    }
  },
  32112: (e, t, i) => {
    "use strict";

    function s(e, t) {
      const i = e.dataSourceForId(t);
      if (i === null) {
        throw new Error(`Chart has no study or shape with id "${t}"`);
      }
      return i;
    }
    i.d(t, {
      SelectionApi: () => o
    });
    class o {
      constructor(e) {
        this._model = e;
      }
      add(e) {
        if (Array.isArray(e)) {
          this._model.selectionMacro(t => {
            e.map(s.bind(null, this._model)).forEach(e => t.addSourceToSelection(e));
          });
        } else {
          this.add([e]);
        }
      }
      canBeAddedToSelection(e) {
        const t = s(this._model, e);
        return this._model.selection().canBeAddedToSelection(t);
      }
      set(e) {
        if (Array.isArray(e)) {
          this._model.selectionMacro(t => {
            t.clearSelection();
            e.map(s.bind(null, this._model)).forEach(e => t.addSourceToSelection(e));
          });
        } else {
          this.set([e]);
        }
      }
      remove(e) {
        if (Array.isArray(e)) {
          this._model.selectionMacro(t => {
            e.map(s.bind(null, this._model)).forEach(e => t.removeSourceFromSelection(e));
          });
        } else {
          this.remove([e]);
        }
      }
      contains(e) {
        const t = s(this._model, e);
        return this._model.selection().isSelected(t);
      }
      allSources() {
        return this._model.selection().dataSources().map(e => e.id());
      }
      isEmpty() {
        return this._model.selection().isEmpty();
      }
      clear() {
        this._model.selectionMacro(e => {
          e.clearSelection();
        });
      }
      onChanged() {
        return this._model.onSelectedSourceChanged();
      }
    }
  },
  23024: (e, t, i) => {
    "use strict";

    i.d(t, {
      getChartStorage: () => n
    });
    var s = i(64289);
    let o = null;
    async function n() {
      const e = (0, s.getCustomAdapter)();
      if (o === null) {
        if (e !== null) {
          const {
            ChartStorageExternalAdapter: t
          } = await i.e(8313).then(i.bind(i, 33047));
          o = new t(e);
        } else {
          const {
            ChartStorageHttpLibrary: e
          } = await i.e(6124).then(i.bind(i, 11777));
          o = new e();
        }
      }
      if (o === null) {
        o = new ChartStorageHttp();
      }
      return o;
    }
  },
  38881: (e, t, i) => {
    "use strict";

    i.d(t, {
      ChunkLoader: () => o
    });
    var s = i(14051);
    class o {
      constructor() {
        this._retries = 5;
        this._cache = null;
        this._tryLoad = (e, t) => {
          this._retries = this._retries - 1;
          this._startLoading(e).then(t, this._retries !== 0 ? i => {
            if (!(0, s.isAbortError)(i)) {
              setTimeout(() => this._tryLoad(e, t), 3000);
            }
          } : undefined);
        };
      }
      load(e) {
        this._cache ||= new Promise(this._tryLoad.bind(this, e ?? null));
        return this._cache;
      }
    }
  },
  80007: (e, t, i) => {
    "use strict";

    i.d(t, {
      preventDefault: () => o,
      preventScrollByWheelClick: () => r,
      wrapHandlerWithPreventEvent: () => n
    });
    var s = i(49483);
    function o(e) {
      if (e.cancelable) {
        e.preventDefault();
      }
    }
    function n(e) {
      return t => {
        o(t);
        e(t);
      };
    }
    function r(e) {
      if (s.isChrome) {
        e.addEventListener("mousedown", e => {
          if (e.button === 1) {
            e.preventDefault();
            return false;
          }
        });
      }
    }
  },
  56186: (e, t, i) => {
    "use strict";

    function s(e) {
      if (e instanceof Error) {
        return e.stack || e.message;
      }
      try {
        return e.outerHTML.slice(0, 1024);
      } catch { }
      try {
        if (e !== undefined) {
          return JSON.stringify(e).slice(0, 1024);
        }
      } catch { }
      return String(e);
    }
    function o() {
      window.__tv_js_errors ||= [];
      window.addEventListener("error", e => {
        const t = new Date().toISOString();
        window.__tv_js_errors.push(`${t} ${e.message || "JS error"}. ${e.filename || "<unknown url>"}, line ${e.lineno}, col ${e.colno}.\nError: ${s(e.error)}`);
      }, false);
      window.addEventListener("unhandledrejection", e => {
        const t = new Date().toISOString();
        window.__tv_js_errors.push(`${t} Unhandled rejection.\nReason: ${s(e.reason)}`);
      }, false);
      document.addEventListener("securitypolicyviolation", e => {
        if (String(e.sourceFile).startsWith("https://securepubads.g.doubleclick.net") && String(e.blockedURI).startsWith("https://adservice.google.")) {
          return;
        }
        const t = new Date().toISOString();
        const i = e.disposition === "report" ? "CSP report-only" : "CSP violation";
        window.__tv_js_errors.push(`${t} ${i}: ${e.violatedDirective || e.effectiveDirective}. ${e.sourceFile || "<unknown url>"}, line ${e.lineNumber}, col ${e.columnNumber}.\nBlocked URI: ${e.blockedURI}\nSample: ${e.sample}\nTarget: ${s(e.target)}`);
      }, false);
    }
    i.d(t, {
      install: () => o
    });
  },
  76422: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      emit: () => u,
      emitOnce: () => _,
      on: () => c,
      subscribe: () => h,
      subscribeToAll: () => d,
      unsubscribe: () => a,
      unsubscribeAll: () => l
    });
    var s = i(52033);
    const o = {};
    const n = [];
    const r = {};
    function a(e, t, i) {
      o[e].unsubscribe(i, t);
    }
    function l(e, t) {
      o[e].unsubscribeAll(t);
    }
    function c(e, t, i) {
      h(e, t, i);
    }
    function h(e, t, i, n) {
      if (!o.hasOwnProperty(e)) {
        o[e] = new s.Delegate();
      }
      if (r[e]) {
        t.call(i);
      } else {
        o[e].subscribe(i, t, n);
      }
    }
    function d(e) {
      n.push(e);
    }
    function u(e, ...t) {
      const i = [e].concat(t);
      n.forEach(e => {
        e.apply(null, i);
      });
      if (o.hasOwnProperty(e)) {
        o[e].fire.apply(o[e], t);
      }
    }
    function _(e) {
      if (r[e]) {
        console.warn(`Something went wrong: emitOnce called multiple times with same event (${e})`);
      }
      r[e] = true;
      u.apply(null, arguments);
    }
  },
  26709: (e, t, i) => {
    "use strict";

    i.d(t, {
      Modifiers: () => n.Modifiers,
      createGroup: () => s.createGroup,
      keyboardPressedKeysState: () => s.keyboardPressedKeysState,
      pressedKeys: () => s.pressedKeys
    });
    var s = i(43222);
    var o = i(93132);
    var n = i(3343);
    var r = i(51768);
    (0, s.registerWindow)(window);
    o.ActionGroup.setMatchedHotkeyHandler(e => {
      (0, r.trackEvent)("Keyboard Shortcuts", (0, n.humanReadableHash)(e));
    });
  },
  68335: (e, t, i) => {
    "use strict";

    i.d(t, {
      Modifiers: () => s.Modifiers,
      hashFromEvent: () => s.hashFromEvent,
      humanReadableHash: () => s.humanReadableHash,
      humanReadableModifiers: () => s.humanReadableModifiers,
      isMacKeyboard: () => s.isMacKeyboard,
      modifiersFromEvent: () => s.modifiersFromEvent
    });
    var s = i(3343);
  },
  35749: (e, t, i) => {
    "use strict";

    i.d(t, {
      isNativeUIInteraction: () => s.isNativeUIInteraction,
      isTextEditingField: () => s.isTextEditingField
    });
    var s = i(54717);
  },
  71382: (e, t, i) => {
    "use strict";

    i.d(t, {
      isTouchEvent: () => o
    });
    var s = i(32563);
    function o(e) {
      const t = e.sourceCapabilities;
      let i = t && t.firesTouchEvents;
      if (i === undefined) {
        i = s.touch;
      }
      return i;
    }
  },
  82992: (e, t, i) => {
    "use strict";

    i.d(t, {
      linking: () => m
    });
    var s = i(90484);
    var o = i(50151);
    var n = i(64147);
    i(56570);
    var r = i(85049);
    var a = i(68805);
    var l = i(9343);
    var c = i(42989);
    var h = i(69109);
    const d = (0, l.getLogger)("Linking");
    var u;
    var _;
    (function (e) {
      e[e.NotBound = 0] = "NotBound";
      e[e.BoundToWidget = 1] = "BoundToWidget";
      e[e.BoundToModel = 2] = "BoundToModel";
    })(u ||= {});
    (function (e) {
      e[e.Symbol = 0] = "Symbol";
      e[e.Resolution = 1] = "Resolution";
    })(_ ||= {});
    class p {
      constructor(e, t, i) {
        this.watchedSymbol = new n.WatchedValue();
        this.seriesShortSymbol = new n.WatchedValue();
        this.proSymbol = new n.WatchedValue();
        this.ensuredProSymbol = new n.WatchedValue();
        this.watchedInterval = new n.WatchedValue();
        this.watchedIntraday = new n.WatchedValue();
        this.watchedSeconds = new n.WatchedValue();
        this.watchedTicks = new n.WatchedValue();
        this.watchedDataFrequencyResolution = new n.WatchedValue();
        this.watchedRange = new n.WatchedValue();
        this.watchedSupportedResolutions = new n.WatchedValue();
        this.watchedSupportedChartStyles = new n.WatchedValue();
        this.symbolNamesList = new n.WatchedValue();
        this._chartWidgetCollection = null;
        this._chartWidgetBindingState = 0;
        this._activeChartWidget = null;
        this._linkingGroupCharts = null;
        this._boundChartWidget = null;
        this._watchedSymbolListenerBound = this._watchedSymbolListener.bind(this);
        this._watchedIntervalListenerBound = this._watchedIntervalListener.bind(this);
        this._setGroupSymbolCancellationToken = {
          cancelled: false
        };
        this._muted = false;
        this.updateBoundChartWidget = () => {
          const e = this._chartToBind();
          if (e !== this._boundChartWidget) {
            if (e === null) {
              this.unbindFromChartWidget();
            } else {
              this.bindToChartWidget(e);
            }
          }
        };
        this._updateAllGroupChartWidgets = () => {
          this._destroySymbolIntervalPropertySubscriptions?.();
          const e = (0, o.ensureNotNull)(this._linkingGroupCharts).value();
          const t = [];
          const i = [];
          for (const s of e) {
            const e = s.symbolWV().spawn();
            const o = s.resolutionWV().spawn();
            e.subscribe(this._updateSymbolByProperty.bind(this, s));
            o.subscribe(this._updateIntervalByProperty.bind(this, s));
            t.push(e);
            i.push(o);
          }
          this._destroySymbolIntervalPropertySubscriptions = () => {
            t.forEach(e => e.destroy());
            i.forEach(e => e.destroy());
            this._destroySymbolIntervalPropertySubscriptions = undefined;
          };
          const s = this.watchedSymbol.value();
          if (e.length > 1 && this._needApplySymbol(s) && !this._muted) {
            this._setGroupSymbol(s);
          }
          const n = this.watchedInterval.value();
          if (e.length > 1 && this._needApplyInterval(n) && !this._muted) {
            this._setGroupInterval(n);
          }
          this.updateBoundChartWidget();
        };
        this._groupIndex = e;
        const s = (e, t) => {
          e.subscribe(e => {
            if (i() === this) {
              t.setValue(e);
            }
          }, {
            callWithLast: true
          });
        };
        s(this.watchedSymbol, t.watchedSymbol);
        s(this.seriesShortSymbol, t.seriesShortSymbol);
        s(this.proSymbol, t.proSymbol);
        s(this.ensuredProSymbol, t.ensuredProSymbol);
        s(this.watchedInterval, t.watchedInterval);
        s(this.watchedIntraday, t.watchedIntraday);
        s(this.watchedSeconds, t.watchedSeconds);
        s(this.watchedTicks, t.watchedTicks);
        s(this.watchedDataFrequencyResolution, t.watchedDataFrequencyResolution);
        s(this.watchedRange, t.watchedRange);
        s(this.watchedSupportedResolutions, t.watchedSupportedResolutions);
        s(this.watchedSupportedChartStyles, t.watchedSupportedChartStyles);
        s(this.symbolNamesList, t.symbolNamesList);
        this.watchedSymbol.subscribe(e => {
          if (!this._boundChartWidget || !this._boundChartWidget.hasModel() || !this._mainSeries().symbolSameAsCurrent(e)) {
            this.proSymbol.setValue(e);
          }
        }, {
          callWithLast: true
        });
      }
      mute(e) {
        this._muted = e;
      }
      bindToChartWidgetCollection(e) {
        this.unbindFromChartWidgetCollection();
        this._chartWidgetCollection = e;
        this._activeChartWidget = e.activeChartWidget.spawn();
        this._activeChartWidget.subscribe(this.updateBoundChartWidget);
        this._linkingGroupCharts = e.linkingGroupsCharts(this._groupIndex).spawn();
        this._linkingGroupCharts.subscribe(this._updateAllGroupChartWidgets);
        this.updateBoundChartWidget();
        this._updateAllGroupChartWidgets();
      }
      unbindFromChartWidgetCollection() {
        this.unbindFromChartWidget();
        this._chartWidgetCollection = null;
        this._activeChartWidget?.destroy();
        this._activeChartWidget = null;
        this._linkingGroupCharts?.destroy();
        this._linkingGroupCharts = null;
        this._destroySymbolIntervalPropertySubscriptions?.();
      }
      bindToChartWidget(e) {
        this.unbindFromChartWidget();
        this._boundChartWidget = e;
        if (e.hasModel()) {
          this._onChartModelCreated(e.model());
          return;
        }
        e.modelCreated().subscribe(this, this._onChartModelCreated, true);
        this._chartWidgetBindingState = 1;
        const t = e.mainSeriesProperties().childs();
        this.watchedSymbol.setValue(t.symbol.value());
        this.watchedInterval.setValue(t.interval.value());
        this._boundChartWidget.linkingGroupIndex().subscribe(this.updateBoundChartWidget);
      }
      unbindFromChartWidget() {
        const e = this._boundChartWidget;
        if (e !== null) {
          switch (this._chartWidgetBindingState) {
            case 1:
              e.modelCreated().unsubscribeAll(this);
              break;
            case 2:
              this.watchedSymbol.unsubscribe(this._watchedSymbolListenerBound);
              const t = this._mainSeries().dataEvents();
              t.symbolResolved().unsubscribeAll(this);
              t.symbolError().unsubscribeAll(this);
              this._mainSeries().onIntervalChanged().unsubscribeAll(this);
              this.watchedInterval.unsubscribe(this._watchedIntervalListenerBound);
              delete this.watchedSymbol.writeLock;
          }
          e.linkingGroupIndex().unsubscribe(this.updateBoundChartWidget);
          this._boundChartWidget = null;
          this._chartWidgetBindingState = 0;
        }
      }
      boundChartWidget() {
        return this._boundChartWidget;
      }
      _mainSeries() {
        if (!this._boundChartWidget) {
          throw new Error("ChartWidget is undefined");
        }
        return this._boundChartWidget.model().mainSeries();
      }
      _watchedSymbolListener(e) {
        if (this._needApplySymbol(e) && !this._muted) {
          this._setGroupSymbol(e);
        }
      }
      _updateSymbolByProperty(e, t) {
        const i = this._symbolLock();
        if (i && this._needApplySymbol(t) && !this._muted) {
          this._setGroupSymbol(t);
        }
        if (i || e === this._boundChartWidget) {
          this.watchedSymbol.setValue(t);
        }
      }
      _watchedIntervalListener(e) {
        const t = r.Interval.normalize(e);
        if (t && this._needApplyInterval(t) && !this._muted) {
          this._setGroupInterval(t);
        }
      }
      _updateIntervalByProperty(e, t) {
        const i = this._intervalLock();
        const s = r.Interval.normalize(t);
        if (i && s && this._needApplyInterval(s) && !this._muted) {
          this._setGroupInterval(s);
        }
        if (i || e === this._boundChartWidget) {
          this.watchedInterval.setValue(s ?? t);
        }
      }
      _sendSnowplowAnalytics() {
        if (!window.user.do_not_track) {
          throw new Error("unsupported");
        }
      }
      _updateSeriesSymbolInfo() {
        this.seriesShortSymbol.setValue((0, o.ensureNotNull)(this._boundChartWidget).getSymbol(true));
        const e = this._mainSeries().symbolInfo();
        if (e) {
          const t = e.pro_name || false;
          this.proSymbol.setValue(t || this.watchedSymbol.value());
          this.ensuredProSymbol.setValue(this.proSymbol.value());
          if (e.aliases) {
            this.symbolNamesList.setValue(e.aliases);
          }
          {
            const t = e.supported_resolutions;
            if (t) {
              this.watchedSupportedResolutions.setValue(t);
            } else {
              this.watchedSupportedResolutions.setValue(undefined);
            }
          }
          let i = (0, c.allChartStyles)();
          if ((0, a.isCloseBasedSymbol)(e) || this._mainSeries().intervalObj().is1Tick()) {
            i = i.filter(e => (0, a.isSingleValueBasedStyle)(e));
          }
          this.watchedSupportedChartStyles.setValue(i);
          this.watchedIntraday.setValue(!!e.has_intraday);
          this.watchedSeconds.setValue(!!e.has_seconds);
          this.watchedTicks.setValue(!(0, a.isCloseBasedSymbol)(e) && !!e["is-tickbars-available"]);
          this.watchedRange.setValue(!(0, a.isCloseBasedSymbol)(e));
          const s = e.data_frequency ? e.data_frequency : undefined;
          this.watchedDataFrequencyResolution.setValue(s);
        } else {
          this.watchedIntraday.setValue(false);
          this.watchedSeconds.setValue(false);
          this.watchedTicks.setValue(false);
          this.watchedRange.setValue(false);
          if (this._mainSeries().isFailed()) {
            this.ensuredProSymbol.setValue(this.proSymbol.value());
          }
        }
      }
      _onChartModelCreated(e) {
        if (!this._boundChartWidget) {
          throw new Error("ChartWidget is undefined");
        }
        this._chartWidgetBindingState = 2;
        this.watchedSymbol.setValue(this._boundChartWidget.symbolWV().value());
        this.watchedSymbol.subscribe(this._watchedSymbolListenerBound);
        const t = e.mainSeries().dataEvents();
        t.symbolResolved().subscribe(this, this._updateSeriesSymbolInfo);
        t.symbolError().subscribe(this, this._updateSeriesSymbolInfo);
        e.mainSeries().onIntervalChanged().subscribe(this, this._updateSeriesSymbolInfo);
        this._updateSeriesSymbolInfo();
        this.watchedInterval.setValue(this._boundChartWidget.resolutionWV().value());
        this.watchedInterval.subscribe(this._watchedIntervalListenerBound);
        if (this._boundChartWidget.readOnly()) {
          this.watchedSymbol.writeLock = true;
        }
      }
      _chartToBind() {
        const e = this._chartWidgetCollection;
        if (e === null) {
          return null;
        } else {
          return e.activeChartWidget.value();
        }
      }
      _symbolLock() {
        return !!this._chartWidgetCollection?.lock.symbol.value();
      }
      _intervalLock() {
        return !!this._chartWidgetCollection?.lock.interval.value();
      }
      _chartsForLock(e) {
        if (e === 0 ? this._symbolLock() : this._intervalLock()) {
          return (0, o.ensureNotNull)(this._linkingGroupCharts).value();
        } else if (this._boundChartWidget) {
          return [this._boundChartWidget];
        } else {
          return [];
        }
      }
      _setGroupSymbol(e) {
        this.mute(true);
        this._setGroupSymbolCancellationToken.cancelled = true;
        const t = this._setGroupSymbolCancellationToken = {
          cancelled: false
        };
        (0, o.ensureNotNull)(this._chartWidgetCollection).setSymbol(e, this._groupIndex, (0, o.ensureNotNull)(this._boundChartWidget)).finally(() => {
          if (this._boundChartWidget && !t.cancelled) {
            const t = this._boundChartWidget.model().mainSeries();
            if (!t.symbolSameAsCurrent(e)) {
              this.watchedSymbol.setValue(t.symbol());
              this.proSymbol.setValue(t.proSymbol());
            }
          }
        });
        this.mute(false);
      }
      _needApplySymbol(e) {
        const t = this._chartsForLock(0);
        const i = t.find(t => t.hasModel() && t.model().mainSeries().symbolInfo() && t.model().mainSeries().symbolSameAsResolved(e));
        if (i) {
          const e = i.model().mainSeries();
          if (t.every(t => e.symbolSameAsResolved(t.symbolWV().value()))) {
            return false;
          }
        }
        return t.some(t => t.symbolWV().value() !== e);
      }
      _setGroupInterval(e) {
        this.mute(true);
        (0, o.ensureNotNull)(this._chartWidgetCollection).setResolution(e, this._groupIndex).finally(() => {
          if (this._boundChartWidget) {
            const t = this._boundChartWidget.resolutionWV().value();
            if (!r.Interval.isEqual(t, e)) {
              this.watchedInterval.setValue(t);
            }
          }
        });
        this.mute(false);
      }
      _needApplyInterval(e) {
        return this._chartsForLock(1).some(t => !r.Interval.isEqual(t.resolutionWV().value(), e));
      }
    }
    const m = new class {
      constructor() {
        this._watchedSymbol = new n.WatchedValue();
        this._seriesShortSymbol = new n.WatchedValue();
        this._proSymbol = new n.WatchedValue();
        this._ensuredProSymbol = new n.WatchedValue();
        this._watchedInterval = new n.WatchedValue();
        this._watchedIntraday = new n.WatchedValue();
        this._watchedSeconds = new n.WatchedValue();
        this._watchedTicks = new n.WatchedValue();
        this._watchedDataFrequencyResolution = new n.WatchedValue();
        this._watchedRange = new n.WatchedValue();
        this._watchedSupportedResolutions = new n.WatchedValue();
        this._watchedSupportedChartStyles = new n.WatchedValue([]);
        this._symbolNamesList = new n.WatchedValue();
        this._chartWidgetCollection = null;
        this._onSymbolLinkBound = this._onSymbolLink.bind(this);
        this._searchCharts = null;
        this._searchChartsLoadDebounced = null;
        this._selfEmit = false;
        this._preventFeedBySymbol = false;
        this._feedBySymbolDebounceCounter = 0;
        this._linkingGroups = new Map();
        this._activeLinkingGroup = new n.WatchedValue();
        this._activeLinkingGroupIndex = null;
        this._updateLinkingGroups = () => {
          (0, o.ensureNotNull)(this._chartWidgetCollection).allLinkingGroups().value().forEach(e => this._linkingGroup(e));
          this._linkingGroups.forEach(e => e.updateBoundChartWidget());
        };
        this._activeLinkingGroup.setValue(this._linkingGroup(null));
        const e = (e, t) => {
          e.subscribe(e => t().setValue(e), {
            callWithLast: true
          });
        };
        e(this._watchedSymbol, () => this._activeLinkingGroup.value().watchedSymbol);
        e(this._seriesShortSymbol, () => this._activeLinkingGroup.value().seriesShortSymbol);
        e(this._proSymbol, () => this._activeLinkingGroup.value().proSymbol);
        e(this._ensuredProSymbol, () => this._activeLinkingGroup.value().ensuredProSymbol);
        e(this._watchedInterval, () => this._activeLinkingGroup.value().watchedInterval);
        e(this._watchedIntraday, () => this._activeLinkingGroup.value().watchedIntraday);
        e(this._watchedSeconds, () => this._activeLinkingGroup.value().watchedSeconds);
        e(this._watchedTicks, () => this._activeLinkingGroup.value().watchedTicks);
        e(this._watchedDataFrequencyResolution, () => this._activeLinkingGroup.value().watchedDataFrequencyResolution);
        e(this._watchedRange, () => this._activeLinkingGroup.value().watchedRange);
        e(this._watchedSupportedResolutions, () => this._activeLinkingGroup.value().watchedSupportedResolutions);
        e(this._watchedSupportedChartStyles, () => this._activeLinkingGroup.value().watchedSupportedChartStyles);
        e(this._symbolNamesList, () => this._activeLinkingGroup.value().symbolNamesList);
        const t = e => {
          this._watchedSymbol.setValue(e.watchedSymbol.value());
          this._seriesShortSymbol.setValue(e.seriesShortSymbol.value());
          this._proSymbol.setValue(e.proSymbol.value());
          this._ensuredProSymbol.setValue(e.ensuredProSymbol.value());
          this._watchedInterval.setValue(e.watchedInterval.value());
          this._watchedIntraday.setValue(e.watchedIntraday.value());
          this._watchedSeconds.setValue(e.watchedSeconds.value());
          this._watchedTicks.setValue(e.watchedTicks.value());
          this._watchedDataFrequencyResolution.setValue(e.watchedDataFrequencyResolution.value());
          this._watchedRange.setValue(e.watchedRange.value());
          this._watchedSupportedResolutions.setValue(e.watchedSupportedResolutions.value());
          this._watchedSupportedChartStyles.setValue(e.watchedSupportedChartStyles.value());
          this._symbolNamesList.setValue(e.symbolNamesList.value());
        };
        this._activeLinkingGroup.subscribe(t);
        t(this._activeLinkingGroup.value());
        (0, h.setMuteLinkingGroup)((e, t) => {
          this._linkingGroup(e).mute(t);
        });
      }
      get symbol() {
        return this._watchedSymbol;
      }
      get proSymbol() {
        return this._proSymbol.readonly();
      }
      get ensuredProSymbol() {
        return this._ensuredProSymbol.readonly();
      }
      get symbolNamesList() {
        return this._symbolNamesList.readonly();
      }
      get seriesShortSymbol() {
        return this._seriesShortSymbol.readonly();
      }
      get interval() {
        return this._watchedInterval;
      }
      get intraday() {
        return this._watchedIntraday.readonly();
      }
      get seconds() {
        return this._watchedSeconds.readonly();
      }
      get ticks() {
        return this._watchedTicks.readonly();
      }
      get range() {
        return this._watchedRange.readonly();
      }
      get supportedResolutions() {
        return this._watchedSupportedResolutions.readonly();
      }
      get supportedChartStyles() {
        return this._watchedSupportedChartStyles.readonly();
      }
      get preventFeedBySymbol() {
        return this._preventFeedBySymbol;
      }
      get dataFrequencyResolution() {
        return this._watchedDataFrequencyResolution.readonly();
      }
      activeLinkingGroup() {
        return this._activeLinkingGroup.readonly();
      }
      getChartWidget() {
        return this.activeLinkingGroup().value().boundChartWidget();
      }
      bindToChartWidgetCollection(e) {
        this._chartWidgetCollection?.onAboutToBeDestroyed.unsubscribeAll(this);
        this._unbindFromChartWidgetCollection();
        this._chartWidgetCollection = e;
        this._chartWidgetCollection.onAboutToBeDestroyed.subscribe(this, this._unbindFromChartWidgetCollection);
        this._chartWidgetCollection.allLinkingGroups().subscribe(this._updateLinkingGroups);
        this._updateLinkingGroups();
        this._activeLinkingGroupIndex = e.activeLinkingGroup().spawn();
        this._activeLinkingGroupIndex.subscribe(e => {
          this._activeLinkingGroup.setValue(this._linkingGroup(e));
        }, {
          callWithLast: true
        });
        this._linkingGroups.forEach(t => t.bindToChartWidgetCollection(e));
      }
      bindToSearchCharts(e) {
        this.unbindFromSearchCharts();
        this._searchCharts = e;
        e.onSearchBySymbol.subscribe(this, this._onSearchBySymbol);
        e.loadingSymbol.subscribe(e => {
          if (e === false) {
            this._feedBySymbolDebounceCounter = 0;
          }
        });
        this._watchedSymbol.subscribe(this._onSymbolLinkBound);
      }
      unbindFromSearchCharts() {
        if (this._searchCharts) {
          this._searchCharts.onSearchBySymbol.unsubscribe(this, this._onSearchBySymbol);
          this._watchedSymbol.unsubscribe(this._onSymbolLinkBound);
          this._searchCharts = null;
        }
      }
      setPreventFeedBySymbol(e) {
        this._preventFeedBySymbol = e;
      }
      setSymbolAndLogInitiator(e, t, i) {
        if (this.symbol.value() !== e || i) {
          d.logInfo(`Change linking symbol to ${e}, initiator: ${t}`);
          this.symbol.setValue(e, i);
        }
      }
      _onSearchBySymbol(e) {
        if (!e.resolved_symbol) {
          throw new Error("no resolved_symbol");
        }
        this._selfEmit = true;
        this._watchedSymbol.setValue(e.resolved_symbol);
        this._selfEmit = false;
      }
      _onSymbolLink(e) {
        if (!this._selfEmit) {
          if (!this._searchCharts) {
            const e = "No search charts defined";
            d.logError(e);
            throw new Error(e);
          }
          if (!this._preventFeedBySymbol) {
            this._loadSearchCharts(e);
          }
        }
      }
      _loadSearchCharts(e) {
        if (!this._searchCharts) {
          const e = "No search charts defined";
          d.logError(e);
          throw new Error(e);
        }
        if (this._searchChartsLoadDebounced) {
          if (this._feedBySymbolDebounceCounter < 100) {
            this._feedBySymbolDebounceCounter++;
            this._searchChartsLoadDebounced(e);
          }
          return;
        }
        const t = e => this._searchCharts ? (this._searchCharts.loadingSymbol.value() === true ? this._feedBySymbolDebounceCounter < 100 && (this._feedBySymbolDebounceCounter++, this._searchChartsLoadDebounced = (0, s.default)(t, 2000), this._searchChartsLoadDebounced(e)) : this._searchChartsLoadDebounced = null, this._searchCharts.feedBySymbol.call(this._searchCharts, e)) : () => { };
        if (this._searchCharts.loadingSymbol.value() === true) {
          if (this._feedBySymbolDebounceCounter < 100) {
            this._feedBySymbolDebounceCounter++;
            this._searchChartsLoadDebounced = (0, s.default)(t, 2000);
            this._searchChartsLoadDebounced(e);
          }
        } else {
          this._searchCharts.feedBySymbol(e);
        }
      }
      _linkingGroup(e) {
        e = null;
        let t = this._linkingGroups.get(e);
        if (t === undefined) {
          const i = {
            watchedSymbol: this._watchedSymbol,
            seriesShortSymbol: this._seriesShortSymbol,
            proSymbol: this._proSymbol,
            ensuredProSymbol: this._ensuredProSymbol,
            watchedInterval: this._watchedInterval,
            watchedIntraday: this._watchedIntraday,
            watchedSeconds: this._watchedSeconds,
            watchedTicks: this._watchedTicks,
            watchedDataFrequencyResolution: this._watchedDataFrequencyResolution,
            watchedRange: this._watchedRange,
            watchedSupportedResolutions: this._watchedSupportedResolutions,
            watchedSupportedChartStyles: this._watchedSupportedChartStyles,
            symbolNamesList: this._symbolNamesList
          };
          t = new p(e, i, () => this._activeLinkingGroup.value());
          this._linkingGroups.set(e, t);
          if (this._chartWidgetCollection) {
            t.bindToChartWidgetCollection(this._chartWidgetCollection);
          }
        }
        return t;
      }
      _unbindFromChartWidgetCollection() {
        if (this._chartWidgetCollection !== null) {
          this._activeLinkingGroupIndex?.destroy();
          this._activeLinkingGroupIndex = null;
          this._linkingGroups.forEach(e => e.unbindFromChartWidgetCollection());
          this._chartWidgetCollection.allLinkingGroups().unsubscribe(this._updateLinkingGroups);
          this._chartWidgetCollection = null;
        }
      }
    }();
    window.TradingViewApi ||= {
      linking: m
    };
  },
  11417: (e, t, i) => {
    "use strict";

    const {
      getLogger: s
    } = i(9343);
    const o = s("TVLocalStorage");
    function n() {
      try {
        this.isAvailable = true;
        this.localStorage = window.localStorage;
        this.localStorage.setItem("tvlocalstorage.available", "true");
      } catch (e) {
        delete this.isAvailable;
        delete this.localStorage;
      }
      this._updateLength();
      try {
        this._report();
      } catch (e) { }
    }
    n.prototype._report = function () {
      if (this.isAvailable) {
        const e = 10;
        const t = [];
        for (let e = 0; e < this.localStorage.length; e++) {
          const i = this.key(e);
          t.push({
            key: i,
            length: String(this.getItem(i)).length
          });
        }
        t.sort((e, t) => t.length - e.length);
        const i = t.slice(0, e);
        t.sort((e, t) => t.key.length - e.key.length);
        const s = t.slice(0, e);
        o.logNormal(`Total amount of keys in Local Storage: ${this.length}`);
        o.logNormal(`Top ${e} keys with longest values: ${JSON.stringify(i)}`);
        o.logNormal(`Top ${e} longest key names: ${JSON.stringify(s)}`);
        try {
          navigator.storage.estimate().then(e => {
            o.logNormal(`Storage estimate: ${JSON.stringify(e)}`);
          });
        } catch (e) { }
      }
    };
    n.prototype.length = 0;
    n.prototype.isAvailable = false;
    n.prototype.localStorage = {
      "tvlocalstorage.available": "false"
    };
    n.prototype._updateLength = function () {
      if (this.isAvailable) {
        this.length = this.localStorage.length;
      } else {
        var e;
        var t = 0;
        for (e in this.localStorage) {
          if (this.localStorage.hasOwnProperty(e)) {
            t++;
          }
        }
        this.length = t;
      }
    };
    n.prototype.key = function (e) {
      if (this.isAvailable) {
        return this.localStorage.key(e);
      } else {
        return Object.keys(this.localStorage)[e];
      }
    };
    n.prototype.getItem = function (e) {
      if (this.isAvailable) {
        return this.localStorage.getItem(e);
      } else if (this.localStorage[e] === undefined) {
        return null;
      } else {
        return this.localStorage[e];
      }
    };
    n.prototype.setItem = function (e, t) {
      if (this.isAvailable) {
        this.localStorage.setItem(e, t);
      } else {
        this.localStorage[e] = t;
      }
      this._updateLength();
    };
    n.prototype.removeItem = function (e) {
      if (this.isAvailable) {
        this.localStorage.removeItem(e);
      } else {
        delete this.localStorage[e];
      }
      this._updateLength();
    };
    n.prototype.clear = function () {
      if (this.isAvailable) {
        this.localStorage.clear();
      } else {
        this.localStorage = {};
      }
      this._updateLength();
    };
    window.TVLocalStorage = new n();
    e.exports.TVLocalStorage = window.TVLocalStorage;
  },
  84015: (e, t, i) => {
    "use strict";

    function s(e, t = false) {
      return false;
    }
    function o(e, t = false) {
      return e;
    }
    i.d(t, {
      isOnMobileAppPage: () => s,
      urlWithMobileAppParams: () => o
    });
  },
  69109: (e, t, i) => {
    "use strict";

    let s;
    function o(e, t) {
      s?.(e, t);
    }
    function n(e) {
      s = e;
    }
    i.d(t, {
      muteLinkingGroup: () => o,
      setMuteLinkingGroup: () => n
    });
  },
  19334: (e, t, i) => {
    "use strict";

    i.d(t, {
      addPerfMark: () => c,
      perfMeasureOperation: () => h
    });
    var s = i(92184);
    function o() { }
    const n = console.timeStamp ? console.timeStamp.bind(console) : o;
    const r = window.performance && performance.mark ? performance.mark.bind(performance) : o;
    const a = window.performance && performance.measure ? performance.measure.bind(performance) : o;
    const l = window.performance && performance.clearMarks ? performance.clearMarks.bind(performance) : o;
    function c(e) {
      n(e);
      r(e);
    }
    async function h(e, t) {
      const i = `measure-${e}-${(0, s.randomHash)()}`;
      r(i);
      try {
        return await t();
      } finally {
        a(e, i);
        l(i);
      }
    }
  },
  16216: (e, t, i) => {
    "use strict";

    i.d(t, {
      hasService: () => r,
      registerService: () => n,
      service: () => a
    });
    const s = {};
    const o = new Map();
    function n(e, t) {
      if (r(e)) {
        throw new Error("Service already registered");
      }
      s[e.id] = t;
      const i = o.get(e.id);
      if (i !== undefined) {
        o.delete(e.id);
        i.resolve(t);
      }
    }
    function r(e) {
      return s[e.id] !== undefined;
    }
    function a(e) {
      const t = s[e.id];
      if (t === undefined) {
        throw new Error("ServiceLocator: Service " + e.id + " not found");
      }
      return t;
    }
  },
  56840: (e, t, i) => {
    "use strict";

    e = i.nmd(e);
    i(49483);
    i(84906).fetch;
    var s = i(66800).regExpEscape;
    var o = i(21097).TVXWindowEvents;
    var n = i(11417).TVLocalStorage;
    var r = i(52033).Delegate;
    var a = i(56570);
    var l = ["s.tradingview.com", "betacdn.tradingview.com"];
    var c = a.enabled("use_localstorage_for_settings");
    var h = window.TVSettings = function () {
      var e = false;
      var t = null;
      function i() {
        return !t && c;
      }
      try {
        e = !TradingView.onWidget() && parent && parent !== window && !!parent.IS_DEMO_PAGE;
      } catch (e) { }
      if (e) {
        var d = {
          "widgetbar.layout-settings": {
            widgets: {},
            settings: {
              minimized: true
            }
          },
          notShowMainWizard: true
        };
        function u(e, t, i) {
          var s = d[e];
          return s ?? t;
        }
        function _() { }
        return {
          loaded: false,
          loadedModel: false,
          getValue: u,
          getJSON: u,
          getBool: u,
          getFloat: u,
          getInt: u,
          setValue: _,
          setJSON: _,
          remove: _,
          keys: function () {
            return Object.keys(d);
          },
          keysMask: function () {
            return [];
          },
          sync: _,
          onSync: {
            subscribe: function () { }
          }
        };
      }
      window.environment;
      var p;
      var m = TradingView.onWidget() ? "tradingview-widget" : "tradingview";
      var g = m + ".";
      var f = {};
      var y = [/^widgetbar\.widget\.watchlist.+/, /.+quicks$/, /^widgetbar\.layout-settings$/, /^ChartSideToolbarWidget\.visible$/, /^onwidget\.watchlist$/, /^chart\.favoriteDrawings$/, /^chart\.favoriteDrawingsPosition$/, /^chart\.favoriteLibraryIndicators$/, /^loadChartDialog.favorites$/, /^ChartFavoriteDrawingToolbarWidget\.visible/, /^trading\.chart\.proterty$/, /^trading_floating_toolbar\.position$/, /^trading\.orderWidgetMode\./, /^symbolWatermark$/, /^pinereference\.size$/, /^pinereference\.position$/, /^hint\.+/, /^ChartDrawingToolbarWidget\.visible/];
      function v(e) {
        return g + e;
      }
      function S(e) {
        return e.substring(g.length);
      }
      function b(e, t) {
        var i = f[e];
        return i ?? t;
      }
      function w(e, t, i) {
        i = i || {};
        var s = "" + t;
        if (f[e] !== s) {
          f[e] = s;
          P(e, i);
        }
        if (i.forceFlush && !p) {
          p = setTimeout(function () {
            p = undefined;
            T();
          }, 10);
        }
        return h;
      }
      function C(e, t) {
        t = t || {};
        if (f[e] != null) {
          delete f[e];
          P(e);
        }
        if (t.forceFlush) {
          T();
        }
        return h;
      }
      function P(e, s) {
        if (t) {
          if (f[e] == null) {
            t.removeValue(e);
          } else {
            t.setValue(e, f[e]);
          }
        } else if (i()) {
          try {
            if (f[e] == null) {
              n.removeItem(v(e));
            } else {
              n.setItem(v(e), f[e]);
            }
          } catch (e) { }
        } else {
          0;
        }
        if (s?.skipCrossWindowEvent !== true) {
          o.emit("settings", JSON.stringify({
            key: e,
            value: f[e]
          }));
        }
      }
      function T(e) { }
      function x() {
        return Object.keys(f);
      }
      function I(e) {
        for (var t = 0; t < y.length; ++t) {
          if (y[t].exec(e)) {
            return true;
          }
        }
        return false;
      }
      function M(e) {
        return e.substring(0, g.length) === g;
      }
      function A(e) {
        f = {};
        const t = Object.keys(e).length === 0;
        if (!t) {
          (function (e) {
            Object.keys(e).forEach(function (t) {
              f[t] = e[t] + "";
            });
          })(e);
        }
        (function (e) {
          for (var t = n.length; t--;) {
            var i = n.key(t);
            if (i && M(i)) {
              if (e) {
                w(S(i), n.getItem(i));
              }
              n.removeItem(i);
            }
          }
        })(t);
      }
      y.push(/^savedwatch\..+/);
      o.on("settings", function (e) {
        var t = JSON.parse(e);
        if (t.value == null) {
          delete f[t.key];
        } else {
          f[t.key] = t.value;
        }
      });
      var L = new r();
      return {
        loaded: false,
        loadedModel: false,
        getValue: b,
        getJSON: function (e, t) {
          var i = b(e, undefined);
          if (i == null) {
            return t;
          }
          try {
            return JSON.parse(i);
          } catch (i) {
            C(e);
            return t;
          }
        },
        getBool: function (e, t) {
          var i = b(e);
          if (i == null) {
            return t;
          } else {
            return !!i && i !== "false" && +i != 0;
          }
        },
        getFloat: function (e, t, i) {
          var s = b(e, undefined);
          if (s == null) {
            return t;
          }
          var o = parseFloat(s);
          if (!isFinite(o)) {
            throw new TypeError("\"" + s + "\" is not float (key: \"" + e + "\")");
          }
          return o;
        },
        getInt: function (e, t, i) {
          var s = b(e, undefined);
          if (s == null) {
            return t;
          }
          var o = parseInt(s, 10);
          if (!isFinite(o)) {
            throw new TypeError("\"" + s + "\" is not int (key: \"" + e + "\")");
          }
          return o;
        },
        setValue: w,
        setJSON: function (e, t, i) {
          w(e, JSON.stringify(t), i);
          return h;
        },
        remove: C,
        keys: x,
        keysMask: function (e, t) {
          var i = x();
          var o = [];
          for (var n = (e = new RegExp("^" + s(e).replace(/\\\*\\\*/gi, ".+").replace(/\\\*/gi, "[^.]+") + "$", "gi"), i.length - 1); n >= 0; n--) {
            if (e.test(i[n])) {
              o.push(i[n]);
            }
            e.lastIndex = 0;
          }
          return o;
        },
        sync: function (e) {
          if (e !== null) {
            if (t) {
              A(t.initialSettings || {});
            } else if (i()) {
              (function () {
                if (TradingView.onWidget() && l.includes(window.location.host)) {
                  var e = "tradingview.";
                  for (var t = n.length; t--;) {
                    var i = n.key(t);
                    if (i.indexOf(e) === 0) {
                      var s = i.replace(e, m + ".");
                      n.setItem(s, n.getItem(i));
                      n.removeItem(i);
                    }
                  }
                }
              })();
              (function () {
                f = {};
                var e = !a.enabled("save_chart_properties_to_local_storage");
                for (var t = n.length; t--;) {
                  var i = n.key(t);
                  if (i && M(i)) {
                    var s = i.substring(g.length);
                    if (!e || !!I(s)) {
                      f[s] = n.getItem(i);
                    }
                  }
                }
              })();
            } else {
              A(e || {});
            }
            L.fire();
          } else {
            true;
          }
        },
        onSync: L,
        setSettingsAdapter: function (e) {
          t = e;
        }
      };
    }();
    if (e && e.exports) {
      e.exports = h;
    }
  },
  88145: (e, t, i) => {
    "use strict";

    function s(e) {
      return e !== undefined && e.includes("crypto");
    }
    function o(e) {
      return e === "bond";
    }
    function n(e) {
      return Boolean(e.typespecs?.includes("yield"));
    }
    function r(e) {
      return e?.includes("discontinued") ?? false;
    }
    i.d(t, {
      hasCryptoTypespec: () => s,
      isBond: () => o,
      isSymbolDelisted: () => r,
      isYield: () => n
    });
  },
  49156: (e, t, i) => {
    "use strict";

    i.d(t, {
      colors: () => a
    });
    var s = i(19625);
    var o = i(19063);
    const n = {
      colorBlack: (0, s.getHexColorByName)("color-black"),
      colorWhite: (0, s.getHexColorByName)("color-white"),
      colorTvBlue50: (0, s.getHexColorByName)("color-tv-blue-50"),
      colorTvBlue200: (0, s.getHexColorByName)("color-tv-blue-200"),
      colorTvBlue400: (0, s.getHexColorByName)("color-tv-blue-400"),
      colorTvBlue500: (0, s.getHexColorByName)("color-tv-blue-500"),
      colorTvBlue600: (0, s.getHexColorByName)("color-tv-blue-600"),
      colorTvBlue800: (0, s.getHexColorByName)("color-tv-blue-800"),
      colorTvBlueA800: (0, s.getHexColorByName)("color-tv-blue-a800"),
      colorDeepBlue200: (0, s.getHexColorByName)("color-deep-blue-200"),
      colorDeepBlue300: (0, s.getHexColorByName)("color-deep-blue-300"),
      colorDeepBlue500: (0, s.getHexColorByName)("color-deep-blue-500"),
      colorDeepBlueA200: (0, s.getHexColorByName)("color-deep-blue-a200"),
      colorDeepBlueA400: (0, s.getHexColorByName)("color-deep-blue-a400"),
      colorDeepBlueA700: (0, s.getHexColorByName)("color-deep-blue-a700"),
      colorSkyBlue400: (0, s.getHexColorByName)("color-sky-blue-400"),
      colorSkyBlue500: (0, s.getHexColorByName)("color-sky-blue-500"),
      colorSkyBlue700: (0, s.getHexColorByName)("color-sky-blue-700"),
      colorDefaultRed: (0, s.getHexColorByName)("color-youtube"),
      colorRipeRed200: (0, s.getHexColorByName)("color-ripe-red-200"),
      colorRipeRed300: (0, s.getHexColorByName)("color-ripe-red-300"),
      colorRipeRed400: (0, s.getHexColorByName)("color-ripe-red-400"),
      colorRipeRed500: (0, s.getHexColorByName)("color-ripe-red-500"),
      colorRipeRed600: (0, s.getHexColorByName)("color-ripe-red-600"),
      colorRipeRed800: (0, s.getHexColorByName)("color-ripe-red-800"),
      colorRipeRedA900: (0, s.getHexColorByName)("color-ripe-red-a900"),
      colorRipeRedA700: (0, s.getHexColorByName)("color-ripe-red-a700"),
      colorGrapesPurpleA200: (0, s.getHexColorByName)("color-grapes-purple-a200"),
      colorGrapesPurpleA400: (0, s.getHexColorByName)("color-grapes-purple-a400"),
      colorGrapesPurple500: (0, s.getHexColorByName)("color-grapes-purple-500"),
      colorBerryPink400: (0, s.getHexColorByName)("color-berry-pink-400"),
      colorBerryPink500: (0, s.getHexColorByName)("color-berry-pink-500"),
      colorMintyGreen100: (0, s.getHexColorByName)("color-minty-green-100"),
      colorMintyGreen200: (0, s.getHexColorByName)("color-minty-green-200"),
      colorMintyGreen400: (0, s.getHexColorByName)("color-minty-green-400"),
      colorMintyGreen500: (0, s.getHexColorByName)("color-minty-green-500"),
      colorMintyGreen600: (0, s.getHexColorByName)("color-minty-green-600"),
      colorMintyGreen800: (0, s.getHexColorByName)("color-minty-green-800"),
      colorMintyGreenA900: (0, s.getHexColorByName)("color-minty-green-a900"),
      colorIguanaGreen300: (0, s.getHexColorByName)("color-iguana-green-300"),
      colorIguanaGreen500: (0, s.getHexColorByName)("color-iguana-green-500"),
      colorIguanaGreenA700: (0, s.getHexColorByName)("color-iguana-green-a700"),
      colorTanOrange300: (0, s.getHexColorByName)("color-tan-orange-300"),
      colorTanOrange500: (0, s.getHexColorByName)("color-tan-orange-500"),
      colorTanOrange600: (0, s.getHexColorByName)("color-tan-orange-600"),
      colorTanOrange700: (0, s.getHexColorByName)("color-tan-orange-700"),
      colorColdGray100: (0, s.getHexColorByName)("color-cold-gray-100"),
      colorColdGray150: (0, s.getHexColorByName)("color-cold-gray-150"),
      colorColdGray200: (0, s.getHexColorByName)("color-cold-gray-200"),
      colorColdGray300: (0, s.getHexColorByName)("color-cold-gray-300"),
      colorColdGray400: (0, s.getHexColorByName)("color-cold-gray-400"),
      colorColdGray450: (0, s.getHexColorByName)("color-cold-gray-450"),
      colorColdGray500: (0, s.getHexColorByName)("color-cold-gray-500"),
      colorColdGray600: (0, s.getHexColorByName)("color-cold-gray-600"),
      colorColdGray650: (0, s.getHexColorByName)("color-cold-gray-650"),
      colorColdGray700: (0, s.getHexColorByName)("color-cold-gray-700"),
      colorColdGray750: (0, s.getHexColorByName)("color-cold-gray-750"),
      colorColdGray800: (0, s.getHexColorByName)("color-cold-gray-800"),
      colorColdGray850: (0, s.getHexColorByName)("color-cold-gray-850"),
      colorColdGray900: (0, s.getHexColorByName)("color-cold-gray-900"),
      colorForestGreen300: (0, s.getHexColorByName)("color-forest-green-300")
    };
    const r = {
      colorWhiteAlpha25: (0, o.generateColor)(n.colorWhite, 75),
      colorTvBlue500Alpha30: (0, o.generateColor)(n.colorTvBlue500, 70),
      colorTvBlue500Alpha28: (0, o.generateColor)(n.colorTvBlue500, 72),
      colorTvBlue500Alpha25: (0, o.generateColor)(n.colorTvBlue500, 75),
      colorTvBlue500Alpha20: (0, o.generateColor)(n.colorTvBlue500, 80),
      colorDeepBlue500Alpha20: (0, o.generateColor)(n.colorDeepBlue500, 80),
      colorSkyBlue400Alpha5: (0, o.generateColor)(n.colorSkyBlue400, 95),
      colorSkyBlue400Alpha50: (0, o.generateColor)(n.colorSkyBlue400, 50),
      colorSkyBlue400Alpha75: (0, o.generateColor)(n.colorSkyBlue400, 25),
      colorSkyBlue500Alpha20: (0, o.generateColor)(n.colorSkyBlue500, 80),
      colorSkyBlue700Alpha70: (0, o.generateColor)(n.colorSkyBlue700, 30),
      colorRipeRed400Alpha5: (0, o.generateColor)(n.colorRipeRed400, 95),
      colorRipeRed500Alpha5: (0, o.generateColor)(n.colorRipeRed500, 95),
      colorRipeRed500Alpha20: (0, o.generateColor)(n.colorRipeRed500, 80),
      colorRipeRed500Alpha28: (0, o.generateColor)(n.colorRipeRed500, 72),
      colorRipeRed500Alpha30: (0, o.generateColor)(n.colorRipeRed500, 70),
      colorRipeRed500Alpha50: (0, o.generateColor)(n.colorRipeRed500, 50),
      colorGrapesPurpleA200Alpha15: (0, o.generateColor)(n.colorGrapesPurpleA200, 85),
      colorGrapesPurple500Alpha0: (0, o.generateColor)(n.colorGrapesPurple500, 100),
      colorGrapesPurple500Alpha20: (0, o.generateColor)(n.colorGrapesPurple500, 80),
      colorGrapesPurple500Alpha70: (0, o.generateColor)(n.colorGrapesPurple500, 30),
      colorBerryPink400Alpha50: (0, o.generateColor)(n.colorBerryPink400, 50),
      colorBerryPink400Alpha75: (0, o.generateColor)(n.colorBerryPink400, 25),
      colorBerryPink500Alpha20: (0, o.generateColor)(n.colorBerryPink500, 80),
      colorMintyGreen500Alpha20: (0, o.generateColor)(n.colorMintyGreen500, 80),
      colorMintyGreen500Alpha28: (0, o.generateColor)(n.colorMintyGreen500, 72),
      colorMintyGreen500Alpha50: (0, o.generateColor)(n.colorMintyGreen500, 50),
      colorMintyGreen500Alpha5: (0, o.generateColor)(n.colorMintyGreen500, 95),
      colorIguanaGreen500Alpha20: (0, o.generateColor)(n.colorIguanaGreen500, 80),
      colorTanOrange500Alpha20: (0, o.generateColor)(n.colorTanOrange500, 80),
      colorForestGreen300Alpha5: (0, o.generateColor)(n.colorForestGreen300, 95),
      colorColdGray100Alpha0: (0, o.generateColor)(n.colorColdGray100, 100),
      colorColdGray100Alpha6: (0, o.generateColor)(n.colorColdGray100, 94),
      colorColdGray800Alpha0: (0, o.generateColor)(n.colorColdGray800, 100),
      colorColdGray800Alpha6: (0, o.generateColor)(n.colorColdGray800, 94)
    };
    const a = {
      ...n,
      ...r
    };
  },
  2433: (e, t, i) => {
    "use strict";

    i.d(t, {
      light: () => te
    });
    var s = i(49156);
    var o = i(46088);
    const {
      colorWhite: n,
      colorBlack: r,
      colorColdGray150: a,
      colorColdGray300: l,
      colorColdGray400: c,
      colorColdGray450: h,
      colorColdGray800Alpha0: d,
      colorColdGray800Alpha6: u,
      colorColdGray900: _,
      colorGrapesPurpleA400: p,
      colorGrapesPurpleA200Alpha15: m,
      colorMintyGreen200: g,
      colorMintyGreen400: f,
      colorMintyGreen500: y,
      colorMintyGreen600: v,
      colorMintyGreen800: S,
      colorMintyGreen500Alpha5: b,
      colorMintyGreen500Alpha20: w,
      colorMintyGreen500Alpha28: C,
      colorMintyGreen500Alpha50: P,
      colorRipeRed200: T,
      colorRipeRed400: x,
      colorRipeRed500: I,
      colorRipeRed600: M,
      colorRipeRedA700: A,
      colorRipeRed500Alpha5: L,
      colorRipeRed500Alpha28: k,
      colorRipeRed500Alpha50: D,
      colorRipeRed500Alpha20: E,
      colorDeepBlueA700: B,
      colorBerryPink500: V,
      colorBerryPink400Alpha50: R,
      colorBerryPink400Alpha75: N,
      colorIguanaGreenA700: O,
      colorSkyBlue400Alpha5: F,
      colorSkyBlue400Alpha50: W,
      colorSkyBlue400Alpha75: H,
      colorSkyBlue500: z,
      colorDeepBlueA400: U,
      colorTvBlue200: j,
      colorTvBlue400: G,
      colorTvBlue500: q,
      colorTvBlue500Alpha28: $,
      colorTvBlue600: K,
      colorTvBlue800: Y,
      colorTanOrange500: Z,
      colorTanOrange600: X
    } = s.colors;
    const J = {};
    const Q = {};
    const ee = {};
    const te = {
      content: {
        chartProperties: {
          scalesProperties: {
            textColor: _,
            lineColor: d,
            backgroundColor: n
          },
          paneProperties: {
            vertGridProperties: {
              color: u
            },
            horzGridProperties: {
              color: u
            },
            crossHairProperties: {
              color: c
            },
            backgroundType: o.ColorType.Solid,
            background: n,
            backgroundGradientStartColor: n,
            backgroundGradientEndColor: n,
            separatorColor: a
          }
        },
        sessions: {
          sessionHighlight: {
            backgrounds: {
              outOfSession: {
                color: q,
                transparency: 92
              },
              preMarket: {
                color: Z,
                transparency: 92
              },
              postMarket: {
                color: q,
                transparency: 92
              },
              electronic: {
                color: q,
                transparency: 92
              }
            },
            vertlines: {
              sessBreaks: {
                color: "#4985e7"
              }
            }
          }
        },
        mainSourceProperties: {
          baseLineColor: l,
          prevClosePriceLineColor: "#555555",
          priceLineColor: "",
          highLowAvgPrice: {
            highLowPriceLinesColor: "",
            averagePriceLineColor: ""
          },
          bidAsk: {
            bidLineColor: q,
            askLineColor: x
          },
          prePostMarket: {
            preMarketColor: X,
            postMarketColor: q
          },
          candleStyle: {
            borderColor: "#378658",
            upColor: y,
            wickColor: "#737375",
            wickUpColor: y,
            wickDownColor: I,
            downColor: I,
            borderUpColor: y,
            borderDownColor: I
          },
          volCandlesStyle: {
            borderColor: "#378658",
            upColor: y,
            wickColor: "#737375",
            wickUpColor: y,
            wickDownColor: I,
            downColor: I,
            borderUpColor: y,
            borderDownColor: I
          },
          haStyle: {
            borderColor: "#378658",
            upColor: y,
            wickColor: "#737375",
            wickUpColor: y,
            wickDownColor: I,
            downColor: I,
            borderUpColor: y,
            borderDownColor: I
          },
          hlcAreaStyle: {
            highLineColor: y,
            lowLineColor: I,
            closeLineColor: h,
            highCloseFillColor: w,
            closeLowFillColor: E
          },
          hollowCandleStyle: {
            upColor: y,
            downColor: I,
            borderColor: "#378658",
            borderUpColor: y,
            borderDownColor: I,
            wickColor: "#737375",
            wickUpColor: y,
            wickDownColor: I
          },
          barStyle: {
            downColor: I,
            upColor: y
          },
          pnfStyle: {
            downColor: I,
            upColor: y,
            upColorProjection: "#a9dcc3",
            downColorProjection: "#f5a6ae"
          },
          baselineStyle: {
            baselineColor: h,
            topFillColor1: C,
            topFillColor2: b,
            bottomFillColor1: L,
            bottomFillColor2: k,
            topLineColor: y,
            bottomLineColor: I
          },
          areaStyle: {
            transparency: 100,
            color1: $,
            color2: q,
            linecolor: q
          },
          hiloStyle: {
            color: q,
            borderColor: q,
            labelColor: q
          },
          columnStyle: {
            upColor: P,
            downColor: D
          },
          renkoStyle: {
            upColor: y,
            downColor: I,
            borderUpColor: y,
            borderDownColor: I,
            upColorProjection: "#a9dcc3",
            downColorProjection: "#f5a6ae",
            borderUpColorProjection: "#a9dcc3",
            borderDownColorProjection: "#f5a6ae",
            wickUpColor: y,
            wickDownColor: I
          },
          lineStyle: {
            colorType: o.ColorType.Gradient,
            color: q,
            gradientStartColor: p,
            gradientEndColor: "#00BCE5"
          },
          lineWithMarkersStyle: {
            colorType: o.ColorType.Gradient,
            color: q,
            gradientStartColor: p,
            gradientEndColor: "#00BCE5"
          },
          steplineStyle: {
            colorType: o.ColorType.Gradient,
            color: q,
            gradientStartColor: p,
            gradientEndColor: "#00BCE5"
          },
          kagiStyle: {
            downColor: I,
            upColor: y,
            upColorProjection: "#a9dcc3",
            downColorProjection: "#f5a6ae"
          },
          pbStyle: {
            upColor: y,
            downColor: I,
            borderUpColor: y,
            borderDownColor: I,
            upColorProjection: "#a9dcc3",
            downColorProjection: "#f5a6ae",
            borderUpColorProjection: "#a9dcc3",
            borderDownColorProjection: "#f5a6ae"
          },
          rangeStyle: {
            upColor: y,
            downColor: I,
            upColorProjection: "#a9dcc3",
            downColorProjection: "#f5a6ae",
            candlesUpColor: y,
            candlesDownColor: I,
            candlesBorderUpColor: y,
            candlesBorderDownColor: I,
            candlesWickUpColor: y,
            candlesWickDownColor: I
          },
          tpoStyle: J,
          volFootprintStyle: Q,
          svpStyle: ee,
          hlcBarsStyle: {
            color: q
          }
        }
      }
    };
  },
  24317: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      darkTheme: () => le,
      getStdChartTheme: () => ue,
      getStdThemeNames: () => de,
      lightTheme: () => ae,
      overrideStdTheme: () => ce,
      restoreStdThemes: () => he,
      translateThemeName: () => _e
    });
    var s = i(11542);
    var o = i(37265);
    var n = i(2433);
    var r = i(46088);
    var a = i(49156);
    const {
      colorWhite: l,
      colorColdGray100Alpha0: c,
      colorColdGray100Alpha6: h,
      colorColdGray200: d,
      colorColdGray300: u,
      colorColdGray400: _,
      colorColdGray450: p,
      colorColdGray600: m,
      colorColdGray800: g,
      colorColdGray900: f,
      colorDeepBlueA200: y,
      colorGrapesPurpleA400: v,
      colorGrapesPurpleA200Alpha15: S,
      colorMintyGreen400: b,
      colorMintyGreen500: w,
      colorMintyGreen600: C,
      colorMintyGreen800: P,
      colorMintyGreen500Alpha5: T,
      colorMintyGreen500Alpha20: x,
      colorMintyGreen500Alpha28: I,
      colorMintyGreen500Alpha50: M,
      colorMintyGreenA900: A,
      colorRipeRed400: L,
      colorRipeRed500: k,
      colorRipeRed600: D,
      colorRipeRed800: E,
      colorRipeRed500Alpha5: B,
      colorRipeRed500Alpha20: V,
      colorRipeRed500Alpha28: R,
      colorRipeRed500Alpha50: N,
      colorRipeRedA900: O,
      colorBerryPink400Alpha50: F,
      colorBerryPink400Alpha75: W,
      colorBerryPink500: H,
      colorIguanaGreenA700: z,
      colorSkyBlue400Alpha5: U,
      colorSkyBlue400Alpha50: j,
      colorSkyBlue400Alpha75: G,
      colorSkyBlue500: q,
      colorDeepBlueA400: $,
      colorTvBlue400: K,
      colorTvBlue500: Y,
      colorTvBlue500Alpha28: Z,
      colorTvBlue600: X,
      colorTvBlue800: J,
      colorTvBlueA800: Q,
      colorTanOrange500: ee,
      colorTanOrange600: te
    } = a.colors;
    const ie = {};
    const se = {};
    const oe = {};
    const ne = {
      content: {
        chartProperties: {
          scalesProperties: {
            textColor: u,
            lineColor: c,
            backgroundColor: l
          },
          paneProperties: {
            vertGridProperties: {
              color: h
            },
            horzGridProperties: {
              color: h
            },
            crossHairProperties: {
              color: _
            },
            background: f,
            backgroundGradientStartColor: "#1C1C1C",
            backgroundGradientEndColor: f,
            backgroundType: "gradient",
            separatorColor: g
          }
        },
        sessions: {
          sessionHighlight: {
            backgrounds: {
              outOfSession: {
                color: Y,
                transparency: 92
              },
              preMarket: {
                color: ee,
                transparency: 92
              },
              postMarket: {
                color: Y,
                transparency: 92
              },
              electronic: {
                color: Y,
                transparency: 92
              }
            },
            vertlines: {
              sessBreaks: {
                color: "#4985e7"
              }
            }
          }
        },
        mainSourceProperties: {
          baseLineColor: m,
          prevClosePriceLineColor: "#555555",
          priceLineColor: "",
          highLowAvgPrice: {
            highLowPriceLinesColor: "",
            averagePriceLineColor: ""
          },
          bidAsk: {
            bidLineColor: Y,
            askLineColor: L
          },
          prePostMarket: {
            preMarketColor: te,
            postMarketColor: Y
          },
          candleStyle: {
            borderColor: "#378658",
            upColor: w,
            wickColor: "#737375",
            wickUpColor: w,
            wickDownColor: k,
            downColor: k,
            borderUpColor: w,
            borderDownColor: k
          },
          volCandlesStyle: {
            borderColor: "#378658",
            upColor: w,
            wickColor: "#737375",
            wickUpColor: w,
            wickDownColor: k,
            downColor: k,
            borderUpColor: w,
            borderDownColor: k
          },
          haStyle: {
            borderColor: "#378658",
            upColor: w,
            wickColor: "#737375",
            wickUpColor: w,
            wickDownColor: k,
            downColor: k,
            borderUpColor: w,
            borderDownColor: k
          },
          hlcAreaStyle: {
            highLineColor: w,
            lowLineColor: k,
            closeLineColor: p,
            highCloseFillColor: x,
            closeLowFillColor: V
          },
          hollowCandleStyle: {
            upColor: w,
            downColor: k,
            borderColor: "#378658",
            borderUpColor: w,
            borderDownColor: k,
            wickColor: "#737375",
            wickUpColor: w,
            wickDownColor: k
          },
          barStyle: {
            downColor: k,
            upColor: w
          },
          pnfStyle: {
            downColor: k,
            upColor: w,
            upColorProjection: "#336854",
            downColorProjection: "#7f323f"
          },
          baselineStyle: {
            baselineColor: p,
            topFillColor1: I,
            topFillColor2: T,
            bottomFillColor1: B,
            bottomFillColor2: R,
            topLineColor: w,
            bottomLineColor: k
          },
          areaStyle: {
            transparency: 100,
            color1: Z,
            color2: Y,
            linecolor: Y
          },
          hiloStyle: {
            color: Y,
            borderColor: Y,
            labelColor: Y
          },
          columnStyle: {
            upColor: M,
            downColor: N
          },
          renkoStyle: {
            upColor: w,
            downColor: k,
            borderUpColor: w,
            borderDownColor: k,
            upColorProjection: "#336854",
            downColorProjection: "#7f323f",
            borderUpColorProjection: "#336854",
            borderDownColorProjection: "#7f323f",
            wickUpColor: w,
            wickDownColor: k
          },
          lineStyle: {
            colorType: r.ColorType.Gradient,
            color: Y,
            gradientStartColor: v,
            gradientEndColor: "#00BCE5"
          },
          lineWithMarkersStyle: {
            colorType: r.ColorType.Gradient,
            color: Y,
            gradientStartColor: v,
            gradientEndColor: "#00BCE5"
          },
          steplineStyle: {
            colorType: r.ColorType.Gradient,
            color: Y,
            gradientStartColor: v,
            gradientEndColor: "#00BCE5"
          },
          kagiStyle: {
            downColor: k,
            upColor: w,
            upColorProjection: "#336854",
            downColorProjection: "#7f323f"
          },
          pbStyle: {
            upColor: w,
            downColor: k,
            borderUpColor: w,
            borderDownColor: k,
            upColorProjection: "#336854",
            downColorProjection: "#7f323f",
            borderUpColorProjection: "#336854",
            borderDownColorProjection: "#7f323f"
          },
          rangeStyle: {
            upColor: w,
            downColor: k,
            upColorProjection: "#336854",
            downColorProjection: "#7f323f",
            candlesUpColor: w,
            candlesDownColor: k,
            candlesBorderUpColor: w,
            candlesBorderDownColor: k,
            candlesWickUpColor: w,
            candlesWickDownColor: k
          },
          tpoStyle: ie,
          volFootprintStyle: se,
          svpStyle: oe,
          hlcBarsStyle: {
            color: Y
          }
        }
      }
    };
    var re = i(24633);
    let ae = (0, o.clone)(n.light);
    let le = (0, o.clone)(ne);
    function ce(e, t) {
      switch (e) {
        case re.StdTheme.Light:
          ae = (0, o.merge)((0, o.clone)(ae), t);
          break;
        case re.StdTheme.Dark:
          le = (0, o.merge)((0, o.clone)(le), t);
      }
    }
    function he() {
      ae = (0, o.clone)(n.light);
      le = (0, o.clone)(ne);
    }
    function de() {
      return [re.StdTheme.Light, re.StdTheme.Dark];
    }
    function ue(e) {
      return (0, o.clone)(e === re.StdTheme.Light ? ae : e === re.StdTheme.Dark ? le : undefined);
    }
    function _e(e) {
      return {
        [re.StdTheme.Light]: s.t(null, {
          context: "colorThemeName"
        }, i(96870)),
        [re.StdTheme.Dark]: s.t(null, {
          context: "colorThemeName"
        }, i(85119))
      }[e] || e;
    }
  },
  24633: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      StdTheme: () => s
    });
    (function (e) {
      e.Light = "light";
      e.Dark = "dark";
    })(s ||= {});
  },
  85662: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      DEFAULT_THEME: () => c,
      getCurrentTheme: () => g,
      getStdTheme: () => T,
      getStdThemeNames: () => C,
      getStdThemedValue: () => x,
      getTheme: () => b,
      getThemeNames: () => w,
      getThemedColor: () => f,
      isPublicTheme: () => m,
      isStdThemeName: () => P,
      isStdThemedDefaultValue: () => I,
      isThemeExist: () => L,
      removeTheme: () => A,
      restoreTheme: () => y,
      saveTheme: () => M,
      savedThemeName: () => v,
      syncTheme: () => S,
      themes: () => p,
      translateStdThemeName: () => k
    });
    var s = i(24377);
    var o = i(56840);
    function n() {
      return (0, o.getValue)("current_theme.name") || null;
    }
    const r = i(64289);
    var a = i(24317);
    var l = i(45345);
    const c = "light";
    var h = i(24633);
    var d = i(11542);
    var u = i(20913);
    var _ = i(19625);
    const p = {
      [h.StdTheme.Light]: {
        name: h.StdTheme.Light,
        label: () => d.t(null, {
          context: "colorThemeName"
        }, i(96870)),
        order: 2,
        getThemedColor: e => (0, _.getHexColorByName)(e)
      },
      [h.StdTheme.Dark]: {
        name: h.StdTheme.Dark,
        label: () => d.t(null, {
          context: "colorThemeName"
        }, i(85119)),
        order: 1,
        getThemedColor: e => {
          const t = u[e] || e;
          return (0, _.getHexColorByName)(t);
        }
      }
    };
    function m(e) {
      return !e.isPrivate;
    }
    function g() {
      return p[l.watchedTheme.value()] || p[c];
    }
    function f(e) {
      return g().getThemedColor(e);
    }
    function y() {
      (0, l.setTheme)(n() || c);
    }
    function v() {
      return n();
    }
    function S() {
      var e;
      e = g().name;
      (0, o.setValue)("current_theme.name", e, {
        forceFlush: true
      });
    }
    function b(e) {
      return r.loadTheme(e);
    }
    function w() {
      return r.loadThemes();
    }
    function C() {
      return a.getStdThemeNames();
    }
    function P(e) {
      return C().includes(e);
    }
    function T(e) {
      return a.getStdChartTheme(e) || {
        content: undefined
      };
    }
    function x(e, t) {
      const i = t || g().name;
      const s = a.getStdChartTheme(i);
      const o = e.length !== 0 && e.split(".");
      if (s && s.content && o) {
        return o.reduce((e, t) => e[t], s.content);
      } else {
        return null;
      }
    }
    function I(e, t, i) {
      const o = x(e, i);
      return o !== null && (0, s.areEqualRgba)((0, s.parseRgba)(o), (0, s.parseRgba)(String(t)));
    }
    function M(e, t) {
      return r.saveTheme(e, t);
    }
    function A(e) {
      return r.removeTheme(e);
    }
    function L(e) {
      return r.isThemeExist(e);
    }
    function k(e) {
      return a.translateThemeName(e);
    }
  },
  45345: (e, t, i) => {
    "use strict";

    i.d(t, {
      setTheme: () => r,
      watchedTheme: () => n
    });
    var s;
    var o = i(64147);
    (function (e) {
      e.ThemeClassPrefix = "theme-";
    })(s ||= {});
    const n = new o.WatchedValue();
    function r(e) {
      n.setValue(e);
    }
    n.subscribe(e => {
      (function (e, t = window) {
        const i = "theme-" + e;
        const s = t.document.documentElement.classList;
        for (const e of Array.from(s)) {
          if (e.startsWith("theme-") && e !== i) {
            s.remove(e);
          }
        }
        s.add(i);
      })(e, window);
    });
  },
  51768: (e, t, i) => {
    "use strict";

    i.d(t, {
      disableTrackingEvents: () => a,
      trackEvent: () => r
    });
    var s = i(76422);
    i(56570);
    (0, i(9343).getLogger)("Common.TrackEvent");
    const o = [/Study_(Drawing)_(.*)/, /(Study)_(.*)@tv-basicstudies/, /(Study)_(.*)/, /(Chart Style) (.*)/];
    let n = false;
    const r = (e, t, i) => {
      if (!n) {
        ((e, t, i) => {
          t = t || e || i || "";
          let n = "";
          for (let e = 0; e < o.length; e++) {
            const i = t.match(o[e]);
            if (i && i.length === 3) {
              t = i[1];
              n = i[2];
              break;
            }
          }
          (0, s.emit)(t.toLowerCase().replace(" ", "_"), {
            category: e,
            label: i,
            value: n
          });
        })(e, t, i);
      }
    };
    function a() {
      n = true;
    }
    var l;
    var c;
    var h;
    if (typeof window != "undefined") {
      window.TradingView = window.TradingView || {};
      window.TradingView.trackEvent = r;
    }
    (function (e) {
      e.GUI = "GUI";
    })(l ||= {});
    (function (e) {
      e.ChartHeaderToolbar = "Chart Header Toolbar";
      e.ChartBottomToolbar = "Chart Bottom Toolbar";
      e.ChartLeftToolbar = "Chart Left Toolbar";
      e.TimeInterval = "Time Interval";
      e.LoadChartLayout = "Load chart layout";
    })(c ||= {});
    (function (e) {
      e.Range = "range";
      e.GoTo = "go to";
      e.ChartProperties = "chart properties";
      e.Compare = "compare";
      e.SelectLayout = "select layout";
      e.MagnetMode = "magnet mode";
      e.DrawingMode = "drawing mode";
      e.LockAllDrawing = "lock all drawing";
      e.RemoveDrawing = "remove drawing";
      e.RemoveIndicator = "remove indicator";
      e.RemoveAll = "remove all";
      e.HideDrawings = "hide drawings";
      e.HideIndicators = "hide indicators";
      e.HidePositions = "hide positions";
      e.HideAll = "hide all";
      e.Sync = "sync";
      e.SyncMode = "sync mode";
      e.SwitchChartLayout = "Switch chart layout";
      e.DeleteChartLayout = "Delete chart layout";
      e.LoadChartLayout = "Load chart layout";
      e.AddToFavorites = "Add to favorites";
      e.Sort = "Sort";
    })(h ||= {});
  },
  21097: (e, t, i) => {
    "use strict";

    i.d(t, {
      TVXWindowEvents: () => r
    });
    i(21251);
    var s = i(9343);
    var o = i(11417);
    const n = (0, s.getLogger)("XWindowEvents");
    var r;
    (function (e) {
      const t = "tvxwevents.";
      const i = {};
      let s;
      if (window.BroadcastChannel) {
        s = new BroadcastChannel("tvxwevents");
        s.addEventListener("message", function (e) {
          const {
            data: {
              event: t,
              value: s
            }
          } = e;
          if (i[t]) {
            i[t].forEach(e => {
              e(s);
            });
          }
        });
        (function () {
          const e = [];
          const i = performance.now();
          for (let i = 0; i < o.TVLocalStorage.length; i++) {
            const s = o.TVLocalStorage.key(i);
            if (s.startsWith(t)) {
              e.push(s);
            }
          }
          const s = o.TVLocalStorage.length;
          for (const t of e) {
            o.TVLocalStorage.removeItem(t);
          }
          const r = performance.now() - i;
          n.logNormal(`Total keys amount in local storage on operation start: ${s}`);
          n.logNormal(`Keys amount in local storage to be deleted: ${e.length}`);
          n.logNormal(`Keys to be deleted from local storage: ${JSON.stringify(e)}`);
          n.logNormal(`Removing keys from local storage took ${r} ms`);
        })();
      } else {
        window.addEventListener("storage", function (e) {
          const {
            newValue: s,
            key: n
          } = e;
          if (s === null || !n || !n.startsWith(t)) {
            return;
          }
          const r = n.substring(11);
          if (i[r]) {
            i[r].forEach(t => {
              t(e.newValue);
            });
          }
          o.TVLocalStorage.removeItem(n);
        });
      }
      e.on = function (e, t) {
        i[e] ||= [];
        i[e].push(t);
      };
      e.off = function (e, t) {
        if (!i[e]) {
          return;
        }
        const s = i[e].indexOf(t);
        if (s !== -1) {
          if (i[e].length === 1) {
            delete i[e];
          } else {
            i[e].splice(s, 1);
          }
        }
      };
      e.emit = function (e, i = Date.now()) {
        try {
          if (s) {
            s.postMessage({
              event: e,
              value: i
            });
          } else {
            o.TVLocalStorage.setItem(t + e, i.toString());
          }
        } catch (e) {
          n.logError(e.message);
        }
      };
    })(r ||= {});
  },
  58473: (e, t, i) => {
    "use strict";

    i.d(t, {
      activateKeyPressHandler: () => m,
      showDialog: () => g
    });
    const s = [];
    let o = null;
    function n(e) {
      for (let t = 0; t < s.length; t++) {
        if (s[t].name === e) {
          return t;
        }
      }
      return -1;
    }
    function r(e) {
      if (!o) {
        for (let t = s.length - 1; t >= 0 && s[t].func(e) !== true; t--);
      }
    }
    window.addEventListener("keypress", r, false);
    var a = i(79652);
    var l = i(56570);
    var c = i(86235);
    var h = i(86001);
    var d = i(50340);
    var u = i(51768);
    let _ = null;
    function p(e) {
      if (!(0, a.globalKeypressMatches)(e)) {
        return false;
      }
      e.preventDefault();
      const t = String.fromCharCode(e.charCode);
      if (l.enabled("show_interval_dialog_on_key_press") && function (e) {
        return /[1-9]/.test(e);
      }(t)) {
        (0, c.showChangeIntervalDialogAsync)({
          initVal: t
        });
      } else if (l.enabled("symbol_search_hot_key")) {
        g({
          defaultValue: t,
          selectSearchOnInit: false,
          source: "keyboard",
          trackResultsOptions: {
            trackResults: false,
            emptySearchType: "empty_result__supercharts"
          },
          enableOptionsChain: l.enabled("symbol_search_option_chain_selector")
        });
        (0, u.trackEvent)("GUI", "SS", "hotkey");
      }
      return true;
    }
    function m() {
      (0, h.loadChangeIntervalDialog)();
      (function (e, t) {
        const i = {
          name: e,
          func: t
        };
        const o = n(i.name);
        if (o > -1) {
          s.splice(o, 1);
        }
        s.unshift(i);
      })("symbolEdit", p);
    }
    function g(e) {
      const t = _ = (0, d.loadNewSymbolSearch)().then(i => {
        if (t === _) {
          i.showDefaultSearchDialog(e);
        }
      });
      return t;
    }
  },
  78136: (e, t, i) => {
    "use strict";

    let s;
    function o() {
      return s;
    }
    function n(e) {
      s = e;
    }
    i.d(t, {
      getSearchRequestDelay: () => o,
      setSearchRequestDelay: () => n
    });
  },
  52092: (e, t, i) => {
    "use strict";

    i.d(t, {
      CLOSE_POPUPS_AND_DIALOGS_COMMAND: () => s
    });
    const s = "CLOSE_POPUPS_AND_DIALOGS_COMMAND";
    var o;
    (function (e) {
      e[e.Mobile = 0] = "Mobile";
      e[e.TabletSmall = 480] = "TabletSmall";
      e[e.Tablet = 768] = "Tablet";
      e[e.TabletLarge = 1024] = "TabletLarge";
      e[e.DesktopSmall = 1280] = "DesktopSmall";
      e[e.Desktop = 1440] = "Desktop";
      e[e.DesktopLarge = 1920] = "DesktopLarge";
    })(o ||= {});
  },
  3615: (e, t, i) => {
    "use strict";

    async function s(e, t) {
      const s = await Promise.all([i.e(1303), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(5826), i.e(4600), i.e(2564), i.e(6445), i.e(3799), i.e(5480), i.e(6489), i.e(9766), i.e(5375), i.e(601), i.e(4876), i.e(4137), i.e(2371), i.e(2227), i.e(4931), i.e(2544), i.e(769), i.e(4411), i.e(8890)]).then(i.bind(i, 70493));
      return s.showSimpleDialog(e, s.renameModule, t);
    }
    async function o(e, t) {
      const s = await Promise.all([i.e(1303), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(5826), i.e(4600), i.e(2564), i.e(6445), i.e(3799), i.e(5480), i.e(6489), i.e(9766), i.e(5375), i.e(601), i.e(4876), i.e(4137), i.e(2371), i.e(2227), i.e(4931), i.e(2544), i.e(769), i.e(4411), i.e(8890)]).then(i.bind(i, 70493));
      return s.showSimpleDialog(e, s.confirmModule, t);
    }
    async function n(e, t) {
      const s = await Promise.all([i.e(1303), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(5826), i.e(4600), i.e(2564), i.e(6445), i.e(3799), i.e(5480), i.e(6489), i.e(9766), i.e(5375), i.e(601), i.e(4876), i.e(4137), i.e(2371), i.e(2227), i.e(4931), i.e(2544), i.e(769), i.e(4411), i.e(8890)]).then(i.bind(i, 70493));
      return s.showSimpleDialog(e, s.warningModule, t);
    }
    i.d(t, {
      showConfirm: () => o,
      showRename: () => s,
      showWarning: () => n
    });
  },
  14881: (e, t, i) => {
    "use strict";

    i.d(t, {
      hideStateChange: () => n
    });
    var s;
    var o = i(52033);
    (function (e) {
      e.Drawings = "drawings";
      e.Indicators = "indicators";
      e.Positions = "positions";
      e.All = "all";
    })(s ||= {});
    const n = new o.Delegate();
  },
  90995: (e, t, i) => {
    "use strict";

    i.d(t, {
      getHideModeStateValue: () => u,
      getHideOptions: () => h,
      getSavedHideMode: () => _,
      toggleHideMode: () => d
    });
    var s = i(50151);
    var o = i(11542);
    var n = i(56840);
    var r = i(79320);
    var a = i(928);
    var l = i(14881);
    let c = null;
    function h() {
      if (c !== null) {
        return c;
      }
      const e = (0, r.tradingService)();
      c = new Map([["drawings", {
        label: o.t(null, undefined, i(3217)),
        dataName: "hide-drawing-tools",
        tooltip: {
          active: o.t(null, undefined, i(85891)),
          inactive: o.t(null, undefined, i(52563))
        },
        getBoxedValue: () => (0, a.hideAllDrawings)(),
        trackLabel: "hide drawings"
      }], ["indicators", {
        label: o.t(null, undefined, i(72351)),
        dataName: "hide-indicators",
        tooltip: {
          active: o.t(null, undefined, i(98753)),
          inactive: o.t(null, undefined, i(78525))
        },
        getBoxedValue: () => (0, a.hideAllIndicators)(),
        trackLabel: "hide indicators"
      }], ["positions", {
        label: o.t(null, undefined, i(92226)),
        dataName: "hide-positions-and-orders",
        tooltip: {
          active: o.t(null, undefined, i(20506)),
          inactive: o.t(null, undefined, i(42164))
        },
        getBoxedValue: () => (0, s.ensureNotNull)(e).showTradedSources,
        inverted: true,
        trackLabel: "hide positions"
      }], ["all", {
        label: o.t(null, undefined, i(47074)),
        dataName: "hide-all",
        tooltip: {
          active: e ? o.t(null, undefined, i(86738)) : o.t(null, undefined, i(25881)),
          inactive: e ? o.t(null, undefined, i(18216)) : o.t(null, undefined, i(90763))
        },
        trackLabel: "hide all"
      }]]);
      if (!e) {
        c.delete("positions");
      }
      return c;
    }
    function d(e) {
      if (e) {
        n.setValue("ChartToolsHideMode", e);
      } else {
        e = _();
      }
      const t = p();
      let i = !t;
      if (e === "all") {
        m((e, t, s) => {
          e.setValue(s ? !i : i);
        });
        l.hideStateChange.fire({
          hideMode: e,
          isActive: i
        });
        return i;
      } else {
        m((s, o, n) => {
          if (o === e) {
            const e = t ? !n : !s.value();
            s.setValue(e);
            i = n ? !e : e;
          } else {
            s.setValue(Boolean(n));
          }
        });
        l.hideStateChange.fire({
          hideMode: e,
          isActive: i
        });
        return i;
      }
    }
    function u(e) {
      if (e === "all") {
        return p();
      }
      const t = (0, s.ensureDefined)(h().get(e));
      const i = (0, s.ensureDefined)(t.getBoxedValue)().value();
      if (t.inverted) {
        return !i;
      } else {
        return i;
      }
    }
    function _() {
      const e = n.getValue("ChartToolsHideMode", "drawings");
      if (h().has(e)) {
        return e;
      } else {
        return "drawings";
      }
    }
    function p() {
      let e = true;
      m((t, i, s) => {
        const o = t.value();
        e = e && (s ? !o : o);
      });
      return e;
    }
    function m(e) {
      h().forEach((t, i) => {
        const s = t.getBoxedValue?.();
        if (s) {
          e(s, i, t.inverted);
        }
      });
    }
  },
  25812: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      ToolboxType: () => s
    });
    (function (e) {
      e[e.Delete = 0] = "Delete";
    })(s ||= {});
  },
  59064: (e, t, i) => {
    "use strict";

    i.d(t, {
      globalCloseDelegate: () => s,
      globalCloseMenu: () => o
    });
    const s = new (i(52033).Delegate)();
    function o() {
      s.fire();
    }
  },
  61223: e => {
    e.exports = {
      "css-value-header-toolbar-height": "38px"
    };
  },
  63844: e => {
    e.exports = {
      chartsSplitter: "chartsSplitter-L0xapso5",
      hovered: "hovered-L0xapso5"
    };
  },
  45982: e => {
    e.exports = {
      "css-value-pane-controls-padding-left": "1px",
      "css-value-pane-controls-padding-right": "4px"
    };
  },
  56479: e => {
    e.exports = {
      paneSeparator: "paneSeparator-uqBaC1Ki",
      handle: "handle-uqBaC1Ki",
      mobile: "mobile-uqBaC1Ki",
      hovered: "hovered-uqBaC1Ki",
      selected: "selected-uqBaC1Ki",
      active: "active-uqBaC1Ki"
    };
  },
  79437: (e, t, i) => {
    "use strict";

    var s = i(37265).declareClassAsPureInterface;
    function o() { }
    TradingView.WEB_SOCKET_WAS_CONNECTED = false;
    o.prototype.defaultResolutions = function () { };
    o.prototype.availableCurrencies = function () { };
    o.prototype.availableUnits = function () { };
    o.prototype.supportedSymbolsTypes = function () { };
    o.prototype.symbolsGrouping = function () { };
    o.prototype.quoteCreateSession = function (e) { };
    o.prototype.quoteDeleteSession = function (e) { };
    o.prototype.quoteSetFields = function (e, t) { };
    o.prototype.quoteAddSymbols = function (e, t) { };
    o.prototype.quoteRemoveSymbols = function (e, t) { };
    o.prototype.quoteFastSymbols = function (e, t) { };
    o.prototype.depthCreateSession = function (e, t, i) { };
    o.prototype.depthDeleteSession = function (e) { };
    o.prototype.depthSetSymbol = function (e, t) { };
    o.prototype.depthClearSymbol = function (e) { };
    o.prototype.depthSetScale = function (e, t) { };
    o.prototype.chartCreateSession = function (e, t) { };
    o.prototype.chartDeleteSession = function (e) { };
    o.prototype.createSession = function (e, t) { };
    o.prototype.removeSession = function (e) { };
    o.prototype.connected = function () { };
    o.prototype.connect = function () { };
    o.prototype.disconnect = function () { };
    o.prototype.switchTimezone = function (e, t) { };
    o.prototype.resolveSymbol = function (e, t, i, s) { };
    o.prototype.createSeries = function (e, t, i, s, o, n, r, a) { };
    o.prototype.removeSeries = function (e, t, i) { };
    o.prototype.modifySeries = function (e, t, i, s, o, n, r) { };
    o.prototype.requestMoreData = function (e, t, i, s) { };
    o.prototype.requestMetadata = function (e) { };
    o.prototype.canCreateStudy = function (e, t, i) { };
    o.prototype.createStudy = function (e, t, i, s, o, n, r, a) { };
    o.prototype.getStudyCounter = function (e) { };
    o.prototype.getFundamentalCounter = function (e) { };
    o.prototype.removeStudy = function (e, t) { };
    o.prototype.modifyStudy = function (e, t, i, s, o) { };
    o.prototype.createPointset = function (e, t, i, s, o, n, r) { };
    o.prototype.modifyPointset = function (e, t, i, s, o) { };
    o.prototype.removePointset = function (e, t, i) { };
    o.prototype.requestMoreTickmarks = function (e, t, i, s) { };
    o.prototype.requestFirstBarTime = function (e, t, i, s) { };
    o.prototype._sendRequest = function (e, t) { };
    o.prototype._onMessage = function (e) { };
    o.prototype._dispatchNotification = function (e) { };
    o.prototype._invokeNotificationHandler = function (e, t, i) { };
    o.prototype._notifySessions = function (e) { };
    o.prototype.unpack = function (e) { };
    o.prototype.searchSymbols = function (e, t, i, s, o, n, r, a, l, c) { };
    o.prototype.getMarks = function (e, t, i, s, o) { };
    o.prototype.getTimescaleMarks = function (e, t, i, s, o) { };
    s(o, "ChartApiInterface");
    e.exports.ChartApiInterface = o;
  },
  64289: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      favorStandardStudyTemplate: () => D,
      favorStudyTemplate: () => k,
      getChartContent: () => C,
      getCharts: () => S,
      getChartsCount: () => v,
      getCustomAdapter: () => g,
      getDrawingTemplates: () => R,
      getStandardStudyTemplateById: () => E,
      getStorageURL: () => p,
      getStudyTemplateById: () => I,
      getStudyTemplatesList: () => A,
      initialize: () => f,
      invalidateStudyTemplatesList: () => L,
      isThemeExist: () => j,
      loadDrawingTemplate: () => N,
      loadLayout: () => P,
      loadTheme: () => W,
      loadThemes: () => H,
      openLayoutLink: () => T,
      removeChart: () => b,
      removeDrawingTemplate: () => O,
      removeStudyTemplate: () => x,
      removeTheme: () => U,
      renameStudyTemplate: () => B,
      replaceStudyTemplate: () => V,
      saveChart: () => w,
      saveDrawingTemplate: () => F,
      saveStudyTemplate: () => M,
      saveTheme: () => z,
      setCustomAdapter: () => m,
      updateUser: () => y
    });
    var s = i(9343);
    var o = i(14712);
    var n = i(56840);
    const r = (0, s.getLogger)("Chart.SaveloadAdapter.Library");
    const a = {
      error: ""
    };
    let l;
    let c;
    let h;
    let d;
    let u = null;
    let _ = null;
    function p(e) {
      return `${h}/${encodeURIComponent(d)}/${e}?client=${encodeURIComponent(l)}&user=${encodeURIComponent(c)}`;
    }
    function m(e) {
      u = e;
    }
    function g() {
      return u;
    }
    function f(e, t, i, s) {
      l = e;
      c = t;
      h = i;
      d = s;
    }
    function y(e) {
      c = e;
    }
    function v(e, t) {
      throw new Error("Not implemented");
    }
    async function S() {
      const e = e => e.map(e => ({
        id: e.id,
        name: e.name,
        image_url: String(e.id),
        modified_iso: e.timestamp,
        short_symbol: e.symbol,
        interval: e.resolution
      }));
      if (u) {
        return u.getAllCharts().then(e);
      }
      try {
        const t = await fetch(`${p("charts")}`, {
          credentials: "same-origin"
        });
        if (!t.ok) {
          throw new Error(`Getting chart content response was not OK. Status: ${t.status}.`);
        }
        const i = await t.json();
        if (i.status !== "ok") {
          throw new Error("Get chart content request failed: " + i.message);
        }
        return e(i.data);
      } catch (e) {
        r.logWarn((0, o.errorToString)(e));
        throw e;
      }
    }
    async function b(e) {
      if (u) {
        return u.removeChart(e);
      }
      try {
        const t = await fetch(`${p("charts")}&chart=${encodeURIComponent(e)}`, {
          method: "DELETE",
          credentials: "same-origin"
        });
        if (!t.ok) {
          throw new Error(`Remove chart response was not OK. Status: ${t.status}.`);
        }
        const i = await t.json();
        if (i.status !== "ok") {
          throw new Error("Remove drawing template request failed: " + i.message);
        }
      } catch (e) {
        r.logWarn((0, o.errorToString)(e));
        throw e;
      }
    }
    async function w(e, t, i, s, n) {
      const a = n.id;
      const l = {
        name: e,
        content: JSON.stringify(s),
        symbol: t,
        resolution: i
      };
      try {
        if (u) {
          return {
            result: await u.saveChart({
              ...l,
              id: a,
              timestamp: Math.round(Date.now() / 1000)
            })
          };
        }
        const e = new FormData();
        for (const t in l) {
          e.append(t, l[t]);
        }
        let t = p("charts");
        if (a != null) {
          t += `&chart=${encodeURIComponent(a)}`;
        }
        const i = await fetch(t, {
          credentials: "same-origin",
          method: "POST",
          body: e
        });
        if (!i.ok) {
          throw new Error(`Saving chart content response was not OK. Status: ${i.status}.`);
        }
        const s = await i.json();
        if (s.status !== "ok") {
          throw new Error("Saving chart content request failed: " + s.message);
        }
        return {
          result: (s.id ?? a).toString(),
          response: i
        };
      } catch (e) {
        r.logWarn((0, o.errorToString)(e));
        throw e;
      }
    }
    async function C(e) {
      const t = t => {
        const i = JSON.parse(t);
        i.uid = e.id;
        return i;
      };
      if (u) {
        return u.getChartContent(e.id).then(e => t(e));
      }
      try {
        const i = await fetch(`${p("charts")}&chart=${encodeURIComponent(e.id)}`, {
          credentials: "same-origin"
        });
        if (!i.ok) {
          throw new Error(`Getting chart content response was not OK. Status: ${i.status}.`);
        }
        const s = await i.json();
        if (s.status !== "ok") {
          throw new Error("Get chart content request failed: " + s.message);
        }
        return t(s.data.content);
      } catch (e) {
        r.logWarn((0, o.errorToString)(e));
        throw e;
      }
    }
    async function P(e) {
      try {
        return {
          chartWidgetCollectionState: await C(e),
          description: e.name,
          id: e.id,
          lastModified: e.modified_iso,
          name: e.name,
          uid: e.url,
          username: ""
        };
      } catch (e) {
        r.logWarn("Error loading chart");
        throw e;
      }
    }
    function T(e, t) {
      throw new Error("Opening layout link is not supported");
    }
    async function x(e) {
      try {
        const t = G().filter(t => t !== e);
        if (u) {
          q(t);
          return u.removeStudyTemplate({
            name: e
          });
        }
        const i = await fetch(`${p("study_templates")}&template=${encodeURIComponent(e)}`, {
          method: "DELETE",
          credentials: "same-origin"
        });
        if (!i.ok) {
          throw new Error(`Remove study template response was not OK. Status: ${i.status}.`);
        }
        const s = await i.json();
        if (s.status !== "ok") {
          throw new Error("Remove study template request failed: " + s.message);
        }
        q(t);
      } catch (e) {
        r.logWarn((0, o.errorToString)(e));
        throw e;
      }
    }
    async function I(e) {
      try {
        if (u) {
          return {
            content: await u.getStudyTemplateContent({
              name: e
            })
          };
        }
        const t = await fetch(`${p("study_templates")}&template=${encodeURIComponent(e)}`, {
          credentials: "same-origin"
        });
        if (!t.ok) {
          throw new Error(`Get study template response was not OK. Status: ${t.status}.`);
        }
        const i = await t.json();
        if (i.status !== "ok") {
          throw new Error("Get study template request failed: " + i.message);
        }
        return i.data;
      } catch (e) {
        r.logWarn((0, o.errorToString)(e));
        throw e;
      }
    }
    async function M(e) {
      try {
        if (u) {
          return u.saveStudyTemplate(e).then(() => ({
            error: ""
          })).catch(e => ({
            error: e != null ? (0, o.errorToString)(e) : "error"
          }));
        }
        const t = new FormData();
        t.append("name", e.name);
        t.append("content", e.content);
        const i = await fetch(p("study_templates"), {
          method: "POST",
          body: t,
          credentials: "same-origin"
        });
        if (!i.ok) {
          throw new Error(`Save study template response was not OK. Status: ${i.status}.`);
        }
        const s = await i.json();
        return {
          error: s.status === "ok" ? "" : s.status
        };
      } catch (e) {
        r.logWarn((0, o.errorToString)(e));
        throw e;
      }
    }
    async function A() {
      try {
        if (_) {
          return _;
        }
        _ = [];
        const e = e => {
          _ = e.map(e => {
            const t = G().indexOf(e.name);
            return {
              id: e.name,
              is_default: false,
              name: e.name,
              favorite_date: t !== -1 ? t : null
            };
          });
          return _;
        };
        if (u) {
          return u.getAllStudyTemplates().then(e);
        }
        const t = await fetch(p("study_templates"), {
          method: "GET",
          credentials: "same-origin"
        });
        if (!t.ok) {
          throw new Error(`Study templates list response was not OK. Status: ${t.status}.`);
        }
        const i = await t.json();
        if (i.status !== "ok") {
          throw new Error("Study templates list request failed: " + i.message);
        }
        return e(i.data);
      } catch (e) {
        r.logWarn((0, o.errorToString)(e));
        throw e;
      }
    }
    function L() {
      _ = null;
    }
    function k(e, t, i) {
      const s = G();
      q(t ? [...s, e] : s.filter(t => t !== e));
      i?.(null);
    }
    function D(e, t, i) {
      k(e, t, i);
    }
    function E(e, t) {
      throw new Error("Not implemented");
    }
    function B(e, t, i) {
      throw new Error("Not implemented");
    }
    function V(e, t, i) {
      throw new Error("Not implemented");
    }
    async function R(e) {
      throw new Error("Not implemented");
    }
    async function N(e, t) {
      throw new Error("Not implemented");
    }
    async function O(e, t) {
      throw new Error("Not implemented");
    }
    async function F(e, t, i) {
      throw new Error("Not implemented");
    }
    function W(e) {
      if (u !== null) {
        return u.getChartTemplateContent(e);
      }
      throw new Error("Not implemented");
    }
    function H() {
      if (u !== null) {
        return u.getAllChartTemplates();
      } else {
        return Promise.resolve([]);
      }
    }
    async function z(e, t) {
      if (u !== null) {
        try {
          await u.saveChartTemplate(e, t);
          return a;
        } catch (e) {
          console.error(e);
          return {
            error: e instanceof Error ? e.message : e.toString()
          };
        }
      }
      throw new Error("Not implemented");
    }
    async function U(e) {
      if (u !== null) {
        try {
          await u.removeChartTemplate(e);
          return a;
        } catch (e) {
          console.error(e);
          return {
            error: e instanceof Error ? e.message : e.toString()
          };
        }
      }
      throw new Error("Not implemented");
    }
    function j(e) {
      return W(e).then(e => Boolean(e.content));
    }
    function G() {
      return n.getJSON("StudyTemplates.quicks", []);
    }
    function q(e) {
      n.setJSON("StudyTemplates.quicks", e);
    }
  },
  51243: (e, t, i) => {
    "use strict";

    var s = i(50151).ensureNotNull;
    var o = i(50151).ensureDefined;
    var n = i(9343).getLogger("Chart.ChartApiLocal");
    var r = i(14381);
    var a = i(85049).Interval;
    var l = i(55812).JSStudyEngineTypescript;
    var c = i(6058);
    var h = i(79437).ChartApiInterface;
    var d = i(18278).HandlerInfo;
    var u = i(37265).requireFullInterfaceImplementation;
    var _ = i(82783).TIMEFRAMETYPE;
    var p = i(53388).createDwmAligner;
    TradingView.STUDY_COUNT_LIMIT = 210;
    function m(e, t) {
      return `${e}__${t}`;
    }
    JSServer.ChartApi = function (e) {
      this._notificationHandlers = {};
      this._sessions = {};
      this.studyCounter = 0;
      this._metadataRequestNextNumber = 1;
      this._connected = false;
      this._enabled = false;
      this._studyEngine = new l(e);
      this._callbacks = {};
      this._serverTimeOffset = 0;
      var t = this;
      this._studyEngine.on("configuration_received", function () {
        t._fireEvent("configuration_received");
      });
      this._studyEngine.on("realtime_tick", function (e) {
        var i = {
          time: e.value[0] / 1000,
          open: e.value[1],
          high: e.value[2],
          low: e.value[3],
          close: e.value[4],
          volume: e.value[5]
        };
        t._fireEvent("realtime_tick", i, true);
      });
      this._setVisibleRangeTimeout = {};
      this._studySpecs = new Map();
      this._isNonCountedStudy = () => true;
      this.defaultResolutions = this.defaultResolutions.bind(this);
    };
    JSServer.ChartApi.prototype.destroy = function () {
      this._studyEngine.destroy();
      this._studyEngine = null;
    };
    JSServer.ChartApi.prototype.purgeCache = function (e) {
      this._studyEngine.purgeCache();
      this._studyEngine.purgeDataCache();
    };
    JSServer.ChartApi.prototype.resetCache = function () {
      this._studyEngine.resetCache();
    };
    JSServer.ChartApi.prototype.defaultResolutions = function () {
      return this._studyEngine.supportedResolutions() || ["1", "3", "5", "15", "30", "45", "60", "120", "180", "240", "1D", "1W", "1M"];
    };
    JSServer.ChartApi.prototype.availableCurrencies = function () {
      var e = this._studyEngine.supportedCurrencies().map(function (e) {
        if (typeof e == "string") {
          return {
            id: e,
            code: e
          };
        } else {
          return e;
        }
      });
      return Promise.resolve(e);
    };
    JSServer.ChartApi.prototype.availableUnits = function () {
      return Promise.resolve(this._studyEngine.supportedUnits());
    };
    JSServer.ChartApi.prototype.availablePriceSources = function (e) {
      return this._studyEngine.supportedPriceSources(e);
    };
    JSServer.ChartApi.prototype.supportedSymbolsTypes = function () {
      return this._studyEngine.supportedSymbolsTypes();
    };
    JSServer.ChartApi.prototype.symbolsGrouping = function () {
      return this._studyEngine.symbolsGrouping();
    };
    JSServer.ChartApi.prototype.start = function () {
      this._enabled = true;
      this._fireEvent("start_enabled");
    };
    JSServer.ChartApi.prototype.unsubscribe = function (e, t) {
      var i = this._callbacks[e];
      if (i) {
        i.splice(i.indexOf(t), 1);
      }
    };
    JSServer.ChartApi.prototype.on = function (e, t) {
      if (!this._callbacks.hasOwnProperty(e)) {
        this._callbacks[e] = [];
      }
      this._callbacks[e].push(t);
      return this;
    };
    JSServer.ChartApi.prototype._fireEvent = function (e, t, i) {
      if (this._callbacks.hasOwnProperty(e)) {
        var s = this._callbacks[e].slice(0);
        if (!i) {
          this._callbacks[e] = [];
        }
        for (var o = 0; o < s.length; ++o) {
          s[o](t);
        }
      }
    };
    JSServer.ChartApi.prototype.chartCreateSession = function (e, t) {
      this._studyEngine.chartCreateSession(e);
    };
    JSServer.ChartApi.prototype.chartDeleteSession = function (e) {
      this._studyEngine.chartDeleteSession(e);
    };
    JSServer.ChartApi.prototype.createSession = function (e, t) {
      TradingView.ChartapiMessagerInstances[e] = new c(this, e);
      this._sessions[e] = t;
      this._notificationHandlers[e] = {};
      if (this.connected()) {
        t.onMessage({
          method: "connected",
          params: []
        });
      }
    };
    JSServer.ChartApi.prototype.removeSession = function (e) {
      delete this._sessions[e];
      delete this._notificationHandlers[e];
      this._studyEngine.stopSources(e);
    };
    JSServer.ChartApi.prototype.connected = function () {
      return this._connected;
    };
    JSServer.ChartApi.prototype.connect = function () {
      if (this._enabled) {
        if (!this.connected()) {
          this._connected = true;
          this.sessionid = "dummy session id";
          this._notifySessions({
            method: "connected",
            params: []
          });
        }
      } else {
        var e = this;
        this.on("start_enabled", function () {
          e.connect();
        });
      }
    };
    JSServer.ChartApi.prototype.disconnect = function () {
      this._connected = false;
      this._notifySessions({
        method: "disconnected",
        params: []
      });
      this.purgeCache();
      this.studyCounter = 0;
    };
    JSServer.ChartApi.prototype.switchTimezone = function (e, t) {
      this._studyEngine.switchTimezone(e, t);
    };
    JSServer.ChartApi.prototype.receiveLocalResponse = function (e) {
      this._dispatchNotification(e);
      this._fireEvent("message_" + e.method, undefined, true);
    };
    JSServer.ChartApi.prototype.getMarks = function (e, t, i, s, o) {
      this._studyEngine.getMarks(e, t, i, s, o);
    };
    JSServer.ChartApi.prototype.getTimescaleMarks = function (e, t, i, s, o) {
      this._studyEngine.getTimescaleMarks(e, t, i, s, o);
    };
    JSServer.ChartApi.prototype.resolveSymbol = function (e, t, i, s) {
      this._notificationHandlers[e][t] = new d(s, t);
      this._studyEngine.resolveSymbol(e, t, i);
    };
    JSServer.ChartApi.prototype.createSeries = function (e, t, i, s, o, n, r, a) {
      var l = this;
      this._notificationHandlers[e][t] = new d(function (o) {
        if (o.method === "series_completed" && r !== null) {
          l._applyTimeFrame(e, s, t, i, r);
          r = null;
        }
        a(o);
      }, t);
      const c = {
        countBack: n || 300
      };
      if (r !== null && r.type === _.TimeRange) {
        c.to = r.to * 1000;
        c.from = r.from * 1000;
      }
      this._studyEngine.createSeries(e, t, i, s, o, c);
    };
    JSServer.ChartApi.prototype.removeSeries = function (e, t) {
      delete this._notificationHandlers[e][t];
      this._studyEngine.removeSeries(e, t);
    };
    JSServer.ChartApi.prototype.setVisibleTimeRange = function (e, t, i, o, n, r, a, l, c, h) {
      var d = o;
      var u = (a = a || {}).applyDefaultRightMargin !== true && a.percentRightMargin === undefined && n !== undefined ? n : null;
      var _ = p(this._studyEngine.getSeriesInterval(e, t), this._studyEngine.getSeriesSymbolInfo(e, t));
      if (_ !== null) {
        d = _.timeToSessionStart(d * 1000) / 1000;
        if (u !== null) {
          u = _.timeToSessionStart(u * 1000) / 1000;
        }
      }
      var m = this;
      function g() {
        var o = m._studyEngine.sessionTimeScale(e);
        if (o !== null) {
          var n;
          var _ = o.indexOfTime(d * 1000);
          if (u === null) {
            n = o.lastSessionBarIndex();
          } else {
            var p = o.indexOfTime(u * 1000);
            n = p && p.index;
          }
          if (_ !== null && n !== null) {
            var g = _.index;
            if (_.timeMs < d * 1000) {
              g += 1;
            }
            if (r === false) {
              const e = s(o.firstSessionBarIndex());
              if (g < e) {
                g = e;
              }
            }
            if (g > n) {
              if (h) {
                h(new Error("Invalid visible range"));
              }
            } else {
              TradingView.ChartapiMessagerInstances[e].onSeriesTimeframeUpdate(t, i, g, n, a, c);
              if (l) {
                setTimeout(l, 0);
              }
            }
          } else if (h) {
            h(new Error("Bars are not available"));
          }
        } else if (h) {
          h(new Error("Session time scale is not available"));
        }
      }
      if (this._studyEngine.isTimeScaleExtendedTo(e, o * 1000)) {
        g();
      } else {
        var f = TradingView.ChartapiMessagerInstances[e].beforeSeriesCompleted;
        var y = TradingView.ChartapiMessagerInstances[e].seriesError;
        if (this._setVisibleRangeTimeout[e] !== undefined) {
          clearTimeout(this._setVisibleRangeTimeout[e]);
        }
        this._setVisibleRangeTimeout[e] = setTimeout(function () {
          delete this._setVisibleRangeTimeout[e];
          f.subscribe(null, v, true);
          y.subscribe(null, S, true);
          this._studyEngine.ensureExtendedTo(t, e, o * 1000);
        }.bind(this), 0);
      }
      function v(e, s) {
        if (e === t && s === i) {
          f.unsubscribe(null, v);
          y.unsubscribe(null, S);
          g();
        }
      }
      function S(e, s) {
        if (e === t && s === i) {
          f.unsubscribe(null, v);
        }
      }
    };
    JSServer.ChartApi.prototype._applyTimeFrame = function (e, t, i, s, o) {
      var n;
      var l;
      var c = {};
      var h = true;
      if (o.type === _.PeriodBack) {
        var d = this._studyEngine.getSeriesLastBarTime(e, i);
        if (d === null) {
          return;
        }
        l = d / 1000;
        var u = a.parse(o.value);
        var m = this._studyEngine.getSeriesSymbolInfo(e, i);
        n = r.alignPeriodsBackForVisibleRange(m.session, m.session_holidays, m.corrections, u.letter(), u.multiplier(), 1, d) / 1000;
        var g = p(this._studyEngine.getSeriesInterval(e, i), m);
        if (g !== null) {
          l = g.timeToExchangeTradingDay(l * 1000) / 1000;
          n = g.timeToExchangeTradingDay(n * 1000) / 1000;
        }
        c = {
          applyDefaultRightMargin: true
        };
        h = false;
      } else {
        n = o.from;
        l = o.to;
      }
      this.setVisibleTimeRange(e, i, s, n, l, h, c, undefined, o);
    };
    JSServer.ChartApi.prototype.modifySeries = function (e, t, i, s, o, n, r, a) {
      var l = this;
      this._notificationHandlers[e][t] = new d(function (o) {
        if (o.method === "series_completed" && r !== null) {
          l._applyTimeFrame(e, s, t, i, r);
          r = null;
        }
        a(o);
      }, t);
      this._studyEngine.modifySeries(e, t, s, o, i, n);
    };
    JSServer.ChartApi.prototype.requestMoreData = function (e, t) {
      this._studyEngine.extendSeriesRange(e, t);
    };
    JSServer.ChartApi.prototype.setStudiesAccessController = function (e) {
      this.studiesAccessController = e;
    };
    JSServer.ChartApi.prototype.allStudiesMetadata = function () {
      return this._studyEngine.studiesMetadata();
    };
    JSServer.ChartApi.prototype.requestMetadata = function () {
      return new Promise((e, t) => {
        const i = this.studiesAccessController.getEnabledTools();
        e({
          method: "studies_metadata",
          params: [this._makeNextRequestId(), {
            errors: [],
            hash: "",
            metainfo: i,
            migrations: []
          }]
        });
      });
    };
    JSServer.ChartApi.prototype._makeNextRequestId = function () {
      return "metadata_" + this._metadataRequestNextNumber++;
    };
    JSServer.ChartApi.prototype.setIsNonCountedStudyFn = function (e) {
      this._isNonCountedStudy = e;
    };
    JSServer.ChartApi.prototype.canCreateStudy = function (e, t, i) {
      if (this._isNonCountedStudy(t.id) || this.studyCounter < TradingView.STUDY_COUNT_LIMIT) {
        return {
          success: true
        };
      } else {
        return {
          success: false,
          reason: "general",
          limitValue: TradingView.STUDY_COUNT_LIMIT
        };
      }
    };
    JSServer.ChartApi.prototype.getStudyCounter = function (e) {
      return this.studyCounter;
    };
    JSServer.ChartApi.prototype.getFundamentalCounter = function (e) {
      return 0;
    };
    JSServer.ChartApi.prototype.createStudy = function (e, t, i, s, o, n, r, a) {
      if (!this.canCreateStudy(e, a).success) {
        const e = new Error("Exceeded the limit of studies");
        e.cause = "TooManyStudies";
        throw e;
      }
      this._notificationHandlers[e][t] = new d(r, t);
      this._studySpecs.set(m(e, t), a);
      this._studyEngine.createStudy(e, t, s, i, o, n);
      if (!this._isNonCountedStudy(a.id)) {
        this.studyCounter++;
      }
      return true;
    };
    JSServer.ChartApi.prototype.removeStudy = function (e, t) {
      if (this._notificationHandlers[e][t]) {
        delete this._notificationHandlers[e][t];
        const i = m(e, t);
        const s = o(this._studySpecs.get(i));
        this._studySpecs.delete(i);
        this._studyEngine.removeStudy(e, t);
        if (!this._isNonCountedStudy(s.id)) {
          this.studyCounter--;
        }
      }
    };
    JSServer.ChartApi.prototype.modifyStudy = function (e, t, i, s, o) {
      this._notificationHandlers[e][t] = new d(o, t);
      this._studyEngine.modifyStudy(e, t, i, s);
    };
    JSServer.ChartApi.prototype.notifyStudy = function () {
      throw Error("This call is not implemented");
    };
    JSServer.ChartApi.prototype.createPointset = function (e, t, i, s, o, n, r) {
      this._notificationHandlers[e][t] = new d(r, t);
      this._studyEngine.createPointset(e, t, s, o, n);
    };
    JSServer.ChartApi.prototype.modifyPointset = function (e, t, i, s, o) {
      throw Error("This call is not implemented");
    };
    JSServer.ChartApi.prototype.removePointset = function (e, t, i) {
      this._notificationHandlers[e][t] = null;
      this._studyEngine.removePointset(e, t);
    };
    JSServer.ChartApi.prototype.requestMoreTickmarks = function (e, t, i) {
      this._studyEngine.requestMoreTickmarks(e, i);
    };
    JSServer.ChartApi.prototype.requestFirstBarTime = function (e, t, i, s) {
      this._notificationHandlers[e][t] = new d(s, t);
    };
    JSServer.ChartApi.prototype._invokeHandler = function (e, t) {
      if (e) {
        e(t);
      }
    };
    JSServer.ChartApi.prototype._sendRequest = function (e, t) {
      throw Error("This method is not implemented");
    };
    JSServer.ChartApi.prototype._onMessage = function (e) {
      throw Error("This method is not implemented");
    };
    JSServer.ChartApi.prototype._dispatchNotification = function (e) {
      var t = e.params.shift();
      if (this._notificationHandlers[t]) {
        switch (e.method) {
          case "timescale_update":
            var i = e.params[0];
            var s = e.params[1];
            s.clear = s.changes.length === 0 && s.marks.length === 0;
            this._sessions[t].onMessage({
              method: "timescale_update",
              params: s
            });
            for (var o in i) {
              var r = {
                method: "data_update",
                params: {
                  customId: o,
                  plots: i[o].series,
                  nonseries: i[o].nonseries,
                  turnaround: i[o].turnaround
                }
              };
              this._invokeNotificationHandler(t, o, r);
            }
            break;
          case "tickmark_update":
            this._sessions[t].onMessage({
              method: "timescale_update",
              params: e.params[0]
            });
            break;
          case "data_update":
            for (var o in e.params[0]) {
              var a = e.params[0][o];
              r = {
                method: "data_update",
                params: {
                  customId: o,
                  plots: a.series ? a.series : a.plots,
                  nonseries: a.nonseries,
                  turnaround: a.turnaround
                }
              };
              this._invokeNotificationHandler(t, o, r);
            }
            break;
          case "index_update":
            for (var o in e.params[0]) {
              r = {
                method: "index_update",
                params: e.params[0][o]
              };
              this._invokeNotificationHandler(t, o, r);
            }
            break;
          case "critical_error":
            n.logNormal(new Date() + " critical_error session:" + this.sessionid + " reason:" + e.params[0]);
            this._sessions[t].onMessage({
              method: "critical_error",
              params: e.params
            });
            break;
          case "timescale_completed":
          case "quote_symbol_data":
          case "quote_list_fields":
          case "depth_symbol_error":
          case "depth_symbol_success":
          case "dd":
          case "dpu":
          case "depth_bar_last_value":
            this._sessions[t].onMessage({
              method: e.method,
              params: e.params
            });
            break;
          case "clear_data":
            for (var l in e.params[0]) {
              this._invokeNotificationHandler(t, l, {
                method: "clear_data",
                params: e.params[0][l]
              });
            }
            break;
          default:
            var c = e.params[0];
            this._invokeNotificationHandler(t, c, e);
        }
      }
    };
    JSServer.ChartApi.prototype._invokeNotificationHandler = function (e, t, i) {
      if (t !== undefined) {
        var s = this._notificationHandlers[e][t];
        if (s !== undefined && s) {
          this._invokeHandler(s.handler, i);
        }
      }
    };
    JSServer.ChartApi.prototype.searchSymbols = function (e, t, i, s) {
      this._studyEngine.searchSymbols(e, t, i, s);
    };
    JSServer.ChartApi.prototype._notifySessions = function (e) {
      for (var t in this._sessions) {
        if (!this._sessions.hasOwnProperty(t)) {
          return;
        }
        var i = this._sessions[t];
        if (typeof i.onMessage == "function") {
          i.onMessage(e);
        }
      }
    };
    JSServer.ChartApi.prototype.unpack = function (e) {
      throw Error("This method is not implemented");
    };
    JSServer.ChartApi.prototype.quoteCreateSession = function (e) {
      return this._studyEngine.quoteCreateSession(e);
    };
    JSServer.ChartApi.prototype.quoteDeleteSession = function (e) {
      return this._studyEngine.quoteDeleteSession(e);
    };
    JSServer.ChartApi.prototype.quoteSetFields = function (e, t) {
      return this._studyEngine.quoteSetFields(e, t);
    };
    JSServer.ChartApi.prototype.quoteAddSymbols = function (e, t) {
      if (t.indexOf(undefined) !== -1) {
        console.warn("Got undefined in quoteAddSymbols");
        t = t.filter(function (e) {
          return !!e;
        });
      }
      return this._studyEngine.quoteAddSymbols(e, t);
    };
    JSServer.ChartApi.prototype.quoteRemoveSymbols = function (e, t) {
      return this._studyEngine.quoteRemoveSymbols(e, t);
    };
    JSServer.ChartApi.prototype.quoteFastSymbols = function (e, t) {
      return this._studyEngine.quoteFastSymbols(e, t);
    };
    JSServer.ChartApi.prototype.quoteHibernateAll = function (e) {
      return this._studyEngine.quoteHibernateAll(e);
    };
    JSServer.ChartApi.prototype.depthCreateSession = function (e) {
      return this._studyEngine.depthCreateSession(e);
    };
    JSServer.ChartApi.prototype.depthDeleteSession = function (e) {
      return this._studyEngine.depthDeleteSession(e);
    };
    JSServer.ChartApi.prototype.depthSetSymbol = function (e, t) {
      return this._studyEngine.depthSetSymbol(e, t);
    };
    JSServer.ChartApi.prototype.depthClearSymbol = function (e) { };
    JSServer.ChartApi.prototype.depthSetScale = function (e, t) { };
    JSServer.ChartApi.prototype.createStudiesAccessController = function (e, t, i) {
      return new this.StudiesAccessController(this._studyEngine, e && JSON.parse(e) || {
        type: "black",
        tools: []
      });
    };
    JSServer.ChartApi.prototype.StudiesAccessController = function (e, t) {
      this._studyEngine = e;
      this._studiesAccess = t;
    };
    JSServer.ChartApi.prototype.StudiesAccessController.prototype._findTool = function (e) {
      var t = null;
      for (var i = 0; i < this._studiesAccess.tools.length; ++i) {
        var s = this._studiesAccess.tools[i];
        if (s.name === e || s === e) {
          t = s;
          break;
        }
      }
      return t;
    };
    JSServer.ChartApi.prototype.StudiesAccessController.prototype.getEnabledTools = function () {
      return this._studyEngine.studiesMetadata().filter(function (e) {
        return this.isToolEnabled(e.description) || e.is_hidden_study;
      }, this);
    };
    JSServer.ChartApi.prototype.StudiesAccessController.prototype.isToolEnabled = function (e) {
      var t = this._findTool(e);
      if (this._studiesAccess.type === "black") {
        return !t || t.grayed;
      } else {
        return !!t;
      }
    };
    JSServer.ChartApi.prototype.StudiesAccessController.prototype.isToolGrayed = function (e) {
      var t = this._findTool(e);
      return t && t.grayed;
    };
    JSServer.ChartApi.prototype.serverTimeOffset = function () {
      return this._studyEngine.serverTimeOffset();
    };
    JSServer.ChartApi.prototype.serverTime = function () {
      return this._studyEngine.serverTime();
    };
    JSServer.ChartApi.prototype.disconnectCount = function () {
      return 0;
    };
    u(JSServer.ChartApi, "JSServer.ChartApi", h, "ChartApiInterface");
    e.exports = JSServer.ChartApi;
  },
  6058: (e, t, i) => {
    "use strict";

    var s = i(52033).Delegate;
    function o(e, t) {
      this._server = e;
      this._session = t;
      this.beforeSeriesCompleted = new s();
      this.seriesError = new s();
    }
    o.prototype.onSymbolResolved = function (e, t) {
      this._server.receiveLocalResponse({
        method: "symbol_resolved",
        params: [this._session, e, t]
      });
    };
    o.prototype.onSymbolError = function (e, t) {
      this._server.receiveLocalResponse({
        method: "symbol_error",
        params: [this._session, e, t]
      });
    };
    o.prototype.onStudyError = function (e, t, i) {
      this._server.receiveLocalResponse({
        method: "study_error",
        params: [this._session, e, t, i]
      });
    };
    o.prototype.onSeriesLoading = function (e, t) {
      this._server.receiveLocalResponse({
        method: "series_loading",
        params: [this._session, e, t]
      });
    };
    o.prototype.onSeriesCompleted = function (e, t, i) {
      this.beforeSeriesCompleted.fire(e, t);
      this._server.receiveLocalResponse({
        method: "series_completed",
        params: [this._session, e, i, t]
      });
    };
    o.prototype.onSeriesError = function (e, t, i) {
      this._server.receiveLocalResponse({
        method: "series_error",
        params: [this._session, e, t, i]
      });
      this.seriesError.fire(e, t);
    };
    o.prototype.onStudyCompleted = function (e, t) {
      this._server.receiveLocalResponse({
        method: "study_completed",
        params: [this._session, e, t]
      });
    };
    o.prototype.onStudyLoading = function (e, t) {
      this._server.receiveLocalResponse({
        method: "study_loading",
        params: [this._session, e, t]
      });
    };
    o.prototype.onTickmarksUpdated = function (e, t) {
      var i = {
        method: "tickmark_update",
        params: [this._session, {
          index: e,
          zoffset: 0,
          changes: [],
          marks: t,
          index_diff: []
        }]
      };
      this._server.receiveLocalResponse(i);
    };
    o.prototype.onTimescaleUpdate = function (e, t) {
      var i = {
        method: "timescale_update",
        params: [this._session, this._prepareDataUpdateObjects(t), {
          index: e.pointsIndex,
          zoffset: 0,
          changes: e.points,
          marks: e.marks,
          index_diff: e.indexChange,
          baseIndex: e.baseIndex
        }]
      };
      this._server.receiveLocalResponse(i);
    };
    o.prototype.onTimescaleCompleted = function (e) {
      this._server.receiveLocalResponse({
        method: "timescale_completed",
        params: [this._session, e]
      });
    };
    o.prototype.onSeriesTimeframeUpdate = function (e, t, i, s, o, n) {
      var r = {
        method: "series_timeframe",
        params: [this._session, e, t, i, s, n || null, true, o]
      };
      this._server.receiveLocalResponse(r);
    };
    o.prototype.onPointsetDataUpdate = function (e, t, i) {
      this.onDataUpdate(e, t, i, null);
    };
    o.prototype._prepareDataUpdateObjects = function (e) {
      var t = {};
      e.forEach(function (e) {
        t[e.objId] = {
          series: e.data,
          turnaround: e.turnaround
        };
        if (e.nonSeriesData) {
          if (e.nonSeriesData.data) {
            t[e.objId].nonseries = {
              d: JSON.stringify(e.nonSeriesData.data),
              indexes: e.nonSeriesData.indexes
            };
          } else {
            t[e.objId].nonseries = {
              d: "",
              indexes: []
            };
          }
        }
      });
      return t;
    };
    o.prototype.onDataUpdate = function (e, t, i, s) {
      var o = {
        method: "data_update",
        params: [this._session, this._prepareDataUpdateObjects([{
          objId: e,
          turnaround: t,
          data: i,
          nonSeriesData: s
        }])]
      };
      this._server.receiveLocalResponse(o);
    };
    o.prototype.onQuotesData = function (e) {
      this._server.receiveLocalResponse({
        method: "quote_symbol_data",
        params: e
      });
    };
    o.prototype.onDepthData = function (e) {
      this._server.receiveLocalResponse({
        method: "dd",
        params: e
      });
    };
    o.prototype.onDepthUpdate = function (e) {
      this._server.receiveLocalResponse({
        method: "dpu",
        params: e
      });
    };
    o.prototype.onClearData = function (e) {
      this._server.receiveLocalResponse({
        method: "clear_data",
        params: [this._session, e]
      });
    };
    TradingView.ChartapiMessagerInstances = [];
    e.exports = o;
  },
  9447: (e, t, i) => {
    "use strict";

    i.d(t, {
      barTimeToEndOfPeriod: () => o,
      endOfPeriodToBarTime: () => n
    });
    var s = i(83910);
    function o(e, t, i) {
      if (i.isDays()) {
        return t;
      }
      e.moveTo(t * 1000);
      if (i.isIntraday()) {
        const i = e.indexOfBar(t * 1000);
        if (i < 0) {
          throw new Error(`${t} is out of the instrument session `);
        }
        return e.endOfBar(i) / 1000;
      }
      return e.startOfBar(s.SessionStage.LASTBAR_SESSION) / 1000;
    }
    function n(e, t, i) {
      if (i.isDays()) {
        return t;
      }
      const s = t * 1000 - 1;
      e.moveTo(s);
      if (i.isIntraday()) {
        const i = e.indexOfBar(s);
        if (i < 0) {
          throw new Error(`${t} is out of the instrument session `);
        }
        return e.startOfBar(i) / 1000;
      }
      return t = e.startOfBar(0) / 1000;
    }
  },
  9001: (e, t, i) => {
    "use strict";

    var s = i(56570);
    window.onload = function () {
      if (location.hostname.indexOf(".") >= 0 && !function () {
        try {
          return /^(192|172|10)\.[0-9][0-9][0-9]\.[0-9][0-9][0-9]\.[0-9][0-9][0-9]/.test(location.hostname) || /^.*((?:\.local)|localhost)$/.test(location.hostname);
        } catch (e) {
          return false;
        }
      }()) {
        setTimeout(function () {
          try {
            var e = function () {
              var e = 0;
              if (JSON.parse(urlParams.logo).image) {
                e = "C";
                if (!s.enabled("link_to_tradingview")) {
                  e = "D";
                }
              }
              return e;
            }();
            if (window.ga) {
              if (e !== 0) {
                window.ga("send", "event", "s", e);
              }
              if (!urlParams.utm) {
                window.ga("send", "event", "l");
              }
            }
          } catch (e) { }
        }, 30000);
      }
    };
  },
  2060: (e, t, i) => {
    "use strict";

    var s;
    var o = i(14381);
    var n = {};
    e.exports = function (e, t, i) {
      var r;
      var a;
      var l;
      var c;
      var h = {};
      var d = n[i] || "out_of_session";
      var u = false;
      var _ = i;
      var p = t;
      var m = null;
      var g = null;
      function f() {
        var e = {
          symbolname: _,
          status: "ok",
          values: {}
        };
        e.values.current_session = d;
        n[_] = d;
        TradingView.ChartapiMessagerInstances[p].onQuotesData([p].concat([e]));
      }
      function y() {
        if (r) {
          if (c) {
            d = "out_of_session";
          } else {
            var e = new Date().getTime();
            var t = o.isTradingNow(e, r) ? "market" : "out_of_session";
            if (a && o.isTradingNow(e, a)) {
              t = "pre_market";
            } else if (l && o.isTradingNow(e, l)) {
              t = "post_market";
            }
            if (t !== d) {
              d = t;
            }
          }
        }
      }
      e(i, null, function (e) {
        if (!u) {
          (function (e) {
            r = new o.SessionInfo(e.timezone, e.session, e.session_holidays, e.corrections);
            c = e.expired;
            if (e.subsession_id && e.subsessions) {
              e.subsessions.forEach(t => {
                switch (t.id) {
                  case "regular":
                    r = new o.SessionInfo(e.timezone, e.session, e.session_holidays, t["session-correction"] || e["session-correction"] || e.corrections);
                    break;
                  case "premarket":
                    a = new o.SessionInfo(e.timezone, t.session, e.session_holidays, t["session-correction"] || e["session-premarket-correction"] || e.corrections);
                    break;
                  case "postmarket":
                    l = new o.SessionInfo(e.timezone, t.session, e.session_holidays, t["session-correction"] || e["session-postmarket-correction"] || e.corrections);
                }
              });
            } else {
              a = undefined;
              l = undefined;
            }
            const t = 60 - new Date(Date.now()).getSeconds();
            if (!s || s?.ticker !== e.ticker) {
              s = {
                ticker: e.ticker,
                timer: t
              };
              clearTimeout(s.timeout);
            }
            g = setTimeout(() => {
              m = setInterval(() => {
                y();
                f();
              }, 60000);
              y();
              f();
            }, s.timer * 1000);
            if (!s || s?.timeout === undefined) {
              s.timeout = g;
            }
            y();
            f();
          })(e);
        }
      }, function () { });
      h.stop = function () {
        u = true;
        if (m) {
          clearInterval(m);
        }
        if (g) {
          clearInterval(g);
        }
      };
      h.marketStatus = function () {
        return d;
      };
      return h;
    };
  },
  39692: (e, t, i) => {
    "use strict";

    let s;
    function o(e, t, i, o) {
      return s?.(e, t, i, o) ?? e;
    }
    function n(e) {
      s = e;
    }
    i.d(t, {
      getVolumeProfileResolutionForPeriod: () => o,
      overwriteVolumeProfileResolutionForPeriodGetter: () => n
    });
  },
  67153: (e, t, i) => {
    "use strict";

    i.d(t, {
      findSuitableResolutionToBuildFrom: () => r
    });
    var s = i(85049);
    function o(e, t) {
      const i = t.multiplier();
      for (let s = e.length - 1; s >= 0; s--) {
        const o = Number(e[s]);
        if (i % o == 0) {
          return {
            error: false,
            resolution: `${o}${t.letter()}`
          };
        }
      }
      return {
        error: true,
        errorMessage: n(t.value())
      };
    }
    function n(e) {
      return `Misconfiguration error: it is trying to request ${e} but we cannot build it from lower resolution`;
    }
    function r(e, t) {
      const i = s.Interval.parse(e);
      if ((i.isWeeks() || i.isMonths()) && t.has_weekly_and_monthly) {
        let e = ["1"];
        if (i.isWeeks() && t.weekly_multipliers !== undefined) {
          e = t.weekly_multipliers;
        }
        if (i.isMonths() && t.monthly_multipliers !== undefined) {
          e = t.monthly_multipliers;
        }
        const s = o(e, i);
        if (!s.error) {
          return s;
        }
      }
      if (i.isDWM() && (t.has_daily === undefined || t.has_daily)) {
        if (i.isDays() && t.daily_multipliers !== undefined) {
          return o(t.daily_multipliers, i);
        } else if (t.daily_multipliers === undefined || t.daily_multipliers.includes("1")) {
          return {
            error: false,
            resolution: "1D"
          };
        } else {
          return {
            error: true,
            errorMessage: "Misconfiguration error: it is trying to request a resolution but symbol does not support it"
          };
        }
      }
      if (i.isDWM()) {
        return {
          error: true,
          errorMessage: n(i.value())
        };
      }
      if (i.isMinutes() && !t.has_intraday) {
        return {
          error: true,
          errorMessage: "Misconfiguration error: it is trying to request intraday resolution but symbol does not support it"
        };
      }
      if (i.isSeconds() && !t.has_seconds) {
        return {
          error: true,
          errorMessage: "Misconfiguration error: it is trying to request seconds resolution but symbol does not support it"
        };
      }
      const r = t.seconds_multipliers ?? ["1"];
      const a = r.length === 0;
      const l = a || r.every(e => parseInt(e, 10) > i.multiplier());
      const c = t.build_seconds_from_ticks && (a || l) && t["is-tickbars-available"];
      if (i.isSeconds() && c) {
        return {
          error: false,
          resolution: "1T"
        };
      }
      if (i.isTicks()) {
        if (!t["is-tickbars-available"] || i.multiplier() > 1) {
          return {
            error: true,
            errorMessage: `Misconfiguration error: it is trying to request ${i.multiplier()} ticks resolution but symbol does not support it`
          };
        } else {
          return {
            error: false,
            resolution: "1T"
          };
        }
      }
      const h = i.isSeconds() ? t.seconds_multipliers : t.intraday_multipliers;
      if (h === undefined) {
        return {
          error: false,
          resolution: i.value()
        };
      } else {
        return o(h, i);
      }
    }
  },
  23863: (e, t, i) => {
    "use strict";

    const s = i(56570);
    const o = i(19625).getHexColorByName;
    var n = i(73772).Std;
    i(42924);
    var r = i(69146).pivotPointsStandardStudyItem;
    var a = i(24018).volumeProfileVisibleRangeStudyItem;
    var l = i(92245).volumeProfileFixedRangeVbPStudyItem;
    var c = i(92245).volumeProfileFixedRangeBSStudyItem;
    var h = i(68563).spreadStudyItem;
    var d = i(15497).ratioStudyItem;
    var u = i(65498).regressionTrendStudyItem;
    var _ = i(46367).anchoredVWAPStudyItem;
    const p = o("color-ripe-red-400");
    const m = o("color-minty-green-400");
    const g = s.enabled("secondary_series_extend_time_scale");
    JSServer.studyLibrary = JSServer.studyLibrary.concat([{
      name: "Compare",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: true,
        defaults: {
          styles: {
            compare: {
              linestyle: 0,
              linewidth: 2,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#9C27B0"
            }
          },
          inputs: {
            source: "close",
            symbol: ""
          }
        },
        plots: [{
          id: "compare",
          type: "line"
        }],
        styles: {
          compare: {
            title: "Plot",
            histogramBase: 0
          }
        },
        description: "Compare",
        shortDescription: "Compare",
        is_price_study: true,
        inputs: [{
          defval: "close",
          id: "source",
          name: "Source",
          options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"],
          type: "text"
        }, {
          id: "symbol",
          name: "Symbol",
          type: "symbol",
          isHidden: true
        }],
        id: "Compare@tv-basicstudies-1",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._context.new_sym(t(1), n.period(this._context));
        };
        this.main = function (e, t) {
          this._context = e;
          var i = this._context.new_unlimited_var(this._context.symbol.time);
          this._context.select_sym(1);
          var s = this._context.new_unlimited_var(this._context.symbol.time);
          var o = n[t(0)](this._context);
          var r = this._context.new_unlimited_var(o);
          this._context.select_sym(0);
          return [r.adopt(s, i, 0)];
        };
      }
    }, {
      name: "Overlay",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: true,
        defaults: {
          styles: {},
          inputs: {
            symbol: "",
            extendTimeScale: false
          }
        },
        plots: [{
          id: "open",
          type: "line"
        }, {
          id: "high",
          type: "line"
        }, {
          id: "low",
          type: "line"
        }, {
          id: "close",
          type: "line"
        }],
        styles: {
          open: {
            title: "Open"
          },
          high: {
            title: "High"
          },
          low: {
            title: "Low"
          },
          close: {
            title: "Close"
          }
        },
        description: "Overlay",
        shortDescription: "Overlay",
        is_price_study: false,
        inputs: [{
          id: "symbol",
          name: "symbol",
          defval: "",
          type: "symbol",
          isHidden: true
        }, {
          id: "extendTimeScale",
          name: "extendTimeScale",
          defval: false,
          type: "boolean",
          isHidden: true
        }],
        id: "Overlay@tv-basicstudies-1",
        format: {
          type: "price",
          precision: 4
        },
        canExtendTimeScale: true
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._context.new_sym(t(0), n.period(this._context));
        };
        this.main = function (e, t) {
          this._context = e;
          var i = !g || t(1) !== true;
          var s = this._context.new_unlimited_var(this._context.symbol.time);
          this._context.select_sym(1);
          var o = this._context.new_unlimited_var(this._context.symbol.time);
          var r = this._context.new_unlimited_var(n.open(this._context));
          var a = this._context.new_unlimited_var(n.high(this._context));
          var l = this._context.new_unlimited_var(n.low(this._context));
          var c = this._context.new_unlimited_var(n.close(this._context));
          if (i) {
            this._context.select_sym(0);
            return [r.adopt(o, s, 1), a.adopt(o, s, 1), l.adopt(o, s, 1), c.adopt(o, s, 1)];
          } else {
            return [r.get(0), a.get(0), l.get(0), c.get(0)];
          }
        };
      }
    }, {
      name: "Volume",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            vol: {
              linestyle: 0,
              linewidth: 1,
              plottype: 5,
              trackPrice: false,
              transparency: 50,
              visible: true,
              color: "#000080"
            },
            vol_ma: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: false,
              color: "#2196F3"
            },
            smoothedMA: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: false,
              color: "#2196F3"
            }
          },
          palettes: {
            volumePalette: {
              colors: {
                0: {
                  color: p,
                  width: 1,
                  style: 0
                },
                1: {
                  color: m,
                  width: 1,
                  style: 0
                }
              }
            }
          },
          inputs: {
            showMA: false,
            volumeMA: "SMA",
            length: 20,
            col_prev_close: false,
            symbol: "",
            smoothingLine: "SMA",
            smoothingLength: 9
          }
        },
        plots: [{
          id: "vol",
          type: "line"
        }, {
          id: "volumePalette",
          palette: "volumePalette",
          target: "vol",
          type: "colorer"
        }, {
          id: "vol_ma",
          type: "line"
        }, {
          id: "smoothedMA",
          type: "line"
        }],
        styles: {
          vol: {
            title: "Volume",
            histogramBase: 0
          },
          vol_ma: {
            title: "Volume MA",
            histogramBase: 0
          },
          smoothedMA: {
            title: "Smoothed MA",
            histogramBase: 0
          }
        },
        description: "Volume",
        shortDescription: "Volume",
        is_price_study: false,
        palettes: {
          volumePalette: {
            colors: {
              0: {
                name: "Falling"
              },
              1: {
                name: "Growing"
              }
            }
          }
        },
        inputs: [{
          id: "symbol",
          name: "Other Symbol",
          defval: "",
          type: "symbol",
          optional: true,
          isHidden: false
        }, {
          id: "showMA",
          name: "show MA",
          defval: false,
          type: "bool",
          isHidden: true
        }, {
          id: "length",
          name: "MA Length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["vol_ma"]
        }, {
          id: "volumeMA",
          name: "Volume MA",
          defval: "SMA",
          type: "text",
          options: ["SMA", "EMA", "WMA"],
          hideWhenPlotsHidden: ["vol_ma"]
        }, {
          defval: false,
          id: "col_prev_close",
          name: "Color based on previous close",
          type: "bool"
        }, {
          id: "smoothingLine",
          name: "Smoothing Line",
          defval: "SMA",
          type: "text",
          options: ["SMA", "EMA", "WMA"],
          hideWhenPlotsHidden: ["smoothedMA"]
        }, {
          id: "smoothingLength",
          name: "Smoothing Length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["smoothedMA"]
        }],
        id: "Volume@tv-basicstudies-1",
        format: {
          type: "volume"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          if (t(0) !== "") {
            this._context.new_sym(t(0), n.period(this._context));
          }
        };
        this.f_0 = function (e, t) {
          if (n.gt(e, t)) {
            return 0;
          } else {
            return 1;
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = n.volume(this._context);
          var s = n.open(this._context);
          var o = n.close(this._context);
          var r = this._context.new_var(this._context.symbol.time);
          var a = this._input(5);
          var l = this._input(6);
          var c = this._input(2);
          var h = this._input(3);
          this._context.setMinimumAdditionalDepth(c + l);
          if (this._input(0) !== "") {
            this._context.select_sym(1);
            var d = this._context.new_var(this._context.symbol.time);
            var u = this._context.new_var(n.volume(this._context));
            var _ = this._context.new_var(n.open(this._context));
            var p = this._context.new_var(n.close(this._context));
            i = u.adopt(d, r, 1);
            s = _.adopt(d, r, 1);
            o = p.adopt(d, r, 1);
            this._context.select_sym(0);
          }
          var m = this._context.new_var(i);
          var g = n[h.toLowerCase()](m, c, this._context);
          var f = this._context.new_var(g);
          var y = this._context.new_var(o);
          return [i, y.get(1) && this._input(4) ? this.f_0(y.get(1), o) : this.f_0(s, o), g, n[a.toLowerCase()](f, l, this._context)];
        };
      }
    }, {
      name: "ZigZag",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 2,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 5,
            in_1: 10
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          target: "plot_0",
          type: "dataoffset"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Zig Zag",
        shortDescription: "ZigZag",
        is_price_study: true,
        classId: "ScriptWithDataOffset",
        inputs: [{
          id: "in_0",
          name: "deviation",
          defval: 5,
          type: "float",
          min: 0.001,
          max: 100
        }, {
          id: "in_1",
          name: "depth",
          defval: 10,
          type: "integer",
          min: 2,
          max: 1000
        }],
        id: "ZigZag@tv-basicstudies-1",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var o = i / 100;
          var r = Math.ceil(s / 2);
          return [n.zigzag(o, r, this._context), n.zigzagbars(o, r, this._context)];
        };
      }
    }, {
      name: "Sessions",
      metainfo: {
        _metainfoVersion: 52,
        defaults: {
          graphics: {
            vertlines: {
              sessBreaks: {
                color: "#4985e7",
                style: 2,
                visible: false,
                width: 1
              }
            },
            backgrounds: {
              preMarket: {
                color: "#FF9800",
                transparency: 92,
                visible: true
              },
              postMarket: {
                color: "#2196F3",
                transparency: 92,
                visible: true
              }
            }
          },
          linkedToSeries: true
        },
        description: "Sessions",
        graphics: {
          vertlines: {
            sessBreaks: {
              name: "Session Break",
              halign: "left"
            }
          },
          backgrounds: {
            preMarket: {
              name: "Pre market"
            },
            postMarket: {
              name: "Post market"
            }
          }
        },
        id: "Sessions@tv-basicstudies-1",
        inputs: [],
        is_hidden_study: true,
        is_price_study: true,
        name: "Sessions@tv-basicstudies",
        palettes: {},
        plots: [],
        shortDescription: "Sessions",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        function e(e, t) {
          return {
            id: e,
            index: e,
            extendBottom: true,
            extendTop: true
          };
        }
        function t(e) {
          return {
            id: e.start,
            start: e.start,
            stop: e.stop
          };
        }
        this.init = function () {
          this._times = [];
        };
        this._getVerticalLineData = function (t) {
          return n.selectSessionBreaks(t, this._times).map(e);
        };
        this._getPreAndPostMarketBackgroundsData = function (e) {
          const i = n.selectPreAndPostMarketTimes(e, this._times);
          return {
            preMarket: i.preMarket.map(t),
            postMarket: i.postMarket.map(t)
          };
        };
        this.main = function (e, t) {
          if (n.isdwm(e)) {
            return null;
          }
          var i = n.time(e);
          if (isNaN(i)) {
            return null;
          }
          var s = this._times.length;
          if (s === 0 || this._times[s - 1] !== i) {
            this._times.push(i);
          }
          if (!e.symbol.isLastBar || !e.symbol.isNewBar) {
            return null;
          }
          var o = this._getVerticalLineData(e);
          var r = this._getPreAndPostMarketBackgroundsData(e);
          if (o.length === 0 && r.preMarket.length === 0 && r.postMarket === 0) {
            return null;
          } else {
            return {
              nonseries: true,
              type: "study_graphics",
              data: {
                graphicsCmds: {
                  create: {
                    vertlines: [{
                      styleId: "sessBreaks",
                      data: o
                    }],
                    backgrounds: [{
                      styleId: "preMarket",
                      data: r.preMarket
                    }, {
                      styleId: "postMarket",
                      data: r.postMarket
                    }]
                  },
                  erase: [{
                    action: "all"
                  }]
                }
              }
            };
          }
        };
      }
    }, {
      name: "SuperTrend",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 3,
              plottype: 0,
              trackPrice: false,
              transparency: 35,
              visible: true,
              color: "#000080"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 3,
              plottype: "shape_arrow_up",
              trackPrice: false,
              location: "BelowBar",
              transparency: 35,
              visible: true,
              color: "#00FF00"
            },
            plot_3: {
              linestyle: 0,
              linewidth: 3,
              plottype: "shape_arrow_down",
              trackPrice: false,
              location: "AboveBar",
              transparency: 35,
              visible: true,
              color: "#FF0000"
            }
          },
          palettes: {
            palette_0: {
              colors: {
                0: {
                  color: "#008000",
                  width: 3,
                  style: 0
                },
                1: {
                  color: "#800000",
                  width: 3,
                  style: 0
                }
              }
            }
          },
          inputs: {
            in_0: 10,
            in_1: 3
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          palette: "palette_0",
          target: "plot_0",
          type: "colorer"
        }, {
          id: "plot_2",
          type: "shapes"
        }, {
          id: "plot_3",
          type: "shapes"
        }],
        styles: {
          plot_0: {
            title: "SuperTrend",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          },
          plot_2: {
            title: "Up Arrow",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          },
          plot_3: {
            title: "Down Arrow",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "SuperTrend",
        shortDescription: "SuperTrend",
        is_price_study: true,
        palettes: {
          palette_0: {
            colors: {
              0: {
                name: "Color 0"
              },
              1: {
                name: "Color 1"
              }
            },
            valToIndex: {
              0: 0,
              1: 1
            }
          }
        },
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 10,
          type: "integer",
          min: 1,
          max: 100
        }, {
          id: "in_1",
          name: "Factor",
          defval: 3,
          type: "float",
          min: 1,
          max: 100
        }],
        id: "SuperTrend@tv-basicstudies-1",
        scriptIdPart: "",
        name: "SuperTrend",
        isCustomIndicator: true,
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          var i = t(0);
          var s = t(1);
          var [o, r] = n.supertrend(s, i, e);
          var a = e.new_var(r).get(1);
          return [o, r === -1 ? 0 : 1, r === -1 && a !== r ? 1 : NaN, r === 1 && a !== r ? 1 : NaN];
        };
      }
    }, r, a, l, c, h, d, u, _]);
  },
  73772: (e, t, i) => {
    "use strict";

    i.d(t, {
      Std: () => h
    });
    var s = i(14381);
    var o = i(2740);
    class n {
      constructor(e, t, i) {
        this._timezone = e;
        this._preMarketSessionSpec = t;
        this._postMarketSessionSpec = i;
      }
      getPreAndPostMarketTimes(e) {
        if (e.length === 0) {
          return {
            preMarket: [],
            postMarket: []
          };
        }
        const t = [];
        const i = [];
        let s = null;
        let n = null;
        let r = e[0];
        let a = (0, o.utc_to_cal)(this._timezone, r);
        if (this._isInPreMarketSession(a)) {
          n = r;
        }
        if (this._isInPostMarketSession(a)) {
          s = r;
        }
        for (let l = 1; l < e.length; l++) {
          const c = e[l];
          const h = (0, o.utc_to_cal)(this._timezone, c);
          if (s !== null && this._isInPostMarketSession(a) && !this._isInPostMarketSession(h)) {
            i.push({
              start: s,
              stop: r
            });
            s = null;
          }
          if (n === null && this._isInPreMarketSession(h)) {
            n = c;
          }
          if (s === null && this._isInPostMarketSession(h)) {
            s = c;
          }
          if (n !== null && this._isInPreMarketSession(a) && !this._isInPreMarketSession(h)) {
            t.push({
              start: n,
              stop: r
            });
            n = null;
          }
          r = c;
          a = h;
        }
        if (n !== null) {
          t.push({
            start: n,
            stop: e[e.length - 1]
          });
        }
        if (s !== null) {
          i.push({
            start: s,
            stop: e[e.length - 1]
          });
        }
        return {
          preMarket: t,
          postMarket: i
        };
      }
      _isInPreMarketSession(e) {
        if (this._preMarketSessionSpec === null) {
          return false;
        }
        const t = this._preMarketSessionSpec.getWeekIndex(e);
        return this._anyEntryContains(this._preMarketSessionSpec.getEntriesForWeek(t).list(), e);
      }
      _isInPostMarketSession(e) {
        if (this._postMarketSessionSpec === null) {
          return false;
        }
        const t = this._postMarketSessionSpec.getWeekIndex(e);
        return this._anyEntryContains(this._postMarketSessionSpec.getEntriesForWeek(t).list(), e);
      }
      _anyEntryContains(e, t) {
        if (e === undefined) {
          return false;
        }
        for (let i = 0; i < e.length; i++) {
          if (e[i].contains(t)) {
            return true;
          }
        }
        return false;
      }
    }
    var r = i(83910);
    var a = i(1452);
    const l = 1e-10;
    const c = e => e ? 1 : 0;
    const h = {};
    function d(e, t, i, s, o) {
      let n = o;
      let r = 0;
      if (isNaN(e.get(t - 1))) {
        return {
          index: NaN,
          value: NaN
        };
      }
      for (let i = 0; i < t; ++i) {
        if (s(e.get(i), n)) {
          r = i;
          n = e.get(i);
        }
      }
      return {
        index: r,
        value: n
      };
    }
    h.max_series_default_size = 10001;
    h.n = e => e.symbol.index + 1;
    h.nz = (e, t = 0) => isFinite(e) ? e : t;
    h.na = function (e) {
      if (arguments.length === 0) {
        return NaN;
      } else if (isNaN(e)) {
        return 1;
      } else {
        return 0;
      }
    };
    h.isZero = e => Math.abs(e) <= 1e-10 ? 1 : 0;
    h.toBool = e => isFinite(e) && !h.isZero(e);
    h.eq = (e, t) => h.isZero(e - t);
    h.neq = (e, t) => c(!h.eq(e, t));
    h.ge = (e, t) => c(h.isZero(e - t) || e > t);
    h.gt = (e, t) => c(!h.isZero(e - t) && e > t);
    h.lt = (e, t) => c(!h.isZero(e - t) && e < t);
    h.le = (e, t) => c(h.isZero(e - t) || e < t);
    h.and = (e, t) => isNaN(e) || isNaN(t) ? NaN : h.isZero(e) || h.isZero(t) ? 0 : 1;
    h.or = (e, t) => isNaN(e) || isNaN(t) ? NaN : h.isZero(e) && h.isZero(t) ? 0 : 1;
    h.not = e => isNaN(e) ? NaN : h.isZero(e) ? 1 : 0;
    h.eps = () => l;
    h.greaterOrEqual = (e, t, i) => t - e < (i || l);
    h.lessOrEqual = (e, t, i) => e - t < (i || l);
    h.equal = (e, t, i) => Math.abs(e - t) < (i || l);
    h.greater = (e, t, i) => e - t > (i || l);
    h.less = (e, t, i) => t - e > (i || l);
    h.compare = (e, t, i) => h.equal(e, t, i) ? 0 : h.greater(e, t, i) ? 1 : -1;
    h.max = Math.max;
    h.min = Math.min;
    h.pow = Math.pow;
    h.abs = Math.abs;
    h.log = Math.log;
    h.log10 = e => Math.log(e) / Math.LN10;
    h.sqrt = Math.sqrt;
    h.sign = e => isNaN(e) ? NaN : h.isZero(e) ? 0 : e > 0 ? 1 : -1;
    h.exp = Math.exp;
    h.sin = Math.sin;
    h.cos = Math.cos;
    h.tan = Math.tan;
    h.asin = Math.asin;
    h.acos = Math.acos;
    h.atan = Math.atan;
    h.floor = Math.floor;
    h.ceil = Math.ceil;
    h.round = Math.round;
    h.avg = (...e) => {
      if (e.length === 2) {
        return (e[0] + e[1]) / 2;
      }
      let t = 0;
      for (let i = 0; i < e.length; i++) {
        t += e[i];
      }
      return t / e.length;
    };
    h.open = e => e.symbol.open;
    h.high = e => e.symbol.high;
    h.low = e => e.symbol.low;
    h.close = e => e.symbol.close;
    h.hl2 = e => (e.symbol.high + e.symbol.low) / 2;
    h.hlc3 = e => (e.symbol.high + e.symbol.low + e.symbol.close) / 3;
    h.ohlc4 = e => (e.symbol.open + e.symbol.high + e.symbol.low + e.symbol.close) / 4;
    h.volume = e => e.symbol.volume;
    h.updatetime = e => e.symbol.updatetime;
    h.time = e => e.symbol.bartime();
    h.period = e => e.symbol.period;
    h.tickerid = e => e.symbol.tickerid;
    h.currencyCode = e => e.symbol.currencyCode;
    h.unitId = e => e.symbol.unitId;
    h.ticker = e => e.symbol.ticker;
    h.interval = e => e.symbol.interval;
    h.isdwm = e => e.symbol.isdwm();
    h.isintraday = e => !e.symbol.isdwm();
    h.isdaily = e => e.symbol.resolution === "D";
    h.isweekly = e => e.symbol.resolution === "W";
    h.ismonthly = e => e.symbol.resolution === "M";
    h.year = (e, t) => h.timepart(e.symbol, o.YEAR, t);
    h.month = (e, t) => h.timepart(e.symbol, o.MONTH, t);
    h.weekofyear = (e, t) => h.timepart(e.symbol, o.WEEK_OF_YEAR, t);
    h.dayofmonth = (e, t) => h.timepart(e.symbol, o.DAY_OF_MONTH, t);
    h.dayofweek = (e, t) => h.timepart(e.symbol, o.DAY_OF_WEEK, t);
    h.hour = (e, t) => h.timepart(e.symbol, o.HOUR_OF_DAY, t);
    h.minute = (e, t) => h.timepart(e.symbol, o.MINUTE, t);
    h.second = (e, t) => h.timepart(e.symbol, o.SECOND, t);
    h.add_days_considering_dst = (e, t, i) => (0, o.add_days_considering_dst)((0, o.get_timezone)(e), t, i);
    h.add_years_considering_dst = (e, t, i) => (0, o.add_years_considering_dst)((0, o.get_timezone)(e), t, i);
    h.selectSessionBreaks = (e, t) => {
      if (h.isdwm(e) || e.symbol.session.timezone === undefined) {
        return [];
      }
      const i = (0, s.newBarBuilder)(e.symbol.period, e.symbol.session, null);
      const o = [];
      const n = t.length;
      i.moveTo(t[n - 1]);
      if (n === 1 && i.startOfBar(0) === t[0]) {
        o.push(t[0]);
      } else {
        for (let e = n - 2; e >= 0; --e) {
          const s = t[e];
          if (s >= i.startOfBar(0)) {
            continue;
          }
          i.moveTo(s);
          const n = t[e + 1];
          o.push(n);
        }
        o.reverse();
      }
      return o;
    };
    h.selectPreAndPostMarketTimes = (e, t) => {
      if (h.isdwm(e) || e.symbol.session.timezone === undefined) {
        return {
          preMarket: [],
          postMarket: []
        };
      }
      return new n(e.symbol.session.timezone, e.symbol.preMarketSubsession ?? null, e.symbol.postMarketSubsession ?? null).getPreAndPostMarketTimes(t);
    };
    h.iff = (e, t, i) => h.not(e) ? i : t;
    h.rising = (e, t) => {
      for (let i = 1; i < t + 1; ++i) {
        if (e.get(i) > e.get(0)) {
          return 0;
        }
      }
      return 1;
    };
    h.falling = (e, t) => {
      for (let i = 1; i < t + 1; ++i) {
        if (e.get(i) < e.get(0)) {
          return 0;
        }
      }
      return 1;
    };
    h.timepart = (e, t, i) => {
      const s = (0, o.utc_to_cal)(e.session.timezone, i || e.bartime());
      return (0, o.get_part)(s, t);
    };
    h.rsi = (e, t) => h.isZero(t) ? 100 : h.isZero(e) ? 0 : 100 - 100 / (1 + e / t);
    h.sum = (e, t, i) => {
      const s = i.new_var();
      const o = h.nz(e.get()) + h.nz(s.get(1)) - h.nz(e.get(t));
      s.set(o);
      return o;
    };
    h.sma = (e, t, i) => {
      const s = h.sum(e, t, i);
      if (h.na(e.get(t - 1))) {
        return NaN;
      } else {
        return s / t;
      }
    };
    h.smma = (e, t, i) => {
      const s = i.new_var(e);
      const o = h.sma(s, t, i);
      const n = i.new_var();
      const r = (n.get(1) * (t - 1) + e) / t;
      n.set(h.na(n.get(1)) ? o : r);
      return n.get(0);
    };
    h.rma = (e, t, i) => {
      const s = h.sum(e, t, i);
      const o = t - 1;
      const n = e.get(o);
      const r = i.new_var();
      const a = r.get(1);
      const l = e.get();
      const c = h.na(n) ? NaN : h.na(a) ? s / t : (l + a * o) / t;
      r.set(c);
      return c;
    };
    h.fixnan = (e, t) => {
      const i = t.new_var();
      if (isNaN(e)) {
        return i.get(1);
      } else {
        i.set(e);
        return e;
      }
    };
    h.tr = (e, t) => {
      let i = t.new_var(h.close(t)).get(1);
      if (e && isNaN(i)) {
        i = h.close(t);
      }
      return h.max(h.max(h.high(t) - h.low(t), h.abs(h.high(t) - i)), h.abs(h.low(t) - i));
    };
    h.atr = (e, t) => {
      const i = t.new_var(h.tr(undefined, t));
      return h.rma(i, e, t);
    };
    h.ema = (e, t, i) => {
      const s = h.sum(e, t, i);
      const o = i.new_var();
      const n = e.get(0);
      const r = e.get(t - 1);
      const a = o.get(1);
      const l = h.na(r) ? NaN : h.na(a) ? s / t : (n - a) * 2 / (t + 1) + a;
      o.set(l);
      return l;
    };
    h.wma = (e, t, i) => {
      let s = 0;
      for (let i = t = Math.round(t); i >= 0; i--) {
        s += (t - i) * e.get(i);
      }
      return s * 2 / (t * (t + 1));
    };
    h.vwma = (e, t, i) => {
      const s = i.new_var(h.volume(i));
      const o = i.new_var(e.get(0) * h.volume(i));
      return h.sma(o, t, i) / h.sma(s, t, i);
    };
    h.swma = (e, t) => (e.get(0) + e.get(1) * 2 + e.get(2) * 2 + e.get(3)) / 6;
    h.supertrend = (e, t, i) => {
      const s = h.atr(t, i);
      const o = i.new_var(s).get(1);
      const n = h.hl2(i);
      let r = n + s * e;
      let a = n - s * e;
      const l = h.close(i);
      const c = i.new_var(l).get(1);
      const d = i.new_var();
      const u = h.nz(d.get(1));
      const _ = i.new_var();
      const p = h.nz(_.get(1));
      a = h.gt(a, u) || h.lt(c, u) ? a : u;
      d.set(a);
      r = h.lt(r, p) || h.gt(c, p) ? r : p;
      _.set(r);
      let m = h.na();
      const g = i.new_var();
      const f = g.get(1);
      m = h.na(o) ? 1 : f === p ? l > r ? -1 : 1 : l < a ? 1 : -1;
      const y = m === -1 ? a : r;
      g.set(y);
      if (h.n(i) <= t) {
        return [Number.NaN, 0];
      } else {
        return [y, m];
      }
    };
    h.lowestbars = (e, t, i) => -d(e, t, 0, (e, t) => h.lt(e, t), Number.MAX_SAFE_INTEGER).index;
    h.lowest = (e, t, i) => d(e, t, 0, (e, t) => h.lt(e, t), Number.MAX_SAFE_INTEGER).value;
    h.highestbars = (e, t, i) => -d(e, t, 0, (e, t) => h.gt(e, t), Number.MIN_SAFE_INTEGER).index;
    h.highest = (e, t, i) => d(e, t, 0, (e, t) => h.gt(e, t), Number.MIN_SAFE_INTEGER).value;
    h.cum = (e, t) => {
      const i = t.new_var();
      const s = h.nz(i.get(1)) + e;
      i.set(s);
      return s;
    };
    h.accdist = e => {
      const t = h.high(e);
      const i = h.low(e);
      const s = h.close(e);
      const o = h.volume(e);
      return h.cum(s === t && s === i || t === i ? 0 : o * (s * 2 - i - t) / (t - i), e);
    };
    h.correlation = (e, t, i, s) => {
      const o = h.sma(e, i, s);
      const n = h.sma(t, i, s);
      const r = s.new_var(e.get() * t.get());
      return (h.sma(r, i, s) - o * n) / Math.sqrt(h.variance2(e, o, i) * h.variance2(t, n, i));
    };
    h.stoch = (e, t, i, s, o) => {
      const n = h.highest(t, s, o);
      const r = h.lowest(i, s, o);
      return h.fixnan((e.get() - r) * 100 / (n - r), o);
    };
    h.tsi = (e, t, i, s) => {
      const o = s.new_var(h.change(e));
      const n = s.new_var(h.abs(h.change(e)));
      const r = s.new_var(h.ema(o, i, s));
      const a = s.new_var(h.ema(n, i, s));
      return h.ema(r, t, s) / h.ema(a, t, s);
    };
    h.cross = (e, t, i) => {
      if (isNaN(e) || isNaN(t)) {
        return false;
      }
      const s = i.new_var((o = e - t) < 0 ? -1 : o === 0 ? 0 : 1);
      var o;
      return !isNaN(s.get(1)) && s.get(1) !== s.get();
    };
    h.linreg = (e, t, i) => {
      let s = 0;
      let o = 0;
      let n = 0;
      let r = 0;
      for (let i = 0; i < t; ++i) {
        const a = e.get(i);
        const l = t - 1 - i + 1;
        s += l;
        o += a;
        n += l * l;
        r += a * l;
      }
      const a = (t * r - s * o) / (t * n - s * s);
      return o / t - a * s / t + a + a * (t - 1 - i);
    };
    h.sar = (e, t, i, s) => {
      const o = s.new_var();
      const n = s.new_var();
      const r = s.new_var();
      const a = h.high(s);
      const l = h.low(s);
      const c = h.close(s);
      const d = s.new_var(a);
      const u = s.new_var(l);
      const _ = s.new_var(c);
      const p = s.new_var();
      let m = p.get(1);
      let g = n.get(1);
      let f = r.get(1);
      n.set(g);
      r.set(f);
      let y = false;
      const v = u.get(1);
      const S = u.get(2);
      const b = d.get(1);
      const w = d.get(2);
      const C = _.get();
      const P = _.get(1);
      if (h.n(s) === 2) {
        if (h.greater(C, P)) {
          o.set(1);
          r.set(d.get());
          m = v;
          f = d.get();
        } else {
          o.set(-1);
          r.set(u.get());
          m = b;
          f = u.get();
        }
        y = true;
        n.set(e);
        g = e;
      }
      let T = m + g * (f - m);
      if (o.get() === 1) {
        if (h.greater(T, u.get())) {
          y = true;
          o.set(-1);
          T = Math.max(d.get(), r.get());
          r.set(u.get());
          n.set(e);
        }
      } else if (h.less(T, d.get())) {
        y = true;
        o.set(1);
        T = Math.min(u.get(), r.get());
        r.set(d.get());
        n.set(e);
      }
      if (!y) {
        if (o.get() === 1) {
          if (h.greater(d.get(), r.get())) {
            r.set(d.get());
            n.set(Math.min(n.get() + t, i));
          }
        } else if (h.less(u.get(), r.get())) {
          r.set(u.get());
          n.set(Math.min(n.get() + t, i));
        }
      }
      if (o.get() === 1) {
        T = Math.min(T, v);
        if (h.n(s) > 2) {
          T = Math.min(T, S);
        }
      } else {
        T = Math.max(T, b);
        if (h.n(s) > 2) {
          T = Math.max(T, w);
        }
      }
      p.set(T);
      return T;
    };
    h.alma = (e, t, i, s) => {
      const o = Math.floor(i * (t - 1));
      const n = t / s * (t / s);
      const r = [];
      let a = 0;
      for (let e = 0; e < t; ++e) {
        const t = Math.exp(Math.pow(e - o, 2) * -1 / (n * 2));
        a += t;
        r.push(t);
      }
      for (let e = 0; e < t; ++e) {
        r[e] /= a;
      }
      let l = 0;
      for (let i = 0; i < t; ++i) {
        l += r[i] * e.get(t - i - 1);
      }
      return l;
    };
    h.change = e => e.get() - e.get(1);
    h.roc = (e, t) => {
      const i = e.get(t);
      return (e.get() - i) * 100 / i;
    };
    h.dev = (e, t, i) => {
      const s = h.sma(e, t, i);
      return h.dev2(e, t, s);
    };
    h.dev2 = (e, t, i) => {
      let s = 0;
      for (let o = 0; o < t; o++) {
        const t = e.get(o);
        s += h.abs(t - i);
      }
      return s / t;
    };
    h.stdev = (e, t, i) => {
      const s = h.variance(e, t, i);
      return h.sqrt(s);
    };
    h.variance = (e, t, i) => {
      const s = h.sma(e, t, i);
      return h.variance2(e, s, t);
    };
    h.variance2 = (e, t, i) => {
      let s = 0;
      for (let o = 0; o < i; o++) {
        const i = e.get(o);
        const n = h.abs(i - t);
        s += n * n;
      }
      return s / i;
    };
    h.percentrank = (e, t) => {
      if (h.na(e.get(t - 1))) {
        return NaN;
      }
      let i = 0;
      const s = e.get();
      for (let o = 1; o < t; o++) {
        const t = e.get(o);
        if (h.ge(s, t)) {
          i++;
        }
      }
      return i * 100 / t;
    };
    h.createNewSessionCheck = e => {
      if (e.symbol.session.timezone === undefined) {
        return () => false;
      }
      const t = (0, s.newBarBuilder)(e.symbol.period, e.symbol.session, null);
      return e => t.indexOfBar(e) === r.SessionStage.POST_SESSION && (t.moveTo(e), true);
    };
    h.createNthBarInSessionCheck = e => {
      if (e.symbol.session.timezone === undefined) {
        return () => false;
      }
      const t = (0, s.newBarBuilder)(e.symbol.period, e.symbol.session, null);
      return (e, i) => {
        if (t.indexOfBar(e) === r.SessionStage.POST_SESSION) {
          t.moveTo(e);
        }
        return t.indexOfBar(e) === i;
      };
    };
    h.error = e => {
      throw new a.StudyError(e);
    };
    h.dmi = (e, t, i) => {
      const s = i.new_var(h.high(i));
      const o = i.new_var(h.low(i));
      const n = h.change(s);
      const r = -h.change(o);
      const a = i.new_var(h.na(n) || h.na(r) ? h.na() : h.and(h.gt(n, r), h.gt(n, 0)) ? n : 0);
      const l = i.new_var(h.na(r) ? h.na() : h.and(h.gt(r, n), h.gt(r, 0)) ? r : 0);
      const c = h.atr(e, i);
      const d = h.fixnan(h.rma(a, e, i) * 100 / c, i);
      const u = h.fixnan(h.rma(l, e, i) * 100 / c, i);
      let _ = d + u;
      if (h.isZero(_)) {
        _ += 1;
      }
      const p = Math.abs(d - u) / _ * 100;
      const m = i.new_var(p);
      const g = h.rma(m, t, i);
      const f = i.new_var(g);
      return [d, u, p, g, (f.get(0) + f.get(e - 1)) / 2];
    };
    h.zigzag = (e, t, i) => new m(e, t, i).lastPrice();
    h.zigzagbars = (e, t, i) => {
      const s = new m(e, t, i);
      if (s.lastIndex() === -1) {
        return NaN;
      } else {
        return s.lastIndex() - h.n(i);
      }
    };
    const u = 0;
    const _ = 1;
    class p {
      constructor(e, t, i, s, o) {
        this._areaRight = e;
        this._areaLeft = t;
        this._pivotType = i;
        this._series = s;
        this._currentIndex = o.new_var(0);
        this._currentValue = o.new_var(NaN);
        this._pivotIndex = o.new_var(-1);
        this._index = h.n(o);
        this._isNewBar = o.symbol.isNewBar;
        const n = this._currentIndex.get(1);
        const r = this._currentValue.get(1);
        const a = this._pivotIndex.get(1);
        if (this._index > 1) {
          this._currentIndex.set(n);
          this._currentValue.set(r);
          this._pivotIndex.set(a);
        }
      }
      isPivotFound() {
        return this._pivotIndex.get() !== -1;
      }
      pivotIndex() {
        return this._pivotIndex.get();
      }
      currentValue() {
        return this._currentValue.get();
      }
      pivotType() {
        return this._pivotType;
      }
      reset() {
        this._currentValue.set(NaN);
        this._currentIndex.set(0);
        this._pivotIndex.set(-1);
      }
      isRightSideOk(e) {
        return e - this._currentIndex.get() === this._areaRight;
      }
      isViolate(e, t) {
        if (e < 1 || isNaN(this._currentValue.get())) {
          return true;
        }
        const i = this._series.get(this._index - e);
        return !!isNaN(i) || (i === this._currentValue.get() ? t : this._pivotType === _ ? i > this._currentValue.get() : i < this._currentValue.get());
      }
      processPoint(e) {
        if (this.isViolate(e, false)) {
          this._currentValue.set(this._series.get());
          this._currentIndex.set(e);
        }
      }
      isRestartNeeded(e) {
        return e - this._currentIndex.get() > this._areaRight;
      }
      update() {
        if (this._isNewBar && this.isPivotFound()) {
          this.reset();
        }
        this.processPoint(this._index);
        if (this.isRightSideOk(this._index)) {
          if (this._pivotIndex.get() === -1) {
            let e = true;
            for (let t = 0; t < this._areaLeft; ++t) {
              if (this.isViolate(this._currentIndex.get() - 1 - t, true)) {
                e = false;
                break;
              }
            }
            if (e) {
              this._pivotIndex.set(this._currentIndex.get());
            }
          }
        } else if (this._pivotIndex.get() !== -1) {
          this._pivotIndex.set(-1);
        }
        if (this.isRestartNeeded(this._index)) {
          this.reset();
          for (let e = 0; e <= this._areaRight; ++e) {
            this.processPoint(this._index - this._areaRight + e);
          }
        }
      }
    }
    p.LOW = 0;
    p.HIGH = 1;
    class m {
      constructor(e, t, i) {
        this._deviation = e;
        const s = i.new_var(h.high(i));
        const o = i.new_var(h.low(i));
        s.get(t * 2 + 1);
        o.get(t * 2 + 1);
        this._pivotHigh = new p(t, t, _, s, i);
        this._pivotLow = new p(t, t, u, o, i);
        this._lastVal = i.new_var(NaN);
        this._lastIndex = i.new_var(-1);
        this._lastType = i.new_var();
        this._index = h.n(i);
        this._isBarClosed = i.symbol.isBarClosed;
        const n = this._lastIndex.get(1);
        const r = this._lastVal.get(1);
        const a = this._lastType.get(1);
        if (this._index > 1) {
          this.addPivot(n, r, a);
        }
        this.processPivot(this._pivotHigh);
        this.processPivot(this._pivotLow);
      }
      addPivot(e, t, i) {
        this._lastIndex.set(e);
        this._lastVal.set(t);
        this._lastType.set(i);
      }
      updatePivot(e, t) {
        this._lastIndex.set(e);
        this._lastVal.set(t);
      }
      lastPrice() {
        return this._lastVal.get();
      }
      lastIndex() {
        return this._lastIndex.get();
      }
      addPoint(e, t, i) {
        if (isNaN(this._lastVal.get())) {
          this.addPivot(e, t, i);
          return;
        }
        const s = this._lastVal.get();
        if (this._lastType.get() === i) {
          if (i === _ ? t > s : t < s) {
            this.updatePivot(e, t);
          }
          return;
        }
        if (Math.abs(s - t) / t > this._deviation) {
          this.addPivot(e, t, i);
        }
      }
      processPivot(e) {
        e.update();
        if (this._isBarClosed && e.isPivotFound()) {
          this.addPoint(e.pivotIndex(), e.currentValue(), e.pivotType());
        }
      }
    }
  },
  46367: (e, t, i) => {
    "use strict";

    i.d(t, {
      anchoredVWAPStudyItem: () => r
    });
    const s = {
      _metainfoVersion: 51,
      description: "Anchored VWAP",
      shortDescription: "Anchored VWAP",
      format: {
        type: "inherit"
      },
      id: "AnchoredVWAP@tv-basicstudies-1",
      is_hidden_study: true,
      is_price_study: true,
      defaults: {
        areaBackground: {
          backgroundColor: "#4caf50",
          fillBackground: true,
          transparency: 95
        },
        filledAreasStyle: {
          Background_1: {
            fillType: undefined,
            color: "#4caf50",
            transparency: 95,
            visible: true
          }
        },
        inputs: {
          start_time: 0,
          "Bands Calculation Mode": "Standard Deviation",
          bands_multiplier: 1,
          bands_multiplier_2: 2,
          bands_multiplier_3: 3,
          calculate_stDev: true,
          calculate_stDev_2: false,
          calculate_stDev_3: false,
          source: "hlc3"
        },
        styles: {
          VWAP: {
            color: "#1e88e5",
            linestyle: 0,
            linewidth: 1,
            plottype: 0,
            trackPrice: false,
            transparency: 0,
            visible: true,
            display: 15
          },
          LowerBand: {
            display: 15,
            color: "#4caf50",
            linestyle: 0,
            linewidth: 1,
            plottype: 0,
            trackPrice: false,
            transparency: 0
          },
          LowerBand_2: {
            display: 15,
            color: "#808000",
            linestyle: 0,
            linewidth: 1,
            plottype: 0,
            trackPrice: false,
            transparency: 0
          },
          LowerBand_3: {
            display: 15,
            color: "#00897b",
            linestyle: 0,
            linewidth: 1,
            plottype: 0,
            trackPrice: false,
            transparency: 0
          },
          UpperBand: {
            display: 15,
            color: "#4caf50",
            linestyle: 0,
            linewidth: 1,
            plottype: 0,
            trackPrice: false,
            transparency: 0
          },
          UpperBand_2: {
            display: 15,
            color: "#808000",
            linestyle: 0,
            linewidth: 1,
            plottype: 0,
            trackPrice: false,
            transparency: 0
          },
          UpperBand_3: {
            display: 15,
            color: "#00897b",
            linestyle: 0,
            linewidth: 1,
            plottype: 0,
            trackPrice: false,
            transparency: 0
          }
        }
      },
      inputs: [{
        defval: 0,
        id: "start_time",
        isHidden: true,
        max: Number.MAX_SAFE_INTEGER,
        min: -Number.MAX_SAFE_INTEGER,
        name: "Start time",
        type: "time"
      }, {
        defval: "Standard Deviation",
        group: "Bands Settings",
        id: "Bands Calculation Mode",
        name: "Bands Calculation Mode",
        options: ["Standard Deviation", "Percentage"],
        tooltip: "Determines the units used to calculate the distance of the bands. When 'Percentage' is selected, a multiplier of 1 means 1%.",
        type: "text",
        display: 15
      }, {
        defval: true,
        group: "Bands Settings",
        id: "calculate_stDev",
        inline: "band_1",
        name: " ",
        type: "bool",
        display: 0
      }, {
        defval: 1,
        group: "Bands Settings",
        id: "bands_multiplier",
        inline: "band_1",
        max: Number.MAX_VALUE,
        min: 0,
        name: "Bands Multiplier #1",
        step: 0.5,
        type: "float",
        display: 15
      }, {
        defval: false,
        group: "Bands Settings",
        id: "calculate_stDev_2",
        inline: "band_2",
        name: " ",
        type: "bool",
        display: 0
      }, {
        defval: 2,
        group: "Bands Settings",
        id: "bands_multiplier_2",
        inline: "band_2",
        max: Number.MAX_VALUE,
        min: 0,
        name: "Bands Multiplier #2",
        step: 0.5,
        type: "float",
        display: 15
      }, {
        defval: false,
        group: "Bands Settings",
        id: "calculate_stDev_3",
        inline: "band_3",
        name: " ",
        type: "bool",
        display: 0
      }, {
        defval: 3,
        group: "Bands Settings",
        id: "bands_multiplier_3",
        inline: "band_3",
        max: Number.MAX_VALUE,
        min: 0,
        name: "Bands Multiplier #3",
        step: 0.5,
        type: "float",
        display: 15
      }, {
        defval: "hlc3",
        id: "source",
        name: "Source",
        options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"],
        type: "source"
      }],
      plots: [{
        id: "VWAP",
        type: "line"
      }, {
        id: "UpperBand",
        type: "line"
      }, {
        id: "LowerBand",
        type: "line"
      }, {
        id: "UpperBand_2",
        type: "line"
      }, {
        id: "LowerBand_2",
        type: "line"
      }, {
        id: "UpperBand_3",
        type: "line"
      }, {
        id: "LowerBand_3",
        type: "line"
      }],
      styles: {
        VWAP: {
          histogramBase: 0,
          title: "VWAP"
        },
        LowerBand: {
          histogramBase: 0,
          title: "Lower Band #1"
        },
        LowerBand_2: {
          histogramBase: 0,
          title: "Lower Band #2"
        },
        LowerBand_3: {
          histogramBase: 0,
          title: "Lower Band #3"
        },
        UpperBand: {
          histogramBase: 0,
          title: "Upper Band #1"
        },
        UpperBand_2: {
          histogramBase: 0,
          title: "Upper Band #2"
        },
        UpperBand_3: {
          histogramBase: 0,
          title: "Upper Band #3"
        }
      },
      filledAreas: [{
        title: "Background #1",
        id: "Background_1",
        objAId: "UpperBand",
        objBId: "LowerBand",
        type: "plot_plot"
      }],
      area: [{
        name: "UpperBand",
        visible: true
      }, {
        name: "LowerBand",
        visible: true
      }]
    };
    var o = i(50151);
    var n = i(73772);
    const r = {
      name: "Anchored VWAP",
      metainfo: s,
      constructor: class {
        constructor() {
          this._isNewSession = null;
          this._firstBarTime = 0;
        }
        init(e, t) {
          this._firstBarTime = t(0);
          this._isNewSession = null;
        }
        main(e, t, i) {
          if (i === undefined) {
            return [NaN];
          }
          (0, o.assert)(e.symbol.time === i.time);
          const s = i.time;
          if (s && s < this._firstBarTime) {
            return [NaN];
          }
          const r = n.Std.volume(e);
          const a = n.Std[t(8)](e);
          const l = e.new_unlimited_var();
          const c = e.new_unlimited_var();
          const h = e.new_unlimited_var();
          const d = e.symbol.time;
          if (d !== null) {
            if (this._isNewSession === null) {
              this._isNewSession = n.Std.createNewSessionCheck(e);
            }
            if (this._isNewSession && this._isNewSession(d)) {
              this._resetHist(l);
              this._resetHist(c);
              this._resetHist(h);
            }
          }
          l.set(n.Std.nz(l.get()) + a * r);
          c.set(n.Std.nz(c.get()) + r);
          h.set(n.Std.nz(h.get()) + a * a * r);
          const u = l.get() / c.get();
          const _ = h.get() / c.get() - Math.pow(u, 2);
          const p = Math.sqrt(Math.max(0, _));
          const m = t(1) === "Standard Deviation" ? p : u * 0.01;
          const g = t(2);
          const f = t(3);
          const y = t(4);
          const v = t(5);
          const S = t(6);
          const b = t(7);
          return [u, g ? u + m * f : NaN, g ? u - m * f : NaN, y ? u + m * v : NaN, y ? u - m * v : NaN, S ? u + m * b : NaN, S ? u - m * b : NaN];
        }
        _resetHist(e) {
          e.reset_hist();
        }
      }
    };
  },
  69146: (e, t, i) => {
    "use strict";

    i.d(t, {
      pivotPointsStandardStudyItem: () => _
    });
    var s;
    var o;
    var n = i(85049);
    var r = i(67153);
    var a = i(73772);
    (function (e) {
      e[e.TRADITIONAL = 0] = "TRADITIONAL";
      e[e.FIBONACCI = 1] = "FIBONACCI";
      e[e.WOODIE = 2] = "WOODIE";
      e[e.CLASSIC = 3] = "CLASSIC";
      e[e.DEMARK = 4] = "DEMARK";
      e[e.CAMARILLA = 5] = "CAMARILLA";
      e[e.FLOOR = 6] = "FLOOR";
    })(s ||= {});
    (function (e) {
      e.AUTO = "Auto";
      e.DAILY = "Daily";
      e.WEEKLY = "Weekly";
      e.MONTHLY = "Monthly";
      e.YEARLY = "Yearly";
    })(o ||= {});
    class l {
      constructor() {
        this.p = NaN;
        this.r1 = NaN;
        this.s1 = NaN;
        this.r2 = NaN;
        this.s2 = NaN;
        this.r3 = NaN;
        this.s3 = NaN;
        this.r4 = NaN;
        this.s4 = NaN;
        this.r5 = NaN;
        this.s5 = NaN;
        this.startIndex__t = NaN;
        this.endIndex__t = NaN;
      }
    }
    class c {
      constructor() {
        this.pivots = [];
      }
    }
    function h(e, t) {
      e.setUTCMonth(e.getUTCMonth() + t);
    }
    function d(e, t) {
      if (a.Std.ismonthly(e)) {
        let i = new Date(t);
        if (i.getUTCDay() < function (e, t) {
          return new Date(t, e, 0).getDate();
        }(i.getUTCMonth(), i.getUTCFullYear())) {
          h(i, a.Std.interval(e));
          i = a.Std.add_days_considering_dst("Etc/UTC", i, 1 - i.getUTCDay());
        } else {
          i = a.Std.add_days_considering_dst("Etc/UTC", i, 1);
          h(i, a.Std.interval(e));
        }
        return i.valueOf();
      }
      return t + n.Interval.parse(e.symbol.resolution).inMilliseconds(t);
    }
    function u(e, t) {
      let i;
      switch (t) {
        case "Auto":
          i = function (e) {
            const t = n.Interval.parse(e.interval + e.resolution);
            switch (t.kind()) {
              case n.ResolutionKind.Weeks:
              case n.ResolutionKind.Months:
                return "12M";
              case n.ResolutionKind.Days:
                return "1M";
              case n.ResolutionKind.Minutes:
                if (t.multiplier() >= 1 && t.multiplier() <= 15) {
                  return "1D";
                } else {
                  return "1W";
                }
              case n.ResolutionKind.Seconds:
              case n.ResolutionKind.Ticks:
                return "1D";
            }
            throw new Error("Unexpected resolution type: " + e.resolution);
          }(e);
          break;
        case "Daily":
          i = "1D";
          break;
        case "Weekly":
          i = "1W";
          break;
        case "Monthly":
          i = "1M";
          break;
        case "Yearly":
          i = "12M";
          break;
        default:
          throw new Error("No such pivTimeFrame: " + t);
      }
      const s = e.resolution === "D" && t === "Daily";
      const o = e.resolution === "W" && (t === "Daily" || t === "Weekly");
      const l = e.resolution === "M" && (t === "Daily" || t === "Weekly" || t === "Monthly");
      if (s || o || l || e.info && (0, r.findSuitableResolutionToBuildFrom)(i, e.info).error) {
        a.Std.error("You cannot see this pivot timeframe on this resolution");
      }
      return i;
    }
    const _ = {
      name: "Pivot Points Standard",
      metainfo: {
        _metainfoVersion: 44,
        defaults: {
          inputs: {
            kind: "Traditional",
            lookBack: 15,
            pivTimeFrame: "Auto",
            showHistoricalPivots: true,
            symbol: ""
          },
          precision: "4"
        },
        description: "Pivot Points Standard",
        id: "PivotPointsStandard@tv-basicstudies-80",
        inputs: [{
          defval: "Traditional",
          id: "kind",
          name: "Type",
          options: ["Traditional", "Fibonacci", "Woodie", "Classic", "DeMark", "Camarilla", "Floor"],
          type: "text"
        }, {
          defval: true,
          id: "showHistoricalPivots",
          name: "Show historical pivots",
          type: "bool"
        }, {
          defval: "Auto",
          id: "pivTimeFrame",
          name: "Pivots Timeframe",
          options: ["Auto", "Daily", "Weekly", "Monthly", "Yearly"],
          type: "text"
        }, {
          defval: 15,
          id: "lookBack",
          max: 5000,
          min: 1,
          name: "Number of Pivots Back",
          type: "integer"
        }, {
          defval: "",
          id: "symbol",
          name: "Other Symbol",
          type: "symbol",
          optional: true
        }],
        is_price_study: true,
        linkedToSeries: true,
        shortDescription: "Pivots",
        format: {
          type: "price",
          precision: 4
        }
      },
      constructor: class {
        constructor() {
          this._secondaryRes = "1D";
          this._firstMainSeriesBarTime = NaN;
        }
        init(e, t) {
          this._isValidResolution = false;
          const i = t(0);
          const s = t(1);
          const o = t(2);
          const r = t(3);
          this._data = new c();
          this._firstMainSeriesBarTime = NaN;
          this._kindPP = function (e) {
            switch (e) {
              case "Traditional":
                return 0;
              case "Fibonacci":
                return 1;
              case "Woodie":
                return 2;
              case "Classic":
                return 3;
              case "DeMark":
                return 4;
              case "Camarilla":
                return 5;
              case "Floor":
                return 6;
              default:
                throw new Error("Unknown kind " + e);
            }
          }(i);
          this._showHistoricalPivots = s;
          this._historicalPivotsToKeep = r;
          this._pivTimeFrame = o;
          const l = t(4);
          if (l === "") {
            this._secondaryRes = u(e.symbol, this._pivTimeFrame);
            e.new_sym(e.symbol.tickerid, this._secondaryRes);
          } else {
            const t = e.new_sym(l, a.Std.period(e));
            const i = n.Interval.parse(u(t, o));
            t.resolution = i.letter();
            t.interval = i.multiplier();
            t.period = i.value();
          }
          this._isValidResolution = true;
        }
        main(e, t, i) {
          if (!this._isValidResolution) {
            return null;
          }
          if (e.is_main_symbol(i)) {
            if (isNaN(this._firstMainSeriesBarTime)) {
              this._firstMainSeriesBarTime = e.symbol.time;
              this._removeUnusedPivots();
            }
            if (e.symbol.isLastBar && e.symbol.isNewBar) {
              return this._createResponse();
            } else {
              return null;
            }
          }
          e.select_sym(1);
          const s = e.new_var(a.Std.open(e));
          const o = e.new_var(a.Std.high(e));
          const n = e.new_var(a.Std.low(e));
          const r = e.new_var(a.Std.close(e));
          const c = e.new_var(a.Std.time(e));
          const h = this._data;
          const u = s.get(0);
          const _ = c.get(0);
          const p = s.get(1);
          const m = o.get(1);
          const g = n.get(1);
          const f = r.get(1);
          const y = e.symbol.isLastBar;
          if (h.pivots.length !== 0 && e.symbol.isNewBar) {
            const e = h.pivots[h.pivots.length - 1];
            if (e.endIndex__t !== _) {
              e.endIndex__t = _;
            }
          }
          if (e.symbol.index === 0 || !e.symbol.isNewBar) {
            e.select_sym(0);
            return null;
          }
          const v = function (e, t, i, s, o, n, r, c) {
            const h = new l();
            let d = NaN;
            const u = i - s;
            switch (c) {
              case 0:
                d = (i + s + o) / 3;
                h.p = d;
                h.r1 = d * 2 - s;
                h.s1 = d * 2 - i;
                h.r2 = d + (i - s);
                h.s2 = d - (i - s);
                h.r3 = d * 2 + (i - s * 2);
                h.s3 = d * 2 - (i * 2 - s);
                h.r4 = d * 3 + (i - s * 3);
                h.s4 = d * 3 - (i * 3 - s);
                h.r5 = d * 4 + (i - s * 4);
                h.s5 = d * 4 - (i * 4 - s);
                break;
              case 1:
                d = (i + s + o) / 3;
                h.p = d;
                h.r1 = d + u * 0.382;
                h.s1 = d - u * 0.382;
                h.r2 = d + u * 0.618;
                h.s2 = d - u * 0.618;
                h.r3 = d + u;
                h.s3 = d - u;
                break;
              case 2:
                d = (i + s + e * 2) / 4;
                h.p = d;
                h.r1 = d * 2 - s;
                h.s1 = d * 2 - i;
                h.r2 = d + u;
                h.s2 = d - u;
                h.r3 = i + (d - s) * 2;
                h.s3 = s - (i - d) * 2;
                h.r4 = h.r3 + u;
                h.s4 = h.s3 - u;
                break;
              case 3:
                d = (i + s + o) / 3;
                h.p = d;
                h.r1 = d * 2 - s;
                h.s1 = d * 2 - i;
                h.r2 = d + u;
                h.s2 = d - u;
                h.r3 = d + u * 2;
                h.s3 = d - u * 2;
                h.r4 = d + u * 3;
                h.s4 = d - u * 3;
                break;
              case 4:
                let n = NaN;
                n = a.Std.equal(t, o) ? i + s + o * 2 : a.Std.greater(o, t) ? i * 2 + s + o : s * 2 + i + o;
                d = n / 4;
                h.p = d;
                h.r1 = n / 2 - s;
                h.s1 = n / 2 - i;
                break;
              case 5:
                d = (i + s + o) / 3;
                h.p = d;
                h.r1 = o + u * 1.1 / 12;
                h.s1 = o - u * 1.1 / 12;
                h.r2 = o + u * 1.1 / 6;
                h.s2 = o - u * 1.1 / 6;
                h.r3 = o + u * 1.1 / 4;
                h.s3 = o - u * 1.1 / 4;
                h.r4 = o + u * 1.1 / 2;
                h.s4 = o - u * 1.1 / 2;
                break;
              case 6:
                d = (i + s + o) / 3;
                h.p = d;
                h.r1 = d * 2 - s;
                h.s1 = d * 2 - i;
                h.r2 = d + (i - s);
                h.s2 = d - (i - s);
                h.r3 = d - h.s1 + h.r2;
                h.s3 = d * 2 - (i * 2 - s);
                break;
              default:
                throw new Error("Unknown kind");
            }
            h.startIndex__t = n;
            h.endIndex__t = r;
            return h;
          }(u, p, m, g, f, _, d(e, _), this._kindPP);
          e.select_sym(0);
          if (!this._showHistoricalPivots) {
            h.pivots = [];
          }
          h.pivots.push(v);
          if (h.pivots.length > this._historicalPivotsToKeep) {
            h.pivots.shift();
          }
          if (y) {
            return this._createResponse();
          } else {
            return null;
          }
        }
        _createResponse() {
          if (this._data.pivots.length === 0) {
            return null;
          } else {
            return {
              nonseries: true,
              type: "non_series_data",
              data: {
                data: this._data
              }
            };
          }
        }
        _removeUnusedPivots() {
          const e = Math.max(this._data.pivots.findIndex(e => e.startIndex__t > this._firstMainSeriesBarTime) - 1, 0);
          if (e > 0) {
            this._data.pivots.splice(0, e);
          }
        }
      }
    };
  },
  15497: (e, t, i) => {
    "use strict";

    i.d(t, {
      ratioStudyItem: () => n
    });
    var s = i(62473);
    class o extends s.SpreadRatioBase {
      _doCalculation(e, t, i, s) {
        return e * t / (i * s);
      }
    }
    const n = {
      name: "Ratio",
      metainfo: {
        _metainfoVersion: 15,
        defaults: s.spreadRatioDefaults,
        plots: s.spreadRatioPlots,
        styles: s.spreadRatioStyles,
        description: "Ratio",
        shortDescription: "Ratio",
        is_price_study: false,
        inputs: s.spreadRatioInputs,
        id: "Ratio@tv-basicstudies-1",
        format: {
          type: "price",
          precision: 2
        }
      },
      constructor: o
    };
  },
  65498: (e, t, i) => {
    "use strict";

    i.d(t, {
      regressionTrendStudyItem: () => n
    });
    var s = i(73772);
    function o(e, t, i) {
      const o = {
        slope: NaN,
        average: NaN,
        intercept: NaN,
        stdDev: NaN,
        upDev: NaN,
        downDev: NaN,
        pearsons: NaN
      };
      if (e.length !== 0) {
        (function (e, t) {
          let i = 0;
          let s = 0;
          let o = 0;
          let n = 0;
          for (let t = 0; t < e.length; ++t) {
            const r = e[t];
            const a = t + 1;
            i += a;
            s += r;
            o += a * a;
            n += r * a;
          }
          t.slope = (e.length * n - i * s) / (e.length * o - i * i);
          t.average = s / e.length;
          t.intercept = t.average - t.slope * i / e.length + t.slope;
        })(e, o);
        (function (e, t, i, o) {
          let n = 0;
          let r = 0;
          let a = 0;
          let l = 0;
          let c = 0;
          let h = 0;
          let d = o.intercept;
          const u = e.length - 1;
          const _ = o.intercept + o.slope * u / 2;
          for (let s = 0; s <= u; ++s) {
            let u = t[s] - d;
            if (u > n) {
              n = u;
            }
            u = d - i[s];
            if (u > r) {
              r = u;
            }
            u = e[s];
            const p = u - o.average;
            const m = d - _;
            u -= d;
            a += u * u;
            l += p * p;
            c += m * m;
            h += p * m;
            d += o.slope;
          }
          o.stdDev = Math.sqrt(a / (u === 0 ? 1 : u));
          o.pearsons = s.Std.isZero(l) || s.Std.isZero(c) ? 0 : h / Math.sqrt(l * c);
          o.upDev = n;
          o.downDev = r;
        })(e, t, i, o);
      }
      return o;
    }
    const n = {
      name: "Regression Trend",
      metainfo: {
        _metainfoVersion: 51,
        description: "Regression Trend",
        format: {
          type: "inherit"
        },
        id: "RegressionTrend@tv-basicstudies-144",
        is_hidden_study: true,
        is_price_study: true,
        shortDescription: "Reg Trend",
        defaults: {
          inputs: {
            "first bar time": 0,
            "last bar time": 0,
            "lower diviation": -2,
            source: "close",
            "upper diviation": 2,
            "use lower diviation": true,
            "use upper diviation": true
          },
          styles: {}
        },
        inputs: [{
          defval: 2,
          id: "upper diviation",
          max: 500,
          min: -500,
          name: "Upper Deviation",
          type: "float"
        }, {
          defval: -2,
          id: "lower diviation",
          max: 500,
          min: -500,
          name: "Lower Deviation",
          type: "float"
        }, {
          defval: true,
          id: "use upper diviation",
          name: "Use Upper Deviation",
          type: "bool"
        }, {
          defval: true,
          id: "use lower diviation",
          name: "Use Lower Deviation",
          type: "bool"
        }, {
          defval: 0,
          id: "first bar time",
          isHidden: true,
          max: 253370764800,
          min: -253370764800,
          name: "First bar time",
          type: "time"
        }, {
          defval: 0,
          id: "last bar time",
          isHidden: true,
          max: 253370764800,
          min: -253370764800,
          name: "Last bar time",
          type: "time"
        }, {
          defval: "close",
          id: "source",
          name: "Source",
          options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"],
          type: "source"
        }],
        plots: []
      },
      constructor: class {
        constructor() {
          this._resultSent = false;
        }
        init(e, t) {
          this._resultSent = false;
          this._data = {
            baseLine: {
              startPrice: NaN,
              endPrice: NaN
            },
            upLine: {
              startPrice: NaN,
              endPrice: NaN
            },
            downLine: {
              startPrice: NaN,
              endPrice: NaN
            },
            pearsons: NaN,
            startIndex__t: NaN,
            endIndex__t: NaN
          };
        }
        main(e, t) {
          const i = t(6);
          const n = e.new_unlimited_var(s.Std.time(e));
          const r = e.new_unlimited_var(s.Std.high(e));
          const a = e.new_unlimited_var(s.Std.low(e));
          const l = e.new_unlimited_var(s.Std[i](e));
          if (!e.symbol.isLastBar) {
            return null;
          }
          if (this._resultSent) {
            return null;
          }
          const c = t(0);
          const h = t(1);
          const d = t(2);
          const u = t(3);
          const _ = t(4);
          const p = t(5);
          const m = n.indexOf(_);
          const g = n.indexOf(p);
          const f = [];
          const y = [];
          const v = [];
          const S = [];
          for (let e = m; e >= g; --e) {
            f.push(n.get(e));
            y.push(r.get(e));
            v.push(a.get(e));
            S.push(l.get(e));
          }
          this._updateData(f, d, c, u, h, _, p, o(S, y, v));
          this._resultSent = true;
          return {
            type: "non_series_data",
            nonseries: true,
            data: {
              data: this._data
            }
          };
        }
        _updateData(e, t, i, s, o, n, r, a) {
          const l = e.length - 1;
          this._data.baseLine.startPrice = a.intercept;
          this._data.baseLine.endPrice = a.intercept + a.slope * l;
          const c = a.intercept + (t ? a.stdDev * i : a.upDev);
          this._data.upLine.startPrice = c;
          this._data.upLine.endPrice = c + a.slope * l;
          const h = a.intercept + (s ? a.stdDev * o : -a.downDev);
          this._data.downLine.startPrice = h;
          this._data.downLine.endPrice = h + a.slope * l;
          this._data.pearsons = a.pearsons;
          this._data.startIndex__t = n;
          this._data.endIndex__t = r;
        }
      }
    };
  },
  62473: (e, t, i) => {
    "use strict";

    i.d(t, {
      SpreadRatioBase: () => l,
      spreadRatioDefaults: () => c,
      spreadRatioFilledAreas: () => p,
      spreadRatioInputs: () => h,
      spreadRatioPalettes: () => _,
      spreadRatioPlots: () => d,
      spreadRatioStyles: () => u
    });
    var s = i(19625);
    var o = i(94113);
    var n = i(73772);
    var r = i(19063);
    const a = "rgba(0, 0, 0, 0)";
    class l {
      init(e, t) {
        e.new_sym(t(1), n.Std.period(e));
        this._source = t(0);
        this._scaleFactor1 = 1;
        this._scaleFactor2 = 1;
      }
      main(e, t) {
        const i = e.symbol.time;
        const s = n.Std[this._source](e);
        e.select_sym(1);
        const o = n.Std[this._source](e);
        const r = e.new_unlimited_var(o);
        const a = e.new_unlimited_var(e.symbol.time);
        e.select_sym(0);
        if (isNaN(i)) {
          return null;
        }
        let l = a.indexOf(i);
        if (l !== -1 && a.get(l) !== i) {
          l = -1;
        }
        const c = l < 0 ? NaN : r.get(l);
        const h = this._doCalculation(this._scaleFactor1, s, this._scaleFactor2, c);
        return [h, 0, n.Std.ge(h, 0), n.Std.lt(h, 0)];
      }
    }
    const c = {
      styles: {
        plot1: {
          linestyle: 0,
          linewidth: 2,
          plottype: o.LineStudyPlotStyle.Line,
          trackPrice: false,
          transparency: 35,
          color: "#800080",
          display: 15
        },
        plotBaseline: {
          linestyle: 0,
          linewidth: 2,
          plottype: o.LineStudyPlotStyle.Line,
          trackPrice: false,
          transparency: 0,
          color: a,
          display: 0
        }
      },
      palettes: {
        negativePalette: {
          colors: [{
            color: (0, r.applyAlpha)((0, s.getHexColorByName)("color-ripe-red-500"), 0.5),
            style: 0,
            width: 0
          }, {
            color: a,
            style: 0,
            width: 0
          }]
        },
        positivePalette: {
          colors: [{
            color: (0, r.applyAlpha)((0, s.getHexColorByName)("color-minty-green-500"), 0.5),
            style: 0,
            width: 0
          }, {
            color: a,
            style: 0,
            width: 0
          }]
        }
      },
      filledAreasStyle: {
        negativeFill: {
          color: "",
          transparency: 0,
          visible: true,
          fillType: undefined
        },
        positiveFill: {
          color: "",
          transparency: 0,
          visible: true,
          fillType: undefined
        }
      },
      precision: 2,
      inputs: {
        source: "close",
        symbol2: ""
      }
    };
    const h = [{
      defval: "close",
      id: "source",
      name: "Source",
      options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"],
      type: "text"
    }, {
      id: "symbol2",
      name: "Symbol",
      type: "symbol",
      confirm: true
    }];
    const d = [{
      id: "plot1",
      type: "line"
    }, {
      id: "plotBaseline",
      type: "line"
    }, {
      id: "plotNegativeFill",
      type: "colorer",
      target: "negativeFill",
      palette: "negativePalette"
    }, {
      id: "plotPositiveFill",
      type: "colorer",
      target: "positiveFill",
      palette: "positivePalette"
    }];
    const u = {
      plot1: {
        title: "Plot",
        histogramBase: 0
      },
      plotBaseline: {
        title: "Baseline",
        isHidden: true
      }
    };
    const _ = {
      negativePalette: {
        valToIndex: {
          0: 0,
          1: 1
        },
        colors: [{
          name: "Color"
        }]
      },
      positivePalette: {
        valToIndex: {
          0: 0,
          1: 1
        },
        colors: [{
          name: "Color"
        }]
      }
    };
    const p = [{
      id: "negativeFill",
      objAId: "plot1",
      objBId: "plotBaseline",
      type: "plot_plot",
      title: "Negative fill",
      palette: "negativePalette",
      fillToIntersection: true
    }, {
      id: "positiveFill",
      objAId: "plot1",
      objBId: "plotBaseline",
      type: "plot_plot",
      title: "Positive fill",
      palette: "positivePalette",
      fillToIntersection: true
    }];
  },
  68563: (e, t, i) => {
    "use strict";

    i.d(t, {
      spreadStudyItem: () => n
    });
    var s = i(62473);
    class o extends s.SpreadRatioBase {
      _doCalculation(e, t, i, s) {
        return e * t - i * s;
      }
    }
    const n = {
      name: "Spread",
      metainfo: {
        _metainfoVersion: 15,
        defaults: s.spreadRatioDefaults,
        plots: s.spreadRatioPlots,
        styles: s.spreadRatioStyles,
        palettes: s.spreadRatioPalettes,
        filledAreas: s.spreadRatioFilledAreas,
        description: "Spread",
        shortDescription: "Spread",
        is_price_study: false,
        inputs: s.spreadRatioInputs,
        id: "Spread@tv-basicstudies-1",
        format: {
          type: "price",
          precision: 2
        }
      },
      constructor: o
    };
  },
  56209: (e, t, i) => {
    "use strict";

    i.d(t, {
      VbPCheckHaveVolumeExpr: () => o
    });
    var s = i(73772);
    class o {
      constructor(e) {
        this._haveAnyVolume = false;
        this._isDisabled = false;
        this._seriesGetter = e;
      }
      update(e, t) {
        if (this._haveAnyVolume || this._isDisabled) {
          return;
        }
        const i = this._seriesGetter.volume().get(e);
        if (i !== 0 && Number.isFinite(i)) {
          this._haveAnyVolume = true;
        }
        if (t) {
          if (!this._haveAnyVolume) {
            s.Std.error("The data vendor doesn't provide volume data for this symbol.");
          }
          this._isDisabled = true;
        }
      }
    }
  },
  43789: (e, t, i) => {
    "use strict";

    i.d(t, {
      VolumeByPriceExpr: () => g
    });
    var s = i(50151);
    var o = i(9859);
    var n = i(85049);
    var r = i(41978);
    class a extends r.GraphicsObj {
      constructor(e, t, i, o, n, r) {
        super(e);
        (0, s.assert)(t < i);
        this._priceLow = this._mixinJSONObject.createDoubleField(t, "priceLow");
        this._priceHigh = this._mixinJSONObject.createDoubleField(i, "priceHigh");
        this._rate = this._mixinJSONObject.createDoubleArrayField(o, "rate");
        this._firstBarTime = this._mixinJSONObject.createTimeField(n, "firstBarTime");
        this._lastBarTime = this._mixinJSONObject.createTimeField(r, "lastBarTime");
      }
      isNaN() {
        return super.isNaN() || Number.isNaN(this._priceLow.get()) || Number.isNaN(this._priceHigh.get()) || this._rate.get().length === 0;
      }
      jsonName() {
        return "hhists";
      }
      primitiveData() {
        return {
          id: this.id(),
          priceHigh: this._priceHigh.get(),
          priceLow: this._priceLow.get(),
          rate: this._rate.get().slice(),
          firstBarTime: this._firstBarTime.get(),
          lastBarTime: this._lastBarTime.get()
        };
      }
      setPriceLow(e) {
        if (this._priceLow.set(e)) {
          this._processObjUpdate();
        }
      }
      priceLow() {
        return this._priceLow.get();
      }
      priceHigh() {
        return this._priceHigh.get();
      }
      setPriceHigh(e) {
        if (this._priceHigh.set(e)) {
          this._processObjUpdate();
        }
      }
      rate() {
        return this._rate.get().slice();
      }
      setRate(e) {
        if (this._rate.set(e)) {
          this._processObjUpdate();
        }
      }
      rateAt(e) {
        return this._rate.get()[e];
      }
      ratesSum() {
        let e = 0;
        for (const t of this._rate.get()) {
          if (!Number.isNaN(t) && Number.isFinite(t)) {
            e += t;
          }
        }
        return e;
      }
      firstBarTime() {
        return this._firstBarTime.get();
      }
      setFirstBarTime(e) {
        if (this._firstBarTime.set(e)) {
          this._processObjUpdate();
        }
      }
      lastBarTime() {
        return this._lastBarTime.get();
      }
      setLastBarTime(e) {
        if (this._lastBarTime.set(e)) {
          this._processObjUpdate();
        }
      }
    }
    var l;
    var c;
    var h = i(61923);
    var d = i(73772);
    class u {
      constructor(e, t, i) {
        this.index = e;
        this.offset = i;
        this.level = t;
      }
      isNaN() {
        return Number.isNaN(this.level);
      }
      equals(e) {
        return e instanceof u && !this.isNaN() && !e.isNaN() && this.index === e.index && this.offset === e.offset && d.Std.equal(this.level, e.level);
      }
      getLevel() {
        return this.level;
      }
      getIndex() {
        return this.index;
      }
    }
    class _ extends r.GraphicsObj {
      constructor(e, t) {
        super(e);
        this._points = [];
        if (t) {
          this._points = t;
        }
      }
      addPoint(e) {
        this._processObjUpdate();
        this._points.push(e);
      }
      addPoints(e) {
        this._processObjUpdate();
        this._points.push(...e);
      }
      setPoint(e, t) {
        const i = this._points[e];
        if (!t.equals(i)) {
          this._processObjUpdate();
          this._points[e] = t;
        }
      }
      point(e) {
        const t = this._points[e];
        return new u(t.index, t.level, t.offset);
      }
      points() {
        return this._points;
      }
      pointsCount() {
        return this._points.length;
      }
      setPoints(e) {
        if (e.length === this._points.length) {
          let t = true;
          for (let i = 0; i < e.length; ++i) {
            if (!e[i].equals(this._points[i])) {
              t = false;
              break;
            }
          }
          if (t) {
            return;
          }
        }
        this._processObjUpdate();
        this._points = [];
        this._points.push(...e);
      }
      clearPoints() {
        this._processObjUpdate();
        this._points = [];
      }
      isNaN() {
        return super.isNaN() || this._points.length < 3;
      }
      jsonName() {
        return "polygons";
      }
      primitiveData() {
        return {
          id: this.id(),
          points: this._points.map(e => ({
            index: e.index,
            offset: e.offset,
            level: e.level
          }))
        };
      }
    }
    class p extends r.GraphicsObj {
      constructor(e, t, i, s, o = false, n = false) {
        super(e);
        this._endIndex = this._mixinJSONObject.createTimeField(i, "endIndex");
        this._extendLeft = this._mixinJSONObject.createField(o, "extendLeft");
        this._extendRight = this._mixinJSONObject.createField(n, "extendRight");
        this._level = this._mixinJSONObject.createDoubleField(s, "level");
        this._startIndex = this._mixinJSONObject.createTimeField(t, "startIndex");
      }
      isNaN() {
        return super.isNaN() || Number.isNaN(this._level.get()) || this._startIndex.get() < 0 || this._endIndex.get() < 0 || this._startIndex.get() === this._endIndex.get() && !this._extendLeft.get() && !this._extendRight.get();
      }
      jsonName() {
        return "horizlines";
      }
      primitiveData() {
        return {
          id: this.id(),
          startIndex: this._startIndex.get(),
          endIndex: this._endIndex.get(),
          extendLeft: this._extendLeft.get(),
          extendRight: this._extendRight.get(),
          level: this._level.get()
        };
      }
      startIndex() {
        return this._startIndex.get();
      }
      setStartIndex(e) {
        if (this._startIndex.set(e)) {
          this._processObjUpdate();
        }
      }
      endIndex() {
        return this._endIndex.get();
      }
      setEndIndex(e) {
        if (this._endIndex.set(e)) {
          this._processObjUpdate();
        }
      }
      level() {
        return this._level.get();
      }
      setLevel(e) {
        if (this._level.set(e)) {
          this._processObjUpdate();
        }
      }
      isExtendLeft() {
        return this._extendLeft.get();
      }
      setExtendLeft(e) {
        if (this._extendLeft.set(e)) {
          this._processObjUpdate();
        }
      }
      extendLeft() {
        return this.isExtendLeft();
      }
      isExtendRight() {
        return this._extendRight.get();
      }
      setExtendRight(e) {
        if (this._extendRight.set(e)) {
          this._processObjUpdate();
        }
      }
      extendRight() {
        return this.isExtendRight();
      }
    }
    (function (e) {
      e[e.AssertAccuracy = 0.05] = "AssertAccuracy";
    })(l ||= {});
    (function (e) {
      e[e.START = 0] = "START";
      e[e.END = 1] = "END";
    })(c ||= {});
    class m {
      constructor() {
        this._map = new Map();
      }
      get(e) {
        const t = this._innerMap(e.start);
        return t && t.get(e.end);
      }
      set(e, t) {
        this._innerMap(e.start, true).set(e.end, t);
      }
      clear() {
        this._map.clear();
      }
      size() {
        let e = 0;
        this._map.forEach(t => e += t.size);
        return e;
      }
      _innerMap(e, t) {
        let i = this._map.get(e);
        if (i === undefined && t) {
          i = new Map();
          this._map.set(e, i);
        }
        return i;
      }
    }
    class g {
      constructor(e, t, i, o, n, r, a, l, c, d, u, _, p, g, f) {
        this._freezedBoxes = new h.GraphicsList();
        this._freezedHists = new h.GraphicsList();
        this._freezedPocs = new h.GraphicsList();
        this._freezedVAHists = new h.GraphicsList();
        this._currentHistsGr = new h.GraphicsList();
        this._currentVAHistsGr = new h.GraphicsList();
        this._currentHists = [];
        this._currentHistsMap = new m();
        this._currentBox = null;
        this._currentPoc = null;
        this._historyBarSet = [];
        this._prevRtBar = null;
        this._minPrice = Number.POSITIVE_INFINITY;
        this._maxPrice = Number.NEGATIVE_INFINITY;
        this._leftBoxTime = null;
        this._rightBoxTime = null;
        this._actualRightBoxTime = null;
        this._needRecalc = false;
        this._largestHistItem = null;
        this._rowsLayout = null;
        this._currentVAStart = 0;
        this._currentVAEnd = 0;
        this._previousVAStart = 0;
        this._previousVAEnd = 0;
        this._idsGenerator = null;
        (0, s.assert)(e === 1 || e === 2);
        this._numOfSubHists = e;
        this._outHists = o;
        this._outBoxLines = n;
        this._outPocLines = r;
        this._extendPocLeftRight = a;
        this._outVAHists = l;
        this._vaVolumePercent = c;
        this._rowsLayoutSupplier = d;
        this._outHists.addStable(this._freezedHists);
        this._outVAHists.addStable(this._freezedVAHists);
        this._maxHHistItems = u;
        this._layoutIsAutoselected = g;
        this._leftBoxTimeMutable = _;
        this._rightBoxTimeMutable = p;
        this._actualRightBoxTime = f ?? p;
        this._ctx = t;
        this._seriesGetter = i;
      }
      update(e) {
        this._supplyRowsLayout(this._ctx);
        if (this._currentBox === null) {
          this._initCurrentBox();
        }
        if (this._currentPoc === null) {
          this._initCurrentPoc();
        }
        const t = this._timeScale().get(e);
        this._leftBoxTime = this._leftBoxTimeMutable;
        this._rightBoxTime = this._rightBoxTimeMutable;
        if (this._ctx.symbol.isLastBar && !Number.isNaN(this._rightBoxTime)) {
          this._rightBoxTime = Math.min(t + n.Interval.parse(this._ctx.symbol.interval + this._ctx.symbol.resolution).inMilliseconds(t) - 1, this._rightBoxTime);
        }
        const i = d.Std.greaterOrEqual(this._seriesClose().get(e), this._seriesOpen().get(e));
        const s = {
          high: this._seriesHigh().get(e),
          low: this._seriesLow().get(e),
          volume: this._seriesVol().get(e),
          isUp: i,
          time: t
        };
        this._updateCurrentHistogram(s);
        if (this._currentHists.length > 0) {
          this._largestHistItem = this._getLargestHistItem();
          this._updateCurrentPoc();
          this._seriesGetter.developingPoc().set(this._currentPoc.level());
          this._updateValueArea();
          if (this._vaVolumePercent > 0) {
            this._seriesGetter.developingVAHigh().set(this._currentHists[this._currentVAEnd].priceHigh());
            this._seriesGetter.developingVALow().set(this._currentHists[this._currentVAStart].priceLow());
          }
        }
        this._updateCurrentBox();
        this._rebuildOutData();
      }
      setIdsGeneratorProxy(e) {
        this._idsGenerator = e;
      }
      nextGraphicsObjId() {
        return (0, s.ensureNotNull)(this._idsGenerator).nextGraphicsObjId();
      }
      pushEraseObjCmd(e, t) {
        (0, s.ensureNotNull)(this._idsGenerator).pushEraseObjCmd(e, t);
      }
      popEraseCmds() {
        return (0, s.ensureNotNull)(this._idsGenerator).popEraseCmds();
      }
      _timeScale() {
        return this._seriesGetter.time();
      }
      _seriesLow() {
        return this._seriesGetter.low();
      }
      _seriesHigh() {
        return this._seriesGetter.high();
      }
      _seriesVol() {
        return this._seriesGetter.volume();
      }
      _seriesOpen() {
        return this._seriesGetter.open();
      }
      _seriesClose() {
        return this._seriesGetter.close();
      }
      _freezeCurrentHistogramAndCleanup() {
        if (this._currentBox !== null) {
          this._freezedBoxes.add(this._currentBox);
        }
        if (d.Std.greater(this._getVolume(this._currentHists), 0)) {
          this._freezedHists.addAll(this._currentHistsGr);
          this._freezedVAHists.addAll(this._currentVAHistsGr);
          if (this._currentPoc !== null) {
            this._freezedPocs.add(this._currentPoc);
          }
        }
        this._currentHists = [];
        this._currentHistsGr.clear();
        this._currentHistsMap.clear();
        this._initCurrentBox();
        this._initCurrentPoc();
        this._currentVAHistsGr.clear();
        this._historyBarSet = [];
        this._minPrice = Number.POSITIVE_INFINITY;
        this._maxPrice = Number.NEGATIVE_INFINITY;
        this._prevRtBar = null;
        this._leftBoxTime = null;
        this._rightBoxTime = null;
      }
      _supplyRowsLayout(e) {
        if (this._rowsLayout === null && e.symbol.isFirstBar && e.symbol.isNewBar) {
          this._rowsLayout = this._rowsLayoutSupplier();
        }
      }
      _updateCurrentHistogram(e) {
        this._needRecalc = false;
        if (d.Std.greater(this._minPrice, e.low)) {
          this._minPrice = e.low;
          this._needRecalc = true;
        }
        if (d.Std.less(this._maxPrice, e.high)) {
          this._maxPrice = e.high;
          this._needRecalc = true;
        }
        if (this._ctx.symbol.isBarClosed && this._historyBarSet.length > 0) {
          const t = this._historyBarSet[this._historyBarSet.length - 1];
          if (t.time === e.time) {
            this._prevRtBar = t;
            this._historyBarSet.pop();
          }
        }
        if (this._needRecalc && (0, s.ensureNotNull)(this._rowsLayout).type() === 0) {
          this._recalculateCurrentResultsOnHistoryBarSet();
          this._applyUpdateToCurrentResults(e, false);
        } else {
          this._applyUpdateToCurrentResults(e, true);
        }
        if (this._ctx.symbol.isBarClosed) {
          (0, s.assert)(this._prevRtBar === null || e.time === this._prevRtBar.time);
          this._historyBarSet.push(e);
          this._prevRtBar = null;
        } else {
          this._prevRtBar = e;
        }
      }
      _getMidLevel(e) {
        return (e.priceHigh() + e.priceLow()) / 2;
      }
      _getMidLevelFromList(e) {
        if (e.length % 2 == 0) {
          return e[e.length / 2].priceLow();
        } else {
          return this._getMidLevel(e[Math.floor(e.length / 2)]);
        }
      }
      _getLargestHistItem() {
        let e = [];
        let t = this._currentHists[0];
        for (const i of this._currentHists) {
          if (d.Std.greater(i.ratesSum(), t.ratesSum())) {
            t = i;
            e = [t];
          } else if (d.Std.equal(i.ratesSum(), t.ratesSum())) {
            e.push(i);
          }
        }
        if (e.length > 1) {
          const i = this._getMidLevelFromList(this._currentHists);
          t = e[e.length - 1];
          for (let s = e.length - 2; s >= 0; s--) {
            const o = e[s];
            if (d.Std.lessOrEqual(Math.abs(this._getMidLevel(o) - i), Math.abs(this._getMidLevel(t) - i))) {
              t = o;
            }
          }
        }
        return t;
      }
      _initCurrentPoc() {
        this._currentPoc = new p(this, 0, 0, 0);
      }
      _updateCurrentPoc() {
        const e = (0, s.ensureNotNull)(this._currentPoc);
        e.setStartIndex((0, s.ensureNotNull)(this._leftBoxTime));
        e.setEndIndex((0, s.ensureNotNull)(this._actualRightBoxTime));
        e.setExtendLeft(this._extendPocLeftRight);
        e.setExtendRight(this._extendPocLeftRight);
        const t = this._getMidLevel((0, s.ensureNotNull)(this._largestHistItem));
        e.setLevel(t);
      }
      _getVolume(e) {
        let t = 0;
        for (const i of e) {
          t += i.ratesSum();
        }
        return t;
      }
      _getPocHistItemIndex() {
        for (let e = 0; e < this._currentHists.length; e++) {
          if (this._currentHists[e] === this._largestHistItem) {
            return e;
          }
        }
        return -1;
      }
      _calculateValueArea() {
        const e = this._getPocHistItemIndex();
        (0, s.assert)(e >= 0, `ERROR - PocHistItemIndex == ${e}`);
        this._currentVAStart = e - 1;
        this._currentVAEnd = e + 1;
        const t = this._getVolume(this._currentHists) * this._vaVolumePercent * 0.01;
        let i = this._currentHists[e].ratesSum();
        let o = 0;
        let n = null;
        while (d.Std.lessOrEqual(i + o, t) && (i += o, n === 0 ? --this._currentVAStart : n === 1 && ++this._currentVAEnd, this._currentVAStart !== -1 || this._currentVAEnd !== this._currentHists.length)) {
          let t;
          let i;
          if (this._currentVAStart > -1) {
            t = this._currentHists[this._currentVAStart].ratesSum();
            if (this._currentVAEnd < this._currentHists.length) {
              i = this._currentHists[this._currentVAEnd].ratesSum();
              if (d.Std.greater(t, i)) {
                o = t;
                n = 0;
              } else if (d.Std.greater(i, t)) {
                o = i;
                n = 1;
              } else {
                const s = Math.abs(e - this._currentVAStart);
                const r = Math.abs(e - this._currentVAEnd);
                if (s < r) {
                  o = t;
                  n = 0;
                } else if (r <= s) {
                  o = i;
                  n = 1;
                }
              }
            } else {
              o = t;
              n = 0;
            }
          } else {
            o = this._currentHists[this._currentVAEnd].ratesSum();
            n = 1;
          }
        }
        this._currentVAStart++;
        this._currentVAEnd--;
      }
      _isVA(e) {
        return e.priceHigh() > this._getMidLevel(this._currentHists[this._currentVAStart]) && e.priceLow() < this._getMidLevel(this._currentHists[this._currentVAEnd]);
      }
      _updateValueArea() {
        this._calculateValueArea();
        if (this._needRecalc || this._previousVAStart !== this._currentVAStart || this._previousVAEnd !== this._currentVAEnd) {
          let e = 0;
          let t = 0;
          while (e < this._currentHistsGr.size() && t < this._currentVAHistsGr.size()) {
            while (e < this._currentHistsGr.size() && !this._isVA(this._currentHistsGr.get(e))) {
              e++;
            }
            while (t < this._currentVAHistsGr.size() && this._isVA(this._currentVAHistsGr.get(t))) {
              t++;
            }
            if (e < this._currentHistsGr.size() && t < this._currentVAHistsGr.size()) {
              const i = this._currentHistsGr.get(e);
              this._currentHistsGr.set(e, this._currentVAHistsGr.get(t));
              this._currentVAHistsGr.set(t, i);
            }
          }
          for (; e < this._currentHistsGr.size(); e++) {
            const t = this._currentHistsGr.get(e);
            if (this._isVA(t)) {
              this._currentHistsGr.remove(e);
              e--;
              this._currentVAHistsGr.add(t);
            }
          }
          for (; t < this._currentVAHistsGr.size(); t++) {
            const e = this._currentVAHistsGr.get(t);
            if (!this._isVA(e)) {
              this._currentVAHistsGr.remove(t);
              t--;
              this._currentHistsGr.add(e);
            }
          }
        }
        this._previousVAStart = this._currentVAStart;
        this._previousVAEnd = this._currentVAEnd;
      }
      _initCurrentBox() {
        this._currentBox = new _(this);
      }
      _updateCurrentBox() {
        let e = this._minPrice;
        let t = this._maxPrice;
        if (this._currentHists.length > 0) {
          e = this._currentHists[0].priceLow();
          t = this._currentHists[this._currentHists.length - 1].priceHigh();
        }
        const i = [];
        const o = (0, s.ensureNotNull)(this._leftBoxTime);
        const n = (0, s.ensureNotNull)(this._actualRightBoxTime);
        i.push(new u(o, e));
        i.push(new u(o, t));
        i.push(new u(n, t));
        i.push(new u(n, e));
        (0, s.ensureNotNull)(this._currentBox).setPoints(i);
      }
      _recalculateCurrentResultsOnHistoryBarSet() {
        for (let e = 0; e < this._currentHists.length; ++e) {
          this._currentHists[e].erase();
        }
        this._currentHists = [];
        this._currentHistsGr.clear();
        this._currentVAHistsGr.clear();
        this._currentHistsMap.clear();
        for (let e = 0; e < this._historyBarSet.length; e++) {
          this._addHistoryBarToHistogram(this._historyBarSet[e], e, this._currentHists, this._currentHistsMap, 1);
        }
        if (this._currentHists.length > 0) {
          this._largestHistItem = this._getLargestHistItem();
          this._updateCurrentPoc();
        }
        this._updateCurrentBox();
      }
      _applyUpdateToCurrentResults(e, t) {
        if (t && this._prevRtBar !== null) {
          this._addHistoryBarToHistogram(this._prevRtBar, this._historyBarSet.length - 1, this._currentHists, this._currentHistsMap, -1);
        }
        this._addHistoryBarToHistogram(e, this._historyBarSet.length - 1, this._currentHists, this._currentHistsMap, 1);
        this._updateLastBarTimeInHistogram(this._currentHists);
      }
      _addHistoryBarToHistogram(e, t, i, o, n) {
        (0, s.assert)(n === -1 || n === 1, "Please set sign argument either +1 or -1");
        const r = e.low;
        const a = e.high;
        const l = isNaN(e.volume) ? 0 : e.volume;
        const c = e.isUp;
        const h = (0, s.ensureNotNull)(this._rowsLayout);
        h.init(this._ctx.symbol.minTick, this._minPrice, this._maxPrice, r, a);
        const u = h.rowWidth();
        if (!d.Std.greater(u, 0)) {
          return;
        }
        h.calculate();
        const _ = h.getIndexLowVbP();
        const p = h.getIndexHighVbP();
        const m = h.getStartPrice();
        if (_ === p) {
          const e = _ * u + m;
          const t = (_ + 1) * u + m;
          this._updateResult({
            start: e,
            end: t
          }, n * l, c, i, o);
        } else {
          let e = 0;
          for (let t = _; t <= p; t++) {
            const s = t * u + m;
            const h = (t + 1) * u + m;
            const d = this._rowCoeff(s, h, r, a);
            const _ = d * l;
            e += d;
            this._updateResult({
              start: s,
              end: h
            }, n * _, c, i, o);
          }
          (0, s.assert)(d.Std.equal(e, 1, 0.05), `totalCoeff not equal 1! totalConf = ${e}`);
        }
      }
      _updateResult(e, t, i, o, n) {
        const r = this._createRates(i, t);
        (0, s.assert)(this._leftBoxTime !== null, "leftBoxTime is not set (equals null)");
        (0, s.assert)(this._rightBoxTime !== null, "rightBoxTime is not set (equals null)");
        const l = (0, s.ensureNotNull)(this._leftBoxTime);
        const c = (0, s.ensureNotNull)(this._actualRightBoxTime);
        let h = n.get(e);
        if (h === undefined) {
          h = new a(this, e.start, e.end, r, l, c);
          n.set(e, h);
          this._verifyHistogramSizeIsNotTooLarge(n.size());
          this._currentHistsGr.add(h);
          g._addInOrder(h, o, 0, o.length, (e, t) => {
            let i = d.Std.compare(e.firstBarTime(), t.firstBarTime());
            if (i !== 0) {
              return i;
            } else {
              i = d.Std.compare(e.priceLow(), t.priceLow());
              if (i !== 0) {
                return i;
              } else {
                return d.Std.compare(e.priceHigh(), t.priceHigh());
              }
            }
          });
        } else {
          const e = [];
          for (let t = 0; t < r.length; t++) {
            e[t] = h.rateAt(t) + r[t];
          }
          h.setRate(e);
        }
      }
      _rebuildOutData() {
        const e = this._currentHistsMap.size();
        const t = this._currentHists.length;
        const i = this._currentHistsGr.size();
        const o = this._currentVAHistsGr.size();
        (0, s.assert)(e === t && t === i + o, `Collections of HHistItems are out of sync ${e} ${t} ${i} ${o}`);
        this._outPocLines.clear();
        this._outPocLines.addAll(this._freezedPocs);
        if (d.Std.greater(this._getVolume(this._currentHists), 0)) {
          this._outHists.setVariable(this._currentHistsGr);
          this._outPocLines.add((0, s.ensureNotNull)(this._currentPoc));
          this._outVAHists.setVariable(this._currentVAHistsGr);
        } else {
          this._outHists.setVariable(null);
          this._outVAHists.setVariable(null);
        }
        this._outBoxLines.clear();
        this._outBoxLines.addAll(this._freezedBoxes);
        this._outBoxLines.add((0, s.ensureNotNull)(this._currentBox));
      }
      _verifyHistogramSizeIsNotTooLarge(e) {
        if (this._layoutIsAutoselected) {
          return;
        }
        if (e <= this._maxHHistItems) {
          return;
        }
        const t = (0, s.ensureNotNull)(this._rowsLayout);
        if (t.type() === 0) {
          d.Std.error("Histogram is too large, please reduce \"Row Size\" input.");
        } else {
          (0, s.assert)(t.type() === 1, `Unexpected rowsLayout type ${t.type()}`);
          d.Std.error("Histogram is too large, please increase \"Row Size\" input.");
        }
      }
      _createRates(e, t) {
        if (this._numOfSubHists === 1) {
          return [t];
        }
        if (this._numOfSubHists === 2) {
          const i = [0, 0];
          i[e ? 0 : 1] = t;
          return i;
        }
        (0, s.assert)(false, `Incorrect value of numOfSubHists = ${this._numOfSubHists}`);
        return [];
      }
      _updateLastBarTimeInHistogram(e) {
        const t = (0, s.ensureNotNull)(this._actualRightBoxTime);
        for (const i of e) {
          i.setLastBarTime(t);
        }
      }
      _rowCoeff(e, t, i, s) {
        const o = s - i;
        return (t - e - Math.max(t - s, 0) - Math.max(0, i - e)) / o;
      }
      static _addInOrder(e, t, i, s, n) {
        if (i === s) {
          t.splice(i, 0, e);
          return;
        }
        const r = (0, o.toInt)((i + s) / 2);
        const a = t[r];
        if (n(e, a) < 0) {
          g._addInOrder(e, t, i, r, n);
        } else if (n(e, a) > 0) {
          g._addInOrder(e, t, r + 1, s, n);
        } else {
          t.splice(r, 0, e);
        }
      }
    }
  },
  7370: (e, t, i) => {
    "use strict";

    i.d(t, {
      VolumeProfileBase: () => p,
      maxHHistItems: () => u,
      numOfSubHists: () => _
    });
    var s;
    var o = i(56570);
    var n = i(85049);
    (function (e) {
      e[e.NumberOfRows = 0] = "NumberOfRows";
      e[e.TicksPerRow = 1] = "TicksPerRow";
    })(s ||= {});
    class r {
      constructor(e, t) {
        this._minTick = NaN;
        this._minPrice = NaN;
        this._maxPrice = NaN;
        this._low = NaN;
        this._high = NaN;
        this._startPrice = NaN;
        this._indexLowVbP = NaN;
        this._indexHighVbP = NaN;
        this._rowSize = e;
        this._type = t;
      }
      init(e, t, i, s, o) {
        this._minTick = e;
        this._minPrice = t;
        this._maxPrice = i;
        this._low = s;
        this._high = o;
      }
      getStartPrice() {
        return this._startPrice;
      }
      setStartPrice(e) {
        this._startPrice = e;
      }
      getIndexLowVbP() {
        return this._indexLowVbP;
      }
      setIndexLowVbP(e) {
        this._indexLowVbP = e;
      }
      getIndexHighVbP() {
        return this._indexHighVbP;
      }
      setIndexHighVbP(e) {
        this._indexHighVbP = e;
      }
      type() {
        return this._type;
      }
    }
    class a extends r {
      constructor(e) {
        super(e, 0);
      }
      calculate() {
        this.setStartPrice(this._minPrice);
        const e = this.rowWidth();
        let t = Math.floor((this._low - this._minPrice) / e);
        let i = Math.ceil((this._high - this._minPrice) / e) - 1;
        t = Math.max(t, 0);
        i = Math.max(i, 0);
        i = Math.min(i, this._rowSize - 1);
        t = Math.min(t, i);
        this.setIndexLowVbP(t);
        this.setIndexHighVbP(i);
      }
      rowWidth() {
        return Math.max((this._maxPrice - this._minPrice) / this._rowSize, this._minTick);
      }
    }
    class l extends r {
      constructor(e) {
        super(e, 1);
      }
      calculate() {
        this.setStartPrice(0);
        const e = this.rowWidth();
        let t = Math.floor(this._low / e);
        const i = Math.ceil(this._high / e) - 1;
        t = Math.min(t, i);
        this.setIndexLowVbP(t);
        this.setIndexHighVbP(i);
      }
      rowWidth() {
        return this._minTick * this._rowSize;
      }
    }
    var c;
    var h = i(73772);
    var d = i(39692);
    function u() {
      return 6000;
    }
    function _(e) {
      switch (e) {
        case "Delta":
        case "Up/Down":
          return 2;
        case "Total":
          return 1;
        default:
          h.Std.error(`Invalid study argument value: ${e}`);
      }
    }
    (function (e) {
      e.VolumeUpDown = "Up/Down";
      e.VolumeTotal = "Total";
      e.VolumeDelta = "Delta";
      e.NumberOfRows = "Number Of Rows";
      e.TicksPerRow = "Ticks Per Row";
    })(c ||= {});
    class p {
      findBasicResolutionForFromTo(e, t, i, s) {
        const r = (0, d.getVolumeProfileResolutionForPeriod)(e.value(), t, i, s);
        const a = n.Interval.parse(r);
        if (o.enabled("charting_library_debug_mode")) {
          console.log(`${new Date().toISOString()} Selected resolution ${a.value()} for (${e.value()}, ${t}, ${i})`);
        }
        return a;
      }
      verifyRowSizeInput(e, t) {
        if (t === "Number Of Rows" && e > 6000) {
          h.Std.error("Histogram is too large, please reduce \"Row Size\" input.");
        }
      }
      _getRowsLayout(e, t) {
        if (e === "Number Of Rows") {
          return new a(t);
        } else {
          return new l(t);
        }
      }
    }
  },
  92245: (e, t, i) => {
    "use strict";

    i.d(t, {
      volumeProfileFixedRangeBSStudyItem: () => w,
      volumeProfileFixedRangeVbPStudyItem: () => b
    });
    var s = i(50151);
    var o = i(7370);
    var n = i(94113);
    var r = i(9233);
    var a = i(85049);
    var l = i(40878);
    var c = i(45382);
    var h = i(32569);
    var d = i(61923);
    var u = i(62628);
    var _ = i(56209);
    var p = i(85904);
    var m = i(43789);
    class g extends m.VolumeByPriceExpr {
      constructor(e, t, i, s, o, n, r, a, l, c, h, d, u) {
        super(e, t, i, n, r, a, false, l, c, () => h, d, s, o, false, u);
        this._firstBarTime = s;
        this._lastBarTime = o;
      }
      update(e) {
        this._supplyRowsLayout(this._ctx);
        if (this.timeInRequestedRange(e)) {
          super.update(e);
        }
      }
      timeInRequestedRange(e) {
        const t = this._timeScale().get(e);
        return this._firstBarTime <= t && t < this._lastBarTime;
      }
    }
    var f = i(11694);
    var y = i(73772);
    class v extends o.VolumeProfileBase {
      constructor() {
        super(...arguments);
        this._rowsLayout = "Number Of Rows";
        this._rowSize = 24;
        this._volume = "Up/Down";
        this._firstBarTime = 0;
        this._lastBarTime = 0;
        this._vaVolumePercent = 70;
        this._anInt = 0;
        this._eraseCmds = [];
      }
      nextGraphicsObjId() {
        return ++this._anInt;
      }
      pushEraseObjCmd(e, t) {
        this._eraseCmds.push(new h.EraseObj(e, t));
      }
      popEraseCmds() {
        const e = this._eraseCmds;
        this._eraseCmds = [];
        return e;
      }
      init(e, t) {
        this._studyDataUpdate = new u.JStudyDataUpdate(true);
        this._hists = new l.GraphicsListColl();
        this._boxPolygons = new d.GraphicsList();
        this._pocLines = new d.GraphicsList();
        this._valueAreaHists = new l.GraphicsListColl();
        const i = new c.StudyGraphicsData();
        i.getObjsContainer("hhists").push(new c.Container("histBars2", this._hists));
        i.getObjsContainer("hhists").push(new c.Container("histBarsVA", this._valueAreaHists));
        i.getObjsContainer("horizlines").push(new c.Container("pocLines", this._pocLines));
        i.getObjsContainer("polygons").push(new c.Container("histBoxBg", this._boxPolygons));
        this._studyDataUpdate.init(i);
        this._rowsLayout = t(0);
        this._rowSize = t(1);
        this._volume = t(2);
        this._firstBarTime = t(3);
        this._lastBarTime = t(4);
        this._vaVolumePercent = t(5);
        this.verifyRowSizeInput(this._rowSize, this._rowsLayout);
        this._originalResolution = a.Interval.parse(e.symbol.interval + e.symbol.resolution);
        const n = this._lastBarTime + this._originalResolution.inMilliseconds(this._lastBarTime);
        if (this._firstBarTime === 0 && this._lastBarTime === 0) {
          this._basicResolution = this._originalResolution;
        } else {
          this._basicResolution = this.findBasicResolutionForFromTo(this._originalResolution, this._firstBarTime, n, (0, s.ensureDefined)(e.symbol.info));
        }
        this._hasSecondarySymbol = !this._originalResolution.isEqualTo(this._basicResolution);
        if (this._hasSecondarySymbol) {
          e.new_sym(e.symbol.tickerid, this._basicResolution.value());
        }
        const r = this._getRowsLayout(this._rowsLayout, this._rowSize);
        this._vbPCheckHaveVolumeExpr = new _.VbPCheckHaveVolumeExpr(this);
        this._volumeByPriceExpr = new g((0, o.numOfSubHists)(this._volume), e, this, this._firstBarTime, n, this._hists, this._boxPolygons, this._pocLines, this._valueAreaHists, this._vaVolumePercent, r, (0, o.maxHHistItems)(), this._lastBarTime);
        this._volumeByPriceExpr.setIdsGeneratorProxy(this);
        this._developingPocSeries = new f.VolumeProfileOutputSeries();
        this._developingVAHighSeries = new f.VolumeProfileOutputSeries();
        this._developingVALowSeries = new f.VolumeProfileOutputSeries();
      }
      main(e, t, i) {
        if (this._hasSecondarySymbol) {
          e.select_sym(1);
        }
        this._timeSeries = e.new_unlimited_var();
        this._openSeries = e.new_unlimited_var();
        this._highSeries = e.new_unlimited_var();
        this._lowSeries = e.new_unlimited_var();
        this._closeSeries = e.new_unlimited_var();
        this._volumeSeries = e.new_unlimited_var();
        const o = {
          type: "composite",
          data: []
        };
        if (i && i.period === this._basicResolution.value() && (this._timeSeries.set(y.Std.time(e)), this._openSeries.set(y.Std.open(e)), this._highSeries.set(y.Std.high(e)), this._lowSeries.set(y.Std.low(e)), this._closeSeries.set(y.Std.close(e)), this._volumeSeries.set(y.Std.volume(e)), this._developingPocSeries.addHist(y.Std.time(e)), this._developingVAHighSeries.addHist(y.Std.time(e)), this._developingVALowSeries.addHist(y.Std.time(e)), this._vbPCheckHaveVolumeExpr.update(0, e.symbol.isLastBar), this._volumeByPriceExpr.update(0), this._developingPocSeries.removeLastIfNaN(), this._developingVAHighSeries.removeLastIfNaN(), this._developingVALowSeries.removeLastIfNaN(), e.symbol.isLastBar)) {
          this._studyDataUpdate.setEraseCmds(this.popEraseCmds());
          this._studyDataUpdate.update();
          const e = this._studyDataUpdate.getUpdate();
          if (e.json) {
            o.data.push({
              nonseries: true,
              type: "study_graphics",
              data: e.json
            });
          }
          if (e.jsonUpdate) {
            o.data.push({
              nonseries: true,
              type: "study_graphics",
              data: e.jsonUpdate
            });
          }
        }
        if (this._hasSecondarySymbol) {
          e.select_sym(0);
        }
        if (i && i.period === this._originalResolution.value()) {
          (0, s.assert)(e.symbol.time === i.time);
          const t = i.time;
          const n = t + this._originalResolution.inMilliseconds(t) - 1;
          if (t && t >= this._firstBarTime) {
            const e = this._developingPocSeries.getLeftOrEqual(n);
            const t = this._developingVAHighSeries.getLeftOrEqual(n);
            const i = this._developingVALowSeries.getLeftOrEqual(n);
            o.data.push([e, t, i]);
          } else {
            o.data.push([NaN, NaN, NaN]);
          }
        }
        return o;
      }
      time() {
        return this._timeSeries;
      }
      open() {
        return this._openSeries;
      }
      high() {
        return this._highSeries;
      }
      low() {
        return this._lowSeries;
      }
      close() {
        return this._closeSeries;
      }
      volume() {
        return this._volumeSeries;
      }
      developingPoc() {
        return this._developingPocSeries;
      }
      developingVAHigh() {
        return this._developingVAHighSeries;
      }
      developingVALow() {
        return this._developingVALowSeries;
      }
    }
    function S(e) {
      return {
        constructor: v,
        name: e.description,
        metainfo: {
          _metainfoVersion: 51,
          shortDescription: "VPFR",
          format: {
            type: "volume"
          },
          is_price_study: true,
          defaults: {
            graphics: {
              hhists: {
                histBars2: {
                  colors: ["", ""],
                  direction: r.HHistDirection.LeftToRight,
                  percentWidth: 30,
                  showValues: false,
                  transparencies: [76, 76],
                  valuesColor: "#424242",
                  visible: true
                },
                histBarsVA: {
                  colors: ["#1592e6", "#fbc123"],
                  direction: r.HHistDirection.LeftToRight,
                  percentWidth: 30,
                  showValues: false,
                  transparencies: [30, 30],
                  valuesColor: "",
                  visible: true
                }
              },
              horizlines: {
                pocLines: {
                  color: "",
                  style: p.LineStyle.Solid,
                  visible: true,
                  width: 2
                }
              },
              polygons: {
                histBoxBg: {
                  color: "",
                  transparency: 94
                }
              }
            },
            inputs: {
              first_bar_time: 0,
              last_bar_time: 0,
              rows: 24,
              rowsLayout: "Number Of Rows",
              subscribeRealtime: true,
              vaVolume: 70,
              volume: "Up/Down"
            },
            styles: {
              developingPoc: {
                color: "",
                linestyle: p.LineStyle.Solid,
                linewidth: 1,
                plottype: n.LineStudyPlotStyle.StepLine,
                trackPrice: false,
                transparency: 0,
                display: 0
              },
              developingVAHigh: {
                color: "",
                linestyle: p.LineStyle.Solid,
                linewidth: 1,
                plottype: n.LineStudyPlotStyle.StepLine,
                trackPrice: false,
                transparency: 0,
                display: 0
              },
              developingVALow: {
                color: "",
                linestyle: p.LineStyle.Solid,
                linewidth: 1,
                plottype: n.LineStudyPlotStyle.StepLine,
                trackPrice: false,
                transparency: 0,
                display: 0
              }
            }
          },
          graphics: {
            hhists: {
              histBars2: {
                location: r.HHistLocation.Absolute,
                title: "Volume Profile",
                titles: ["Up Volume", "Down Volume"]
              },
              histBarsVA: {
                location: r.HHistLocation.Absolute,
                title: "Value Area",
                titles: ["Value Area Up", "Value Area Down"]
              }
            },
            horizlines: {
              pocLines: {
                name: "POC",
                showPrice: true
              }
            },
            polygons: {
              histBoxBg: {
                mouseTouchable: false,
                name: "Histogram Box",
                showBorder: false
              }
            }
          },
          inputs: [{
            defval: "Number Of Rows",
            id: "rowsLayout",
            name: "Rows Layout",
            options: ["Number Of Rows", "Ticks Per Row"],
            type: "text"
          }, {
            defval: 24,
            id: "rows",
            max: 1000000,
            min: 1,
            name: "Row Size",
            type: "integer"
          }, {
            defval: "Up/Down",
            id: "volume",
            name: "Volume",
            options: ["Up/Down", "Total", "Delta"],
            type: "text"
          }, {
            defval: 0,
            id: "first_bar_time",
            isHidden: true,
            max: 253370764800,
            min: -253370764800,
            name: "First Bar Time",
            type: "time"
          }, {
            defval: 0,
            id: "last_bar_time",
            isHidden: true,
            max: 253370764800,
            min: -253370764800,
            name: "Last Bar Time",
            type: "time"
          }, {
            defval: 70,
            id: "vaVolume",
            max: 100,
            min: 0,
            name: "Value Area Volume",
            type: "integer"
          }, {
            defval: true,
            id: "subscribeRealtime",
            isHidden: true,
            name: "SubscribeRealtime",
            type: "bool"
          }],
          plots: [{
            id: "developingPoc",
            type: "line"
          }, {
            id: "developingVAHigh",
            type: "line"
          }, {
            id: "developingVALow",
            type: "line"
          }],
          styles: {
            developingPoc: {
              histogramBase: 0,
              title: "Developing Poc"
            },
            developingVAHigh: {
              histogramBase: 0,
              title: "Developing VA High"
            },
            developingVALow: {
              histogramBase: 0,
              title: "Developing VA Low"
            }
          },
          ...e
        }
      };
    }
    const b = S({
      id: "VbPFixed@tv-volumebyprice-57",
      description: "Volume Profile Fixed Range"
    });
    const w = S({
      id: "VbPFixed@tv-basicstudies-152",
      description: "Fixed Range",
      is_hidden_study: true
    });
  },
  11694: (e, t, i) => {
    "use strict";

    i.d(t, {
      VolumeProfileOutputSeries: () => n
    });
    var s = i(50151);
    var o = i(29981);
    class n {
      constructor() {
        this._histPos = -1;
        this._hist = new Float64Array(2000);
        this._times = new Float64Array(2000);
      }
      addHist(e) {
        if (this._histPos >= 0) {
          const t = this._times[this._histPos];
          (0, s.assert)(t <= e, "History order violation");
          this._histPos += t === e ? 0 : 1;
        } else {
          this._histPos += 1;
        }
        if (this._histPos === this._hist.length) {
          const e = new Float64Array(this._hist.length * 2);
          e.set(this._hist);
          this._hist = e;
          const t = new Float64Array(this._hist.length);
          t.set(this._times);
          this._times = t;
        }
        this._hist[this._histPos] = NaN;
        this._times[this._histPos] = e;
      }
      removeLastIfNaN() {
        if (Number.isNaN(this.get(0))) {
          this._histPos -= 1;
        }
      }
      get(e) {
        (0, s.assert)(e === 0);
        const t = this._histPos - e;
        return this._hist[t];
      }
      getLeftOrEqual(e) {
        const t = (0, o.upperbound)(this._times, e, (e, t) => e < t, 0, this._histPos + 1);
        if (t === 0) {
          return NaN;
        } else {
          return this._hist[t - 1];
        }
      }
      set(e) {
        this._hist[this._histPos] = e;
      }
      indexOf(e) {
        throw new Error("Not implemented");
      }
      adopt(e, t, i) {
        throw new Error("Method not implemented.");
      }
    }
  },
  24018: (e, t, i) => {
    "use strict";

    i.d(t, {
      volumeProfileVisibleRangeStudyItem: () => y
    });
    var s = i(50151);
    var o = i(7370);
    var n = i(9233);
    var r = i(85049);
    var a = i(40878);
    var l = i(43789);
    var c = i(61923);
    class h extends l.VolumeByPriceExpr {
      constructor(e, t, i, s, o, n, r, a, l, h, d) {
        super(e, t, i, n, new c.GraphicsList(), r, true, a, l, () => h, d, s, o, false);
        this._firstBarTime = s;
        this._lastBarTime = o;
      }
      update(e) {
        this._supplyRowsLayout(this._ctx);
        if (this.timeInRequestedRange(e)) {
          super.update(e);
        }
      }
      timeInRequestedRange(e) {
        const t = this._timeScale().get(e);
        return this._firstBarTime <= t && t < this._lastBarTime;
      }
    }
    var d = i(45382);
    var u = i(32569);
    var _ = i(62628);
    var p = i(56209);
    var m = i(11694);
    var g = i(73772);
    class f extends o.VolumeProfileBase {
      constructor() {
        super(...arguments);
        this._rowsLayout = "Number Of Rows";
        this._rowSize = 24;
        this._volume = "Up/Down";
        this._firstBarTime = 0;
        this._lastBarTime = 0;
        this._vaVolumePercent = 70;
        this._anInt = 0;
        this._eraseCmds = [];
      }
      nextGraphicsObjId() {
        return ++this._anInt;
      }
      pushEraseObjCmd(e, t) {
        this._eraseCmds.push(new u.EraseObj(e, t));
      }
      popEraseCmds() {
        const e = this._eraseCmds;
        this._eraseCmds = [];
        return e;
      }
      init(e, t) {
        this._studyDataUpdate = new _.JStudyDataUpdate(true);
        this._hists = new a.GraphicsListColl();
        this._pocLines = new c.GraphicsList();
        this._valueAreaHists = new a.GraphicsListColl();
        const i = new d.StudyGraphicsData();
        i.getObjsContainer("hhists").push(new d.Container("histBars2", this._hists));
        i.getObjsContainer("hhists").push(new d.Container("histBarsVA", this._valueAreaHists));
        i.getObjsContainer("horizlines").push(new d.Container("pocLines", this._pocLines));
        this._studyDataUpdate.init(i);
        this._rowsLayout = t(0);
        this._rowSize = t(1);
        this._volume = t(2);
        this._firstBarTime = t(3);
        this._lastBarTime = t(4);
        this._vaVolumePercent = t(5);
        this.verifyRowSizeInput(this._rowSize, this._rowsLayout);
        this._originalResolution = r.Interval.parse(e.symbol.interval + e.symbol.resolution);
        const n = this._lastBarTime + this._originalResolution.inMilliseconds(this._lastBarTime);
        if (this._firstBarTime === 0 && this._lastBarTime === 0) {
          this._basicResolution = this._originalResolution;
        } else {
          this._basicResolution = this.findBasicResolutionForFromTo(this._originalResolution, this._firstBarTime, n, (0, s.ensureDefined)(e.symbol.info));
        }
        this._hasSecondarySymbol = !this._originalResolution.isEqualTo(this._basicResolution);
        if (this._hasSecondarySymbol) {
          e.new_sym(e.symbol.tickerid, this._basicResolution.value());
        }
        const l = this._getRowsLayout(this._rowsLayout, this._rowSize);
        this._vbPCheckHaveVolumeExpr = new p.VbPCheckHaveVolumeExpr(this);
        this._volumeByPriceExpr = new h((0, o.numOfSubHists)(this._volume), e, this, this._firstBarTime, n, this._hists, this._pocLines, this._valueAreaHists, this._vaVolumePercent, l, (0, o.maxHHistItems)());
        this._volumeByPriceExpr.setIdsGeneratorProxy(this);
        this._developingPocSeries = new m.VolumeProfileOutputSeries();
        this._developingVAHighSeries = new m.VolumeProfileOutputSeries();
        this._developingVALowSeries = new m.VolumeProfileOutputSeries();
      }
      main(e, t, i) {
        if (this._hasSecondarySymbol) {
          e.select_sym(1);
        }
        this._timeSeries = e.new_unlimited_var();
        this._openSeries = e.new_unlimited_var();
        this._highSeries = e.new_unlimited_var();
        this._lowSeries = e.new_unlimited_var();
        this._closeSeries = e.new_unlimited_var();
        this._volumeSeries = e.new_unlimited_var();
        const o = {
          type: "composite",
          data: []
        };
        if (i && i.period === this._basicResolution.value() && (this._timeSeries.set(g.Std.time(e)), this._openSeries.set(g.Std.open(e)), this._highSeries.set(g.Std.high(e)), this._lowSeries.set(g.Std.low(e)), this._closeSeries.set(g.Std.close(e)), this._volumeSeries.set(g.Std.volume(e)), e.symbol.isFirstBar && e.symbol.isLastBar || (this._developingPocSeries.addHist(g.Std.time(e)), this._developingVAHighSeries.addHist(g.Std.time(e)), this._developingVALowSeries.addHist(g.Std.time(e))), this._vbPCheckHaveVolumeExpr.update(0, e.symbol.isLastBar), this._volumeByPriceExpr.update(0), this._developingPocSeries.removeLastIfNaN(), this._developingVAHighSeries.removeLastIfNaN(), this._developingVALowSeries.removeLastIfNaN(), e.symbol.isLastBar)) {
          this._studyDataUpdate.setEraseCmds(this.popEraseCmds());
          this._studyDataUpdate.update();
          const e = this._studyDataUpdate.getUpdate();
          if (e.json) {
            o.data.push({
              nonseries: true,
              type: "study_graphics",
              data: e.json
            });
          }
          if (e.jsonUpdate) {
            o.data.push({
              nonseries: true,
              type: "study_graphics",
              data: e.jsonUpdate
            });
          }
        }
        if (this._hasSecondarySymbol) {
          e.select_sym(0);
        }
        if (i && i.period === this._originalResolution.value()) {
          (0, s.assert)(e.symbol.time === i.time);
          const t = i.time;
          const n = t + this._originalResolution.inMilliseconds(t) - 1;
          if (t && t >= this._firstBarTime) {
            const e = this._developingPocSeries.getLeftOrEqual(n);
            const t = this._developingVAHighSeries.getLeftOrEqual(n);
            const i = this._developingVALowSeries.getLeftOrEqual(n);
            o.data.push([e, t, i]);
          } else {
            o.data.push([NaN, NaN, NaN]);
          }
        }
        return o;
      }
      time() {
        return this._timeSeries;
      }
      open() {
        return this._openSeries;
      }
      high() {
        return this._highSeries;
      }
      low() {
        return this._lowSeries;
      }
      close() {
        return this._closeSeries;
      }
      volume() {
        return this._volumeSeries;
      }
      developingPoc() {
        return this._developingPocSeries;
      }
      developingVAHigh() {
        return this._developingVAHighSeries;
      }
      developingVALow() {
        return this._developingVALowSeries;
      }
    }
    const y = {
      constructor: f,
      name: "Volume Profile Visible Range",
      metainfo: {
        _metainfoVersion: 51,
        id: "VbPVisible@tv-basicstudies-49",
        description: "Volume Profile Visible Range",
        shortDescription: "VPVR",
        format: {
          type: "volume"
        },
        is_price_study: true,
        linkedToSeries: true,
        palettes: {},
        inputs: [{
          id: "rowsLayout",
          name: "Rows Layout",
          defval: "Number Of Rows",
          options: ["Number Of Rows", "Ticks Per Row"],
          type: "text"
        }, {
          id: "rows",
          name: "Row Size",
          defval: 24,
          max: 1000000,
          min: 1,
          type: "integer"
        }, {
          id: "volume",
          name: "Volume",
          defval: "Up/Down",
          options: ["Up/Down", "Total", "Delta"],
          type: "text"
        }, {
          id: "first_visible_bar_time",
          name: "First Visible Bar Time",
          defval: 0,
          isHidden: true,
          max: 253370764800,
          min: -253370764800,
          type: "time"
        }, {
          id: "last_visible_bar_time",
          name: "Last Visible Bar Time",
          defval: 0,
          isHidden: true,
          max: 253370764800,
          min: -253370764800,
          type: "time"
        }, {
          id: "vaVolume",
          name: "Value Area Volume",
          defval: 70,
          max: 100,
          min: 0,
          type: "integer"
        }],
        plots: [{
          id: "developingPoc",
          type: "line"
        }, {
          id: "developingVAHigh",
          type: "line"
        }, {
          id: "developingVALow",
          type: "line"
        }],
        graphics: {
          hhists: {
            histBars2: {
              location: n.HHistLocation.Relative,
              title: "Volume Profile",
              titles: ["Up Volume", "Down Volume"]
            },
            histBarsVA: {
              location: n.HHistLocation.Relative,
              title: "Value Area",
              titles: ["Value Area Up", "Value Area Down"]
            }
          },
          horizlines: {
            pocLines: {
              name: "POC",
              showPrice: true
            }
          }
        },
        defaults: {
          graphics: {
            hhists: {
              histBars2: {
                colors: ["", ""],
                direction: n.HHistDirection.RightToLeft,
                percentWidth: 30,
                showValues: false,
                transparencies: [76, 76],
                valuesColor: "",
                visible: true
              },
              histBarsVA: {
                colors: ["", ""],
                direction: n.HHistDirection.RightToLeft,
                percentWidth: 30,
                showValues: false,
                transparencies: [30, 30],
                valuesColor: "",
                visible: true
              }
            },
            horizlines: {
              pocLines: {
                color: "",
                style: 0,
                visible: true,
                width: 2
              },
              vahLines: {
                color: "",
                style: 0,
                visible: false,
                width: 2
              },
              valLines: {
                color: "",
                style: 0,
                visible: false,
                width: 2
              }
            }
          },
          inputs: {
            first_visible_bar_time: 0,
            last_visible_bar_time: 0,
            rows: 24,
            rowsLayout: "Number Of Rows",
            vaVolume: 70,
            volume: "Up/Down"
          },
          styles: {
            developingPoc: {
              color: "",
              linestyle: 0,
              linewidth: 1,
              plottype: 9,
              trackPrice: false,
              transparency: 0,
              display: 0
            },
            developingVAHigh: {
              color: "",
              linestyle: 0,
              linewidth: 1,
              plottype: 9,
              trackPrice: false,
              transparency: 0,
              display: 0
            },
            developingVALow: {
              color: "",
              linestyle: 0,
              linewidth: 1,
              plottype: 9,
              trackPrice: false,
              transparency: 0,
              display: 0
            }
          }
        },
        styles: {
          developingPoc: {
            histogramBase: 0,
            title: "Developing Poc"
          },
          developingVAHigh: {
            histogramBase: 0,
            title: "Developing VA High"
          },
          developingVALow: {
            histogramBase: 0,
            title: "Developing VA Low"
          }
        }
      }
    };
  },
  1452: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyError: () => s
    });
    class s extends Error {
      constructor(e) {
        super(e);
        this.studyError = true;
      }
    }
  },
  32569: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      EraseAll: () => n,
      EraseObj: () => o,
      GraphicsCmds: () => r
    });
    (function (e) {
      e.One = "one";
      e.All = "all";
    })(s ||= {});
    class o {
      constructor(e, t) {
        this.id = e;
        this.type = t;
      }
      primitiveData() {
        return {
          action: "one",
          id: this.id,
          type: this.type
        };
      }
    }
    class n {
      primitiveData() {
        return {
          action: "all"
        };
      }
    }
    class r {
      constructor() {
        this.erase = [];
        this.create = null;
        this._modified = false;
      }
      primitiveData(e) {
        if (this.isNaN()) {
          return null;
        }
        const t = {};
        const i = this.create && this.create.primitiveData(e);
        if (i !== null) {
          t.create = i;
        }
        if (this.erase !== null && this.erase.length > 0) {
          t.erase = this.erase.map(e => e.primitiveData());
        }
        if (t.create === undefined && t.erase === undefined) {
          return null;
        } else {
          return t;
        }
      }
      setCreate(e) {
        this.create = e;
        this.create.forEachList(e => e.setOwner(this));
      }
      isNaN() {
        return (this.erase === null || this.erase.length === 0) && this.create === null;
      }
      isModified() {
        return this._modified;
      }
      setModified(e) {
        this._modified = e;
      }
      dirty() {
        this._modified = true;
      }
      setOwner(e) {
        throw new Error("Unsupported");
      }
    }
  },
  40878: (e, t, i) => {
    "use strict";

    i.d(t, {
      GraphicsListColl: () => s
    });
    class s {
      constructor() {
        this._stable = [];
        this._variable = null;
        this._owner = null;
      }
      addStable(e) {
        e.setOwner(this);
        this._stable.push(e);
      }
      setVariable(e) {
        this._variable = e;
        if (this._variable !== null) {
          this._variable.setOwner(this);
        }
      }
      primitivesData(e) {
        const t = [];
        this._forEach(i => t.push(...i.primitivesData(e)));
        return t;
      }
      deleteErasedItems() {
        this._forEach(e => e.deleteErasedItems());
      }
      markPostedItems() {
        this._forEach(e => e.markPostedItems());
      }
      isNaN() {
        return this._all(e => e.isNaN());
      }
      dirty() {
        if (this._owner !== null) {
          this._owner.dirty();
        }
      }
      setOwner(e) {
        this._owner = e;
      }
      _forEach(e) {
        for (const t of this._stable) {
          e(t);
        }
        if (this._variable !== null) {
          e(this._variable);
        }
      }
      _all(e) {
        for (const t of this._stable) {
          if (!e(t)) {
            return false;
          }
        }
        return this._variable === null || e(this._variable);
      }
    }
  },
  61923: (e, t, i) => {
    "use strict";

    i.d(t, {
      GraphicsList: () => n
    });
    var s = i(41978);
    var o = i(67908);
    class n {
      constructor() {
        this._items = [];
        this._owner = null;
      }
      primitivesData(e) {
        const t = [];
        for (const i of this._items) {
          if (!e.isIgnoredObj(i)) {
            t.push(i.primitiveData());
          }
        }
        return t;
      }
      get(e) {
        return this._items[e];
      }
      set(e, t) {
        this.dirty();
        t.setOwner(this);
        this._items[e] = t;
        return t;
      }
      addAtIndex(e, t) {
        this.dirty();
        t.setOwner(this);
        this._items[e] = t;
      }
      clear() {
        this._unsetOwner(this._items);
        this._items = [];
        this.dirty();
      }
      addAllFromNumber(e, t) {
        this.setOwner(t);
        this._items.splice(e, 0, ...t._items);
        const i = true;
        this._setCachedDataValid(false);
        return i;
      }
      addAll(e) {
        this.setOwner(e);
        this._items.push(...e._items);
        const t = true;
        this._setCachedDataValid(false);
        return t;
      }
      remove(e) {
        const t = this._items[e];
        this._items.splice(e, 1);
        t.unsetOwner(this);
        this.dirty();
        return t;
      }
      getItems() {
        return this._items;
      }
      size() {
        return this._items.length;
      }
      add(e) {
        e.setOwner(this);
        this._items.push(e);
        const t = true;
        this._setCachedDataValid(false);
        return t;
      }
      deleteErasedItems() {
        this._items = this._items.filter(e => !e.isErased());
      }
      markPostedItems() {
        for (const e of this._items) {
          e.markAsPosted();
        }
      }
      isNaN() {
        if (this._items.length === 0) {
          return true;
        }
        for (const e of this._items) {
          if (!(0, o.isNaNable)(e)) {
            return false;
          }
          if (!e.isNaN()) {
            return false;
          }
        }
        return true;
      }
      setOwner(e) {
        this._owner = e;
      }
      dirty() {
        if (this._owner !== null) {
          this._owner.dirty();
        }
      }
      _unsetOwner(e) {
        for (const t of e) {
          if (t instanceof s.GraphicsObj) {
            t.unsetOwner(this);
          }
        }
      }
      _setCachedDataValid(e) {
        if (!e) {
          this.dirty();
        }
      }
    }
  },
  41978: (e, t, i) => {
    "use strict";

    i.d(t, {
      GraphicsObj: () => l
    });
    var s = i(73772);
    class o {
      constructor(e, t, i, s) {
        this._value = e;
        this._name = t;
        this._owner = i;
        this._comparer = s !== undefined ? s : (e, t) => e == null ? t != null : e === t;
      }
      getName() {
        return this._name;
      }
      set(e) {
        const t = this._comparer(this._value, e);
        if (t) {
          this._owner.dirty();
        }
        this._value = e;
        return t;
      }
      get() {
        return this._value;
      }
    }
    class n {
      constructor(e, t, i) {
        this._owner = null;
        this._value = e;
        this._name = t;
        this._owner = i;
      }
      getName() {
        return this._name;
      }
      set(e) {
        return this._value !== e && (this._value = e, this._owner !== null && this._owner.dirty(), true);
      }
      get() {
        return this._value;
      }
    }
    class r extends o {
      constructor(e, t, i, s) {
        super(e, t, i, s);
      }
    }
    class a {
      constructor(e) {
        this._owner = e;
      }
      createField(e, t) {
        return new o(e, t, this);
      }
      createDoubleField(e, t) {
        return new o(e, t, this, (e, t) => !s.Std.equal(e, t));
      }
      createDoubleArrayField(e, t) {
        return new r(e, t, this, (e, t) => {
          if (e === t) {
            return false;
          }
          const i = e.length;
          if (t.length !== i) {
            return true;
          }
          for (let o = 0; o < i; o++) {
            const i = e[o];
            const n = t[o];
            if (!s.Std.equal(i, n)) {
              return true;
            }
          }
          return false;
        });
      }
      createTimeField(e, t) {
        return new n(e, t, this);
      }
      dirty() {
        if (this._owner !== null) {
          this._owner.dirty();
        }
      }
      setOwner(e) {
        this._owner = e;
      }
    }
    class l {
      constructor(e) {
        this._mixinJSONObject = new a(this);
        this._state = 0;
        this._owner = null;
        this._gen = e;
        this._id = e.nextGraphicsObjId();
        this._id2 = this._mixinJSONObject.createField(this.id(), "id");
      }
      dirty() {
        if (this._owner !== null) {
          this._owner.dirty();
        }
      }
      setOwner(e) {
        this._owner = e;
      }
      id() {
        return this._id;
      }
      unsetOwner(e) {
        if (this._owner === e) {
          this._owner = null;
        }
      }
      state() {
        return this._state;
      }
      erase() {
        if (this._state === 1) {
          this._gen.pushEraseObjCmd(this._id, this.jsonName());
        }
        this._state = 2;
        this.dirty();
      }
      markAsPosted() {
        if (this._state !== 1) {
          this._state = 1;
          this.dirty();
        }
      }
      isErased() {
        return this._state === 2;
      }
      isPosted() {
        return this._state === 1;
      }
      isNaN() {
        return false;
      }
      _processObjUpdate() {
        if (this._state === 1) {
          this._gen.pushEraseObjCmd(this._id, this.jsonName());
          this._id = this._gen.nextGraphicsObjId();
          this._id2.set(this._id);
          this._state = 0;
        }
        this.dirty();
      }
    }
  },
  67908: (e, t, i) => {
    "use strict";

    function s(e) {
      return Boolean(e.isNaN);
    }
    i.d(t, {
      isNaNable: () => s
    });
  },
  62628: (e, t, i) => {
    "use strict";

    i.d(t, {
      JStudyDataUpdate: () => p
    });
    var s = i(32569);
    class o {
      constructor() {
        this.isUpdate = false;
        this.graphicsCmds = new s.GraphicsCmds();
        this._offsetsChanged = false;
        this._disableGraphicsAndData = false;
      }
      isNaN() {
        return this.graphicsCmds.isNaN();
      }
      primitiveData(e) {
        const t = {};
        if (!this._disableGraphicsAndData) {
          const i = this.graphicsCmds.primitiveData(e);
          if (i !== null) {
            t.graphicsCmds = i;
          }
        }
        if (this.isUpdate) {
          t.isUpdate = true;
        }
        if (t.graphicsCmds === undefined) {
          return undefined;
        } else {
          return t;
        }
      }
      disable() {
        this._disableGraphicsAndData = true;
      }
      checkForChangeAndResetChangedState(e) {
        const t = this._offsetsChanged;
        const i = this.graphicsCmds.isModified();
        this.graphicsCmds.setModified(false);
        this._offsetsChanged = false;
        return i || t || e.length !== 0;
      }
    }
    class n {
      constructor(e) {
        this._dataObj = new o();
        this._isDirty = false;
        this._eraseCmds = [];
        this._enableCmdDataStudy = e;
      }
      init(e) {
        this._dataObj.graphicsCmds.setCreate(e);
        this.update(true);
      }
      dataObj() {
        return this._dataObj;
      }
      setEraseCmds(e) {
        this._eraseCmds = e;
      }
      resetDirtyState() {
        this._isDirty = false;
      }
      disable() {
        this._dataObj.disable();
      }
    }
    var r;
    var a = i(37265);
    var l = i(67908);
    function c(e) {
      return Boolean(e.isPosted);
    }
    (function (e) {
      e[e.New = 0] = "New";
      e[e.Posted = 1] = "Posted";
      e[e.Erased = 2] = "Erased";
    })(r ||= {});
    class h {
      isIgnoredObj(e, t) {
        return h.isIgnoredObjDefault(e, t);
      }
      static isIgnoredObjDefault(e, t) {
        if (t === undefined) {
          return h.isIgnoredObjNaNable(e);
        }
        const i = e[t];
        return h.isIgnoredByGeneralRules(e, t) || h.isIgnoredObjNaNable(i) || h.isIgnoredObjListOfNaNables(i);
      }
      static isIgnoredObjNaNable(e) {
        return (0, l.isNaNable)(e) && e.isNaN();
      }
      static isIgnoredObjListOfNaNables(e) {
        if (!(0, a.isArray)(e)) {
          return false;
        }
        let t = true;
        for (const i of e) {
          if (!(0, l.isNaNable)(i) || !i.isNaN()) {
            t = false;
            break;
          }
        }
        return t;
      }
      static isIgnoredObjPosted(e) {
        return c(e) && e.isPosted();
      }
      static isIgnoredObjErased(e) {
        return c(e) && e.isErased();
      }
      static isIgnoredByGeneralRules(e, t) {
        const i = e[t];
        return (0, a.isArray)(i) && i.length === 0;
      }
    }
    class d {
      isIgnoredObj(e, t) {
        if (t === undefined) {
          return h.isIgnoredObjDefault(e) || h.isIgnoredObjErased(e);
        }
        const i = e[t];
        return h.isIgnoredObjDefault(e, t) || h.isIgnoredObjErased(i);
      }
    }
    class u extends n {
      constructor(e) {
        super(e);
        this._snapshotPredicate = new d();
        this._dataSnapShot = {};
      }
      getData() {
        return this._dataSnapShot;
      }
      getUpdate() {
        if (this._isDirty) {
          return this._dataSnapShot;
        } else {
          return {};
        }
      }
      update(e) {
        if (this._dataObj.checkForChangeAndResetChangedState(this._eraseCmds) || e) {
          if (this._dataObj.graphicsCmds.create !== null) {
            this._dataObj.graphicsCmds.create.deleteErasedObjs();
            this._dataObj.graphicsCmds.erase = [new s.EraseAll()];
          }
          this._makeSnapshot();
          this._isDirty = true;
        }
      }
      _makeSnapshot() {
        this._json = this._dataObj.primitiveData(this._snapshotPredicate);
        this._dataSnapShot = {
          json: this._json
        };
      }
    }
    class _ {
      isIgnoredObj(e, t) {
        if (t === undefined) {
          return h.isIgnoredObjDefault(e) || h.isIgnoredObjErased(e) || h.isIgnoredObjPosted(e);
        }
        const i = e[t];
        return h.isIgnoredObjDefault(e, t) || h.isIgnoredObjErased(i) || h.isIgnoredObjPosted(i);
      }
    }
    class p extends u {
      constructor(e) {
        super(e);
        this._updatePredicate = new _();
        this._sendShapshotOnly = true;
        this._isFirstNotForcedUpdate = true;
      }
      update(e) {
        if (this._dataObj.checkForChangeAndResetChangedState(this._eraseCmds) || e) {
          if (this._dataObj.graphicsCmds.create !== null) {
            this._dataObj.graphicsCmds.erase = [new s.EraseAll()];
          }
          this._dataObj.isUpdate = true;
          this._makeSnapshot();
          if (this._dataObj.graphicsCmds.create !== null) {
            this._dataObj.graphicsCmds.erase = this._eraseCmds;
          }
          this._dataObj.isUpdate = true;
          this._jsonUpdate = this._dataObj.primitiveData(this._updatePredicate);
          if (this._dataObj.graphicsCmds.create !== null) {
            this._dataObj.graphicsCmds.create.deleteErasedAndMarkPostedObjs();
          }
          this._sendShapshotOnly = e || this._isFirstNotForcedUpdate;
          this._isFirstNotForcedUpdate = Boolean(e);
          this._isDirty = true;
        }
      }
      getUpdate() {
        if (this._isDirty) {
          if (this._enableCmdDataStudy) {
            return {
              json: this._sendShapshotOnly ? this._json : undefined,
              jsonUpdate: this._sendShapshotOnly ? undefined : this._jsonUpdate
            };
          } else {
            return {
              json: this._json,
              jsonUpdate: this._sendShapshotOnly ? undefined : this._jsonUpdate
            };
          }
        } else {
          return {};
        }
      }
    }
  },
  45382: (e, t, i) => {
    "use strict";

    i.d(t, {
      Container: () => n,
      StudyGraphicsData: () => o
    });
    var s = i(50151);
    class o {
      constructor() {
        this._horizlines = [];
        this._hhists = [];
        this._polygons = [];
        this._vertlines = [];
        this._containersCache = [];
        this._containerNamesCache = [];
        this._containersMapCache = new Map();
        this._addToCache("horizlines", this._horizlines);
        this._addToCache("hhists", this._hhists);
        this._addToCache("polygons", this._polygons);
        this._addToCache("vertlines", this._vertlines);
      }
      primitiveData(e) {
        const t = {};
        let i = false;
        for (const s of this._containerNamesCache) {
          const o = [];
          const n = this.getObjsContainer(s);
          for (const t of n) {
            if (t.isNaN()) {
              continue;
            }
            const i = t.primitiveData(e);
            if (i.data.length > 0) {
              o.push(i);
            }
          }
          if (o.length > 0) {
            t[s] = o;
            i = true;
          }
        }
        if (i) {
          return t;
        } else {
          return null;
        }
      }
      deleteErasedAndMarkPostedObjs() {
        this.forEachList(e => {
          e.deleteErasedItems();
          e.markPostedItems();
        });
      }
      deleteErasedObjs() {
        this.forEachList(e => e.deleteErasedItems());
      }
      getObjsContainer(e) {
        return (0, s.ensureDefined)(this._containersMapCache.get(e));
      }
      forEachList(e) {
        for (const t of this._containersCache) {
          for (const i of t) {
            e(i.data);
          }
        }
      }
      _addToCache(e, t) {
        this._containersCache.push(t);
        this._containerNamesCache.push(e);
        this._containersMapCache.set(e, t);
      }
    }
    class n {
      constructor(e, t) {
        this.styleId = e;
        this.data = t;
      }
      isNaN() {
        return this.data.isNaN();
      }
      primitiveData(e) {
        return {
          styleId: this.styleId,
          data: this.data.primitivesData(e)
        };
      }
    }
  },
  42924: (e, t, i) => {
    "use strict";

    const s = i(19625).getHexColorByName;
    const o = i(73772).Std;
    const n = s("color-ripe-red-100");
    const r = s("color-ripe-red-200");
    const a = s("color-ripe-red-500");
    const l = s("color-ripe-red-900");
    const c = s("color-ripe-red-a200");
    const h = s("color-minty-green-100");
    const d = s("color-minty-green-400");
    const u = s("color-minty-green-500");
    JSServer.studyLibrary = [{
      name: "Accumulation/Distribution",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {}
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Accumulation/Distribution",
        shortDescription: "Accum/Dist",
        is_price_study: false,
        inputs: [],
        id: "Accumulation/Distribution@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Accumulation/Distribution",
        format: {
          type: "volume"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t, i, s) {
          if (o.or(o.and(o.eq(e, t), o.eq(e, i)), o.eq(t, i))) {
            return 0;
          } else {
            return (e * 2 - i - t) / (t - i) * s;
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this.f_0(o.close(this._context), o.high(this._context), o.low(this._context), o.volume(this._context));
          return [o.cum(i, this._context)];
        };
      }
    }, {
      name: "Accumulative Swing Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 10
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "ASI",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Accumulative Swing Index",
        shortDescription: "ASI",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "Limit Move Value",
          defval: 10,
          type: "float",
          min: 0.1,
          max: 100000
        }],
        id: "Accumulative Swing Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Accumulative Swing Index",
        format: {
          type: "volume"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          var i = t.new_var(o.open(t));
          var s = t.new_var(o.high(t));
          var n = t.new_var(o.low(t));
          var r = t.new_var(o.close(t));
          var a = o.abs(s - r.get(1));
          var l = o.abs(n - r.get(1));
          var c = o.abs(s - n);
          var h = o.abs(r.get(1) - i.get(1));
          var d = o.max(a, l);
          var u = o.iff(a >= o.max(l, c), a - l * 0.5 + h * 0.25, o.iff(l >= o.max(a, c), l - a * 0.5 + h * 0.25, c + h * 0.25));
          return o.iff(u === 0, 0, (r - r.get(1) + (r - i) * 0.5 + (r.get(1) - i.get(1)) * 0.25) / u * d / e * 50);
        };
        this.f_1 = function (e, t) {
          var i = this.f_0(e, t);
          return o.cum(i, t);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          return [this.f_1(i, this._context)];
        };
      }
    }, {
      name: "Advance/Decline",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 10
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Advance/Decline",
        shortDescription: "AD",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Advance/Decline@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Advance/Decline",
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return o.gt(e, t);
        };
        this.f_1 = function (e, t) {
          return o.lt(e, t);
        };
        this.f_2 = function (e, t) {
          if (t === 0) {
            return e;
          } else {
            return e / t;
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this.f_0(o.close(this._context), o.open(this._context));
          var n = this._context.new_var(s);
          var r = o.sum(n, i, this._context);
          var a = this.f_1(o.close(this._context), o.open(this._context));
          var l = this._context.new_var(a);
          var c = o.sum(l, i, this._context);
          return [this.f_2(r, c)];
        };
      }
    }, {
      name: "Arnaud Legoux Moving Average",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 9,
            in_1: 0.85,
            in_2: 6
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Arnaud Legoux Moving Average",
        shortDescription: "ALMA",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Window Size",
          defval: 9,
          type: "integer",
          min: 0,
          max: 5000
        }, {
          id: "in_1",
          name: "Offset",
          defval: 0.85,
          type: "float",
          min: -1000000000000,
          max: 1000000000000
        }, {
          id: "in_2",
          name: "Sigma",
          defval: 6,
          type: "float",
          min: -1000000000000,
          max: 1000000000000
        }],
        id: "Arnaud Legoux Moving Average@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Arnaud Legoux Moving Average",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = this._input(1);
          var r = this._input(2);
          var a = this._context.new_var(i);
          return [o.alma(a, s, n, r)];
        };
      }
    }, {
      name: "Aroon",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FB8C00"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Upper",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Lower",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Aroon",
        shortDescription: "Aroon",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Aroon@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Aroon",
        format: {
          precision: 2,
          type: "percent"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return (e + t) * 100 / t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = o.high(this._context);
          var n = i + 1;
          var r = this._context.new_var(s);
          var a = o.highestbars(r, n, this._context);
          var l = this.f_0(a, i);
          var c = o.low(this._context);
          var h = this._context.new_var(c);
          var d = o.lowestbars(h, n, this._context);
          return [l, this.f_0(d, i)];
        };
      }
    }, {
      name: "Average Price",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        id: "AveragePrice@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Average Price",
        description: "Average Price",
        shortDescription: "Average Price",
        is_price_study: true,
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: "#2196F3"
            }
          },
          inputs: {
            symbol: ""
          }
        },
        styles: {
          plot_0: {
            title: "Plot"
          }
        },
        inputs: [{
          id: "symbol",
          name: "Other Symbol",
          defval: "",
          type: "symbol",
          optional: true,
          isHidden: false
        }],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          if (t(0) !== "") {
            this._context.new_sym(t(0), o.period(this._context));
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          if (this._input(0) === "") {
            return [o.ohlc4(this._context)];
          }
          this._context.select_sym(0);
          const i = this._context.new_var(this._context.symbol.time);
          this._context.select_sym(1);
          const s = this._context.new_var(o.ohlc4(this._context)).adopt(this._context.new_var(this._context.symbol.time), i, 1);
          this._context.select_sym(0);
          return [s];
        };
      }
    }, {
      name: "Average Directional Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: c
            }
          },
          inputs: {
            in_0: 14,
            in_1: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "ADX",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "Average Directional Index",
        shortDescription: "ADX",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "ADX Smoothing",
          defval: 14,
          type: "integer",
          min: -1000000000000,
          max: 1000000000000
        }, {
          id: "in_1",
          name: "DI Length",
          defval: 14,
          type: "integer",
          min: -1000000000000,
          max: 1000000000000
        }],
        id: "average_directional_Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Average Directional Index",
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function (e) {
          var t = this._context.new_var(o.high(this._context));
          var i = o.change(t);
          var s = this._context.new_var(o.low(this._context));
          var n = -o.change(s);
          var r = this._context.new_var(o.tr(undefined, this._context));
          var a = o.rma(r, e, this._context);
          var l = this._context.new_var(o.and(o.gt(i, n), o.gt(i, 0)) ? i : 0);
          var c = o.fixnan(o.rma(l, e, this._context) * 100 / a, this._context);
          var h = this._context.new_var(o.and(o.gt(n, i), o.gt(n, 0)) ? n : 0);
          return [c, o.fixnan(o.rma(h, e, this._context) * 100 / a, this._context)];
        };
        this.f_1 = function (e, t) {
          var i = this.f_0(e);
          var s = i[0];
          var n = i[1];
          var r = s + n;
          var a = this._context.new_var(o.abs(s - n) / (o.eq(r, 0) ? 1 : r));
          return [o.rma(a, t, this._context) * 100];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          this._context.setMinimumAdditionalDepth(this._input(0) + this._input(1));
          return this.f_1(this._input(1), this._input(0));
        };
      }
    }, {
      name: "Average True Range",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: l
            }
          },
          inputs: {
            in_0: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Average True Range",
        shortDescription: "ATR",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Average True Range@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Average True Range",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          var i = t(0);
          return [o.atr(i, e)];
        };
      }
    }, {
      name: "Awesome Oscillator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 1,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#000080"
            }
          },
          palettes: {
            palette_0: {
              colors: {
                0: {
                  color: a,
                  width: 1,
                  style: 0
                },
                1: {
                  color: u,
                  width: 1,
                  style: 0
                }
              }
            }
          },
          inputs: {}
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          palette: "palette_0",
          target: "plot_0",
          type: "colorer"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Awesome Oscillator",
        shortDescription: "AO",
        is_price_study: false,
        palettes: {
          palette_0: {
            colors: {
              0: {
                name: "Color 0"
              },
              1: {
                name: "Color 1"
              }
            }
          }
        },
        inputs: [],
        id: "Awesome Oscillator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Awesome Oscillator",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e - t;
        };
        this.f_1 = function (e) {
          if (o.le(e, 0)) {
            return 0;
          } else {
            return 1;
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.hl2(this._context);
          var s = this._context.new_var(i);
          var n = o.sma(s, 5, this._context);
          var r = this._context.new_var(i);
          var a = o.sma(r, 34, this._context);
          var l = this.f_0(n, a);
          var c = l;
          var h = this._context.new_var(l);
          var d = o.change(h);
          return [c, this.f_1(d)];
        };
      }
    }, {
      name: "Accelerator Oscillator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 1,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#000080"
            }
          },
          palettes: {
            palette_0: {
              colors: {
                0: {
                  color: a,
                  width: 1,
                  style: 0
                },
                1: {
                  color: u,
                  width: 1,
                  style: 0
                }
              }
            }
          },
          inputs: {}
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          palette: "palette_0",
          target: "plot_0",
          type: "colorer"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Accelerator Oscillator",
        shortDescription: "AO",
        is_price_study: false,
        palettes: {
          palette_0: {
            colors: {
              0: {
                name: "Color 0"
              },
              1: {
                name: "Color 1"
              }
            }
          }
        },
        inputs: [],
        id: "Accelerator Oscillator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Accelerator Oscillator",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e - t;
        };
        this.f_1 = function (e) {
          if (o.le(e, 0)) {
            return 0;
          } else {
            return 1;
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.hl2(this._context);
          var s = this._context.new_var(i);
          var n = o.sma(s, 5, this._context);
          var r = this._context.new_var(i);
          var a = o.sma(r, 34, this._context);
          var l = this.f_0(n, a);
          var c = this._context.new_var(l);
          var h = o.sma(c, 5, this._context);
          var d = this.f_0(l, h);
          var u = this._context.new_var(d);
          var _ = o.change(u);
          return [d, this.f_1(_)];
        };
      }
    }, {
      name: "Balance of Power",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: c
            }
          },
          inputs: {}
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Balance of Power",
        shortDescription: "Balance of Power",
        is_price_study: false,
        inputs: [],
        id: "Balance of Power@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Balance of Power",
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t, i, s) {
          return (e - t) / (i - s);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return [this.f_0(o.close(this._context), o.open(this._context), o.high(this._context), o.low(this._context))];
        };
      }
    }, {
      name: "BB",
      metainfo: {
        _metainfoVersion: 23,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: true,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 35,
              visible: true,
              color: "#FF0000"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 35,
              visible: true,
              color: "#0000FF"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 35,
              visible: true,
              color: "#0000FF"
            }
          },
          precision: 4,
          filledAreasStyle: {
            fill_0: {
              color: "#000080",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 20,
            in_1: 2
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Median",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Upper",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Lower",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Bollinger Bands",
        shortDescription: "BB",
        is_price_study: true,
        filledAreas: [{
          id: "fill_0",
          objAId: "plot_1",
          objBId: "plot_2",
          type: "plot_plot",
          title: "Plots Background"
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_1",
          name: "mult",
          defval: 2,
          type: "float",
          min: 0.001,
          max: 50
        }],
        id: "BB@tv-basicstudies-1"
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e * t;
        };
        this.f_1 = function (e, t) {
          return e + t;
        };
        this.f_2 = function (e, t) {
          return e - t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = this._input(1);
          var r = this._context.new_var(i);
          var a = o.sma(r, s, this._context);
          var l = this._context.new_var(i);
          var c = o.stdev(l, s, this._context);
          var h = this.f_0(n, c);
          return [a, this.f_1(a, h), this.f_2(a, h)];
        };
      }
    }, {
      name: "Bollinger Bands",
      metainfo: {
        _metainfoVersion: 53,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 95,
              visible: true
            }
          },
          inputs: {
            in_0: 20,
            in_1: 2,
            symbol: "",
            offset: 0
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Median",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Upper",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Lower",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Bollinger Bands",
        shortDescription: "BB",
        is_price_study: true,
        filledAreas: [{
          id: "fill_0",
          objAId: "plot_1",
          objBId: "plot_2",
          type: "plot_plot",
          title: "Plots Background"
        }],
        inputs: [{
          id: "symbol",
          name: "Other Symbol",
          defval: "",
          type: "symbol",
          optional: true,
          isHidden: false
        }, {
          id: "in_0",
          name: "length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "in_1",
          name: "mult",
          defval: 2,
          type: "float",
          min: 0.001,
          max: 50
        }, {
          id: "offset",
          name: "Offset",
          defval: 0,
          type: "integer",
          min: -10000,
          max: 10000
        }],
        id: "Bollinger Bands@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Bollinger Bands",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e * t;
        };
        this.f_1 = function (e, t) {
          return e + t;
        };
        this.f_2 = function (e, t) {
          return e - t;
        };
        this.init = function (e, t) {
          this._context = e;
          if (t(0) !== "") {
            this._context.new_sym(t(0), o.period(this._context));
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(o.time(this._context));
          var s = o.close(this._context);
          var n = this._input(0);
          var r = this._input(1);
          var a = this._input(2);
          var l = this._input(3);
          if (n !== "") {
            this._context.select_sym(1);
            var c = this._context.new_var(o.time(this._context));
            s = this._context.new_var(o.close(this._context)).adopt(c, i, 1);
            this._context.select_sym(0);
          }
          var h = this._context.new_var(s);
          var d = o.sma(h, r, this._context);
          var u = this._context.new_var(s);
          var _ = o.stdev(u, r, this._context);
          var p = this.f_0(a, _);
          return [{
            value: d,
            offset: l
          }, {
            value: this.f_1(d, p),
            offset: l
          }, {
            value: this.f_2(d, p),
            offset: l
          }];
        };
      }
    }, {
      name: "Bollinger Bands %B",
      metainfo: {
        _metainfoVersion: 53,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: d
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 1
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          filledAreasStyle: {
            fill_0: {
              color: "#26A69A",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 20,
            in_1: 2
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Bollinger Bands %B",
        shortDescription: "BB %B",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "UpperLimit",
          zorder: -1.1
        }, {
          id: "hline_1",
          name: "LowerLimit",
          zorder: -1.11
        }],
        filledAreas: [{
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          title: "Hlines Background",
          zorder: -2
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "in_1",
          name: "mult",
          defval: 2,
          type: "float",
          min: 0.001,
          max: 50
        }],
        id: "Bollinger Bands %B@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Bollinger Bands %B",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e * t;
        };
        this.f_1 = function (e, t) {
          return e + t;
        };
        this.f_2 = function (e, t) {
          return e - t;
        };
        this.f_3 = function (e, t, i) {
          return (e - t) / (i - t);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = this._input(1);
          var r = this._context.new_var(i);
          var a = o.sma(r, s, this._context);
          var l = this._context.new_var(i);
          var c = o.stdev(l, s, this._context);
          var h = this.f_0(n, c);
          var d = this.f_1(a, h);
          var u = this.f_2(a, h);
          return [this.f_3(i, u, d)];
        };
      }
    }, {
      name: "Bollinger Bands Width",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            }
          },
          inputs: {
            in_0: 20,
            in_1: 2
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Bollinger Bands Width",
        shortDescription: "BBW",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "in_1",
          name: "mult",
          defval: 2,
          type: "float",
          min: 0.001,
          max: 50
        }],
        id: "Bollinger Bands Width@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Bollinger Bands Width",
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e * t;
        };
        this.f_1 = function (e, t) {
          return e + t;
        };
        this.f_2 = function (e, t) {
          return e - t;
        };
        this.f_3 = function (e, t, i) {
          return (e - t) / i;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = this._input(1);
          var r = this._context.new_var(i);
          var a = o.sma(r, s, this._context);
          var l = this._context.new_var(i);
          var c = o.stdev(l, s, this._context);
          var h = this.f_0(n, c);
          var d = this.f_1(a, h);
          var u = this.f_2(a, h);
          return [this.f_3(d, u, a)];
        };
      }
    }, {
      name: "Chaikin Money Flow",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#43A047"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 20
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Chaikin Money Flow",
        shortDescription: "CMF",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Zero",
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Chaikin Money Flow@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Chaikin Money Flow",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e, t, i, s) {
          if (o.or(o.and(o.eq(e, t), o.eq(e, i)), o.eq(t, i))) {
            return 0;
          } else {
            return (e * 2 - i - t) / (t - i) * s;
          }
        };
        this.f_1 = function (e, t) {
          return e / t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this.f_0(o.close(this._context), o.high(this._context), o.low(this._context), o.volume(this._context));
          var n = this._context.new_var(s);
          var r = o.sum(n, i, this._context);
          var a = o.volume(this._context);
          var l = this._context.new_var(a);
          var c = o.sum(l, i, this._context);
          return [this.f_1(r, c)];
        };
      }
    }, {
      name: "Chaikin Oscillator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#EC407A"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 3,
            in_1: 10
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Chaikin Oscillator",
        shortDescription: "Chaikin Osc",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Zero",
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "short",
          defval: 3,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_1",
          name: "long",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Chaikin Oscillator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Chaikin Oscillator",
        format: {
          type: "volume"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e - t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = o.accdist(this._context);
          var r = this._context.new_var(n);
          var a = o.ema(r, i, this._context);
          var l = this._context.new_var(n);
          var c = o.ema(l, s, this._context);
          return [this.f_0(a, c)];
        };
      }
    }, {
      name: "Chaikin Volatility",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: false,
        id: "Chaikin Volatility@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Chaikin Volatility",
        description: "Chaikin Volatility",
        shortDescription: "Chaikin Volatility",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: "#AB47BC"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            periods: 10,
            rocLookback: 10
          }
        },
        styles: {
          plot_0: {
            title: "Plot",
            zorder: 1
          }
        },
        bands: [{
          id: "hline_0",
          name: "Zero",
          zorder: -1
        }],
        inputs: [{
          id: "periods",
          type: "integer",
          name: "Periods"
        }, {
          id: "rocLookback",
          type: "integer",
          name: "Rate of Change Lookback"
        }],
        format: {
          type: "volume"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.period = this._input(0);
          this.rocLookback = this._input(1);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          this._context.setMinimumAdditionalDepth(this.period + this.rocLookback);
          var i = this._context.new_var(o.high(this._context) - o.low(this._context));
          var s = this._context.new_var(o.ema(i, this.period, this._context));
          return [o.roc(s, this.rocLookback)];
        };
      }
    }, {
      name: "Chande Kroll Stop",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            }
          },
          inputs: {
            in_0: 10,
            in_1: 1,
            in_2: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Long",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Short",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Chande Kroll Stop",
        shortDescription: "Chande Kroll Stop",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "p",
          defval: 10,
          type: "integer",
          min: 1,
          max: 4999
        }, {
          id: "in_1",
          name: "x",
          defval: 1,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_2",
          name: "q",
          defval: 9,
          type: "integer",
          min: 1,
          max: 1000000000000
        }],
        id: "Chande Kroll Stop@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Chande Kroll Stop",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t, i) {
          return e - t * i;
        };
        this.f_1 = function (e, t, i) {
          return e + t * i;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = this._input(2);
          var r = o.high(this._context);
          var a = this._context.new_var(r);
          var l = o.highest(a, i, this._context);
          var c = o.atr(i, this._context);
          var h = this.f_0(l, s, c);
          var d = this._context.new_var(r);
          var u = o.lowest(d, i, this._context);
          var _ = this.f_1(u, s, c);
          var p = this._context.new_var(h);
          var m = o.highest(p, n, this._context);
          var g = this._context.new_var(_);
          return [o.lowest(g, n, this._context), m];
        };
      }
    }, {
      name: "Chande Momentum Oscillator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Chande Momentum Oscillator",
        shortDescription: "ChandeMO",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Chande Momentum Oscillator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Chande Momentum Oscillator",
        format: {
          type: "price",
          precision: 2
        }
      },
      constructor: function () {
        this.f_0 = function (e) {
          if (o.ge(e, 0)) {
            return e;
          } else {
            return 0;
          }
        };
        this.f_1 = function (e) {
          if (o.ge(e, 0)) {
            return 0;
          } else {
            return -e;
          }
        };
        this.f_2 = function (e, t) {
          return e * 100 / t;
        };
        this.f_3 = function (e, t) {
          return this.f_2(e - t, e + t);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = o.close(this._context);
          var n = this._context.new_var(s);
          var r = o.change(n);
          var a = this.f_0(r);
          var l = this.f_1(r);
          var c = this._context.new_var(a);
          var h = o.sum(c, i, this._context);
          var d = this._context.new_var(l);
          var u = o.sum(d, i, this._context);
          return [this.f_3(h, u)];
        };
      }
    }, {
      name: "Chop Zone",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 5,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#000080"
            }
          },
          palettes: {
            palette_0: {
              colors: {
                0: {
                  color: "#26C6DA",
                  width: 1,
                  style: 0
                },
                1: {
                  color: "#43A047",
                  width: 1,
                  style: 0
                },
                2: {
                  color: "#A5D6A7",
                  width: 1,
                  style: 0
                },
                3: {
                  color: u,
                  width: 1,
                  style: 0
                },
                4: {
                  color: "#D50000",
                  width: 1,
                  style: 0
                },
                5: {
                  color: "#E91E63",
                  width: 1,
                  style: 0
                },
                6: {
                  color: "#FF6D00",
                  width: 1,
                  style: 0
                },
                7: {
                  color: "#FFB74D",
                  width: 1,
                  style: 0
                },
                8: {
                  color: "#FDD835",
                  width: 1,
                  style: 0
                }
              }
            }
          },
          inputs: {}
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          palette: "palette_0",
          target: "plot_0",
          type: "colorer"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "Chop Zone",
        shortDescription: "Chop Zone",
        is_price_study: false,
        palettes: {
          palette_0: {
            colors: {
              0: {
                name: "Color 0"
              },
              1: {
                name: "Color 1"
              },
              2: {
                name: "Color 2"
              },
              3: {
                name: "Color 3"
              },
              4: {
                name: "Color 4"
              },
              5: {
                name: "Color 5"
              },
              6: {
                name: "Color 6"
              },
              7: {
                name: "Color 7"
              },
              8: {
                name: "Color 8"
              }
            },
            valToIndex: {
              0: 0,
              1: 1,
              2: 2,
              3: 3,
              4: 4,
              5: 5,
              6: 6,
              7: 7,
              8: 8
            }
          }
        },
        inputs: [],
        id: "chop_zone@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Chop Zone",
        format: {
          precision: 0,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function () {
          var e = o.close(this._context);
          var t = o.hlc3(this._context);
          var i = this._context.new_var(o.high(this._context));
          var s = o.highest(i, 30, this._context);
          var n = o.lowest(i, 30, this._context);
          var r = 25 / (s - n) * n;
          var a = this._context.new_var(e);
          var l = this._context.new_var(o.ema(a, 34, this._context));
          var c = (l.get(1) - l.get(0)) / t * r;
          var h = o.sqrt(1 + c * c);
          var d = o.round(o.acos(1 / h) * 180 / 3.141592653589793);
          var u = o.iff(o.gt(c, 0), -d, d);
          var _ = o.and(o.gt(u, -2.14), o.le(u, -0.71)) ? 7 : 8;
          var p = o.and(o.gt(u, -3.57), o.le(u, -2.14)) ? 6 : _;
          var m = o.and(o.gt(u, -5), o.le(u, -3.57)) ? 5 : p;
          var g = o.le(u, -5) ? 4 : m;
          var f = o.and(o.lt(u, 2.14), o.ge(u, 0.71)) ? 3 : g;
          var y = o.and(o.lt(u, 3.57), o.ge(u, 2.14)) ? 2 : f;
          var v = o.and(o.lt(u, 5), o.ge(u, 3.57)) ? 1 : y;
          return [1, o.ge(u, 5) ? 0 : v];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return this.f_0();
        };
      }
    }, {
      name: "Choppiness Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 61.8
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 38.2
          }],
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Choppiness Index",
        shortDescription: "CHOP",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "UpperLimit",
          zorder: -1.1
        }, {
          id: "hline_1",
          name: "LowerLimit",
          zorder: -1.11
        }],
        filledAreas: [{
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          title: "Hlines Background",
          zorder: -2
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Choppiness Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Choppiness Index",
        format: {
          type: "price",
          precision: 2
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e, t, i, s) {
          return o.log10(e / (t - i)) * 100 / s;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = o.atr(1, this._context);
          var n = this._context.new_var(s);
          var r = o.sum(n, i, this._context);
          var a = o.high(this._context);
          var l = this._context.new_var(a);
          var c = o.highest(l, i, this._context);
          var h = o.low(this._context);
          var d = this._context.new_var(h);
          var u = o.lowest(d, i, this._context);
          var _ = o.log10(i);
          return [this.f_0(r, c, u, _)];
        };
      }
    }, {
      name: "Commodity Channel Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            smoothedMA: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: false
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 100
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: -100
          }],
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 20,
            smoothingLine: "SMA",
            smoothingLength: 20
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "smoothedMA",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 2
          },
          smoothedMA: {
            title: "Smoothed MA",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Commodity Channel Index",
        shortDescription: "CCI",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "UpperLimit",
          zorder: -1.1
        }, {
          id: "hline_1",
          name: "LowerLimit",
          zorder: -1.11
        }],
        filledAreas: [{
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          title: "Hlines Background",
          zorder: -2
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "smoothingLine",
          name: "Smoothing Line",
          defval: "SMA",
          type: "text",
          options: ["SMA", "EMA", "WMA"],
          hideWhenPlotsHidden: ["smoothedMA"]
        }, {
          id: "smoothingLength",
          name: "Smoothing Length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["smoothedMA"]
        }],
        id: "Commodity Channel Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Commodity Channel Index",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e, t, i) {
          return (e - t) / (i * 0.015);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.hlc3(this._context);
          var s = this._input(0);
          var n = this._input(1);
          var r = this._input(2);
          this._context.setMinimumAdditionalDepth(s + r);
          var a;
          var l = this._context.new_var(i);
          var c = o.sma(l, s, this._context);
          var h = this._context.new_var(i);
          var d = o.dev(h, s, this._context);
          var u = this.f_0(i, c, d);
          var _ = this._context.new_var(u);
          if (n === "EMA") {
            a = o.ema(_, r, this._context);
          } else if (n === "WMA") {
            a = o.wma(_, r, this._context);
          } else if (n === "SMA") {
            a = o.sma(_, r, this._context);
          }
          return [u, a];
        };
      }
    }, {
      name: "Connors RSI",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 70
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 30
          }],
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 3,
            in_1: 2,
            in_2: 100
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "CRSI",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Connors RSI",
        shortDescription: "CRSI",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "UpperLimit",
          zorder: -1.1
        }, {
          id: "hline_1",
          name: "LowerLimit",
          zorder: -1.11
        }],
        filledAreas: [{
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          title: "Hlines Background",
          zorder: -2
        }],
        inputs: [{
          id: "in_0",
          name: "RSI Length",
          defval: 3,
          type: "integer",
          min: 1
        }, {
          id: "in_1",
          name: "UpDown Length",
          defval: 2,
          type: "integer",
          min: 1
        }, {
          id: "in_2",
          name: "ROC Length",
          defval: 100,
          type: "integer",
          min: 1
        }],
        id: "Connors RSI@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Connors RSI",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        var e;
        this.f_1 = function (e, t, i) {
          var s = i.new_var(o.max(o.change(e), 0));
          return o.rma(s, t, i);
        };
        this.f_2 = function (e, t, i) {
          var s = i.new_var(-o.min(o.change(e), 0));
          return o.rma(s, t, i);
        };
        this.f_3 = (e = 0, function (t) {
          var i = t.get(0);
          var s = t.get(1);
          e = i === s ? 0 : i > s ? o.nz(e) <= 0 ? 1 : o.nz(e) + 1 : o.nz(e) >= 0 ? -1 : o.nz(e) - 1;
          return this._context.new_var(e);
        });
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._context.new_var(i);
          var n = this._input(0);
          var r = this._input(1);
          var a = this._input(2);
          this._context.setMinimumAdditionalDepth(a);
          var l = o.rsi(this.f_1(s, n, this._context), this.f_2(s, n, this._context));
          var c = this.f_3(s);
          var h = o.rsi(this.f_1(c, r, this._context), this.f_2(c, r, this._context));
          var d = this._context.new_var(o.roc(s, 1));
          var u = o.percentrank(d, a);
          return [o.avg(l, h, u)];
        };
      }
    }, {
      name: "Coppock Curve",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 10,
            in_1: 14,
            in_2: 11
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Coppock Curve",
        shortDescription: "Coppock Curve",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "WMA Length",
          defval: 10,
          type: "integer",
          min: -1000000000000,
          max: 5000
        }, {
          id: "in_1",
          name: "Long RoC Length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 4999
        }, {
          id: "in_2",
          name: "Short RoC Length",
          defval: 11,
          type: "integer",
          min: 1,
          max: 4999
        }],
        id: "Coppock Curve@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Coppock Curve",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e + t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = this._input(2);
          this._context.setMinimumAdditionalDepth(i + Math.max(s, n));
          var r = o.close(this._context);
          var a = this._context.new_var(r);
          var l = o.roc(a, s);
          var c = this._context.new_var(r);
          var h = o.roc(c, n);
          var d = this.f_0(l, h);
          var u = this._context.new_var(d);
          return [o.wma(u, i, this._context)];
        };
      }
    }, {
      name: "Correlation Coeff",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 4,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: "",
            in_1: 20
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Correlation Coefficient",
        shortDescription: "CC",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "sym",
          defval: "",
          type: "symbol"
        }, {
          id: "in_1",
          name: "length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Correlation Coeff@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Correlation Coeff",
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this._context.new_sym(this._input(0), o.period(this._context));
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_unlimited_var(this._context.symbol.time);
          this._input(0);
          o.period(this._context);
          var s = o.close(this._context);
          var n = this._input(1);
          this._context.select_sym(1);
          var r = this._context.new_unlimited_var(this._context.symbol.time);
          var a = o.close(this._context);
          var l = this._context.new_unlimited_var(a);
          this._context.select_sym(0);
          var c = l.adopt(r, i, 0);
          var h = this._context.new_var(s);
          var d = this._context.new_var(c);
          return [o.correlation(h, d, n, this._context)];
        };
      }
    }, {
      name: "Correlation - Log",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: false,
        id: "Correlation - Log@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Correlation - Log",
        description: "Correlation - Log",
        shortDescription: "Correlation - Log",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: "#2196F3"
            }
          },
          inputs: {
            instrument: "",
            instrument2: "",
            periods: 25
          }
        },
        styles: {
          plot_0: {
            title: "Plot"
          }
        },
        inputs: [{
          id: "instrument",
          name: "Instrument 1",
          type: "symbol",
          defval: "",
          confirm: true
        }, {
          id: "instrument2",
          name: "Instrument 2",
          type: "symbol",
          defval: "",
          confirm: true
        }, {
          id: "periods",
          name: "Periods",
          type: "integer",
          defval: 25
        }],
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this._context.new_sym(this._input(0), o.period(this._context));
          this._context.new_sym(this._input(1), o.period(this._context));
          this.period = this._input(2);
        };
        this.correlationLog = function (e, t, i, s) {
          var n = o.sma(e, i, s);
          var r = o.sma(t, i, s);
          var a = s.new_var(e.get() * t.get());
          return (o.sma(a, i, s) - n * r) / Math.sqrt(o.variance2(e, n, i) * o.variance2(t, r, i));
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(this._context.symbol.time);
          this._context.select_sym(2);
          var s = this._context.new_var(o.close(this._context));
          var n = this._context.new_var(o.log(s.get() / s.get(1)));
          var r = this._context.new_var(this._context.symbol.time);
          this._context.select_sym(1);
          var a = this._context.new_var(this._context.symbol.time);
          var l = this._context.new_var(o.close(this._context));
          var c = this._context.new_var(o.log(l.get() / l.get(1)));
          var h = this._context.new_var(n.adopt(r, a, 0));
          var d = this._context.new_var(this.correlationLog(c, h, this.period, this._context));
          var u = this._context.new_var(d.adopt(a, i, 0)).get();
          var _ = o.round(u * 1000) / 1000;
          this._context.select_sym(0);
          return [_];
        };
      }
    }, {
      name: "Detrended Price Oscillator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#43A047"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 21,
            in_1: false
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "DPO",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false,
            zorder: 1
          }
        },
        description: "Detrended Price Oscillator",
        shortDescription: "DPO",
        is_price_study: false,
        is_hidden_study: false,
        id: "detrended_price_oscillator@tv-basicstudies-1",
        bands: [{
          id: "hline_0",
          name: "Zero",
          isHidden: false,
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "Period",
          defval: 21,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_1",
          name: "isCentered",
          defval: false,
          type: "bool"
        }],
        scriptIdPart: "",
        name: "Detrended Price Oscillator",
        format: {
          type: "price",
          precision: 2
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function () {
          var e = this._input(0);
          var t = this._input(1);
          var i = Math.floor(e / 2 + 1);
          this._context.setMinimumAdditionalDepth(e + i);
          var s = this._context.new_var(o.close(this._context));
          var n = this._context.new_var(o.sma(s, e, this._context));
          var r = this._context.new_var(o.close(this._context)).get(i) - n;
          var a = o.close(this._context) - n.get(i);
          return [t ? r : a, t ? -i : 0];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this.f_0();
          return [{
            value: i[0],
            offset: i[1]
          }];
        };
      }
    }, {
      name: "Directional Movement Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            },
            plot_3: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#F50057"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FFA726"
            },
            plot_4: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#ab47bc"
            }
          },
          inputs: {
            in_0: 14,
            in_1: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }, {
          id: "plot_3",
          type: "line"
        }, {
          id: "plot_4",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "+DI",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "-DI",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "DX",
            histogramBase: 0,
            joinPoints: false
          },
          plot_3: {
            title: "ADX",
            histogramBase: 0,
            joinPoints: false
          },
          plot_4: {
            title: "ADXR",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Directional Movement",
        shortDescription: "DMI",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "DI Length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_1",
          name: "ADX Smoothing",
          defval: 14,
          type: "integer",
          min: 1,
          max: 50
        }],
        id: "Directional Movement Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Directional Movement Index",
        format: {
          precision: 4,
          type: "price"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          this._context.setMinimumAdditionalDepth(i * 2 + s);
          return o.dmi(i, s, this._context);
        };
      }
    }, {
      name: "Donchian Channels",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            }
          },
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 95,
              visible: true
            }
          },
          inputs: {
            in_0: 20,
            offset: 0
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Lower",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Upper",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Basis",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Donchian Channels",
        shortDescription: "DC",
        is_price_study: true,
        filledAreas: [{
          id: "fill_0",
          objAId: "plot_1",
          objBId: "plot_0",
          type: "plot_plot",
          title: "Plots Background"
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "offset",
          name: "Offset",
          defval: 0,
          type: "integer",
          min: -1000,
          max: 1000
        }],
        id: "Donchian Channels@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Donchian Channels",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = o.low(this._context);
          var r = this._context.new_var(n);
          this._context.setMinimumAdditionalDepth(i + Math.max(s, 0));
          var a = o.lowest(r, i, this._context);
          var l = o.high(this._context);
          var c = this._context.new_var(l);
          var h = o.highest(c, i, this._context);
          return [{
            value: a,
            offset: s
          }, {
            value: h,
            offset: s
          }, {
            value: o.avg(h, a),
            offset: s
          }];
        };
      }
    }, {
      name: "Double Exponential Moving Average",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#43A047"
            }
          },
          inputs: {
            in_0: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Double EMA",
        shortDescription: "DEMA",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 10000
        }],
        id: "Double Exponential Moving Average@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Double Exponential Moving Average",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e * 2 - t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          this._context.setMinimumAdditionalDepth(i * 2);
          var s = o.close(this._context);
          var n = this._context.new_var(s);
          var r = o.ema(n, i, this._context);
          var a = this._context.new_var(r);
          var l = o.ema(a, i, this._context);
          return [this.f_0(r, l)];
        };
      }
    }, {
      name: "Ease of Movement",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#43A047"
            }
          },
          inputs: {
            in_0: 10000,
            in_1: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Ease Of Movement",
        shortDescription: "EOM",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "Divisor",
          defval: 10000,
          type: "integer",
          min: 1,
          max: 1000000000
        }, {
          id: "in_1",
          name: "length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Ease of Movement@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Ease of Movement",
        format: {
          type: "volume"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t, i, s, o) {
          return e * t * (i - s) / o;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = o.hl2(this._context);
          var r = this._context.new_var(n);
          var a = o.change(r);
          var l = this.f_0(i, a, o.high(this._context), o.low(this._context), o.volume(this._context));
          var c = this._context.new_var(l);
          return [o.sma(c, s, this._context)];
        };
      }
    }, {
      name: "Elders Force Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: a
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 13
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Elder's Force Index",
        shortDescription: "EFI",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Zero",
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 13,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Elders Force Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Elders Force Index",
        format: {
          type: "volume"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e * t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = o.close(this._context);
          var n = this._context.new_var(s);
          var r = o.change(n);
          var a = this.f_0(r, o.volume(this._context));
          var l = this._context.new_var(a);
          return [o.ema(l, i, this._context)];
        };
      }
    }, {
      name: "EMA Cross",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#43A047"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 4,
              plottype: 3,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 9,
            in_1: 26
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Short",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Long",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Crosses",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "EMA Cross",
        shortDescription: "EMA Cross",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Short",
          defval: 9,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_0", "plot_2"]
        }, {
          id: "in_1",
          name: "Long",
          defval: 26,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_1", "plot_2"]
        }],
        id: "EMA Cross@tv-basicstudies-1",
        scriptIdPart: "",
        name: "EMA Cross",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          if (e) {
            return t;
          } else {
            return o.na();
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = o.close(this._context);
          var r = this._context.new_var(n);
          var a = o.ema(r, i, this._context);
          var l = this._context.new_var(n);
          var c = o.ema(l, s, this._context);
          var h = a;
          var d = c;
          var u = o.cross(a, c, this._context);
          return [h, d, this.f_0(u, a)];
        };
      }
    }, {
      name: "Envelopes",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 95,
              visible: true
            }
          },
          inputs: {
            in_0: 20,
            in_1: 10,
            in_2: 10,
            in_3: "Simple",
            in_4: "close"
          }
        },
        plots: [{
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Average",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Upper",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Lower",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Envelopes",
        shortDescription: "Envelopes",
        is_price_study: true,
        filledAreas: [{
          id: "fill_0",
          objAId: "plot_1",
          objBId: "plot_2",
          type: "plot_plot",
          title: "Plots Background"
        }],
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_1",
          name: "Upper Percentage",
          defval: 2,
          type: "float",
          min: 0
        }, {
          id: "in_2",
          name: "Lower Percentage",
          defval: 2,
          type: "float",
          min: 0
        }, {
          id: "in_3",
          name: "Method",
          type: "text",
          defval: "Simple",
          options: ["Simple", "Exponential", "Weighted"]
        }, {
          id: "in_4",
          name: "Source",
          defval: "close",
          type: "source",
          options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"]
        }],
        id: "Envelope@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Envelopes",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e * (1 + t);
        };
        this.f_1 = function (e, t) {
          return e * (1 - t);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(o[this._input(4)](this._context));
          var s = o.sma(i, this._input(0), this._context);
          if (this._input(3) === "Exponential") {
            s = o.ema(i, this._input(0), this._context);
          } else if (this._input(3) === "Weighted") {
            s = o.wma(i, this._input(0), this._context);
          }
          return [this.f_0(s, this._input(1) / 100), s, this.f_1(s, this._input(2) / 100)];
        };
      }
    }, {
      name: "Standard Error",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: false,
        id: "Standard Error@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Standard Error",
        description: "Standard Error",
        shortDescription: "Standard Error",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: "#FF6D00"
            }
          },
          inputs: {
            length: 14
          }
        },
        styles: {
          plot_0: {
            title: "Plot"
          }
        },
        inputs: [{
          id: "length",
          type: "integer",
          name: "Length",
          min: 3
        }],
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.period = this._input(0);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i;
          var s;
          var n = this._context.new_var(o.close(this._context));
          var r = 0;
          var a = 0;
          for (var l = 0; l < this.period; l++) {
            r += l + 1;
            a += n.get(l);
          }
          i = r / this.period;
          s = a / this.period;
          var c = 0;
          var h = 0;
          var d = 0;
          for (l = 0; l < this.period; l++) {
            d += Math.pow(s - n.get(l), 2);
            h += (i - l - 1) * (s - n.get(l));
            c += Math.pow(i - l - 1, 2);
          }
          h = Math.pow(h, 2);
          return [Math.sqrt((d - h / c) / (this.period - 2))];
        };
      }
    }, {
      name: "Standard Error Bands",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: true,
        id: "Standard Error Bands@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Standard Error Bands",
        description: "Standard Error Bands",
        shortDescription: "Standard Error Bands",
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              transparency: 0,
              trackPrice: false,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              transparency: 0,
              plottype: 0,
              trackPrice: false,
              color: "#FF6D00"
            },
            plot_2: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              transparency: 0,
              plottype: 0,
              trackPrice: false,
              color: "#2196F3"
            }
          },
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 95,
              visible: true
            }
          },
          inputs: {
            periods: 21,
            errors: 2,
            method: "Simple",
            averagePeriods: 3
          }
        },
        styles: {
          plot_0: {
            title: "Plot 1"
          },
          plot_1: {
            title: "Plot 2"
          },
          plot_2: {
            title: "Plot 3"
          }
        },
        filledAreas: [{
          id: "fill_0",
          objAId: "plot_0",
          objBId: "plot_2",
          type: "plot_plot",
          title: "Background"
        }],
        inputs: [{
          id: "periods",
          type: "integer",
          name: "Periods"
        }, {
          id: "errors",
          type: "float",
          name: "Standard Errors"
        }, {
          id: "method",
          name: "Method",
          type: "text",
          defval: "Simple",
          options: ["Simple", "Exponential", "Weighted"]
        }, {
          id: "averagePeriods",
          type: "integer",
          name: "Averaging Periods"
        }],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.period = this._input(0);
          this.errorDeviation = this._input(1);
          this.maMethod = this._input(2);
          this.averagePeriod = this._input(3);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i;
          var s;
          var n = this._context.new_var(o.close(this._context));
          var r = 0;
          var a = 0;
          for (var l = 0; l < this.period; l++) {
            r += l + 1;
            a += n.get(l);
          }
          i = r / this.period;
          s = a / this.period;
          var c = 0;
          var h = 0;
          var d = 0;
          for (l = 0; l < this.period; l++) {
            d += Math.pow(s - n.get(l), 2);
            h += (i - l - 1) * (s - n.get(l));
            c += Math.pow(i - l - 1, 2);
          }
          h = Math.pow(h, 2);
          var u;
          var _;
          var p;
          var m = Math.sqrt((d - h / c) / (this.period - 2));
          var g = o.linreg(n, this.period, 0);
          var f = this._context.new_var(g + this.errorDeviation * m);
          var y = this._context.new_var(g);
          var v = this._context.new_var(g - this.errorDeviation * m);
          if (this.maMethod === "Simple") {
            u = o.sma(f, this.averagePeriod, this._context);
            _ = o.sma(y, this.averagePeriod, this._context);
            p = o.sma(v, this.averagePeriod, this._context);
          } else if (this.maMethod === "Exponential") {
            u = o.ema(f, this.averagePeriod, this._context);
            _ = o.ema(y, this.averagePeriod, this._context);
            p = o.ema(v, this.averagePeriod, this._context);
          } else {
            u = o.wma(f, this.averagePeriod, this._context);
            _ = o.wma(y, this.averagePeriod, this._context);
            p = o.wma(v, this.averagePeriod, this._context);
          }
          return [u, _, p];
        };
      }
    }, {
      name: "Fisher Transform",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            }
          },
          bands: [{
            color: "#E91E63",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 1.5
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0.75
          }, {
            color: "#E91E63",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: -0.75
          }, {
            color: "#E91E63",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: -1.5
          }],
          inputs: {
            in_0: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Fisher",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false,
            zorder: 1
          },
          plot_1: {
            title: "Trigger",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false,
            zorder: 1.1
          }
        },
        description: "Fisher Transform",
        shortDescription: "Fisher",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Level",
          isHidden: false,
          zorder: -1.1
        }, {
          id: "hline_1",
          name: "Level",
          isHidden: false,
          zorder: -1.11
        }, {
          id: "hline_2",
          name: "Level",
          isHidden: false,
          zorder: -1.111
        }, {
          id: "hline_3",
          name: "Level",
          isHidden: false,
          zorder: -1.1111
        }, {
          id: "hline_4",
          name: "Level",
          isHidden: false,
          zorder: -1.11111
        }],
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 1000000000000
        }],
        id: "fisher_transform@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Fisher Transform",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e) {
          var t = o.lt(e, -0.99) ? -0.999 : e;
          return [o.gt(e, 0.99) ? 0.999 : t];
        };
        this.f_1 = function () {
          var e = this._input(0);
          var t = this._context.new_var(o.hl2(this._context));
          var i = o.highest(t, e, this._context);
          var s = this._context.new_var(o.hl2(this._context));
          var n = o.lowest(s, e, this._context);
          var r = this._context.new_var();
          var a = this.f_0(((o.hl2(this._context) - n) / o.max(i - n, 0.001) - 0.5) * 0.66 + o.nz(r.get(1)) * 0.67);
          r.set(a[0]);
          var l = this._context.new_var();
          l.set(o.log((1 + r.get(0)) / o.max(1 - r.get(0), 0.001)) * 0.5 + o.nz(l.get(1)) * 0.5);
          var c = l.get(1);
          return [l.get(0), c];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return this.f_1();
        };
      }
    }, {
      name: "Historical Volatility",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 10
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "Historical Volatility",
        shortDescription: "HV",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 10,
          type: "integer",
          min: 1,
          max: 1000000000000
        }],
        id: "historical_volatility@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Historical Volatility",
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function () {
          var e = this._input(0);
          var t = o.or(o.isintraday(this._context), o.and(o.isdaily(this._context), o.eq(o.interval(this._context), 1))) ? 1 : 7;
          var i = this._context.new_var(o.close(this._context));
          var s = this._context.new_var(o.log(o.close(this._context) / i.get(1)));
          return [o.stdev(s, e, this._context) * 100 * o.sqrt(365 / t)];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return this.f_0();
        };
      }
    }, {
      name: "Hull MA",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Hull Moving Average",
        shortDescription: "HMA",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 10000
        }],
        id: "Hull MA@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Hull MA",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e * 2 - t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = s / 2;
          this._context.setMinimumAdditionalDepth(Math.ceil(s + n));
          var r = this._context.new_var(i);
          var a = o.wma(r, n, this._context);
          var l = this._context.new_var(i);
          var c = o.wma(l, s, this._context);
          var h = this.f_0(a, c);
          var d = o.sqrt(s);
          var u = o.round(d);
          var _ = this._context.new_var(h);
          return [o.wma(_, u, this._context)];
        };
      }
    }, {
      name: "Ichimoku Cloud",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: l
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#43A047"
            },
            plot_3: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#A5D6A7"
            },
            plot_4: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: r
            }
          },
          palettes: {
            palette_0: {
              colors: {
                0: {
                  color: "#43A047",
                  width: 1,
                  style: 0
                },
                1: {
                  color: a,
                  width: 1,
                  style: 0
                }
              }
            }
          },
          filledAreasStyle: {
            fill_0: {
              color: "#000080",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            symbol: "",
            in_0: 9,
            in_1: 26,
            in_2: 52,
            in_3: 26,
            in_4: 26
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }, {
          id: "plot_3",
          type: "line"
        }, {
          id: "plot_4",
          type: "line"
        }, {
          id: "plot_5",
          palette: "palette_0",
          target: "fill_0",
          type: "colorer"
        }],
        styles: {
          plot_0: {
            title: "Conversion Line",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          },
          plot_1: {
            title: "Base Line",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          },
          plot_2: {
            title: "Lagging Span",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          },
          plot_3: {
            title: "Leading Span A",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          },
          plot_4: {
            title: "Leading Span B",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "Ichimoku Cloud",
        shortDescription: "Ichimoku",
        is_price_study: true,
        is_hidden_study: false,
        id: "Ichimoku Cloud@tv-basicstudies-1",
        palettes: {
          palette_0: {
            colors: {
              0: {
                name: "Color 0"
              },
              1: {
                name: "Color 1"
              }
            },
            valToIndex: {
              0: 0,
              1: 1
            }
          }
        },
        filledAreas: [{
          id: "fill_0",
          objAId: "plot_3",
          objBId: "plot_4",
          type: "plot_plot",
          title: "Plots Background",
          isHidden: false,
          palette: "palette_0"
        }],
        inputs: [{
          id: "symbol",
          name: "Another symbol",
          defval: "",
          type: "symbol",
          optional: true,
          isHidden: false
        }, {
          id: "in_0",
          name: "Conversion Line Periods",
          defval: 9,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_1",
          name: "Base Line Periods",
          defval: 26,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_2",
          name: "Leading Span Periods",
          defval: 52,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_3",
          name: "Lagging Span Periods",
          defval: 26,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_4",
          name: "Leading Shift Periods",
          defval: 26,
          type: "integer",
          min: 1,
          max: 1000000000000
        }],
        scriptIdPart: "",
        name: "Ichimoku Cloud",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.donchian = function (e, t, i) {
          var s = this._context.new_var(e);
          var n = this._context.new_var(t);
          return o.avg(o.lowest(s, i, this._context), o.highest(n, i, this._context));
        };
        this.f_1 = function () {
          var e = this._input(1);
          var t = this._input(2);
          var i = this._input(3);
          var s = this._input(4) - 1;
          var n = this._input(5) - 1;
          var r = this._context.new_var(o.time(this._context));
          var a = o.close(this._context);
          var l = o.low(this._context);
          var c = o.high(this._context);
          if (this._input(0) !== "") {
            this._context.select_sym(1);
            var h = this._context.new_var(o.time(this._context));
            var d = o.close(this._context);
            var u = o.low(this._context);
            var _ = o.high(this._context);
            a = this._context.new_var(d).adopt(h, r, 1);
            l = this._context.new_var(u).adopt(h, r, 1);
            c = this._context.new_var(_).adopt(h, r, 1);
            this._context.select_sym(0);
          }
          var p = this.donchian(l, c, e);
          var m = this.donchian(l, c, t);
          var g = o.avg(p, m);
          var f = this.donchian(l, c, i);
          return [p, m, a, g, f, -s, s, n, o.gt(g, f) ? 0 : 1];
        };
        this.init = function (e, t) {
          this._context = e;
          if (t(0) !== "") {
            this._context.new_sym(t(0), o.period(this._context));
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this.f_1();
          return [i[0], i[1], {
            value: i[2],
            offset: i[5]
          }, {
            value: i[3],
            offset: i[7]
          }, {
            value: i[4],
            offset: i[7]
          }, i[8]];
        };
      }
    }, {
      name: "Keltner Channels",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 95,
              visible: true
            }
          },
          inputs: {
            in_0: true,
            in_1: 20,
            in_2: 1
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Upper",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Middle",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Lower",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Keltner Channels",
        shortDescription: "KC",
        is_price_study: true,
        filledAreas: [{
          id: "fill_0",
          objAId: "plot_0",
          objBId: "plot_2",
          type: "plot_plot",
          title: "Plots Background"
        }],
        inputs: [{
          id: "in_0",
          name: "useTrueRange",
          defval: true,
          type: "bool"
        }, {
          id: "in_1",
          name: "length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_2",
          name: "mult",
          defval: 1,
          type: "float",
          min: -1000000000000,
          max: 1000000000000
        }],
        id: "Keltner Channels@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Keltner Channels",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t, i, s) {
          if (e) {
            return t;
          } else {
            return i - s;
          }
        };
        this.f_1 = function (e, t, i) {
          return e + t * i;
        };
        this.f_2 = function (e, t, i) {
          return e - t * i;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = this._input(1);
          var r = this._input(2);
          var a = this._context.new_var(i);
          var l = o.ema(a, n, this._context);
          var c = this.f_0(s, o.tr(undefined, this._context), o.high(this._context), o.low(this._context));
          var h = this._context.new_var(c);
          var d = o.ema(h, n, this._context);
          return [this.f_1(l, d, r), l, this.f_2(l, d, r)];
        };
      }
    }, {
      name: "Klinger Oscillator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#43A047"
            }
          },
          inputs: {}
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Signal",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Klinger Oscillator",
        shortDescription: "Klinger Oscillator",
        is_price_study: false,
        inputs: [],
        id: "Klinger Oscillator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Klinger Oscillator",
        format: {
          type: "volume"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          if (o.ge(e, 0)) {
            return t;
          } else {
            return -t;
          }
        };
        this.f_1 = function (e, t) {
          return e - t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.hlc3(this._context);
          this._context.setMinimumAdditionalDepth(66);
          var s = this._context.new_var(i);
          var n = o.change(s);
          var r = this.f_0(n, o.volume(this._context));
          var a = this._context.new_var(r);
          var l = o.ema(a, 34, this._context);
          var c = this._context.new_var(r);
          var h = o.ema(c, 55, this._context);
          var d = this.f_1(l, h);
          var u = this._context.new_var(d);
          return [d, o.ema(u, 13, this._context)];
        };
      }
    }, {
      name: "Know Sure Thing",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: u
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: a
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 10,
            in_1: 15,
            in_2: 20,
            in_3: 30,
            in_4: 10,
            in_5: 10,
            in_6: 10,
            in_7: 15,
            in_8: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "KST",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1.1
          },
          plot_1: {
            title: "Signal",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1.11
          }
        },
        description: "Know Sure Thing",
        shortDescription: "KST",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Zero",
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "roclen1",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_1",
          name: "roclen2",
          defval: 15,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_2",
          name: "roclen3",
          defval: 20,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_3",
          name: "roclen4",
          defval: 30,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_4",
          name: "smalen1",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_5",
          name: "smalen2",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_6",
          name: "smalen3",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_7",
          name: "smalen4",
          defval: 15,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_8",
          name: "siglen",
          defval: 9,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_1"]
        }],
        id: "Know Sure Thing@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Know Sure Thing",
        format: {
          type: "price",
          precision: 4
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e, t, i, s) {
          return e + t * 2 + i * 3 + s * 4;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = this._input(2);
          var r = this._input(3);
          var a = this._input(4);
          var l = this._input(5);
          var c = this._input(6);
          var h = this._input(7);
          var d = this._input(8);
          this._context.setMinimumAdditionalDepth(Math.max(a + i, l + s, c + n, h + r) + d);
          var u = o.close(this._context);
          var _ = i;
          var p = this._context.new_var(u);
          var m = o.roc(p, _);
          var g = a;
          var f = this._context.new_var(m);
          var y = o.sma(f, g, this._context);
          var v = s;
          var S = this._context.new_var(u);
          var b = o.roc(S, v);
          var w = l;
          var C = this._context.new_var(b);
          var P = o.sma(C, w, this._context);
          var T = n;
          var x = this._context.new_var(u);
          var I = o.roc(x, T);
          var M = c;
          var A = this._context.new_var(I);
          var L = o.sma(A, M, this._context);
          var k = r;
          var D = this._context.new_var(u);
          var E = o.roc(D, k);
          var B = h;
          var V = this._context.new_var(E);
          var R = o.sma(V, B, this._context);
          var N = this.f_0(y, P, L, R);
          var O = this._context.new_var(N);
          return [N, o.sma(O, d, this._context)];
        };
      }
    }, {
      name: "Least Squares Moving Average",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 25,
            in_1: 0
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Least Squares Moving Average",
        shortDescription: "LSMA",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 25,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_1",
          name: "Offset",
          defval: 0,
          type: "integer",
          min: -1000000000000,
          max: 1000000000000
        }],
        id: "Least Squares Moving Average@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Least Squares Moving Average",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = o.close(this._context);
          var r = this._context.new_var(n);
          return [o.linreg(r, i, s)];
        };
      }
    }, {
      name: "Linear Regression Curve",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Linear Regression Curve",
        shortDescription: "LRC",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Linear Regression Curve@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Linear Regression Curve",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = this._context.new_var(i);
          return [o.linreg(n, s, 0)];
        };
      }
    }, {
      name: "Linear Regression Slope",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: false,
        id: "Linear Regression Slope@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Linear Regression Slope",
        description: "Linear Regression Slope",
        shortDescription: "Linear Regression Slope",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: c
            }
          },
          inputs: {
            periods: 14
          }
        },
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0
          }
        },
        inputs: [{
          id: "periods",
          type: "integer",
          name: "Periods",
          min: 2
        }],
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.period = this._input(0);
        };
        this.linregSlope = function (e, t, i) {
          var s;
          var o;
          var n;
          var r = 0;
          var a = 0;
          var l = 0;
          var c = 0;
          for (s = 0; s < t; ++s) {
            r += n = t - 1 - s + 1;
            a += o = e.get(s);
            l += n * n;
            c += o * n;
          }
          return (t * c - r * a) / (t * l - r * r);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(o.close(this._context));
          return [this.linregSlope(i, this.period, 0)];
        };
      }
    }, {
      name: "MA Cross",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#43A047"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 4,
              plottype: 3,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 9,
            in_1: 26
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Short",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Long",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Crosses",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "MA Cross",
        shortDescription: "MA Cross",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Short",
          defval: 9,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_0", "plot_2"]
        }, {
          id: "in_1",
          name: "Long",
          defval: 26,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_1", "plot_2"]
        }],
        id: "MA Cross@tv-basicstudies-1",
        scriptIdPart: "",
        name: "MA Cross",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          if (e) {
            return t;
          } else {
            return o.na();
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = o.close(this._context);
          var r = this._context.new_var(n);
          var a = o.sma(r, i, this._context);
          var l = this._context.new_var(n);
          var c = o.sma(l, s, this._context);
          var h = a;
          var d = c;
          var u = o.cross(a, c, this._context);
          return [h, d, this.f_0(u, a)];
        };
      }
    }, {
      name: "MA with EMA Cross",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#43A047"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 4,
              plottype: 3,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 10,
            in_1: 10
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "MA",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "EMA",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Crosses",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "MA with EMA Cross",
        shortDescription: "MA/EMA Cross",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Length MA",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_0", "plot_2"]
        }, {
          id: "in_1",
          name: "Length EMA",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_1", "plot_2"]
        }],
        id: "MA with EMA Cross@tv-basicstudies-1",
        scriptIdPart: "",
        name: "MA with EMA Cross",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          if (e) {
            return t;
          } else {
            return o.na();
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = o.close(this._context);
          var r = this._context.new_var(n);
          var a = o.sma(r, i, this._context);
          var l = this._context.new_var(n);
          var c = o.ema(l, s, this._context);
          var h = a;
          var d = c;
          var u = o.cross(a, c, this._context);
          return [h, d, this.f_0(u, a)];
        };
      }
    }, {
      name: "Mass Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 10
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Mass Index",
        shortDescription: "Mass Index",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Mass Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Mass Index",
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e - t;
        };
        this.f_1 = function (e, t) {
          return e / t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this.f_0(o.high(this._context), o.low(this._context));
          var n = this._context.new_var(s);
          var r = o.ema(n, 9, this._context);
          var a = this._context.new_var(r);
          var l = o.ema(a, 9, this._context);
          var c = this.f_1(r, l);
          var h = this._context.new_var(c);
          return [o.sum(h, i, this._context)];
        };
      }
    }, {
      name: "McGinley Dynamic",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "McGinley Dynamic",
        shortDescription: "McGinley Dynamic",
        is_price_study: true,
        is_hidden_study: false,
        id: "mcginley_dynamic@tv-basicstudies-1",
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 1000000000000
        }],
        scriptIdPart: "",
        name: "McGinley Dynamic",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function () {
          var e = this._input(0);
          var t = o.close(this._context);
          var i = this._context.new_var(t);
          var s = o.ema(i, e, this._context);
          var n = this._context.new_var();
          var r = n.get(1) + (t - n.get(1)) / (e * o.pow(t / n.get(1), 4));
          n.set(o.na(n.get(1)) ? s : o.nz(r, s));
          return [n.get(0)];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return this.f_0();
        };
      }
    }, {
      name: "Median Price",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        id: "Median Price@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Median Price",
        description: "Median Price",
        shortDescription: "Median Price",
        is_price_study: true,
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: "#FF6D00"
            }
          },
          inputs: {}
        },
        styles: {
          plot_0: {
            title: "Plot"
          }
        },
        inputs: [],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return [o.hl2(this._context)];
        };
      }
    }, {
      name: "Momentum",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 10,
            in_1: "close"
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Mom",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false,
            zorder: 0
          }
        },
        description: "Momentum",
        shortDescription: "Mom",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Zero",
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_1",
          name: "Source",
          defval: "close",
          type: "source",
          options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"]
        }],
        id: "Momentum@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Momentum",
        format: {
          type: "inherit"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = o[this._input(1)](this._context);
          var n = this._context.new_var(s).get(i);
          return [n ? s - n : null];
        };
      }
    }, {
      name: "Money Flow Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#7E57C2"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 80
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 20
          }],
          filledAreasStyle: {
            fill_0: {
              color: "#7E57C2",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Money Flow Index",
        shortDescription: "MFI",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "UpperLimit",
          zorder: -1.1
        }, {
          id: "hline_1",
          name: "LowerLimit",
          zorder: -1.11
        }],
        filledAreas: [{
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          title: "Hlines Background",
          zorder: -2
        }],
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Money Flow@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Money Flow Index",
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t, i) {
          return e * (o.le(t, 0) ? 0 : i);
        };
        this.f_1 = function (e, t, i) {
          return e * (o.ge(t, 0) ? 0 : i);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = o.hlc3(this._context);
          var n = this._context.new_var(s);
          var r = o.change(n);
          var a = this.f_0(o.volume(this._context), r, s);
          var l = this._context.new_var(a);
          var c = o.sum(l, i, this._context);
          var h = this.f_1(o.volume(this._context), r, s);
          var d = this._context.new_var(h);
          var u = o.sum(d, i, this._context);
          return [o.rsi(c, u)];
        };
      }
    }, {
      name: "Moving Average",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            smoothedMA: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: false
            }
          },
          inputs: {
            symbol: "",
            length: 9,
            source: "close",
            offset: 0,
            smoothingLine: "SMA",
            smoothingLength: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "smoothedMA",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          },
          smoothedMA: {
            title: "Smoothed MA",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Moving Average",
        shortDescription: "MA",
        is_price_study: true,
        inputs: [{
          id: "symbol",
          name: "Other Symbol",
          defval: "",
          type: "symbol",
          optional: true,
          isHidden: false
        }, {
          id: "length",
          name: "Length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "source",
          name: "Source",
          defval: "close",
          type: "source",
          options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"]
        }, {
          id: "offset",
          name: "Offset",
          defval: 0,
          type: "integer",
          min: -10000,
          max: 10000
        }, {
          id: "smoothingLine",
          name: "Smoothing Line",
          defval: "SMA",
          type: "text",
          options: ["SMA", "EMA", "WMA"],
          hideWhenPlotsHidden: ["smoothedMA"]
        }, {
          id: "smoothingLength",
          name: "Smoothing Length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["smoothedMA"]
        }],
        id: "Moving Average@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Moving Average",
        format: {
          type: "inherit"
        },
        symbolSource: {
          type: "symbolInputSymbolSource",
          inputId: "symbol"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          if (t(0) !== "") {
            this._context.new_sym(t(0), o.period(this._context));
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(this._context.symbol.time);
          var s = o[this._input(2)](this._context);
          var n = this._input(1);
          var r = this._input(3);
          var a = this._input(4);
          var l = this._input(5);
          this._context.setMinimumAdditionalDepth(n + l);
          if (this._input(0) !== "") {
            this._context.select_sym(1);
            var c = this._context.new_var(this._context.symbol.time);
            var h = o[this._input(2)](this._context);
            s = this._context.new_var(h).adopt(c, i, 1);
            this._context.select_sym(0);
          }
          var d;
          var u = this._context.new_var(s);
          var _ = o.sma(u, n, this._context);
          var p = this._context.new_var(_);
          if (a === "EMA") {
            d = o.ema(p, l, this._context);
          } else if (a === "WMA") {
            d = o.wma(p, l, this._context);
          } else if (a === "SMA") {
            d = o.sma(p, l, this._context);
          }
          return [{
            value: _,
            offset: r
          }, {
            value: d,
            offset: r
          }];
        };
      }
    }, {
      name: "Moving Average Channel",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            }
          },
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 20,
            in_1: 20,
            in_2: 0,
            in_3: 0
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Upper",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Lower",
            histogramBase: 0,
            joinPoints: false
          }
        },
        filledAreas: [{
          id: "fill_0",
          objAId: "plot_0",
          objBId: "plot_1",
          type: "plot_plot",
          title: "Plots Background"
        }],
        description: "Moving Average Channel",
        shortDescription: "MAC",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Upper Length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "in_1",
          name: "Lower Length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "in_2",
          name: "Upper Offset",
          defval: 0,
          type: "integer",
          min: -10000,
          max: 10000
        }, {
          id: "in_3",
          name: "Lower Offset",
          defval: 0,
          type: "integer",
          min: -10000,
          max: 10000
        }],
        id: "Moving Average Channel@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Moving Average Channel",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.high(this._context);
          var s = o.low(this._context);
          var n = this._input(0);
          var r = this._input(1);
          var a = this._input(2);
          var l = this._input(3);
          var c = this._context.new_var(i);
          var h = this._context.new_var(s);
          return [{
            value: o.sma(c, n, this._context),
            offset: a
          }, {
            value: o.sma(h, r, this._context),
            offset: l
          }];
        };
      }
    }, {
      name: "Moving Average Convergence/Divergence",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 5,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: c
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            }
          },
          palettes: {
            palette_0: {
              colors: {
                0: {
                  color: d,
                  width: 1,
                  style: 0
                },
                1: {
                  color: h,
                  width: 1,
                  style: 0
                },
                2: {
                  color: n,
                  width: 1,
                  style: 0
                },
                3: {
                  color: "#FF5252",
                  width: 1,
                  style: 0
                }
              }
            }
          },
          inputs: {
            symbol: "",
            in_0: 12,
            in_1: 26,
            in_3: "close",
            in_2: 9,
            oscillatorMAType: "EMA",
            signalLineMAType: "EMA"
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }, {
          id: "plot_3",
          palette: "palette_0",
          target: "plot_0",
          type: "colorer"
        }],
        styles: {
          plot_0: {
            title: "Histogram",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "MACD",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Signal",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "MACD",
        shortDescription: "MACD",
        is_price_study: false,
        palettes: {
          palette_0: {
            colors: {
              0: {
                name: "Color 0"
              },
              1: {
                name: "Color 1"
              },
              2: {
                name: "Color 2"
              },
              3: {
                name: "Color 3"
              }
            }
          }
        },
        inputs: [{
          id: "symbol",
          name: "Other Symbol",
          defval: "",
          type: "symbol",
          optional: true,
          isHidden: false
        }, {
          id: "in_0",
          name: "Fast Length",
          defval: 12,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_1",
          name: "Slow Length",
          defval: 26,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_3",
          name: "Source",
          defval: "close",
          type: "source",
          options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"]
        }, {
          id: "in_2",
          name: "Signal Length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 50
        }, {
          id: "oscillatorMAType",
          name: "Oscillator MA Type",
          defval: "EMA",
          type: "text",
          options: ["SMA", "EMA", "WMA"]
        }, {
          id: "signalLineMAType",
          name: "Signal Line MA Type",
          defval: "EMA",
          type: "text",
          options: ["SMA", "EMA", "WMA"]
        }],
        id: "Moving Average Convergence/Divergence@tv-basicstudies-1",
        scriptIdPart: "",
        name: "MACD",
        format: {
          type: "inherit"
        },
        symbolSource: {
          type: "symbolInputSymbolSource",
          inputId: "symbol"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e - t;
        };
        this.f_1 = function (e) {
          var t = e > 0 ? 1 : 3;
          var i = o.change(this._context.new_var(e));
          return t - (o.le(i, 0) ? 0 : 1);
        };
        this.init = function (e, t) {
          this._context = e;
          if (t(0) !== "") {
            this._context.new_sym(t(0), o.period(this._context));
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(this._context.symbol.time);
          var s = o[this._input(3)](this._context);
          var n = this._input(1);
          var r = this._input(2);
          var a = this._input(4);
          var l = this._input(5);
          var c = this._input(6);
          this._context.setMinimumAdditionalDepth(Math.max(n, r) + a);
          if (this._input(0) !== "") {
            this._context.select_sym(1);
            var h = this._context.new_var(this._context.symbol.time);
            var d = o[this._input(3)](this._context);
            s = this._context.new_var(d).adopt(h, i, 0);
            this._context.select_sym(0);
          }
          var u;
          var _;
          var p = this._context.new_var(s);
          if (l === "EMA") {
            u = o.ema(p, n, this._context);
          } else if (l === "WMA") {
            u = o.wma(p, n, this._context);
          } else if (l === "SMA") {
            u = o.sma(p, n, this._context);
          }
          if (l === "EMA") {
            _ = o.ema(p, r, this._context);
          } else if (l === "WMA") {
            _ = o.wma(p, r, this._context);
          } else if (l === "SMA") {
            _ = o.sma(p, r, this._context);
          }
          var m;
          var g = this.f_0(u, _);
          var f = this._context.new_var(g);
          if (c === "EMA") {
            m = o.ema(f, a, this._context);
          } else if (c === "WMA") {
            m = o.wma(f, a, this._context);
          } else if (c === "SMA") {
            m = o.sma(f, a, this._context);
          }
          var y = this.f_0(g, m);
          return [y, g, m, this.f_1(y)];
        };
      }
    }, {
      name: "Moving Average Exponential",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            smoothedMA: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: false
            }
          },
          inputs: {
            length: 9,
            source: "close",
            offset: 0,
            smoothingLine: "SMA",
            smoothingLength: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "smoothedMA",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          },
          smoothedMA: {
            title: "Smoothed MA",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Moving Average Exponential",
        shortDescription: "EMA",
        is_price_study: true,
        inputs: [{
          id: "length",
          name: "Length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "source",
          name: "Source",
          defval: "close",
          type: "source",
          options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"]
        }, {
          id: "offset",
          name: "Offset",
          defval: 0,
          type: "integer",
          min: -10000,
          max: 10000
        }, {
          id: "smoothingLine",
          name: "Smoothing Line",
          defval: "SMA",
          type: "text",
          options: ["SMA", "EMA", "WMA"],
          hideWhenPlotsHidden: ["smoothedMA"]
        }, {
          id: "smoothingLength",
          name: "Smoothing Length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["smoothedMA"]
        }],
        id: "Moving Average Exponential@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Moving Average Exponential",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o[this._input(1)](this._context);
          var s = this._input(0);
          var n = this._input(2);
          var r = this._input(3);
          var a = this._input(4);
          this._context.setMinimumAdditionalDepth(s + a);
          var l;
          var c = this._context.new_var(i);
          var h = o.ema(c, s, this._context);
          var d = this._context.new_var(h);
          if (r === "EMA") {
            l = o.ema(d, a, this._context);
          } else if (r === "WMA") {
            l = o.wma(d, a, this._context);
          } else if (r === "SMA") {
            l = o.sma(d, a, this._context);
          }
          return [{
            value: h,
            offset: n
          }, {
            value: l,
            offset: n
          }];
        };
      }
    }, {
      name: "Moving Average Weighted",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 9,
            in_1: "close",
            in_2: 0
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Moving Average Weighted",
        shortDescription: "WMA",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_1",
          name: "Source",
          defval: "close",
          type: "source",
          options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"]
        }, {
          id: "in_2",
          name: "Offset",
          defval: 0,
          type: "integer",
          min: -10000,
          max: 10000
        }],
        id: "Moving Average Weighted@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Moving Average Weighted",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o[this._input(1)](this._context);
          var s = this._input(0);
          var n = this._input(2);
          var r = this._context.new_var(i);
          return [{
            value: o.wma(r, s, this._context),
            offset: n
          }];
        };
      }
    }, {
      name: "Moving Average Double",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        id: "Moving Average Double@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Moving Average Double",
        description: "Moving Average Double",
        shortDescription: "Moving Average Double",
        is_price_study: true,
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: "#FF6D00"
            },
            plot_1: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: "#2196F3"
            }
          },
          inputs: {
            symbol: "",
            firstPeriods: 14,
            secondPeriods: 21,
            method: "Simple"
          }
        },
        styles: {
          plot_0: {
            title: "Plot 1"
          },
          plot_1: {
            title: "Plot 2"
          }
        },
        inputs: [{
          id: "symbol",
          name: "Another symbol",
          defval: "",
          type: "symbol",
          optional: true,
          isHidden: false
        }, {
          id: "firstPeriods",
          name: "1st Period",
          type: "integer",
          defval: 14,
          min: 1,
          max: 10000
        }, {
          id: "secondPeriods",
          name: "2nd Period",
          type: "integer",
          defval: 21,
          min: 1,
          max: 10000
        }, {
          id: "method",
          name: "Method",
          type: "text",
          defval: "Simple",
          options: ["Simple", "Exponential", "Weighted"]
        }],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          if (t(0) !== "") {
            this._context.new_sym(t(0), o.period(this._context));
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(o.time(this._context));
          var s = o.close(this._context);
          if (this._input(0) !== "") {
            this._context.select_sym(1);
            var n = this._context.new_var(o.time(this._context));
            var r = o.close(this._context);
            s = this._context.new_var(r).adopt(n, i, 1);
            this._context.select_sym(0);
          }
          var a;
          var l;
          var c = this._context.new_var(s);
          if (this._input(2) === "Exponential") {
            a = o.ema(c, this._input(1), this._context);
            l = o.ema(c, this._input(2), this._context);
          } else if (this._input(2) === "Weighted") {
            a = o.wma(c, this._input(1), this._context);
            l = o.wma(c, this._input(2), this._context);
          } else {
            a = o.sma(c, this._input(1), this._context);
            l = o.sma(c, this._input(2), this._context);
          }
          return [a, l];
        };
      }
    }, {
      name: "Moving Average Triple",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: true,
        id: "Moving Average Triple@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Moving Average Triple",
        description: "Moving Average Triple",
        shortDescription: "Moving Average Triple",
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              transparency: 0,
              trackPrice: false,
              color: "#FF6D00"
            },
            plot_1: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              transparency: 0,
              plottype: 0,
              trackPrice: false,
              color: "#2196F3"
            },
            plot_2: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              transparency: 0,
              plottype: 0,
              trackPrice: false,
              color: "#26C6DA"
            }
          },
          inputs: {
            symbol: "",
            firstPeriods: 14,
            secondPeriods: 21,
            thirdPeriods: 35,
            method: "Simple"
          }
        },
        styles: {
          plot_0: {
            title: "Plot 1"
          },
          plot_1: {
            title: "Plot 2"
          },
          plot_2: {
            title: "Plot 3"
          }
        },
        inputs: [{
          id: "symbol",
          name: "Other Symbol",
          defval: "",
          type: "symbol",
          optional: true,
          isHidden: false
        }, {
          id: "firstPeriods",
          name: "1st Period",
          type: "integer",
          defval: 14,
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["plot_0"]
        }, {
          id: "secondPeriods",
          name: "2nd Period",
          type: "integer",
          defval: 21,
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["plot_1"]
        }, {
          id: "thirdPeriods",
          name: "3rd Period",
          type: "integer",
          defval: 35,
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["plot_2"]
        }, {
          id: "method",
          name: "Method",
          type: "text",
          defval: "Simple",
          options: ["Simple", "Exponential", "Weighted"]
        }],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          if (t(0) !== "") {
            this._context.new_sym(t(0), o.period(this._context));
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(this._context.symbol.time);
          var s = o.close(this._context);
          if (this._input(0) !== "") {
            this._context.select_sym(1);
            var n = this._context.new_var(this._context.symbol.time);
            var r = o.close(this._context);
            s = this._context.new_var(r).adopt(n, i, 1);
            this._context.select_sym(0);
          }
          var a;
          var l;
          var c;
          var h = this._context.new_var(s);
          if (this._input(4) === "Exponential") {
            a = o.ema(h, this._input(1), this._context);
            l = o.ema(h, this._input(2), this._context);
            c = o.ema(h, this._input(3), this._context);
          } else if (this._input(4) === "Weighted") {
            a = o.wma(h, this._input(1), this._context);
            l = o.wma(h, this._input(2), this._context);
            c = o.wma(h, this._input(3), this._context);
          } else {
            a = o.sma(h, this._input(1), this._context);
            l = o.sma(h, this._input(2), this._context);
            c = o.sma(h, this._input(3), this._context);
          }
          return [a, l, c];
        };
      }
    }, {
      name: "Moving Average Adaptive",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: true,
        id: "Moving Average Adaptive@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Moving Average Adaptive",
        description: "Moving Average Adaptive",
        shortDescription: "Moving Average Adaptive",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              transparency: 0,
              trackPrice: false,
              color: "#AB47BC"
            }
          },
          inputs: {
            periods: 10
          }
        },
        styles: {
          plot_0: {
            title: "Plot 1"
          }
        },
        inputs: [{
          id: "periods",
          name: "Period",
          type: "integer",
          defval: 10,
          min: 2,
          max: 10000
        }],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.periods = this._input(0);
        };
        this.ama = function (e, t) {
          var i = this.periods;
          var s = this._context.new_var();
          var n = e.get();
          var r = o.stdev(t, i, this._context);
          var a = o.log(n / e.get(i)) / (r * Math.sqrt(i));
          var l = Math.abs(a) * 0.1;
          var c = (n - s.get(1)) * l + s.get(1);
          s.set(isNaN(c) ? n : c);
          return c;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(o.close(this._context));
          var s = this._context.new_var(o.log(i.get() / i.get(1)));
          return [this.ama(i, s)];
        };
      }
    }, {
      name: "Moving Average Hamming",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: true,
        id: "Moving Average Hamming@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Moving Average Hamming",
        description: "Moving Average Hamming",
        shortDescription: "Moving Average Hamming",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              transparency: 0,
              trackPrice: false,
              color: "#4CAF50"
            }
          },
          inputs: {
            periods: 10
          }
        },
        styles: {
          plot_0: {
            title: "Plot 1"
          }
        },
        inputs: [{
          id: "periods",
          name: "Period",
          type: "integer",
          defval: 10,
          min: 1,
          max: 10000
        }],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.periods = this._input(0);
          var i = [];
          var s = 0;
          for (var o = 1; o <= this.periods; ++o) {
            var n = Math.sin((1 + o) / this.periods * Math.PI / 2);
            i.unshift(n);
            s += n;
          }
          this.hmaFactors = i;
          this.hmaFactorsSum = s;
        };
        this.hma = function (e) {
          for (var t = this.periods, i = 0, s = 0; s < t; ++s) {
            i += e.get(t - s - 1) * this.hmaFactors[s];
          }
          return i /= this.hmaFactorsSum;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(o.close(this._context));
          return [this.hma(i)];
        };
      }
    }, {
      name: "Moving Average Multiple",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: true,
        id: "Moving Average Multiple@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Moving Average Multiple",
        description: "Moving Average Multiple",
        shortDescription: "Moving Average Multiple",
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }, {
          id: "plot_3",
          type: "line"
        }, {
          id: "plot_4",
          type: "line"
        }, {
          id: "plot_5",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              transparency: 0,
              trackPrice: false,
              color: "#9C27B0"
            },
            plot_1: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              transparency: 0,
              plottype: 0,
              trackPrice: false,
              color: "#FF6D00"
            },
            plot_2: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              transparency: 0,
              plottype: 0,
              trackPrice: false,
              color: "#43A047"
            },
            plot_3: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              transparency: 0,
              plottype: 0,
              trackPrice: false,
              color: "#26C6DA"
            },
            plot_4: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              transparency: 0,
              plottype: 0,
              trackPrice: false,
              color: "#F50057"
            },
            plot_5: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              transparency: 0,
              plottype: 0,
              trackPrice: false,
              color: "#2196F3"
            }
          },
          inputs: {
            symbol: "",
            firstPeriods: 14,
            secondPeriods: 21,
            thirdPeriods: 35,
            fourthPeriods: 50,
            fifthPeriods: 100,
            sixthPeriods: 200,
            method: "Simple"
          }
        },
        styles: {
          plot_0: {
            title: "Plot 1"
          },
          plot_1: {
            title: "Plot 2"
          },
          plot_2: {
            title: "Plot 3"
          },
          plot_3: {
            title: "Plot 4"
          },
          plot_4: {
            title: "Plot 5"
          },
          plot_5: {
            title: "Plot 6"
          }
        },
        inputs: [{
          id: "symbol",
          name: "Other Symbol",
          defval: "",
          type: "symbol",
          optional: true,
          isHidden: false
        }, {
          id: "firstPeriods",
          name: "1st Period",
          type: "integer",
          defval: 14,
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["plot_0"]
        }, {
          id: "secondPeriods",
          name: "2nd Period",
          type: "integer",
          defval: 21,
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["plot_1"]
        }, {
          id: "thirdPeriods",
          name: "3rd Period",
          type: "integer",
          defval: 35,
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["plot_2"]
        }, {
          id: "fourthPeriods",
          name: "4th Period",
          type: "integer",
          defval: 50,
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["plot_3"]
        }, {
          id: "fifthPeriods",
          name: "5th Period",
          type: "integer",
          defval: 100,
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["plot_4"]
        }, {
          id: "sixthPeriods",
          name: "6th Period",
          type: "integer",
          defval: 200,
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["plot_5"]
        }, {
          id: "method",
          name: "Method",
          type: "text",
          defval: "Simple",
          options: ["Simple", "Exponential", "Weighted"]
        }],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          if (t(0) !== "") {
            this._context.new_sym(t(0), o.period(this._context));
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(this._context.symbol.time);
          var s = o.close(this._context);
          if (this._input(0) !== "") {
            this._context.select_sym(1);
            var n = this._context.new_var(this._context.symbol.time);
            var r = o.close(this._context);
            s = this._context.new_var(r).adopt(n, i, 1);
            this._context.select_sym(0);
          }
          var a;
          var l;
          var c;
          var h;
          var d;
          var u;
          var _ = this._context.new_var(s);
          if (this._input(7) === "Exponential") {
            a = o.ema(_, this._input(1), this._context);
            l = o.ema(_, this._input(2), this._context);
            c = o.ema(_, this._input(3), this._context);
            h = o.ema(_, this._input(4), this._context);
            d = o.ema(_, this._input(5), this._context);
            u = o.ema(_, this._input(6), this._context);
          } else if (this._input(7) === "Weighted") {
            a = o.wma(_, this._input(1), this._context);
            l = o.wma(_, this._input(2), this._context);
            c = o.wma(_, this._input(3), this._context);
            h = o.wma(_, this._input(4), this._context);
            d = o.wma(_, this._input(5), this._context);
            u = o.wma(_, this._input(6), this._context);
          } else {
            a = o.sma(_, this._input(1), this._context);
            l = o.sma(_, this._input(2), this._context);
            c = o.sma(_, this._input(3), this._context);
            h = o.sma(_, this._input(4), this._context);
            d = o.sma(_, this._input(5), this._context);
            u = o.sma(_, this._input(6), this._context);
          }
          return [a, l, c, h, d, u];
        };
      }
    }, {
      name: "Majority Rule",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: false,
        id: "Majority Rule@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Majority Rule",
        description: "Majority Rule",
        shortDescription: "Majority Rule",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: c
            }
          },
          inputs: {
            rollingPeriod: 14
          }
        },
        styles: {
          plot_0: {
            title: "Majority Rule"
          }
        },
        inputs: [{
          id: "rollingPeriod",
          type: "integer",
          name: "Rolling Period",
          min: 1
        }],
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.rollingPeriod = this._input(0);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i;
          var s = o.close(this._context);
          i = s > this._context.new_var(s).get(1) ? 1 : 0;
          return [o.sma(this._context.new_var(i), this.rollingPeriod, this._context) * 100];
        };
      }
    }, {
      name: "Net Volume",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {}
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Net Volume",
        shortDescription: "Net Volume",
        is_price_study: false,
        inputs: [],
        id: "Net Volume@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Net Volume",
        format: {
          type: "volume"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t, i) {
          if (o.gt(e, 0)) {
            return t;
          } else if (o.lt(i, 0)) {
            return -t;
          } else {
            return t * 0;
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._context.new_var(i);
          var n = o.change(s);
          return [this.f_0(n, o.volume(this._context), n)];
        };
      }
    }, {
      name: "On Balance Volume",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            smoothedMA: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: false
            }
          },
          inputs: {
            smoothingLine: "SMA",
            smoothingLength: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "smoothedMA",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          },
          smoothedMA: {
            title: "Smoothed MA",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "On Balance Volume",
        shortDescription: "OBV",
        is_price_study: false,
        inputs: [{
          id: "smoothingLine",
          name: "Smoothing Line",
          defval: "SMA",
          type: "text",
          options: ["SMA", "EMA", "WMA"],
          hideWhenPlotsHidden: ["smoothedMA"]
        }, {
          id: "smoothingLength",
          name: "Smoothing Length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["smoothedMA"]
        }],
        id: "On Balance Volume@tv-basicstudies-1",
        scriptIdPart: "",
        name: "On Balance Volume",
        format: {
          type: "volume"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t, i) {
          if (o.gt(e, 0)) {
            return t;
          } else if (o.lt(i, 0)) {
            return -t;
          } else {
            return t * 0;
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = o.close(this._context);
          var r = this._context.new_var(n);
          var a = o.change(r);
          var l = this.f_0(a, o.volume(this._context), a);
          var c = o.cum(l, this._context);
          this._context.setMinimumAdditionalDepth(s);
          var h;
          var d = this._context.new_var(c);
          if (i === "EMA") {
            h = o.ema(d, s, this._context);
          } else if (i === "WMA") {
            h = o.wma(d, s, this._context);
          } else if (i === "SMA") {
            h = o.sma(d, s, this._context);
          }
          return [c, h];
        };
      }
    }, {
      name: "Parabolic SAR",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 3,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 0.02,
            in_1: 0.02,
            in_2: 0.2,
            symbol: ""
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Parabolic SAR",
        shortDescription: "SAR",
        is_price_study: true,
        inputs: [{
          id: "symbol",
          name: "Other Symbol",
          defval: "",
          type: "symbol",
          optional: true,
          isHidden: false
        }, {
          id: "in_0",
          name: "start",
          defval: 0.02,
          type: "float",
          min: -1000000000000,
          max: 1000000000000
        }, {
          id: "in_1",
          name: "increment",
          defval: 0.02,
          type: "float",
          min: -1000000000000,
          max: 1000000000000
        }, {
          id: "in_2",
          name: "maximum",
          defval: 0.2,
          type: "float",
          min: -1000000000000,
          max: 1000000000000
        }],
        id: "Parabolic SAR@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Parabolic SAR",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          if (t(0) !== "") {
            this._context.new_sym(t(0), o.period(this._context));
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          const i = () => o.sar(this._input(1), this._input(2), this._input(3), this._context);
          if (this._input(0) === "") {
            return [i()];
          }
          this._context.select_sym(0);
          const s = this._context.new_var(this._context.symbol.time);
          this._context.select_sym(1);
          const n = this._context.new_var(i()).adopt(this._context.new_var(this._context.symbol.time), s, 1);
          this._context.select_sym(0);
          return [n];
        };
      }
    }, {
      name: "Price Channel",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#F50057"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#F50057"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 20,
            in_1: 0
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Highprice Line",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Lowprice Line",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Centerprice Line",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Price Channel",
        shortDescription: "PC",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 20,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_1",
          name: "Offset Length",
          defval: 0,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Price Channel@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Price Channel",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.high(this._context);
          var s = this._context.new_var(i);
          var n = o.low(this._context);
          var r = this._context.new_var(n);
          var a = this._input(0);
          var l = this._input(1);
          var c = o.highest(s, a, this._context);
          var h = o.lowest(r, a, this._context);
          return [{
            value: c,
            offset: l
          }, {
            value: h,
            offset: l
          }, {
            value: o.avg(c, h),
            offset: l
          }];
        };
      }
    }, {
      name: "Price Oscillator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: u
            }
          },
          inputs: {
            in_0: 10,
            in_1: 21
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Price Oscillator",
        shortDescription: "PPO",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "shortlen",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_1",
          name: "longlen",
          defval: 21,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Price Oscillator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Price Oscillator",
        format: {
          type: "price",
          precision: 2
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return (e - t) / t * 100;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = this._input(1);
          var r = this._context.new_var(i);
          var a = o.sma(r, s, this._context);
          var l = this._context.new_var(i);
          var c = o.sma(l, n, this._context);
          return [this.f_0(a, c)];
        };
      }
    }, {
      name: "Price Volume Trend",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {}
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "PVT",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "Price Volume Trend",
        shortDescription: "PVT",
        is_price_study: false,
        is_hidden_study: false,
        id: "price_volume_trend@tv-basicstudies-1",
        inputs: [],
        scriptIdPart: "",
        name: "Price Volume Trend",
        format: {
          type: "volume"
        }
      },
      constructor: function () {
        this.f_0 = function () {
          var e = this._context.new_var(o.close(this._context));
          return [o.cum(o.change(e) / e.get(1) * o.volume(this._context), this._context)];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return [this.f_0()[0]];
        };
      }
    }, {
      name: "Rank Correlation Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 12
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "RCI",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false,
            zorder: 1
          }
        },
        description: "Rank Correlation Index",
        shortDescription: "RCI",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Zero Line",
          isHidden: false,
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 12,
          type: "integer",
          min: 1,
          max: 1000000000000
        }],
        id: "rank_correlation_index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Rank Correlation Index",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.orderRank = function (e, t, i) {
          let s = e.get(t);
          let n = 1;
          let r = 0;
          for (let t = 0; t < i; t++) {
            const i = e.get(t);
            if (o.na(i)) {
              return o.na();
            }
            if (s < i) {
              n += 1;
            } else if (s === i) {
              r += 1;
            }
          }
          return n + (r - 1) / 2;
        };
        this.rankDifferences = function (e, t) {
          var i = 0;
          for (let s = 0; s < t; s++) {
            i += Math.pow(s + 1 - this.orderRank(e, s, t), 2);
          }
          return i;
        };
        this.rci = function (e, t) {
          return 1 - this.rankDifferences(e, t) * 6 / (t * (t * t - 1));
        };
        this.main = function (e, t) {
          var i = e.new_var(o.close(e));
          var s = t(0);
          return [this.rci(i, s)];
        };
      }
    }, {
      name: "Rate Of Change",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "ROC",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false,
            zorder: 1
          }
        },
        description: "Rate Of Change",
        shortDescription: "ROC",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Zero Line",
          isHidden: false,
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 1000000000000
        }],
        id: "rate_of_change@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Rate Of Change",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(o.close(this._context));
          var s = this._input(0);
          return [(i.get(0) - i.get(s)) * 100 / i.get(s)];
        };
      }
    }, {
      name: "Relative Strength Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#7E57C2"
            },
            smoothedMA: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: false
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 70,
            zorder: -1.1
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 50,
            zorder: -1.11
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 30,
            zorder: -1.111
          }],
          filledAreasStyle: {
            fill_0: {
              color: "#7E57C2",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            length: 14,
            smoothingLine: "SMA",
            smoothingLength: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "smoothedMA",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          },
          smoothedMA: {
            title: "Smoothed MA",
            histogramBase: 0,
            joinPoints: false,
            zorder: 2
          }
        },
        description: "Relative Strength Index",
        shortDescription: "RSI",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "UpperLimit",
          zorder: -1.1
        }, {
          id: "hline_2",
          name: "MiddleLimit",
          zorder: -1.11
        }, {
          id: "hline_1",
          name: "LowerLimit",
          zorder: -1.111
        }],
        filledAreas: [{
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          title: "Hlines Background",
          zorder: -2
        }],
        inputs: [{
          id: "length",
          name: "Length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "smoothingLine",
          name: "Smoothing Line",
          defval: "SMA",
          type: "text",
          options: ["SMA", "EMA", "WMA"],
          hideWhenPlotsHidden: ["smoothedMA"]
        }, {
          id: "smoothingLength",
          name: "Smoothing Length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 10000,
          hideWhenPlotsHidden: ["smoothedMA"]
        }],
        id: "Relative Strength Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Relative Strength Index",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e) {
          return o.max(e, 0);
        };
        this.f_1 = function (e) {
          return -o.min(e, 0);
        };
        this.f_2 = function (e, t) {
          if (o.eq(e, 0)) {
            return 100;
          } else if (o.eq(t, 0)) {
            return 0;
          } else {
            return 100 - 100 / (1 + t / e);
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = this._input(1);
          var r = this._input(2);
          this._context.setMinimumAdditionalDepth(s + r);
          var a;
          var l = this._context.new_var(i);
          var c = o.change(l);
          var h = this.f_0(c);
          var d = this._context.new_var(h);
          var u = o.rma(d, s, this._context);
          var _ = this.f_1(c);
          var p = this._context.new_var(_);
          var m = o.rma(p, s, this._context);
          var g = this.f_2(m, u);
          var f = this._context.new_var(g);
          if (n === "EMA") {
            a = o.ema(f, r, this._context);
          } else if (n === "WMA") {
            a = o.wma(f, r, this._context);
          } else if (n === "SMA") {
            a = o.sma(f, r, this._context);
          }
          return [{
            value: g
          }, {
            value: a
          }];
        };
      }
    }, {
      name: "Relative Vigor Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: u
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: a
            }
          },
          inputs: {
            in_0: 10
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "RVGI",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Signal",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Relative Vigor Index",
        shortDescription: "RVGI",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Relative Vigor Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Relative Vigor Index",
        format: {
          precision: 4,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e - t;
        };
        this.f_1 = function (e, t) {
          return e / t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this.f_0(o.close(this._context), o.open(this._context));
          var n = this._context.new_var(s);
          var r = o.swma(n, this._context);
          var a = this._context.new_var(r);
          var l = o.sum(a, i, this._context);
          var c = this.f_0(o.high(this._context), o.low(this._context));
          var h = this._context.new_var(c);
          var d = o.swma(h, this._context);
          var u = this._context.new_var(d);
          var _ = o.sum(u, i, this._context);
          var p = this.f_1(l, _);
          var m = this._context.new_var(p);
          return [p, o.swma(m, this._context)];
        };
      }
    }, {
      name: "Relative Volatility Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#7E57C2"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 80
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 20
          }],
          filledAreasStyle: {
            fill_0: {
              color: "#7E57C2",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 10
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Relative Volatility Index",
        shortDescription: "RVI",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "UpperLimit",
          zorder: -1.1
        }, {
          id: "hline_1",
          name: "LowerLimit",
          zorder: -1.11
        }],
        filledAreas: [{
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          title: "Hlines Background",
          zorder: -2
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 10,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Relative Volatility Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Relative Volatility Index",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          if (o.le(e, 0)) {
            return 0;
          } else {
            return t;
          }
        };
        this.f_1 = function (e, t) {
          if (o.gt(e, 0)) {
            return 0;
          } else {
            return t;
          }
        };
        this.f_2 = function (e, t) {
          return e / (e + t) * 100;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          this._context.setMinimumAdditionalDepth(i + 12);
          var s = o.close(this._context);
          var n = this._context.new_var(s);
          var r = o.stdev(n, i, this._context);
          var a = this._context.new_var(s);
          var l = o.change(a);
          var c = this.f_0(l, r);
          var h = this._context.new_var(c);
          var d = o.ema(h, 14, this._context);
          var u = this.f_1(l, r);
          var _ = this._context.new_var(u);
          var p = o.ema(_, 14, this._context);
          return [this.f_2(d, p)];
        };
      }
    }, {
      name: "SMI Ergodic Indicator/Oscillator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 1,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: c
            }
          },
          inputs: {
            in_0: 5,
            in_1: 20,
            in_2: 5
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Indicator",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Signal",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Oscillator",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "SMI Ergodic Indicator/Oscillator",
        shortDescription: "SMIIO",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "shortlen",
          defval: 5,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_1",
          name: "longlen",
          defval: 20,
          type: "integer",
          min: 1,
          max: 2000
        }, {
          id: "in_2",
          name: "siglen",
          defval: 5,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_1"]
        }],
        id: "SMI Ergodic Indicator/Oscillator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "SMI Ergodic Indicator/Oscillator",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return e - t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = this._input(2);
          this._context.setMinimumAdditionalDepth(i + s + n);
          var r = o.close(this._context);
          var a = this._context.new_var(r);
          var l = o.tsi(a, i, s, this._context);
          var c = this._context.new_var(l);
          var h = o.ema(c, n, this._context);
          return [l, h, this.f_0(l, h)];
        };
      }
    }, {
      name: "Smoothed Moving Average",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#673AB7"
            }
          },
          inputs: {
            in_0: 7,
            in_1: "close"
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "Smoothed Moving Average",
        shortDescription: "SMMA",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Length",
          defval: 7,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_1",
          name: "Source",
          defval: "close",
          type: "source",
          options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"]
        }],
        id: "smoothed_moving_average@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Smoothed Moving Average",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function () {
          var e = this._input(0);
          var t = o[this._input(1)](this._context);
          return [o.smma(t, e, this._context)];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return this.f_0();
        };
      }
    }, {
      name: "Standard Deviation",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        id: "Standard Deviation@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Standard Deviation",
        description: "Standard Deviation",
        shortDescription: "Standard Deviation",
        is_price_study: false,
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: u
            }
          },
          inputs: {
            periods: 5,
            deviations: 1
          }
        },
        styles: {
          plot_0: {
            title: "Plot"
          }
        },
        inputs: [{
          id: "periods",
          name: "Periods",
          type: "integer"
        }, {
          id: "deviations",
          name: "Deviations",
          type: "float"
        }],
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = this._context.new_var(o.close(this._context));
          return [o.stdev(n, i, this._context) * s];
        };
      }
    }, {
      name: "Stochastic",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 80
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 20
          }],
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 14,
            in_1: 1,
            in_2: 3
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "%K",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1.1
          },
          plot_1: {
            title: "%D",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1.11
          }
        },
        description: "Stochastic",
        shortDescription: "Stoch",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "UpperLimit",
          zorder: -1.1
        }, {
          id: "hline_1",
          name: "LowerLimit",
          zorder: -1.11
        }],
        filledAreas: [{
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          title: "Hlines Background",
          zorder: -2
        }],
        inputs: [{
          id: "in_0",
          name: "%K Length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "in_1",
          name: "%K Smoothing",
          defval: 1,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "in_2",
          name: "%D Smoothing",
          defval: 3,
          type: "integer",
          min: 1,
          max: 10000
        }],
        id: "Stochastic@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Stochastic",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = this._input(2);
          this._context.setMinimumAdditionalDepth(i + s + n);
          var r = o.close(this._context);
          var a = o.high(this._context);
          var l = o.low(this._context);
          var c = this._context.new_var(r);
          var h = this._context.new_var(a);
          var d = this._context.new_var(l);
          var u = o.stoch(c, h, d, i, this._context);
          var _ = this._context.new_var(u);
          var p = o.sma(_, s, this._context);
          var m = this._context.new_var(p);
          return [p, o.sma(m, n, this._context)];
        };
      }
    }, {
      name: "Stochastic RSI",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#FF6D00"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 80
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 20
          }],
          filledAreasStyle: {
            fill_0: {
              color: "#2196F3",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 14,
            in_1: 14,
            in_2: 3,
            in_3: 3
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "%K",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1.1
          },
          plot_1: {
            title: "%D",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1.11
          }
        },
        description: "Stochastic RSI",
        shortDescription: "Stoch RSI",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "UpperLimit",
          zorder: -1.1
        }, {
          id: "hline_1",
          name: "LowerLimit",
          zorder: -1.11
        }],
        filledAreas: [{
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          title: "Hlines Background",
          zorder: -2
        }],
        inputs: [{
          id: "in_0",
          name: "lengthRSI",
          defval: 14,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "in_1",
          name: "lengthStoch",
          defval: 14,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "in_2",
          name: "smoothK",
          defval: 3,
          type: "integer",
          min: 1,
          max: 10000
        }, {
          id: "in_3",
          name: "smoothD",
          defval: 3,
          type: "integer",
          min: 1,
          max: 10000
        }],
        id: "Stochastic RSI@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Stochastic RSI",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_1 = function (e, t, i) {
          var s = i.new_var(o.max(o.change(e), 0));
          return o.rma(s, t, i);
        };
        this.f_2 = function (e, t, i) {
          var s = i.new_var(-o.min(o.change(e), 0));
          return o.rma(s, t, i);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = this._input(1);
          var r = this._input(2);
          var a = this._input(3);
          e.setMinimumAdditionalDepth(s + n + r + a);
          var l = this._context.new_var(i);
          var c = o.rsi(this.f_1(l, s, this._context), this.f_2(l, s, this._context));
          var h = this._context.new_var(c);
          var d = this._context.new_var(c);
          var u = this._context.new_var(c);
          var _ = o.stoch(h, d, u, n, this._context);
          var p = this._context.new_var(_);
          var m = o.sma(p, r, this._context);
          var g = this._context.new_var(m);
          return [m, o.sma(g, a, this._context)];
        };
      }
    }, {
      name: "TRIX",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: a
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 18
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "TRIX",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "TRIX",
        shortDescription: "TRIX",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Zero",
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 18,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "TRIX@tv-basicstudies-1",
        scriptIdPart: "",
        name: "TRIX",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e) {
          return o.log(e);
        };
        this.f_1 = function (e) {
          return e * 10000;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          e.setMinimumAdditionalDepth(i * 3);
          var s = this.f_0(o.close(this._context));
          var n = this._context.new_var(s);
          var r = o.ema(n, i, this._context);
          var a = this._context.new_var(r);
          var l = o.ema(a, i, this._context);
          var c = this._context.new_var(l);
          var h = o.ema(c, i, this._context);
          var d = this._context.new_var(h);
          var u = o.change(d);
          return [this.f_1(u)];
        };
      }
    }, {
      name: "Triple EMA",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 9
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Triple EMA",
        shortDescription: "TEMA",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 9,
          type: "integer",
          min: 1,
          max: 10000
        }],
        id: "Triple EMA@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Triple EMA",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t, i) {
          return (e - t) * 3 + i;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          this._context.setMinimumAdditionalDepth(i * 3);
          var s = o.close(this._context);
          var n = this._context.new_var(s);
          var r = o.ema(n, i, this._context);
          var a = this._context.new_var(r);
          var l = o.ema(a, i, this._context);
          var c = this._context.new_var(l);
          var h = o.ema(c, i, this._context);
          return [this.f_0(r, l, h)];
        };
      }
    }, {
      name: "True Strength Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#E91E63"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 25,
            in_1: 13,
            in_2: 13
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "True Strength Index",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1.1
          },
          plot_1: {
            title: "Signal",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1.11
          }
        },
        description: "True Strength Index",
        shortDescription: "True Strength Index",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Zero",
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "long",
          defval: 25,
          type: "integer",
          min: 1,
          max: 4999
        }, {
          id: "in_1",
          name: "short",
          defval: 13,
          type: "integer",
          min: 1,
          max: 4999
        }, {
          id: "in_2",
          name: "siglen",
          defval: 13,
          type: "integer",
          min: 1,
          max: 4999,
          hideWhenPlotsHidden: ["plot_1"]
        }],
        id: "True Strength Indicator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "True Strength Index",
        format: {
          precision: 4,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = this._input(2);
          this._context.setMinimumAdditionalDepth(this._input(0) + this._input(1) + this._input(2));
          var r = o.close(this._context);
          var a = this._context.new_var(r);
          var l = o.tsi(a, s, i, this._context);
          var c = this._context.new_var(l);
          return [l, o.ema(c, n, this._context)];
        };
      }
    }, {
      name: "Trend Strength Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: false,
        id: "Trend Strength Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Trend Strength Index",
        description: "Trend Strength Index",
        shortDescription: "Trend Strength Index",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: c
            }
          },
          inputs: {
            periods: 14
          }
        },
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0
          }
        },
        inputs: [{
          id: "periods",
          type: "integer",
          name: "Periods"
        }],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.period = this._input(0);
          this.invertedPeriod = 1 / this.period;
          this.sumX = (this.period - 1) * this.period / 2;
          this.sumXX = (this.period - 1) * this.period * (this.period * 2 - 1) / 6;
          this.invertedPeriodSumXSumX = this.invertedPeriod * this.sumX * this.sumX;
        };
        this.trendStrengthIndex = function () {
          var e = this._context.new_var(o.close(this._context));
          var t = o.sum(e, this.period, this._context);
          var i = 0;
          var s = 0;
          for (var n = 0; n < this.period; n++) {
            var r = e.get(n);
            s += (this.period - 1 - n) * r;
            i += r * r;
          }
          var a = s - this.invertedPeriod * this.sumX * t;
          var l = (this.sumXX - this.invertedPeriodSumXSumX) * (i - this.invertedPeriod * t * t);
          if (l < 0) {
            if (a == 0) {
              return 0;
            } else if (a > 0) {
              return 1;
            } else {
              return -1;
            }
          } else {
            return a / (l = Math.sqrt(l));
          }
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return [this.trendStrengthIndex()];
        };
      }
    }, {
      name: "Typical Price",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        id: "TypicalPrice@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Typical Price",
        description: "Typical Price",
        shortDescription: "Typical Price",
        is_price_study: true,
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: "#FF6D00"
            }
          },
          inputs: {}
        },
        styles: {
          plot_0: {
            title: "Plot"
          }
        },
        inputs: [],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return [o.hlc3(this._context)];
        };
      }
    }, {
      name: "Ultimate Oscillator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: a
            }
          },
          inputs: {
            in_0: 7,
            in_1: 14,
            in_2: 28
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "UO",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "Ultimate Oscillator",
        shortDescription: "UO",
        is_price_study: false,
        inputs: [{
          id: "in_0",
          name: "length7",
          defval: 7,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_1",
          name: "length14",
          defval: 14,
          type: "integer",
          min: 1,
          max: 1000000000000
        }, {
          id: "in_2",
          name: "length28",
          defval: 28,
          type: "integer",
          min: 1,
          max: 1000000000000
        }],
        id: "ultimate_oscillator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Ultimate Oscillator",
        format: {
          precision: 2,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function (e, t, i) {
          var s = this._context.new_var(e);
          var n = this._context.new_var(t);
          return [o.sum(s, i, this._context) / o.sum(n, i, this._context)];
        };
        this.f_1 = function () {
          var e = this._input(0);
          var t = this._input(1);
          var i = this._input(2);
          var s = this._context.new_var(o.close(this._context));
          var n = o.max(o.high(this._context), s.get(1));
          var r = this._context.new_var(o.close(this._context));
          var a = o.min(o.low(this._context), r.get(1));
          var l = o.close(this._context) - a;
          var c = n - a;
          var h = this.f_0(l, c, e);
          var d = this.f_0(l, c, t);
          var u = this.f_0(l, c, i);
          return [(h[0] * 4 + d[0] * 2 + u[0]) * 100 / 7];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return this.f_1();
        };
      }
    }, {
      name: "Volatility Close-to-Close",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: false,
        id: "Volatility Close-to-Close@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Volatility Close-to-Close",
        description: "Volatility Close-to-Close",
        shortDescription: "Volatility Close-to-Close",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: "#2196F3"
            }
          },
          inputs: {
            periods: 10,
            daysPerYear: 252
          }
        },
        styles: {
          plot_0: {
            title: "Plot"
          }
        },
        inputs: [{
          id: "periods",
          name: "Periods",
          type: "integer",
          defval: 10,
          min: 2
        }, {
          id: "daysPerYear",
          name: "Days Per Year",
          type: "integer",
          defval: 252,
          min: 1,
          max: 366
        }],
        format: {
          precision: 2,
          type: "percent"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.period = this._input(0);
          this.daysPerYear = this._input(1);
        };
        this.stdev = function (e, t, i) {
          var s = this.variance(e, t, i);
          return o.sqrt(s);
        };
        this.variance = function (e, t, i) {
          var s = o.sma(e, t, i);
          return this.variance2(e, s, t);
        };
        this.variance2 = function (e, t, i) {
          var s;
          var o;
          var n = 0;
          for (s = 0; s < i; s++) {
            n += (o = e.get(s) - t) * o;
          }
          return n / (i - 1);
        };
        this.standardHistVol = function () {
          var e = this._context.new_var(o.close(this._context));
          var t = this._context.new_var(o.log(e.get() / e.get(1)));
          return this.stdev(t, this.period, this._context) * 100 * o.sqrt(this.daysPerYear);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return [this.standardHistVol()];
        };
      }
    }, {
      name: "Volatility Zero Trend Close-to-Close",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: false,
        id: "Volatility Zero Trend Close-to-Close@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Volatility Zero Trend Close-to-Close",
        description: "Volatility Zero Trend Close-to-Close",
        shortDescription: "Volatility Zero Trend Close-to-Close",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: "#2196F3"
            }
          },
          inputs: {
            periods: 10,
            daysPerYear: 252
          }
        },
        styles: {
          plot_0: {
            title: "Plot"
          }
        },
        inputs: [{
          id: "periods",
          name: "Periods",
          type: "integer",
          min: 0,
          max: 10000
        }, {
          id: "daysPerYear",
          name: "Days Per Year",
          type: "integer"
        }],
        format: {
          precision: 2,
          type: "percent"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.period = this._input(0);
          this.daysPerYear = this._input(1);
        };
        this.volatliityZTCTC = function () {
          this._context.setMinimumAdditionalDepth(this._input(0) + 1);
          var e = this._context.new_var(o.close(this._context));
          var t = this._context.new_var(e.symbol.time);
          var i = Math.sqrt((t.get(0) - t.get(1)) / 86400000 / this.daysPerYear);
          var s = Math.log(o.close(this._context) / e.get(1));
          var n = this._context.new_var(s / i);
          var r = this._context.new_var(Math.pow(n, 2));
          var a = 0;
          for (var l = 0; l < this.period; l++) {
            a += r.get(l);
          }
          return Math.sqrt(a / this.period) * 100;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return [this.volatliityZTCTC()];
        };
      }
    }, {
      name: "Volatility O-H-L-C",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: false,
        id: "Volatility O-H-L-C@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Volatility O-H-L-C",
        description: "Volatility O-H-L-C",
        shortDescription: "Volatility O-H-L-C",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: c
            }
          },
          inputs: {
            periods: 10,
            marketClosedPercentage: 0,
            daysPerYear: 252
          }
        },
        styles: {
          plot_0: {
            title: "Plot"
          }
        },
        inputs: [{
          id: "periods",
          type: "integer",
          name: "Periods"
        }, {
          id: "marketClosedPercentage",
          type: "float",
          name: "Market Closed Percentage",
          min: 0,
          max: 0.999
        }, {
          id: "daysPerYear",
          type: "integer",
          name: "Days Per Year"
        }],
        format: {
          precision: 2,
          type: "percent"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.period = this._input(0);
          this.marketClosedPercentage = this._input(1);
          this.daysPerYear = this._input(2);
          this.secondsPerYear = this.daysPerYear * 86400;
        };
        this.square = function (e) {
          return e * e;
        };
        this.volatilityOHLC = function () {
          var e = this._context.new_var(Math.log(o.open(this._context)));
          var t = this._context.new_var(Math.log(o.high(this._context)));
          var i = this._context.new_var(Math.log(o.low(this._context)));
          var s = this._context.new_var(Math.log(o.close(this._context)));
          var n = this._context.new_var(o.close(this._context));
          var r = this._context.new_var(n.symbol.time);
          var a = (r.get(0) - r.get(1)) / 1000;
          var l = this.square(t.get() - i.get()) * 0.5;
          l -= (Math.log(4) - 1) * this.square(s.get() - e.get());
          if (this.marketClosedPercentage > 0) {
            l = this.square(e.get() - s.get(1)) * 0.12 / this.marketClosedPercentage + l * 0.88 / (1 - this.marketClosedPercentage);
          }
          l /= a;
          l *= this.secondsPerYear;
          var c = this._context.new_var(l);
          return Math.sqrt(o.sum(c, this.period, this._context) / this.period) * 100;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return [this.volatilityOHLC()];
        };
      }
    }, {
      name: "Volatility Index",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        is_price_study: true,
        id: "Volatility Index@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Volatility Index",
        description: "Volatility Index",
        shortDescription: "Volatility Index",
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              visible: true,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              color: c
            }
          },
          inputs: {
            periods: 10,
            atrMult: 3,
            method: "Wilder Smoothing"
          }
        },
        styles: {
          plot_0: {
            title: "Plot"
          }
        },
        inputs: [{
          id: "periods",
          name: "Periods",
          type: "integer"
        }, {
          id: "atrMult",
          name: "ATR Mult",
          type: "float"
        }, {
          id: "method",
          name: "Method",
          type: "text",
          defval: "Exponential",
          options: ["Exponential", "Wilder Smoothing"]
        }],
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this.period = this._input(0);
          this.atrMult = this._input(1);
          this.maMethod = this._input(2);
          this.nextsar = null;
          this.position = null;
          this.sic = null;
          this.bars = [];
          this.count = 0;
          this.lastSar = null;
          this._context.setMinimumAdditionalDepth(this.maMethod === "Exponential" ? this.period * 2 + 2 : this.period);
        };
        this.computeATR = function () {
          var e = o.high(this._context) - o.low(this._context);
          var t = o.high(this._context) - this.bars[this.bars.length - 2];
          var i = this.bars[this.bars.length - 2] - o.low(this._context);
          this.tr = Math.max(e, t, i);
          if (this.maMethod === "Exponential") {
            this.atr = o.ema(this._context.new_var(this.tr), this.period, this._context);
          } else {
            this.atr = this.tr / this.period + (1 - 1 / this.period) * this.atr;
          }
          return this.atr * this.atrMult;
        };
        this.calculateVolatility = function () {
          if (o.close(this._context) === this.bars[this.bars.length - 1]) {
            return this.lastSar;
          }
          this.bars.push(o.close(this._context));
          if (this.count === 1) {
            this.atr = o.high(this._context) - o.low(this._context);
            this.sic = o.close(this._context);
          } else if (this.count < this.period) {
            var e = o.high(this._context) - o.low(this._context);
            var t = o.high(this._context) - this.bars[this.bars.length - 2];
            var i = this.bars[this.bars.length - 2] - o.low(this._context);
            this.atr += Math.max(e, t, i);
            if (o.close(this._context) > this.sic) {
              this.sic = o.close(this._context);
            }
          } else if (this.count === this.period) {
            e = o.high(this._context) - o.low(this._context);
            t = o.high(this._context) - this.bars[this.bars.length - 2];
            i = this.bars[this.bars.length - 2] - o.low(this._context);
            this.atr += Math.max(e, t, i);
            this.atr *= 1 / this.period;
            if (o.close(this._context) > this.sic) {
              this.sic = o.close(this._context);
            }
            this.position = "LONG";
            this.nextsar = this.sic - this.atr * this.atrMult;
          } else {
            var s = this.nextsar;
            if (this.position === "LONG") {
              if (o.close(this._context) < s) {
                this.position = "SHORT";
                this.sic = o.close(this._context);
                this.nextsar = this.sic + this.computeATR();
              } else {
                this.position = "LONG";
                this.sic = Math.max(o.close(this._context), this.sic);
                this.nextsar = this.sic - this.computeATR();
              }
            } else if (this.position === "SHORT") {
              if (o.close(this._context) > s) {
                this.position = "LONG";
                this.sic = o.close(this._context);
                this.nextsar = this.sic - this.computeATR();
              } else {
                this.position = "SHORT";
                this.sic = Math.min(o.close(this._context), this.sic);
                this.nextsar = this.sic + this.computeATR();
              }
            }
            this.lastSar = s;
          }
          this.count++;
          return s;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          this._context.select_sym(0);
          return [this.calculateVolatility()];
        };
      }
    }, {
      name: "VWAP",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          inputs: {
            in_0: "hlc3",
            in_anchor: "Session"
          },
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: 0,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "VWAP",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "VWAP",
        shortDescription: "VWAP",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Source",
          defval: "hlc3",
          type: "source",
          options: ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"]
        }, {
          id: "in_anchor",
          name: "Anchor Period",
          defval: "Session",
          type: "text",
          options: ["Session", "Week", "Month", "Quarter", "Year", "Decade", "Century"]
        }],
        id: "VWAP@tv-basicstudies-1",
        scriptIdPart: "",
        name: "VWAP",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_1 = function (e) {
          e.reset_hist();
        };
        this.createAnchorChecker = function (e, t) {
          switch (t) {
            case "Week":
              return function (t, i) {
                return o.weekofyear(e, t) !== o.weekofyear(e, i) || o.year(e, t) !== o.year(e, i);
              };
            case "Month":
              return function (t, i) {
                return o.month(e, t) !== o.month(e, i) || o.year(e, t) !== o.year(e, i);
              };
            case "Quarter":
              return function (t, i) {
                return Math.floor(o.month(e, t) / 3) !== Math.floor(o.month(e, i) / 3) || o.year(e, t) !== o.year(e, i);
              };
            case "Year":
              return function (t, i) {
                return o.year(e, t) !== o.year(e, i);
              };
            case "Decade":
              return function (t, i) {
                return Math.floor(o.year(e, t) / 10) !== Math.floor(o.year(e, i) / 10);
              };
            case "Century":
              return function (t, i) {
                return Math.floor(o.year(e, t) / 100) !== Math.floor(o.year(e, i) / 100);
              };
            default:
              return e => this._isFirstBarInSession(e);
          }
        };
        this.init = function (e, t) {
          this._input = t;
          this._isFirstBarInSession = null;
          const i = this._input(1) || "Session";
          this._anchorChecker = this.createAnchorChecker(e, i);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          const i = this._input(0);
          var s = e.new_var();
          var n = e.new_var();
          var r = e.new_var();
          const a = o.time(this._context);
          const l = this._context.new_unlimited_var(a).get(1);
          if (a) {
            if (this._isFirstBarInSession === null) {
              const t = o.createNthBarInSessionCheck(e);
              this._isFirstBarInSession = e => t(e, 0);
            }
            if (this._anchorChecker(a, l)) {
              this.f_1(s);
              this.f_1(n);
              r.set(a);
            }
          }
          s.set(o.nz(s.get(1)) + o[i](this._context) * o.volume(this._context));
          n.set(o.nz(n.get(1)) + o.volume(this._context));
          if (o.na(r.get(0))) {
            return [NaN];
          } else {
            return [s.get(0) / n.get(0)];
          }
        };
      }
    }, {
      name: "VWMA",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          inputs: {
            in_0: 20
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "VWMA",
        shortDescription: "VWMA",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "len",
          defval: 20,
          type: "integer",
          min: 1,
          max: 10000
        }],
        id: "VWMA@tv-basicstudies-1",
        scriptIdPart: "",
        name: "VWMA",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = o.close(this._context);
          var s = this._input(0);
          var n = this._context.new_var(i);
          return [o.vwma(n, s, this._context)];
        };
      }
    }, {
      name: "Volume Oscillator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: 0
          }],
          inputs: {
            in_0: 5,
            in_1: 10
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Volume Oscillator",
        shortDescription: "Volume Osc",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "Zero",
          zorder: -1
        }],
        inputs: [{
          id: "in_0",
          name: "shortlen",
          defval: 5,
          type: "integer",
          min: 1,
          max: 4999
        }, {
          id: "in_1",
          name: "longlen",
          defval: 10,
          type: "integer",
          min: 1,
          max: 4999
        }],
        id: "Volume Oscillator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Volume Oscillator",
        format: {
          precision: 2,
          type: "percent"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e, t) {
          return (e - t) * 100 / t;
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = o.volume(this._context);
          var r = this._context.new_var(n);
          var a = o.ema(r, i, this._context);
          var l = this._context.new_var(n);
          var c = o.ema(l, s, this._context);
          return [this.f_0(a, c)];
        };
      }
    }, {
      name: "Vortex Indicator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#E91E63"
            }
          },
          inputs: {
            in_0: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "VI +",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          },
          plot_1: {
            title: "VI -",
            histogramBase: 0,
            joinPoints: false,
            isHidden: false
          }
        },
        description: "Vortex Indicator",
        shortDescription: "VI",
        is_price_study: false,
        is_hidden_study: false,
        id: "vortex_indicator@tv-basicstudies-1",
        inputs: [{
          id: "in_0",
          name: "Period",
          defval: 14,
          type: "integer",
          min: 2,
          max: 1000000000000
        }],
        scriptIdPart: "",
        name: "Vortex Indicator",
        format: {
          precision: 4,
          type: "price"
        }
      },
      constructor: function () {
        this.f_0 = function () {
          var e = this._input(0);
          var t = this._context.new_var(o.low(this._context));
          var i = this._context.new_var(o.abs(o.high(this._context) - t.get(1)));
          var s = o.sum(i, e, this._context);
          var n = this._context.new_var(o.high(this._context));
          var r = this._context.new_var(o.abs(o.low(this._context) - n.get(1)));
          var a = o.sum(r, e, this._context);
          var l = this._context.new_var(o.atr(1, this._context));
          var c = o.sum(l, e, this._context);
          return [s / c, a / c];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          return this.f_0();
        };
      }
    }, {
      name: "Willams %R",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#7E57C2"
            }
          },
          bands: [{
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: -20
          }, {
            color: "#787B86",
            linestyle: 2,
            linewidth: 1,
            visible: true,
            value: -80
          }],
          filledAreasStyle: {
            fill_0: {
              color: "#7E57C2",
              transparency: 90,
              visible: true
            }
          },
          inputs: {
            in_0: 14
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Plot",
            histogramBase: 0,
            joinPoints: false,
            zorder: 1
          }
        },
        description: "Williams %R",
        shortDescription: "%R",
        is_price_study: false,
        bands: [{
          id: "hline_0",
          name: "UpperLimit",
          zorder: -1.1
        }, {
          id: "hline_1",
          name: "LowerLimit",
          zorder: -1.11
        }],
        filledAreas: [{
          id: "fill_0",
          objAId: "hline_0",
          objBId: "hline_1",
          type: "hline_hline",
          title: "Hlines Background",
          zorder: -2
        }],
        inputs: [{
          id: "in_0",
          name: "length",
          defval: 14,
          type: "integer",
          min: 1,
          max: 2000
        }],
        id: "Willams %R@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Willams %R",
        format: {
          precision: 2,
          type: "price"
        },
        usePlotsZOrder: true
      },
      constructor: function () {
        this.f_0 = function (e, t, i) {
          return (e - t) * 100 / (t - i);
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = o.high(this._context);
          var n = this._context.new_var(s);
          var r = o.highest(n, i, this._context);
          var a = o.low(this._context);
          var l = this._context.new_var(a);
          var c = o.lowest(l, i, this._context);
          return [this.f_0(o.close(this._context), r, c)];
        };
      }
    }, {
      name: "Williams Alligator",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        defaults: {
          styles: {
            plot_0: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#2196F3"
            },
            plot_1: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#E91E63"
            },
            plot_2: {
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true,
              color: "#66BB6A"
            }
          },
          inputs: {
            in_0: 21,
            in_1: 13,
            in_2: 8,
            in_3: 8,
            in_4: 5,
            in_5: 3
          }
        },
        plots: [{
          id: "plot_0",
          type: "line"
        }, {
          id: "plot_1",
          type: "line"
        }, {
          id: "plot_2",
          type: "line"
        }],
        styles: {
          plot_0: {
            title: "Jaw",
            histogramBase: 0,
            joinPoints: false
          },
          plot_1: {
            title: "Teeth",
            histogramBase: 0,
            joinPoints: false
          },
          plot_2: {
            title: "Lips",
            histogramBase: 0,
            joinPoints: false
          }
        },
        description: "Williams Alligator",
        shortDescription: "Alligator",
        is_price_study: true,
        inputs: [{
          id: "in_0",
          name: "Jaw Length",
          defval: 21,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_0"]
        }, {
          id: "in_1",
          name: "Teeth Length",
          defval: 13,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_1"]
        }, {
          id: "in_2",
          name: "Lips Length",
          defval: 8,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_2"]
        }, {
          id: "in_3",
          name: "Jaw Offset",
          defval: 8,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_0"]
        }, {
          id: "in_4",
          name: "Teeth Offset",
          defval: 5,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_1"]
        }, {
          id: "in_5",
          name: "Lips Offset",
          defval: 3,
          type: "integer",
          min: 1,
          max: 2000,
          hideWhenPlotsHidden: ["plot_2"]
        }],
        id: "Williams Alligator@tv-basicstudies-1",
        scriptIdPart: "",
        name: "Williams Alligator",
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._input(0);
          var s = this._input(1);
          var n = this._input(2);
          var r = this._input(3);
          var a = this._input(4);
          var l = this._input(5);
          var c = o.hl2(this._context);
          return [{
            value: o.smma(c, i, this._context),
            offset: r
          }, {
            value: o.smma(c, s, this._context),
            offset: a
          }, {
            value: o.smma(c, n, this._context),
            offset: l
          }];
        };
      }
    }, {
      name: "Williams Fractals",
      metainfo: {
        _metainfoVersion: 52,
        isTVScript: false,
        isTVScriptStub: false,
        defaults: {
          styles: {
            plot_0: {
              plottype: "shape_triangle_down",
              visible: true,
              location: "BelowBar",
              transparency: 0,
              color: a
            },
            plot_1: {
              plottype: "shape_triangle_up",
              visible: true,
              location: "AboveBar",
              transparency: 0,
              color: u
            }
          },
          inputs: {
            in_0: 2
          }
        },
        plots: [{
          id: "plot_0",
          type: "shapes"
        }, {
          id: "plot_1",
          type: "shapes"
        }],
        styles: {
          plot_0: {
            title: "Down fractals",
            isHidden: false
          },
          plot_1: {
            title: "Up fractals",
            isHidden: false
          }
        },
        description: "Williams Fractal",
        shortDescription: "Fractals",
        is_price_study: true,
        is_hidden_study: false,
        id: "Williams Fractals@tv-basicstudies-1",
        inputs: [{
          id: "in_0",
          name: "Periods",
          defval: 2,
          type: "integer",
          min: 2,
          max: 1000000000000
        }],
        scriptIdPart: "",
        name: "Williams Fractals",
        isCustomIndicator: true,
        format: {
          type: "inherit"
        }
      },
      constructor: function () {
        this.f_0 = function () {
          for (var e = this._input(0), t = this._context.new_var(o.high(this._context)), i = true, s = true, n = true, r = true, a = true, l = true, c = 1; c <= e; c++) {
            i = o.and(i, o.lt(t.get(e - c), t.get(e)));
            s = o.and(s, o.lt(t.get(e + c), t.get(e)));
            n = o.and(n, o.and(o.le(t.get(e + 1), t.get(e)), o.lt(t.get(e + c + 1), t.get(e))));
            r = o.and(r, o.and(o.le(t.get(e + 1), t.get(e)), o.and(o.le(t.get(e + 2), t.get(e)), o.lt(t.get(e + c + 2), t.get(e)))));
            a = o.and(a, o.and(o.le(t.get(e + 1), t.get(e)), o.and(o.le(t.get(e + 2), t.get(e)), o.and(o.le(t.get(e + 3), t.get(e)), o.lt(t.get(e + c + 3), t.get(e))))));
            l = o.and(l, o.and(o.le(t.get(e + 1), t.get(e)), o.and(o.le(t.get(e + 2), t.get(e)), o.and(o.le(t.get(e + 3), t.get(e)), o.and(o.le(t.get(e + 4), t.get(e)), o.lt(t.get(e + c + 4), t.get(e)))))));
          }
          var h = o.or(s, o.or(n, o.or(r, o.or(a, l))));
          var d = o.and(i, h);
          var u = this._context.new_var(o.low(this._context));
          var _ = 1;
          var p = 1;
          var m = 1;
          var g = 1;
          var f = 1;
          var y = 1;
          for (c = 1; c <= e; c++) {
            _ = o.and(_, o.gt(u.get(e - c), u.get(e)));
            p = o.and(p, o.gt(u.get(e + c), u.get(e)));
            m = o.and(m, o.and(o.ge(u.get(e + 1), u.get(e)), o.gt(u.get(e + c + 1), u.get(e))));
            g = o.and(g, o.and(o.ge(u.get(e + 1), u.get(e)), o.and(o.ge(u.get(e + 2), u.get(e)), o.gt(u.get(e + c + 2), u.get(e)))));
            f = o.and(f, o.and(o.ge(u.get(e + 1), u.get(e)), o.and(o.ge(u.get(e + 2), u.get(e)), o.and(o.ge(u.get(e + 3), u.get(e)), o.gt(u.get(e + c + 3), u.get(e))))));
            y = o.and(y, o.and(o.ge(u.get(e + 1), u.get(e)), o.and(o.ge(u.get(e + 2), u.get(e)), o.and(o.ge(u.get(e + 3), u.get(e)), o.and(o.ge(u.get(e + 4), u.get(e)), o.gt(u.get(e + c + 4), u.get(e)))))));
          }
          var v = o.or(p, o.or(m, o.or(g, o.or(f, y))));
          return [o.and(_, v), d];
        };
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this.f_0();
          return [{
            value: i[0],
            offset: -this._input(0)
          }, {
            value: i[1],
            offset: -this._input(0)
          }];
        };
      }
    }, {
      name: "Guppy Multiple Moving Average",
      metainfo: {
        isTVScript: false,
        isTVScriptStub: false,
        is_hidden_study: false,
        description: "Guppy Multiple Moving Average",
        shortDescription: "GMMA",
        is_price_study: true,
        id: "Guppy Multiple Moving Average@tv-basicstudies-1",
        _metainfoVersion: 52,
        format: {
          type: "inherit"
        },
        defaults: {
          inputs: {
            traderEMA1Length: 3,
            traderEMA2Length: 5,
            traderEMA3Length: 8,
            traderEMA4Length: 10,
            traderEMA5Length: 12,
            traderEMA6Length: 15,
            investorEMA1Length: 30,
            investorEMA2Length: 35,
            investorEMA3Length: 40,
            investorEMA4Length: 45,
            investorEMA5Length: 50,
            investorEMA6Length: 60
          },
          styles: {
            traderEMA1: {
              color: "#00FFFF",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 15,
              visible: true
            },
            traderEMA2: {
              color: "#00FFFF",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 12,
              visible: true
            },
            traderEMA3: {
              color: "#00FFFF",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 9,
              visible: true
            },
            traderEMA4: {
              color: "#00FFFF",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 6,
              visible: true
            },
            traderEMA5: {
              color: "#00FFFF",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 3,
              visible: true
            },
            traderEMA6: {
              color: "#00FFFF",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true
            },
            investorEMA1: {
              color: "#FF0000",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 15,
              visible: true
            },
            investorEMA2: {
              color: "#FF0000",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 12,
              visible: true
            },
            investorEMA3: {
              color: "#FF0000",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 9,
              visible: true
            },
            investorEMA4: {
              color: "#FF0000",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 6,
              visible: true
            },
            investorEMA5: {
              color: "#FF0000",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 3,
              visible: true
            },
            investorEMA6: {
              color: "#FF0000",
              linestyle: 0,
              linewidth: 1,
              plottype: 0,
              trackPrice: false,
              transparency: 0,
              visible: true
            }
          }
        },
        inputs: [{
          defval: 3,
          id: "traderEMA1Length",
          max: 1000,
          min: 1,
          name: "Trader EMA 1 length",
          type: "integer",
          hideWhenPlotsHidden: ["traderEMA1"]
        }, {
          defval: 5,
          id: "traderEMA2Length",
          max: 1000,
          min: 1,
          name: "Trader EMA 2 length",
          type: "integer",
          hideWhenPlotsHidden: ["traderEMA2"]
        }, {
          defval: 8,
          id: "traderEMA3Length",
          max: 1000,
          min: 1,
          name: "Trader EMA 3 length",
          type: "integer",
          hideWhenPlotsHidden: ["traderEMA3"]
        }, {
          defval: 10,
          id: "traderEMA4Length",
          max: 1000,
          min: 1,
          name: "Trader EMA 4 length",
          type: "integer",
          hideWhenPlotsHidden: ["traderEMA4"]
        }, {
          defval: 12,
          id: "traderEMA5Length",
          max: 1000,
          min: 1,
          name: "Trader EMA 5 length",
          type: "integer",
          hideWhenPlotsHidden: ["traderEMA5"]
        }, {
          defval: 15,
          id: "traderEMA6Length",
          max: 1000,
          min: 1,
          name: "Trader EMA 6 length",
          type: "integer",
          hideWhenPlotsHidden: ["traderEMA6"]
        }, {
          defval: 30,
          id: "investorEMA1Length",
          max: 1000,
          min: 1,
          name: "Investor EMA 1 length",
          type: "integer",
          hideWhenPlotsHidden: ["investorEMA1"]
        }, {
          defval: 35,
          id: "investorEMA2Length",
          max: 1000,
          min: 1,
          name: "Investor EMA 2 length",
          type: "integer",
          hideWhenPlotsHidden: ["investorEMA2"]
        }, {
          defval: 40,
          id: "investorEMA3Length",
          max: 1000,
          min: 1,
          name: "Investor EMA 3 length",
          type: "integer",
          hideWhenPlotsHidden: ["investorEMA3"]
        }, {
          defval: 45,
          id: "investorEMA4Length",
          max: 1000,
          min: 1,
          name: "Investor EMA 4 length",
          type: "integer",
          hideWhenPlotsHidden: ["investorEMA4"]
        }, {
          defval: 50,
          id: "investorEMA5Length",
          max: 1000,
          min: 1,
          name: "Investor EMA 5 length",
          type: "integer",
          hideWhenPlotsHidden: ["investorEMA5"]
        }, {
          defval: 60,
          id: "investorEMA6Length",
          max: 1000,
          min: 1,
          name: "Investor EMA 6 length",
          type: "integer",
          hideWhenPlotsHidden: ["investorEMA6"]
        }],
        plots: [{
          id: "traderEMA1",
          type: "line"
        }, {
          id: "traderEMA2",
          type: "line"
        }, {
          id: "traderEMA3",
          type: "line"
        }, {
          id: "traderEMA4",
          type: "line"
        }, {
          id: "traderEMA5",
          type: "line"
        }, {
          id: "traderEMA6",
          type: "line"
        }, {
          id: "investorEMA1",
          type: "line"
        }, {
          id: "investorEMA2",
          type: "line"
        }, {
          id: "investorEMA3",
          type: "line"
        }, {
          id: "investorEMA4",
          type: "line"
        }, {
          id: "investorEMA5",
          type: "line"
        }, {
          id: "investorEMA6",
          type: "line"
        }],
        styles: {
          traderEMA1: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Trader EMA 1"
          },
          traderEMA2: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Trader EMA 2"
          },
          traderEMA3: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Trader EMA 3"
          },
          traderEMA4: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Trader EMA 4"
          },
          traderEMA5: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Trader EMA 5"
          },
          traderEMA6: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Trader EMA 6"
          },
          investorEMA1: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Investor EMA 1"
          },
          investorEMA2: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Investor EMA 2"
          },
          investorEMA3: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Investor EMA 3"
          },
          investorEMA4: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Investor EMA 4"
          },
          investorEMA5: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Investor EMA 5"
          },
          investorEMA6: {
            histogramBase: 0,
            isHidden: false,
            joinPoints: false,
            title: "Investor EMA 6"
          }
        }
      },
      constructor: function () {
        this.main = function (e, t) {
          this._context = e;
          this._input = t;
          var i = this._context.new_var(o.close(this._context));
          var s = this._input(0);
          var n = this._input(1);
          var r = this._input(2);
          var a = this._input(3);
          var l = this._input(4);
          var c = this._input(5);
          var h = o.ema(i, s, this._context);
          var d = o.ema(i, n, this._context);
          var u = o.ema(i, r, this._context);
          var _ = o.ema(i, a, this._context);
          var p = o.ema(i, l, this._context);
          var m = o.ema(i, c, this._context);
          var g = this._input(6);
          var f = this._input(7);
          var y = this._input(8);
          var v = this._input(9);
          var S = this._input(10);
          var b = this._input(11);
          return [h, d, u, _, p, m, o.ema(i, g, this._context), o.ema(i, f, this._context), o.ema(i, y, this._context), o.ema(i, v, this._context), o.ema(i, S, this._context), o.ema(i, b, this._context)];
        };
      }
    }, {
      name: "52 Week High/Low",
      metainfo: {
        _metainfoVersion: 52,
        id: "52 Week High/Low@tv-basicstudies-1",
        description: "52 Week High/Low",
        shortDescription: "52W H/L",
        is_price_study: true,
        format: {
          type: "inherit"
        },
        plots: [],
        graphics: {
          horizlines: {
            highest: {
              name: "Highest"
            },
            lowest: {
              name: "Lowest"
            }
          }
        },
        inputs: [{
          defval: "close",
          id: "highestSource",
          name: "High source",
          options: ["close", "high"],
          type: "text"
        }, {
          defval: "close",
          id: "lowestSource",
          name: "Low source",
          options: ["close", "low"],
          type: "text"
        }],
        defaults: {
          graphics: {
            horizlines: {
              highest: {
                color: "rgb(93, 96, 107)",
                showPrice: true,
                style: 1,
                visible: true,
                width: 2
              },
              lowest: {
                color: "rgb(93, 96, 107)",
                showPrice: true,
                style: 1,
                visible: true,
                width: 2
              }
            }
          },
          inputs: {
            highestSource: "close",
            lowestSource: "close"
          }
        }
      },
      constructor: function () {
        this.init = function (e, t) {
          this._context = e;
          this._input = t;
          this._symbolSupports1DResolution = !this._context.symbol.info.supported_resolutions || this._context.symbol.info.supported_resolutions.indexOf("1D") !== -1;
          if (this._symbolSupports1DResolution && o.period(this._context) !== "1D") {
            this._context.new_sym(this._context.symbol.ticker, "1D");
          }
        };
        this.main = function (e, t) {
          if (!this._symbolSupports1DResolution) {
            o.error(`Daily bars are not available for ${this._context.symbol.info.name}`);
          }
          this._context = e;
          this._input = t;
          if (o.period(this._context) !== "1D") {
            this._context.select_sym(1);
          }
          const i = this._input(0);
          const s = this._input(1);
          const n = o.time(this._context);
          const r = this._context.new_unlimited_var(n);
          const a = this._context.new_unlimited_var(o[i](this._context));
          const l = this._context.new_unlimited_var(o[s](this._context));
          r.get(365);
          if (!this._context.symbol.isLastBar || !this._context.symbol.isNewBar) {
            return null;
          }
          const c = o.add_years_considering_dst(this._context.symbol.info.timezone, new Date(n), -1);
          const h = r.indexOf(c.getTime());
          const d = h === -1 ? NaN : o.highest(a, h, this._context);
          const u = h === -1 ? NaN : o.lowest(l, h, this._context);
          if (isNaN(d) || isNaN(u)) {
            return {
              nonseries: true,
              type: "study_graphics",
              data: {
                graphicsCmds: {
                  erase: [{
                    action: "all"
                  }]
                }
              }
            };
          }
          return {
            nonseries: true,
            type: "study_graphics",
            data: {
              graphicsCmds: {
                create: {
                  horizlines: [{
                    styleId: "highest",
                    data: [{
                      startIndex: n,
                      endIndex: n,
                      level: d,
                      extendLeft: true,
                      extendRight: true
                    }]
                  }, {
                    styleId: "lowest",
                    data: [{
                      startIndex: n,
                      endIndex: n,
                      level: u,
                      extendLeft: true,
                      extendRight: true
                    }]
                  }]
                },
                erase: [{
                  action: "all"
                }]
              }
            }
          };
        };
      }
    }];
  },
  91007: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      SubsessionId: () => s
    });
    (function (e) {
      e.Regular = "regular";
      e.Extended = "extended";
      e.PreMarket = "premarket";
      e.PostMarket = "postmarket";
    })(s ||= {});
  },
  55812: (e, t, i) => {
    "use strict";

    i.d(t, {
      JSStudyEngineTypescript: () => Ee
    });
    var s;
    var o = i(56570);
    var n = i(63193);
    var r = i(56052);
    var a = i(82433);
    var l = i(83873);
    var c = i(88987);
    var h = i(39692);
    var d = i(50151);
    var u = i(85049);
    var _ = i(29981);
    var p = i(14381);
    var m = i(53388);
    var g = i(17326);
    i(21251);
    class f {
      constructor(e, t) {
        this.info = e;
        this.bars = t || [];
        this.isBarClosed = true;
        this.firstLoadedTimeMs = this.bars.length !== 0 ? this.bars[0].time : Infinity;
        this._emptyBarCount = 0;
        this._lastBarIsEmpty = false;
      }
      symbolinfo() {
        return this.info;
      }
      isLastBarClosed() {
        return this.isBarClosed;
      }
      setLastBarClosed(e) {
        this.isBarClosed = e;
      }
      bar(e) {
        const t = this.bars[e];
        if (t === undefined) {
          throw new Error(`BarSet has no value at index ${e}`);
        }
        return t;
      }
      count() {
        return this.bars.length;
      }
      emptyBarCount() {
        return this._emptyBarCount;
      }
      add(e, t, i = false) {
        const s = e;
        const o = this.bars;
        const n = o.length;
        const r = s.time;
        const a = n === 0 ? NaN : o[n - 1].time;
        if (n === 0 || a < r) {
          o.push(s);
          if (i) {
            this._emptyBarCount += 1;
            this._lastBarIsEmpty = true;
          }
        } else if (a === r) {
          if (i !== this._lastBarIsEmpty) {
            this._emptyBarCount += i ? 1 : -1;
            this._lastBarIsEmpty = i;
          }
          o[n - 1] = s;
        } else {
          console.error("time order violation, prev: " + new Date(a).toUTCString() + ", cur: " + new Date(r).toUTCString());
        }
        this.isBarClosed = !!t;
      }
    }
    function y(e, t) {
      return e.ticker + (e.currency_code ? "_#_" + e.currency_code : "") + (e.unit_id ? "_#_" + e.unit_id : "") + (e.subsession_id ? "_#_" + e.subsession_id : "") + "_#_" + t;
    }
    function v(e) {
      return new Date(e).toISOString();
    }
    (function (e) {
      e.ThreadKeySeparator = "_#_";
    })(s ||= {});
    (function (e) {
      e[e.MaxEmptyResponsesInARow = 50] = "MaxEmptyResponsesInARow";
      e[e.ResetCacheTimePeriod = 10000] = "ResetCacheTimePeriod";
    })(s ||= {});
    class S {
      constructor(e, t, i, s, o, n) {
        this._cache = {
          bars: []
        };
        this._nextSubscriptionId = 0;
        this._pendingSubscribers = [];
        this._subscribers = [];
        this._requesting = false;
        this._leftDate = null;
        this._nextTime = null;
        this._realtimeOn = false;
        this._endOfData = false;
        this._resetCacheTimeout = null;
        this._errorMessage = null;
        this._destroyed = false;
        this._emptyResponsesCount = 0;
        this._firstDataRequest = true;
        this._datafeed = e;
        this._symbolInfo = t;
        this._interval = u.Interval.parse(i);
        this._resolution = this._interval.value();
        this._dwmAligner = o;
        this._serverTimeOffsetGetter = s;
        this._resetCacheTimePeriod = n === undefined ? 10000 : n;
        this._sessionSpec = new g.SessionsSpec(t.timezone, t.session, t.session_holidays, t.corrections);
        this._updateDatesFromExpirationDate();
      }
      destroy() {
        if (this._subscribers.length !== 0) {
          this._logWarning("Destroying with not-empty state");
        }
        this._clearResetCacheTimeout();
        this._unsubscribeRealtime();
        this._purgeCache();
        delete this._datafeed;
        this._destroyed = true;
      }
      addSubscription(e, t, i) {
        const s = this._getNextSubscriptionId();
        this._pendingSubscribers.push({
          key: s,
          range: e,
          onHistoryCallback: t,
          onErrorCallback: i
        });
        if (u.Interval.isDWM(this._resolution) && e.to !== undefined && this._dwmAligner !== null && e.to % 86400000) {
          this._logWarning(`Internal error: invalid date for DWM resolution ${v(e.to)}, expected time without a time part`);
        }
        this._clearResetCacheTimeout();
        setTimeout(() => {
          if (!this._destroyed) {
            this._processPendingSubscribers();
          }
        }, 0);
        return s;
      }
      removeSubscription(e) {
        const t = this._pendingSubscribers.find(t => t.key === e);
        if (t) {
          this._pendingSubscribers.splice(this._pendingSubscribers.indexOf(t), 1);
          return;
        }
        const i = this._subscribers.find(t => t.key === e);
        if (i) {
          this._subscribers.splice(this._subscribers.indexOf(i), 1);
          if (!this._subscribers.length) {
            this._resetCacheTimeout = setTimeout(() => {
              this._resetCacheTimeout = null;
              this._purgeCache();
              this._unsubscribeRealtime();
            }, this._resetCacheTimePeriod);
          }
          return;
        }
        this._logWarning("Unknown subscription symbol={0}, resolution={1}, key={2}".format(this._symbolInfo.name, this._resolution, e));
      }
      resetCache() {
        this._unsubscribeRealtime();
        const e = this._leftDate;
        this._purgeCache();
        if (e !== null && !o.enabled("request_only_visible_range_on_reset")) {
          this._ensureRequestedTo({
            to: e,
            countBack: 0
          });
        }
      }
      _logMessage(e, t) {
        if (o.enabled("charting_library_debug_mode") || t) {
          console.log(`${this._logMessagePrefix()}${e}`);
        }
      }
      _logWarning(e) {
        console.warn(`${this._logMessagePrefix()}${e}`);
      }
      _logError(e) {
        console.error(`${this._logMessagePrefix()}${e}`);
      }
      _logMessagePrefix() {
        const e = this._symbolInfo.currency_code;
        const t = this._symbolInfo.unit_id;
        return `${new Date().toISOString()} FEED [${this._symbolInfo.name}|${this._resolution}${e ? "|" + e : ""}${t ? "|" + t : ""}]: `;
      }
      _clearResetCacheTimeout() {
        if (this._resetCacheTimeout !== null) {
          clearTimeout(this._resetCacheTimeout);
          this._resetCacheTimeout = null;
        }
      }
      _purgeCache() {
        this._logMessage("Reset cache");
        this._cache = {
          bars: []
        };
        this._errorMessage = null;
        this._leftDate = null;
        this._endOfData = false;
        this._firstDataRequest = true;
        this._updateDatesFromExpirationDate();
      }
      _updateDatesFromExpirationDate() {
        if (this._symbolInfo.expiration_date !== undefined) {
          this._nextTime = this._symbolInfo.expiration_date * 1000;
          this._leftDate = (this._symbolInfo.expiration_date + 1) * 1000;
        }
      }
      _dealignTime(e) {
        if (this._dwmAligner === null) {
          return e;
        } else {
          return this._dwmAligner.timeToExchangeTradingDay(e);
        }
      }
      _normalizeRange(e) {
        const t = e.to !== undefined ? e.to : this._dealignTime(this._now());
        if (this._cache.bars.length === 0 || e.to !== undefined && t <= (0, d.ensureNotNull)(this._leftDate)) {
          return {
            countBack: e.countBack,
            to: t
          };
        }
        const i = this._dwmAligner !== null ? this._dwmAligner.timeToSessionStart(t) : t;
        const s = (0, _.lowerbound)(this._cache.bars, i, (e, t) => e.time < t);
        if (e.countBack < s) {
          return {
            countBack: 0,
            to: e.countBack !== 0 && s <= this._cache.bars.length ? this._dealignTime(this._cache.bars[s - e.countBack].time) : t
          };
        } else {
          return {
            countBack: e.countBack - s,
            to: this._dealignTime(this._cache.bars[0].time)
          };
        }
      }
      _processPendingSubscribers() {
        const e = this._pendingSubscribers;
        if (!e.length) {
          return;
        }
        if (this._requesting) {
          this._logMessage("Processing is skipped due active request");
          return;
        }
        this._logMessage(`Processing pending subscribers, count=${e.length}`);
        if (this._errorMessage) {
          const t = this._errorMessage;
          this._logMessage(`Return error: ${t}`);
          this._pendingSubscribers = [];
          e.forEach(e => {
            e.onErrorCallback(t);
          });
          return;
        }
        let t = this._normalizeRange(e[0].range);
        for (const i of e.map(e => this._normalizeRange(e.range))) {
          if (i.to < t.to || i.to === t.to && i.countBack > t.countBack) {
            t = i;
          }
        }
        this._logMessage(`Leftmost subscriber requires ${t.countBack} bars prior ${v(t.to)}`);
        if (this._leftDate !== null && (!(t.to < this._leftDate) || this._nextTime !== null && !(t.to < this._nextTime)) && t.countBack === 0 || this._endOfData) {
          this._pendingSubscribers = [];
          e.forEach(e => {
            const t = this._moveSubscriberToRealtime(e);
            this._returnHistoryDataToSubscriber(e, t);
          });
          this._subscribeRealtimeIfNeeded();
        } else {
          this._ensureRequestedTo(t);
        }
      }
      _moveSubscriberToRealtime(e) {
        const t = {
          key: e.key,
          onHistoryCallback: e.onHistoryCallback,
          barset: null
        };
        this._subscribers.push(t);
        return t;
      }
      _isSymbolExpired() {
        return this._symbolInfo.expired || this._symbolInfo.expiration_date !== undefined;
      }
      _subscribeRealtimeIfNeeded() {
        if (!!this._subscribers.length && !this._realtimeOn && !this._isSymbolExpired()) {
          this._subscribeRealtime();
        }
      }
      _subscribeRealtime() {
        if (this._symbolInfo.expired || this._realtimeOn) {
          return;
        }
        this._realtimeOn = true;
        this._datafeed.subscribeBars(this._symbolInfo, this._resolution, e => {
          if (this._dwmAligner !== null) {
            e.time = this._dwmAligner.timeToSessionStart(e.time);
          }
          this._putToCacheNewBar(e);
          this._subscribers.forEach(t => {
            const i = t.barset;
            if (i === null) {
              throw new Error("subscriber.barset is null");
            }
            i.add(e);
            t.onHistoryCallback(i);
          });
        }, y(this._symbolInfo, this._resolution), this.resetCache.bind(this));
        this._logMessage("Subscribed to realtime");
      }
      _unsubscribeRealtime() {
        if (!this._isSymbolExpired() && this._realtimeOn) {
          this._datafeed.unsubscribeBars(y(this._symbolInfo, this._resolution));
          this._logMessage("Unsubscribed from realtime");
          this._realtimeOn = false;
        }
      }
      _returnHistoryDataToSubscriber(e, t) {
        const i = this._normalizeRange(e.range);
        const s = this._createBarsetForRange(i);
        if (s.count() > 0) {
          this._logMessage("Bars to return for request {0}: total {1} bars in [{2} ... {3}] ".format(e.key, s.count(), v(s.bars[0].time), v(s.bars[s.count() - 1].time)));
        } else {
          this._logMessage("Request {0}. Nothing to return.".format(e.key));
        }
        t.barset = s;
        if (this._endOfData && this._leftDate !== null && i.to <= this._leftDate) {
          s.endOfData = true;
        }
        e.onHistoryCallback(s);
      }
      _createBarsetForRange(e) {
        const t = this._dwmAligner !== null ? this._dwmAligner.timeToSessionStart(e.to) : e.to;
        const i = (0, _.lowerbound)(this._cache.bars, t, (e, t) => e.time < t);
        const s = new f(this._symbolInfo, this._cache.bars.slice(Math.max(0, i - e.countBack)));
        if (s.bars.length !== 0) {
          s.firstLoadedTimeMs = this._dealignTime(s.bars[0].time);
        } else if (this._cache.bars.length !== 0) {
          s.firstLoadedTimeMs = this._dealignTime(this._cache.bars[this._cache.bars.length - 1].time);
        } else {
          s.firstLoadedTimeMs = this._dealignTime((0, d.ensureNotNull)(this._leftDate));
        }
        return s;
      }
      _ensureRequestedTo(e) {
        let t;
        if (this._requesting) {
          this._logMessage("Internal error: trying to call getBars while the previous request is active", true);
        }
        if (this._leftDate !== null) {
          t = this._leftDate;
        } else {
          const e = this._now();
          if (this._dwmAligner === null) {
            t = e;
          } else {
            let i = this._sessionSpec.alignToNearestSessionStart(new Date(e), 1).getTime();
            if (i < e) {
              const e = this._sessionSpec.alignToNearestSessionEnd(new Date(i), 1).getTime();
              i = this._sessionSpec.alignToNearestSessionStart(new Date(e + 1000), 1).getTime();
            }
            t = this._dealignTime(i);
          }
        }
        const i = (0, p.alignPeriodsBackForDataRequest)(this._symbolInfo.session, this._symbolInfo.session_holidays, this._symbolInfo.corrections, this._interval.letter(), this._interval.multiplier(), e.countBack, Math.min(e.to, t, this._nextTime ?? Infinity));
        let s = e.countBack;
        if (e.to < t) {
          s += (0, p.getPeriodsBetweenDates)(this._symbolInfo.session, this._symbolInfo.session_holidays, this._symbolInfo.corrections, this._interval.letter(), this._interval.multiplier(), e.to, t);
        }
        if (this._leftDate !== null && this._leftDate < i) {
          this._processPendingSubscribers();
          return;
        }
        const o = this._firstDataRequest || (this._isSymbolExpired() ? this._cache.bars.length === 0 : this._leftDate === null);
        this._firstDataRequest = false;
        this._requesting = true;
        this._nextTime = null;
        this._leftDate = i;
        const n = `[${v(i)} ... ${v(t)}, ${s} bars]`;
        this._logMessage(`Requesting data: ${n}`);
        let r = false;
        const a = i / 1000;
        const l = t / 1000;
        this._datafeed.getBars(this._symbolInfo, this._resolution, {
          from: this._interval.isTicks() ? a : Math.floor(a),
          to: this._interval.isTicks() ? l : Math.floor(l),
          countBack: s,
          firstDataRequest: o
        }, (e, t) => {
          if (!this._destroyed) {
            if (r) {
              this._logMessage("getBars callback is already called before", true);
            } else {
              r = true;
              if (e.length > 0) {
                const t = ` [${v(e[0].time)} ... ${v(e[e.length - 1].time)}]`;
                this._logMessage(`Receiving bars: total ${e.length} bars in ${t}, requested range: ${n}`);
              } else {
                this._logMessage(`Receiving bars: barset is empty, requested range: ${n}`);
              }
              this._requesting = false;
              this._processBars(e, t);
            }
          }
        }, e => {
          if (!this._destroyed) {
            if (r) {
              this._logMessage("getBars callback is already called before", true);
            } else {
              r = true;
              this._requesting = false;
              this._errorMessage = e || null;
              this._processPendingSubscribers();
            }
          }
        });
      }
      _processBars(e, t) {
        this._checkBars(e);
        this._alignBarsTime(e);
        if (e.length > 0) {
          this._emptyResponsesCount = 0;
          this._processFullBarset(e, t);
        } else {
          this._emptyResponsesCount += 1;
          this._processEmptyBarset(t);
        }
        this._processPendingSubscribers();
      }
      _processEmptyBarset(e) {
        if (e && e.nextTime) {
          this._logMessage("Next time received: `{0}`".format(v(e.nextTime * 1000)));
          this._nextTime = e.nextTime * 1000;
        } else if (e && e.noData) {
          this._logMessage("EOD received");
          this._setEndOfData();
        } else {
          this._logMessage("nextTime or noData should present in metainfo when empty barset is returned");
        }
        if (this._emptyResponsesCount === 50) {
          this._logMessage("EOD detected due 50 empty responses in a row");
          this._setEndOfData();
        }
      }
      _setEndOfData() {
        this._endOfData = true;
        if (this._cache.bars.length) {
          this._leftDate = this._dealignTime(this._cache.bars[0].time);
        }
      }
      _processFullBarset(e, t) {
        if (this._putToCache(e)) {
          if (this._leftDate !== null && this._cache.bars.length !== 0) {
            if (this._interval.isTicks()) {
              this._leftDate = this._dealignTime(this._cache.bars[0].time);
            } else {
              this._leftDate = Math.min(this._leftDate, this._dealignTime(this._cache.bars[0].time));
            }
          }
        } else {
          this._logMessage("Incremental update failed. Starting full update. Returned data should be in the requested range.", true);
        }
        if (t && t.nextTime) {
          this._logWarning("nextTime should be set when there is no data in the requested period only");
        } else if (t && t.noData) {
          this._logWarning("noData should be set when there is no data in the requested period and earlier only");
        }
      }
      _getNextSubscriptionId() {
        return this._nextSubscriptionId++;
      }
      _checkBars(e, t = false) {
        if (o.enabled("charting_library_debug_mode")) {
          for (let i = 1; i < e.length; i++) {
            if (e[i].time <= e[i - 1].time) {
              let s = `Wrong bars time: time ${e[i].time} of bar ${i} should be more than time ${e[i - 1].time} of bar ${i - 1}`;
              if (t && this._dwmAligner !== null) {
                s += "\nCheck that you provide DWM bars without time part, i.e. 00:00 GMT";
              }
              this._logError(s);
            }
            if (["high", "low", "open", "close", "time"].some(t => typeof e[i][t] != "number" || !isFinite(e[i][t]))) {
              this._logError("Wrong bars values: all OHLC values should be numbers");
            }
          }
        }
      }
      _putToCache(e) {
        if (e.length === 0) {
          return true;
        }
        if (this._cache.bars.length === e.length && this._cache.bars[0].time === e[0].time && this._cache.bars[this._cache.bars.length - 1].time === e[e.length - 1].time) {
          this._logMessage("Time range of received data is the same as cached one. Skip the update.");
          return true;
        }
        if (this._cache.bars.length !== 0 && e[e.length - 1].time === this._cache.bars[0].time) {
          this._cache.bars.splice(0, 1);
        }
        if (this._cache.bars.length !== 0 && e[e.length - 1].time >= this._cache.bars[0].time) {
          const t = this._cache.bars[this._cache.bars.length - 1].time === e[e.length - 1].time;
          this._cache.bars = [];
          if (!t) {
            this._leftDate = null;
            return false;
          }
          this._logMessage("Received history up to now instead of incremental update. Return exactly what is requested.");
        }
        this._cache.bars = [...e, ...this._cache.bars];
        this._checkBars(this._cache.bars, true);
        return true;
      }
      _putToCacheNewBar(e) {
        const t = this._cache.bars.length;
        const i = e.time;
        const s = t === 0 ? NaN : this._cache.bars[t - 1].time;
        if (t === 0 || s < i) {
          this._cache.bars.push(e);
        } else if (s === i) {
          if (this._interval.isTicks()) {
            this._logMessage("Received update for the last tick bar");
          }
          this._cache.bars[t - 1] = e;
        } else {
          this._logError(`putToCacheNewBar: time violation, previous bar time: ${v(s)} should be less or equal to new time: ${v(i)}`);
        }
      }
      _alignBarsTime(e) {
        if (this._dwmAligner) {
          for (const t of e) {
            t.time = this._dwmAligner.timeToSessionStart(t.time);
          }
        }
      }
      _now() {
        return Date.now() + this._serverTimeOffsetGetter() * 1000 + 60000;
      }
    }
    class b {
      constructor(e, t, i) {
        this._threads = {};
        this._datafeed = e;
        this._serverTimeOffsetGetter = t;
        this._resetCacheTimePeriod = i;
      }
      destroy() {
        this._forEachThread((e, t) => t.destroy());
        this._threads = {};
        delete this._datafeed;
      }
      purgeCache() {
        this._forEachThread((e, t) => t.destroy());
        this._threads = {};
      }
      resetCache() {
        this._forEachThread((e, t) => t.resetCache());
      }
      subscribe(e, t, i, s, o) {
        const n = y(e, t);
        this._threads[n] ||= this._createThread(e, t);
        return n + "\"" + this._threads[n].addSubscription(i, s, o);
      }
      unsubscribe(e) {
        const t = e.split("\"");
        if (t.length !== 2) {
          this._logWarning("Wrong guid format");
          return;
        }
        const i = t[0];
        const s = parseInt(t[1]);
        if (this._threads.hasOwnProperty(i)) {
          this._threads[i].removeSubscription(s);
        } else {
          this._logWarning("Data thread doesnt exist: " + e);
        }
      }
      _createThread(e, t) {
        return new S(this._datafeed, e, t, this._serverTimeOffsetGetter, (0, m.createDwmAligner)(t, e), this._resetCacheTimePeriod);
      }
      _forEachThread(e) {
        Object.keys(this._threads).forEach(t => e(t, this._threads[t]));
      }
      _logWarning(e) {
        console.warn(`${new Date().toISOString()} FEED: ${e}`);
      }
    }
    class w {
      constructor() {
        this._listeners = [];
      }
      listenersCount() {
        return this._listeners.reduce((e, t) => e + (t ? 1 : 0), 0);
      }
      addListener(e, t) {
        this._listeners.push({
          dataListener: e,
          onErrorCallback: t
        });
        if (this._barset) {
          e(this._barset);
        }
        if (this._errorMsg) {
          t(this._errorMsg);
        }
      }
      removeListener(e) {
        const t = this._listeners.filter(t => t && t.dataListener === e);
        if (t.length === 0) {
          return;
        }
        const i = this._listeners.indexOf(t[0]);
        delete this._listeners[i];
      }
      onError(e) {
        this._errorMsg = e || "unspecified error";
        const t = this._listeners;
        const i = t.length;
        for (let s = 0; s < i; s++) {
          const i = t[s];
          if (i && i.onErrorCallback) {
            i.onErrorCallback(e);
          }
        }
      }
      fire(e, t) {
        if (!t) {
          this._barset = e;
        }
        const i = this._listeners;
        const s = i.length;
        for (let t = 0; t < s; t++) {
          const s = i[t];
          if (s) {
            s.dataListener(e);
          }
        }
      }
    }
    var C = i(73698);
    var P = i(2740);
    var T = i(42217);
    var x = i(91007);
    var I = i(50335);
    const M = o.enabled("align_dwm_bars_to_main_series");
    class A {
      constructor(e, t, i, s, o, n, r) {
        this.periodBase = "";
        const a = (0, C.decodeExtendedSymbol)(e);
        const l = typeof a.symbol == "string" ? a : a.symbol;
        if ((0, C.isStudySymbol)(l)) {
          throw new Error(`Unexpected nested study symbol: ${e}`);
        }
        const c = typeof a.symbol == "string" ? a.symbol : a.symbol.symbol;
        this.ticker = c;
        this.currencyCode = i || l["currency-id"];
        this.unitId = s || l["unit-id"];
        this.subsessionId = r || l.session;
        const h = l["currency-id"] !== this.currencyCode || l["unit-id"] !== this.unitId;
        l["currency-id"] = this.currencyCode;
        l["unit-id"] = this.unitId;
        if (h) {
          e = (0, C.encodeExtendedSymbolOrGetSimpleSymbolString)(a);
        }
        this.tickerid = e;
        const d = u.Interval.parse(t);
        this.resolution = d.letter();
        this.interval = d.multiplier();
        this.period = d.value();
        this.index = -1;
        this.time = NaN;
        this.open = NaN;
        this.high = NaN;
        this.low = NaN;
        this.close = NaN;
        this.volume = NaN;
        this.updatetime = NaN;
        this.minTick = NaN;
        this.isNewBar = false;
        this.isBarClosed = false;
        this.isFirstBar = false;
        this.isLastBar = false;
        this.session = new T.SessionInfo("Etc/UTC", "24x7");
        this.regularSubsession = null;
        this.preMarketSubsession = null;
        this.postMarketSubsession = null;
        this.script = o;
        this.projectionTime = NaN;
        this.isAdditionalDepthAllowed = !(0, C.isStudySymbol)(a) || a.type.includes("BarSetHeikenAshi");
        if (n) {
          this.set_symbolinfo(n);
        }
      }
      set_symbolinfo(e) {
        if (!e) {
          console.error("WARN: symbolinfo isn't defined for " + this.tickerid);
        }
        this.info = e;
        this.minTick = e.minmov / e.pricescale;
        this.currencyCode = e.currency_code;
        this.unitId = e.unit_id;
        this.subsessionId = e.subsession_id;
        this.timezone = (0, P.get_timezone)(e.timezone);
        this.session.init(e.timezone, e.session, e.session_holidays, e.corrections);
        if (e.subsessions !== undefined) {
          const t = e.subsessions.find(e => e.id === x.SubsessionId.Regular);
          const i = e.subsessions.find(e => e.id === x.SubsessionId.PreMarket);
          const s = e.subsessions.find(e => e.id === x.SubsessionId.PostMarket);
          if (t !== undefined) {
            this.regularSubsession = new g.SessionsSpec(e.timezone, t.session, e.session_holidays, t["session-correction"]);
          }
          if (i !== undefined) {
            this.preMarketSubsession = new g.SessionsSpec(e.timezone, i.session, e.session_holidays, i["session-correction"]);
          }
          if (s !== undefined) {
            this.postMarketSubsession = new g.SessionsSpec(e.timezone, s.session, e.session_holidays, s["session-correction"]);
          }
        }
      }
      isdwm() {
        return this.resolution !== "" && this.resolution !== "S" && this.resolution !== "T";
      }
      enable_dwm_aligning(e, t) {
        this.dwm_aligner = (0, p.newBarBuilder)(this.period, e, t);
      }
      bartime() {
        const e = this.time;
        if (!this.isdwm() || isNaN(e)) {
          return e;
        }
        const t = (0, d.ensureDefined)(this.timezone, "symbol instrument timezone");
        let i = (0, P.utc_to_cal)(t, e);
        i = this.session.spec.correctTradingDay(i);
        return (0, P.cal_to_utc)(t, i);
      }
      lastbar(e) {
        if (isNaN(e.time)) {
          return;
        }
        let t = e.time;
        if (this.dwm_aligner) {
          const e = (0, P.get_cal_from_unix_timestamp_ms)(this.dwm_aligner.sessionSrc().timezone, t);
          if (!M || this.dwm_aligner.sessionTgt().spec.includesDay(e)) {
            this.dwm_aligner.moveTo(t);
            t = this.dwm_aligner.startOfBar(0);
          }
        }
        const i = this.time !== t;
        if (i && this.index >= 0 && !this.isBarClosed) {
          this.isNewBar = false;
          this.isBarClosed = true;
          this.script.calc(this);
        }
        this.time = t;
        this.open = e.open;
        this.high = e.high;
        this.low = e.low;
        this.close = e.close;
        this.volume = (0, I.isNumber)(e.volume) && e.volume >= 0 ? e.volume : NaN;
        this.updatetime = e.updatetime || NaN;
        this.isNewBar = i;
        this.isBarClosed = !!e.isBarClosed;
        this.isLastBar = !!e.isLastBar;
        this.projectionTime = e.projectionTime || NaN;
        if (this.isNewBar) {
          this.index++;
          this.isFirstBar = this.index === 0;
        }
        this.script.calc(this);
      }
    }
    var L = i(73772);
    class k {
      constructor(e) {
        this.mindepth = 0;
        this.original = NaN;
        this.modified = false;
        this._hist = null;
        this._histPos = 0;
        this.symbol = e;
      }
      valueOf() {
        return this.get(0);
      }
      get(e = 0) {
        if (isNaN(e)) {
          e = 0;
        }
        e = e || 0;
        if (this._hist) {
          if (e >= this._hist.length) {
            console.error("not enough depth: " + this);
            return NaN;
          } else {
            return this._get(e);
          }
        } else {
          this.mindepth = L.Std.max(this.mindepth, e);
          return NaN;
        }
      }
      set(e) {
        if (this._hist) {
          this._hist[this._histPos] = e;
          this.modified = true;
        }
      }
      prepare(e) {
        if (e === this.symbol) {
          if (e.isNewBar) {
            this.original = this.get(0);
            if (!!this.modified || !this._hist) {
              this.add_hist();
            }
          } else {
            this.set(this.original);
          }
          this.modified = false;
        }
      }
      add_hist() {
        if (!this._hist) {
          let e = L.Std.na(this.mindepth) ? L.Std.max_series_default_size : L.Std.max(this.mindepth + 1, 1);
          e = Math.round(e);
          const t = new Array(e);
          for (let i = 0; i < e; i++) {
            t[i] = NaN;
          }
          this._hist = t;
          this._histPos = -1;
        }
        this._histPos = Math.min(this._histPos + 1, this._hist.length);
        if (this._histPos === this._hist.length) {
          this._histPos = this._hist.length - 1;
          this._hist.shift();
          this._hist.push(NaN);
        }
        this._hist[this._histPos] = this.original;
      }
      reset_hist() {
        this._hist = null;
        this.add_hist();
      }
      adopt(e, t, i) {
        if (!this._hist) {
          this.mindepth = NaN;
        }
        const s = t.get();
        let o = e.indexOf(s);
        if (i !== 0) {
          const i = t.get(1);
          if (!L.Std.na(i)) {
            o = o === e.indexOf(i) ? -1 : o;
          }
        }
        if (o < 0) {
          return NaN;
        } else {
          return this._get(o);
        }
      }
      indexOf(e) {
        if (!this._hist) {
          this.mindepth = NaN;
          return -1;
        }
        if (L.Std.na(e)) {
          return -1;
        }
        const t = this._hist.length;
        const i = this.symbol.index + 1;
        const s = Math.min(t, i);
        const o = (0, _.upperbound_int)(this._hist, e, 0, s);
        if (o === 0) {
          return -1;
        } else {
          return s - o;
        }
      }
      _get(e) {
        if (this._hist === null) {
          return NaN;
        }
        let t = this._histPos - e;
        if (t < 0) {
          t += this._hist.length;
        }
        return this._hist[t];
      }
    }
    class D extends k {
      add_hist() {
        if (!this._hist) {
          this._hist = new Float64Array(2000);
          this._histPos = -1;
        }
        this._histPos = this._histPos + 1;
        if (this._histPos === this._hist.length) {
          const e = new Float64Array(this._hist.length * 2);
          e.set(this._hist);
          this._hist = e;
        }
        this._hist[this._histPos] = this.original;
      }
    }
    class E {
      constructor(e) {
        this.minimumAdditionalDepth = null;
        this._vars = [];
        this._varsIndex = 0;
        this._ctx = [];
        this._ctxIndex = 0;
        this.symbol = e;
      }
      new_sym(e, t, i, s, o) {
        return this.symbol.script.add_sym(e, t, i, s, o);
      }
      select_sym(e) {
        const t = this.symbol.script.get_sym(e);
        if (t == null) {
          L.Std.error(`Attempted to select symbol at index ${e} but there is no such symbol`);
        }
        this.symbol = t;
      }
      is_main_symbol(e) {
        return e !== undefined && e === this.symbol.script.get_sym(0);
      }
      new_var(e) {
        const t = this._vars;
        if (t.length <= this._varsIndex) {
          t.push(new k(this.symbol));
        }
        const i = t[this._varsIndex++];
        if (arguments.length > 0 && e !== undefined) {
          i.set(e);
        }
        return i;
      }
      new_unlimited_var(e) {
        const t = this._vars;
        if (t.length <= this._varsIndex) {
          t.push(new D(this.symbol));
        }
        const i = t[this._varsIndex++];
        if (arguments.length > 0) {
          i.set(e);
        }
        return i;
      }
      new_ctx() {
        if (this._ctx.length <= this._ctxIndex) {
          this._ctx.push(new E(this.symbol));
        }
        return this._ctx[this._ctxIndex++];
      }
      prepare(e) {
        this._ctxIndex = 0;
        this._varsIndex = 0;
        for (let t = 0; t < this._vars.length; t++) {
          this._vars[t].prepare(e);
        }
        for (let t = 0; t < this._ctx.length; t++) {
          this._ctx[t].prepare(e);
        }
      }
      maxAdditionalDepth() {
        if (this.minimumAdditionalDepth !== null) {
          return this.minimumAdditionalDepth;
        }
        let e = 0;
        for (let t = 0; t < this._vars.length; t++) {
          const i = this._vars[t].mindepth;
          if (!isNaN(i) && i > e) {
            e = i;
          }
        }
        return e;
      }
      stop() {
        this.symbol = null;
        this._vars = null;
      }
      setMinimumAdditionalDepth(e) {
        this.minimumAdditionalDepth = e;
      }
    }
    function B(e) {
      return !Array.isArray(e) && e.type !== "composite" && e.type !== "non_series_bars" && !!e.nonseries;
    }
    class V {
      constructor(e, t, i, s, o, n, r, a, l, c, h) {
        this._body = n;
        this._symbols = [];
        this._runner = o;
        this._inputCallback = a;
        this._out = r;
        this._nonseriesOut = l;
        this._ctx = new E(this.add_sym(e, t, i, s, c, h));
        this.init();
      }
      calc(e) {
        const t = this._ctx;
        const i = this._body;
        t.prepare(e);
        const s = i.main(t, this._inputCallback, e);
        var o;
        if (s != null) {
          if ((o = s) === null || Array.isArray(o) || o.type !== "composite") {
            this._processResult(s);
          } else {
            for (let e = 0; e < s.data.length; ++e) {
              this._processResult(s.data[e]);
            }
          }
        }
      }
      init() {
        const e = this._ctx;
        const t = this._body;
        if (t.init) {
          t.init(e, this._inputCallback);
        }
        t.main(e, this._inputCallback);
      }
      add_sym(e, t, i, s, o, n) {
        const r = this._runner.add_sym(e, t, i, s, this, o, n);
        this._symbols.push(r);
        if (r.isdwm() && this._symbols.length > 1 && this._runner.host.enableDwmAligning) {
          r.enable_dwm_aligning(this._symbols[0].session, r.session);
        }
        return r;
      }
      maxAdditionalDepth() {
        if (this._symbols[0].isAdditionalDepthAllowed) {
          return this._ctx.maxAdditionalDepth();
        } else {
          return 0;
        }
      }
      stop() {
        this._symbols = null;
        this._ctx?.stop();
        this._ctx = null;
      }
      get_sym(e) {
        return this._symbols[e];
      }
      _processResult(e) {
        const t = this._ctx;
        var i;
        if (this._out && e && (!isNaN(t.symbol.time) || B(e))) {
          if (B(e)) {
            i = e;
            if (!Array.isArray(i) && i.type === "projection") {
              e.projectionTime = t.symbol.time;
            }
            this._nonseriesOut(t.symbol, e);
          } else if (!function (e) {
            return !Array.isArray(e) && (e.type === "non_series_bars" || e.type === "projection");
          }(e)) {
            this._out(t.symbol, e);
          } else {
            e.bars.forEach(e => {
              this._out(t.symbol, e);
            });
          }
        }
      }
    }
    var R = i(1452);
    class N {
      constructor(e) {
        this._nonseriesUpdate = null;
        this._script = null;
        this._symbols = [];
        this._barsets = [];
        this._subscription = [];
        this.host = e;
        this._isRecalculated = false;
        this.isStarted = false;
        this.start();
      }
      add_sym(e, t, i, s, o, n, r) {
        const a = new A(e, t, i, s, o, n, r);
        this._symbols.push(a);
        return a;
      }
      get_sym(e) {
        return this._symbols[e];
      }
      out(e, t) {
        if (this._nonseriesUpdate) {
          const i = Object.assign({}, this._nonseriesUpdate);
          t.splice(0, 0, e.time);
          i.lastBar = t;
          this.host.nonseriesOut(e, i);
        } else {
          this.host.out(e, t);
        }
      }
      start() {
        this.isStarted = true;
        const e = this.host;
        const t = new V(e.tickerid, e.period, e.currencyCode, e.unitId, this, e.body, this.out.bind(this), e.input, e.nonseriesOut, e.symbolInfo, e.subsessionId);
        this._script = t;
        const i = [];
        const s = this._symbols;
        const o = Object.assign({}, e.dataRange, {
          countBack: e.dataRange.countBack + this._script.maxAdditionalDepth()
        });
        const n = s[0];
        const r = (t, s, o) => {
          i.push(N.feed.subscribe(t.tickerid, t.currencyCode, t.unitId, t.period, o, e.onErrorCallback, e.symbolInfo, e.sessionId, s, e.forceAlignBars, t.subsessionId));
        };
        const a = (t, i) => {
          if ((i.nonseries ? "nonseries" : "series") === "series") {
            this.update(t, i);
          } else if (i.lastBar) {
            this._nonseriesUpdate = i;
            i.lastBar.isLastBar = true;
            this._symbols[0].lastbar(i.lastBar);
            this._nonseriesUpdate = null;
          } else {
            e.nonseriesOut(s[0], i);
          }
        };
        const l = () => o;
        r(n, l, e => {
          if (!e.nonseries && Number.isFinite(e.firstLoadedTimeMs)) {
            (e => {
              function i(i, s) {
                let o = (0, m.createTimeToBarTimeAligner)(i, s)(e);
                const n = (0, m.createDwmAligner)(i, s);
                if (n !== null) {
                  o = n.timeToExchangeTradingDay(o);
                }
                return {
                  to: o,
                  countBack: (0, d.ensureNotNull)(t, "script runner script").maxAdditionalDepth()
                };
              }
              for (let e = 1; e < s.length; e++) {
                const t = s[e];
                const o = t.period;
                if (!u.Interval.isEqual(o, n.period)) {
                  r(t, i.bind(null, o), a.bind(null, e));
                }
              }
            })(e.firstLoadedTimeMs);
          }
          a(0, e);
        });
        for (let e = 1; e < s.length; e++) {
          const t = s[e];
          if (u.Interval.isEqual(t.period, n.period)) {
            r(t, l, a.bind(null, e));
          }
        }
        this._subscription = i;
      }
      stop() {
        const e = this._subscription;
        if (e || this._script) {
          if (e !== null) {
            for (let t = 0; t < e?.length; t++) {
              N.feed.unsubscribe(e[t]);
            }
          }
          this._subscription = null;
          this._script?.stop();
          this._script = null;
          this._symbols = null;
          this.isStarted = false;
        } else {
          console.warn("Recurring script engine stop happened.");
        }
      }
      update(e, t) {
        if (!t) {
          console.error("Unexpected barset = null");
          return;
        }
        const i = this._symbols[e];
        if (this._isRecalculated) {
          const e = t.bar(t.count() - 1);
          e.isBarClosed = t.isLastBarClosed();
          e.isLastBar = true;
          i.lastbar(e);
        } else if (!this._barsets[e]) {
          this._barsets[e] = t;
          i.set_symbolinfo(t.symbolinfo());
          this.recalc();
        }
      }
      recalc() {
        const e = this._symbols;
        for (let t = 0; t < e.length; t++) {
          if (!this._barsets[t]) {
            return;
          }
        }
        try {
          for (let t = e.length - 1; t >= 0; t--) {
            const i = e[t];
            const s = this._barsets[t];
            const o = s.count();
            for (let e = 0; e < o; e++) {
              const t = s.bar(e);
              t.isLastBar = e === o - 1;
              t.isBarClosed = !t.isLastBar || s.isLastBarClosed();
              i.lastbar(t);
            }
          }
          this._isRecalculated = true;
          const t = this._barsets.every(e => e.endOfData);
          if (t) {
            this.host.setNoMoreData();
          }
          this.host.recalc(this, {
            endOfData: t,
            firstLoadedTimeMs: this._barsets[0].firstLoadedTimeMs,
            emptyBarCount: this._barsets[0].emptyBarCount()
          });
        } catch (e) {
          if (!(e instanceof R.StudyError)) {
            throw e;
          }
          this.host.onErrorCallback(e.message);
        }
      }
    }
    N.feed = {
      subscribe() {
        console.error("must be initialized with setupFeed");
        throw new Error("must be initialized with setupFeed");
      },
      unsubscribe() {
        console.error("must be initialized with setupFeed");
        throw new Error("must be initialized with setupFeed");
      }
    };
    class O {
      constructor(e) {
        this.runner = new N(e);
      }
      stop() {
        this.runner.stop();
      }
      isStarted() {
        return this.runner.isStarted;
      }
    }
    class F {
      constructor(e, t, i, s, o, n, r, a, l, c) {
        this.listeners = e;
        this._isRecalculated = false;
        this._symbolInfo = r;
        this.engine = new O({
          tickerid: t,
          currencyCode: i,
          unitId: s,
          subsessionId: c,
          period: o,
          body: n,
          sessionId: l,
          symbolInfo: r,
          dataRange: a,
          forceAlignBars: false,
          enableDwmAligning: false,
          input: () => {
            throw new Error("BarBuildItem scripts should not need to access any input values");
          },
          recalc: (e, t) => {
            this._recalc(t);
          },
          out: (e, t) => {
            this._out(e, t);
          },
          nonseriesOut: (e, t) => {
            this._nonseriesOut(e, t);
          },
          setNoMoreData: () => {
            if (this._barset) {
              this._barset.endOfData = true;
            }
          },
          onErrorCallback: e => {
            this.listeners.onError(e);
          }
        });
      }
      stop() {
        if (this.engine) {
          this.engine.stop();
        } else {
          console.error("Internal library error 0x1");
        }
      }
      _recalc(e) {
        if (this._isRecalculated) {
          console.error("recalc called twice!");
        }
        this._barset ||= new f(this._symbolInfo);
        if (e) {
          this._barset.firstLoadedTimeMs = e.firstLoadedTimeMs;
          this._barset.endOfData = e.endOfData;
        }
        this.listeners.fire(this._barset);
        this._isRecalculated = true;
      }
      _nonseriesOut(e, t) {
        const i = Object.assign({}, t);
        i.nonseries = true;
        i.data = t.bars;
        delete i.bars;
        i.barsetSize = this._barset ? this._barset.count() : 0;
        i.lastBar = this._barset && this._barset.count() > 0 ? this._barset.bar(this._barset.count() - 1) : null;
        this.listeners.fire(i, true);
      }
      _out(e, t) {
        const i = t[0];
        if (isNaN(i)) {
          return;
        }
        const s = {
          time: i,
          open: t[1],
          high: t[2],
          low: t[3],
          close: t[4],
          volume: t[5],
          updatetime: t[6]
        };
        const o = t[7];
        this._barset ||= new f((0, d.ensureDefined)(e.info, "bar builder item output symbol info"));
        const n = t[8];
        const r = t[9];
        if (n instanceof Array && r) {
          for (let e = 0; e < n.length; e++) {
            const t = n[e];
            const i = {
              time: t,
              open: r,
              high: r,
              low: r,
              close: r,
              volume: 0,
              updatetime: t
            };
            this._barset.add(i, true, true);
            if (this._isRecalculated) {
              this.listeners.fire(this._barset);
            }
          }
        }
        this._barset.add(s, o);
        this._barset.isBarClosed = !!o;
        if (this._isRecalculated) {
          this.listeners.fire(this._barset);
        }
      }
    }
    class W {
      main(e) {
        const t = e.new_var(L.Std.open(e));
        const i = e.new_var(L.Std.close(e));
        const s = t.get(1);
        const o = i.get(1);
        const n = L.Std.ohlc4(e);
        const r = L.Std.na(t.get(1)) ? (L.Std.open(e) + L.Std.close(e)) / 2 : (s + o) / 2;
        t.set(r);
        i.set(n);
        const a = L.Std.max(L.Std.high(e), L.Std.max(r, n));
        const l = L.Std.min(L.Std.low(e), L.Std.min(r, n));
        const c = L.Std.volume(e);
        const h = e.symbol;
        return [h.time, r, a, l, n, c, h.updatetime, h.isBarClosed, undefined, undefined];
      }
    }
    var H = i(67153);
    class z {
      constructor(e, t, i, s, o, n, r, a) {
        this.listeners = e;
        this._host = n;
        this._host.resolve(t, i, e => {
          if (o && e.regular_session) {
            e.session = e.regular_session;
          }
          this._subs = this._host.subscribe(e, s, a, e => {
            this.listeners.fire(e);
          }, e => {
            this.listeners.onError(e);
          });
        }, e => {
          this.listeners.onError(e);
        });
      }
      stop() {
        if (this._subs) {
          this._host.unsubscribe(this._subs);
        }
      }
    }
    var U = i(40644);
    class j {
      constructor(e, t) {
        this._period = e;
        this._generateEmptyBars = !!t;
      }
      init(e) {
        this._bb = (0, p.newBarBuilder)(this._period, e.symbol.session, null);
        this._bbEmptyBars = this._generateEmptyBars ? (0, p.newBarBuilder)(this._period, e.symbol.session, null) : undefined;
        e.setMinimumAdditionalDepth(0);
      }
      main(e) {
        const t = (0, d.ensureDefined)(this._bb, "bar builder study bar builder");
        const i = e.symbol.time;
        const s = t.alignTime(i);
        const o = e.new_var(s);
        const n = L.Std.na(s);
        const r = o.get(1);
        const a = L.Std.na(r) ? 1 : L.Std.neq(s, r);
        const l = e.new_var();
        const c = e.new_var();
        const h = e.new_var();
        const u = e.new_var();
        const _ = l.get(1);
        const p = c.get(1);
        const m = h.get(1);
        const g = u.get(1);
        const f = n ? NaN : a ? L.Std.open(e) : _;
        const y = n ? NaN : a ? L.Std.high(e) : L.Std.max(L.Std.high(e), p);
        const v = n ? NaN : a ? L.Std.low(e) : L.Std.min(L.Std.low(e), m);
        const S = n ? NaN : L.Std.close(e);
        const b = n ? NaN : a ? L.Std.volume(e) : L.Std.volume(e) + g;
        const w = n ? NaN : i;
        const C = e.symbol.isBarClosed && t.isLastBar(0, i);
        const P = this._generateEmptyBars && a ? this._extrapolate(r, s) : undefined;
        const T = e.new_var(L.Std.close(e)).get(1);
        const x = P instanceof Array ? T : NaN;
        l.set(f);
        c.set(y);
        h.set(v);
        u.set(b);
        return [s, f, y, v, S, b, w, C, P, x];
      }
      _extrapolate(e, t) {
        if (isNaN(e) || isNaN(t)) {
          return undefined;
        } else {
          return (0, U.extrapolateBarsFrontToTime)((0, d.ensureDefined)(this._bbEmptyBars, "bar builder study empty bar builder"), e, t, Number.MAX_SAFE_INTEGER, true).times;
        }
      }
    }
    const G = e => {
      var t;
      Y.instance = new Y(e);
      t = Y.instance;
      N.feed = t;
    };
    const q = () => {
      Y.instance.removeUnused();
    };
    const $ = e => {
      console.error(e);
      L.Std.error(e);
    };
    const K = u.Interval.parse("1M").inMilliseconds(0);
    class Y {
      constructor(e) {
        this._host = e;
        this._cache = {};
      }
      subscribe(e, t, i, s, o, n, r, a, l, c, h) {
        const d = l(r);
        const u = ((e, t, i, s, o, n, r, a, l) => n + e + s + (t || "") + (i || "") + (l || "") + (o.has_empty_bars ? "_" : "") + "_" + r.countBack + "_" + r.to + "_" + Boolean(a))(e, t, i, s, r, a, d, c, h);
        let _ = this._getCache(u);
        if (!_) {
          _ = this._createItem(e, t, i, s, r, d, a, c, h);
          this._putCache(u, _);
        }
        _.listeners.addListener(o, n);
        return {
          key: u,
          listener: o
        };
      }
      unsubscribe(e) {
        const t = this._getCache(e.key);
        if (t) {
          t.listeners.removeListener(e.listener);
        }
      }
      removeUnused() {
        const e = [];
        const t = e => !!this._cache[e];
        for (const i in this._cache) {
          if (t(i)) {
            if ((0, d.ensureNotNull)(this._cache[i], `datafeed cache item ${i}`).listeners.listenersCount() === 0) {
              e.push(i);
            }
          }
        }
        if (e.length !== 0) {
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            const s = (0, d.ensureNotNull)(this._cache[i], `unused datafeed cache item ${i}`);
            this._cache[i] = null;
            s.stop();
          }
          this.removeUnused();
        }
      }
      _getCache(e) {
        return this._cache[e];
      }
      _putCache(e, t) {
        this._cache[e] = t;
      }
      _rebuildFrom(e, t) {
        const i = (0, H.findSuitableResolutionToBuildFrom)(e, t);
        if (i.error) {
          $(i.errorMessage);
          throw new Error(i.errorMessage);
        }
        return i.resolution;
      }
      _createItem(e, t, i, s, o, n, r, a, l) {
        const c = new w();
        const h = (0, C.decodeExtendedSymbol)(e);
        const d = typeof h.symbol != "string" ? h.symbol : h;
        t = d["currency-id"] || t;
        i = d["unit-id"] || i;
        const _ = d.symbol;
        const p = d.session && d.session !== x.SubsessionId.Extended;
        if ((l = d.session || l) === x.SubsessionId.Regular) {
          l = undefined;
        }
        if ("type" in h) {
          const e = Object.assign({}, o);
          if (o.has_empty_bars) {
            e.has_empty_bars = false;
          }
          return new F(c, _, t, i, s, function (e) {
            if (e.type.indexOf("BarSetHeikenAshi@tv-basicstudies-") === 0) {
              return new W();
            }
            const t = `unknown builder type: ${e.type}`;
            console.error(t);
            throw new Error(t);
          }(h), e, n, r, l);
        }
        if (a && !(0, m.isAlignmentEnabled)()) {
          $("Internal error: rebuilding is requested but it is disabled.");
        }
        if (!a && o.has_empty_bars) {
          $("Misconfiguration error: attempt to request data for symbol with \"has_empty_bars\" flag, but \"disable_resolution_rebuild\" featureset is enabled");
        }
        const g = this._rebuildFrom(s, o);
        if (!u.Interval.isTicks(s) && (!u.Interval.isEqual(s, g) || a)) {
          if (!(0, m.isAlignmentEnabled)()) {
            $("Misconfiguration error: remove \"disable_resolution_rebuild\" featureset or provide " + s + " data by yourself");
          }
          const a = o.has_empty_bars;
          const h = Object.assign({}, o);
          if (o.has_empty_bars) {
            h.has_empty_bars = false;
          }
          const d = Math.ceil((f = u.Interval.parse(s), y = u.Interval.parse(g), f.kind() === y.kind() ? f.multiplier() / y.multiplier() : (f.isMonths() ? f.multiplier() * K : f.inMilliseconds()) / (y.isMonths() ? y.multiplier() * K : y.inMilliseconds())));
          n = Object.assign({}, n, {
            countBack: n.countBack * d
          });
          return new F(c, e, t, i, g, new j(s, a), h, n, r, l);
        }
        var f;
        var y;
        return new z(c, _, {
          currency: t,
          unit: i,
          session: l
        }, s, !!p, this._host, o, n);
      }
    }
    var Z = i(97085);
    var X = i(68805);
    var J;
    var Q = i(63950);
    function ee(e, t) {
      return e.length > t;
    }
    (function (e) {
      e[e.DefaultExtrapolateLimit = 200000] = "DefaultExtrapolateLimit";
    })(J ||= {});
    class te {
      constructor(e, t, i = 200000) {
        this._firstRealBarTimeMs = null;
        this._historyBarsCache = [];
        this._projectionFirstIndex = Infinity;
        this._barsTimes = [];
        this._minFutureBarsCount = 0;
        this._lastRealBarTimeMs = null;
        this._futureBarsCache = [];
        this._symbolInfo = e;
        this._interval = u.Interval.parse(t);
        this._extrapolateLimit = i;
        this._session = new p.SessionInfo(e.timezone, e.session, e.session_holidays, e.corrections);
        this._barBuilder = (0, p.newBarBuilder)(t, this._session, null);
      }
      destroy() {
        this.clear();
      }
      interval() {
        return this._interval;
      }
      barBuilder() {
        return this._barBuilder;
      }
      symbolInfo() {
        return this._symbolInfo;
      }
      clear() {
        this._firstRealBarTimeMs = null;
        this._historyBarsCache = [];
        this._barsTimes = [];
        this._lastRealBarTimeMs = null;
        this._futureBarsCache = [];
        this._minFutureBarsCount = 0;
        this._projectionFirstIndex = Infinity;
      }
      firstFutureBarIndex() {
        return this._barsTimes.length;
      }
      futureBars() {
        return this._futureBarsCache;
      }
      replaceBarsTimesTail(e, t = e.length) {
        if (e.length === 0) {
          return;
        }
        if (this._barsTimes.length === 0) {
          this.setBarsTimes(e, t);
          return;
        }
        const i = e[0];
        const s = this._barsTimes[this._barsTimes.length - 1];
        const o = i > s ? this._barsTimes.length : (0, _.lowerbound_int)(this._barsTimes, i);
        if (o !== 0) {
          this._barsTimes.splice(o, this._barsTimes.length, ...e);
          this._projectionFirstIndex = t === e.length ? this._barsTimes.length : this._barsTimes.indexOf(e[t]);
          (0, d.assert)(this._projectionFirstIndex !== -1, "something went wrong");
          if (s !== e[e.length - 1]) {
            this._setLastRealBarTime(e[e.length - 1]);
          }
        } else {
          this.setBarsTimes(e, t);
        }
      }
      setBarsTimes(e, t = e.length) {
        const i = this._barsTimes;
        this._barsTimes = e.slice();
        this._projectionFirstIndex = this._barsTimes.length === 0 ? Infinity : t;
        if (e.length === 0) {
          this._historyBarsCache = [];
          this._futureBarsCache = [];
          this._firstRealBarTimeMs = null;
          this._lastRealBarTimeMs = null;
          return;
        }
        if (i.length === 0 || i[i.length - 1] !== e[e.length - 1]) {
          this._setLastRealBarTime(e[e.length - 1]);
        }
        if (i.length === 0 || i[0] !== e[0]) {
          this._historyBarsCache = [];
          this._firstRealBarTimeMs = e[0];
        }
      }
      extrapolateTimeWithOffsetToTime(e, t) {
        if (t === 0) {
          return {
            timeMs: e,
            exact: true
          };
        }
        if (this._barsTimes.length === 0) {
          if (t < 0) {
            if (this._firstRealBarTimeMs === null) {
              this._firstRealBarTimeMs = e;
            } else {
              this._extendHistoryCacheToTimeFromRight(Math.min(e, this._lastRealBarTimeMs !== null ? this._lastRealBarTimeMs : Infinity));
              this._ensureExtrapolatedToHistoryTime(e);
            }
          } else if (this._lastRealBarTimeMs === null) {
            this._lastRealBarTimeMs = e;
          } else {
            this._extendFutureCacheToTimeFromLeft(Math.max(e, this._firstRealBarTimeMs !== null ? this._firstRealBarTimeMs : Infinity));
            this.ensureExtrapolatedToFutureTime(e);
          }
        }
        const i = this.indexOfTime(e);
        if (i === null) {
          return null;
        }
        const s = this.timeOfBarIndex(i.index + t, 0);
        if (s === null) {
          return null;
        } else {
          if (i.index < 0 || this._projectionFirstIndex <= i.index) {
            s.exact = false;
          }
          return s;
        }
      }
      indexOfTime(e) {
        if (this._firstRealBarTimeMs !== null && e < this._firstRealBarTimeMs) {
          this._ensureExtrapolatedToHistoryTime(e);
          let t = (0, _.lowerbound_int)(this._historyBarsCache, e);
          if (this._historyBarsCache.length !== 0 && t === 0 && e < this._historyBarsCache[0]) {
            return null;
          }
          if (t === this._historyBarsCache.length || this._historyBarsCache[t] !== e) {
            t -= 1;
          }
          return {
            index: t - this._historyBarsCache.length,
            timeMs: this._historyBarsCache[t]
          };
        }
        if (this._lastRealBarTimeMs !== null && e > this._lastRealBarTimeMs) {
          this.ensureExtrapolatedToFutureTime(e);
          let t = (0, _.lowerbound_int)(this._futureBarsCache, e);
          if (this._futureBarsCache.length !== 0 && t === this._futureBarsCache.length && e > this._futureBarsCache[this._futureBarsCache.length - 1]) {
            return null;
          }
          if (this._futureBarsCache[t] !== e) {
            t -= 1;
          }
          const i = Math.max(1, this._barsTimes.length) + t;
          return {
            index: i,
            timeMs: i === this._barsTimes.length - 1 ? (0, d.ensureNotNull)(this._lastRealBarTimeMs) : this._futureBarsCache[t]
          };
        }
        if (this._barsTimes.length === 0) {
          if (this._firstRealBarTimeMs !== null && this._firstRealBarTimeMs <= e || this._lastRealBarTimeMs !== null && e <= this._lastRealBarTimeMs) {
            const e = this.timeOfBarIndex(0, 0);
            if (e === null) {
              return null;
            } else {
              return {
                index: 0,
                timeMs: e.timeMs
              };
            }
          }
          return null;
        }
        let t = (0, _.lowerbound_int)(this._barsTimes, e);
        if (this._barsTimes[t] !== e) {
          t -= 1;
        }
        return {
          index: t,
          timeMs: this._barsTimes[t]
        };
      }
      setMinFutureBarsCount(e) {
        this._minFutureBarsCount = e;
        if (this._barsTimes.length !== 0) {
          this._ensureExtrapolatedToFutureBar(e);
        }
      }
      ensureExtrapolatedToFutureTime(e) {
        if ((this._lastRealBarTimeMs === null || !(this._lastRealBarTimeMs >= e)) && !ee(this._futureBarsCache, this._extrapolateLimit) && (this._futureBarsCache.length === 0 || !(this._futureBarsCache[this._futureBarsCache.length - 1] >= e))) {
          if (o.enabled("disable_resolution_rebuild") && (this._interval.isDays() || this._interval.isWeeks()) && this._barsTimes.length >= 2) {
            this._extendFutureCacheFromRight((t, i) => {
              const s = this._futureBarsCache.length > 0 ? this._futureBarsCache[this._futureBarsCache.length - 1] : t;
              return this._calculateBarPattern(s, e, null);
            });
          } else {
            this._extendFutureCacheFromRight((t, i) => (0, U.extrapolateBarsFrontToTime)(this._barBuilder, t, e, this._extrapolateLimit, true).times);
          }
          if (this._futureBarsCache[this._futureBarsCache.length - 1] < e) {
            this._ensureExtrapolatedToFutureBar(this._futureBarsCache.length + 1);
          }
        }
      }
      timeOfBarIndex(e, t = 0) {
        const i = this._timeOfBarIndex(e);
        if (i === null) {
          this._ensureExtrapolatedToFutureBar(Math.max(0, this._barsTimes.length === 0 ? 0 : this._barsTimes.length - 1) + t + 1);
          const i = this._timeOfBarIndex(e + t);
          if (i !== null) {
            this.ensureExtrapolatedToFutureTime(i.timeMs);
          }
        }
        return i;
      }
      _setLastRealBarTime(e) {
        const t = this._futureBarsCache.length;
        const i = (0, _.upperbound_int)(this._futureBarsCache, e);
        if (i === 0) {
          this._extendFutureCacheToTimeFromLeft(e);
        } else {
          this._lastRealBarTimeMs = e;
          this._futureBarsCache = this._futureBarsCache.slice(i);
        }
        this._ensureExtrapolatedToFutureBar(Math.max(t, this._minFutureBarsCount));
      }
      _timeOfBarIndex(e) {
        if (e < 0) {
          const t = Math.abs(e);
          this._ensureExtrapolatedToHistoryBar(t);
          const i = this._historyBarsCache.length - t;
          if (i < 0) {
            return null;
          } else {
            return {
              timeMs: this._historyBarsCache[i],
              exact: false
            };
          }
        }
        if (e === 0 && this._barsTimes.length === 0) {
          return {
            timeMs: (0, d.ensureNotNull)(this._firstRealBarTimeMs ?? this._lastRealBarTimeMs),
            exact: false
          };
        }
        if (e >= this._barsTimes.length) {
          const t = e - Math.max(1, this._barsTimes.length);
          this._ensureExtrapolatedToFutureBar(t + 1);
          if (t >= this._futureBarsCache.length) {
            return null;
          } else {
            return {
              timeMs: this._futureBarsCache[t],
              exact: false
            };
          }
        }
        return {
          timeMs: this._barsTimes[e],
          exact: e < this._projectionFirstIndex
        };
      }
      _calculateBarPattern(e, t, i) {
        const s = this.interval();
        const o = s.multiplier();
        const n = s.isDWM();
        const r = [];
        let a;
        let l = e;
        a = s.isSeconds() ? 1000 : s.isMinutes() ? 60000 : s.isDays() ? 86400000 : s.isWeeks() ? 604800000 : s.isMonths() ? 2592000000 : 86400000;
        let c = 0;
        while ((i === null || c < i) && (t === null || l < t)) {
          const e = l + o * a;
          let t = e;
          if (n) {
            this._barBuilder.moveTo(e);
            const i = new Date(e);
            const s = this._session.spec;
            const o = s?.correctTradingDay(i);
            if (o) {
              t = o.getTime();
            }
          } else {
            this._barBuilder.moveTo(e);
            const i = this._barBuilder.indexOfBar(e);
            t = this._barBuilder.startOfBar(i);
          }
          if (r.includes(t)) {
            const e = l + o * a;
            if (r.includes(e)) {
              break;
            }
            r.push(e);
            l = e;
          } else {
            r.push(t);
            l = t;
          }
          if (r.length > this._extrapolateLimit) {
            break;
          }
          c++;
        }
        return r;
      }
      _extendFutureCacheFromRight(e) {
        const t = this._futureBarsCache.length !== 0 ? this._futureBarsCache[this._futureBarsCache.length - 1] : this._lastRealBarTimeMs;
        if (t === null) {
          return false;
        }
        const i = e(t, this._futureBarsCache.length) || [];
        return i.length !== 0 && (this._futureBarsCache = this._futureBarsCache.concat(i), true);
      }
      _extendHistoryCacheFromLeft(e) {
        const t = this._historyBarsCache.length !== 0 ? this._historyBarsCache[0] : this._firstRealBarTimeMs;
        if (t === null) {
          return;
        }
        const i = e(t, this._historyBarsCache.length);
        this._historyBarsCache = i.concat(this._historyBarsCache);
      }
      _extendFutureCacheToTimeFromLeft(e) {
        if (this._lastRealBarTimeMs !== null && this._lastRealBarTimeMs <= e) {
          return;
        }
        (0, d.assert)(this._barsTimes.length === 0 || e === this._barsTimes[this._barsTimes.length - 1], "invalid argument");
        this._lastRealBarTimeMs = e;
        if (this._futureBarsCache.length === 0) {
          return;
        }
        const t = (0, U.extrapolateBarsFrontToTime)(this._barBuilder, e, this._futureBarsCache[0] - 1, this._extrapolateLimit, true).times;
        this._futureBarsCache = t.concat(this._futureBarsCache);
      }
      _extendHistoryCacheToTimeFromRight(e) {
        if (this._firstRealBarTimeMs !== null && this._firstRealBarTimeMs >= e) {
          return;
        }
        (0, d.assert)(this._barsTimes.length === 0, "bars should be empty");
        this._firstRealBarTimeMs = e;
        if (this._historyBarsCache.length === 0) {
          return;
        }
        const t = (0, U.extrapolateBarsFrontToTime)(this._barBuilder, this._historyBarsCache[this._historyBarsCache.length - 1], e - 1, this._extrapolateLimit, true).times;
        this._historyBarsCache = this._historyBarsCache.concat(t);
      }
      _ensureExtrapolatedToFutureBar(e) {
        return !(this._futureBarsCache.length >= e) && !ee(this._futureBarsCache, this._extrapolateLimit) && (o.enabled("disable_resolution_rebuild") && (this._interval.isDays() || this._interval.isWeeks()) && this._barsTimes.length >= 2 ? this._extendFutureCacheFromRight((t, i) => {
          const s = this._futureBarsCache.length > 0 ? this._futureBarsCache[this._futureBarsCache.length - 1] : t;
          const o = e - i;
          return this._calculateBarPattern(s, null, o);
        }) : this._extendFutureCacheFromRight((t, i) => (0, U.extrapolateBarsFrontByCount)(this._barBuilder, t, e - i, true).times));
      }
      _ensureExtrapolatedToHistoryBar(e) {
        if (!(this._historyBarsCache.length >= e) && !ee(this._historyBarsCache, this._extrapolateLimit)) {
          this._extendHistoryCacheFromLeft((t, i) => (0, U.extrapolateBarsFrontByCount)(this._barBuilder, t, -(e - i), true).times.reverse());
        }
      }
      _ensureExtrapolatedToHistoryTime(e) {
        if ((this._firstRealBarTimeMs === null || !(this._firstRealBarTimeMs <= e)) && !ee(this._historyBarsCache, this._extrapolateLimit) && (this._historyBarsCache.length === 0 || !(this._historyBarsCache[0] <= e))) {
          this._extendHistoryCacheFromLeft((t, i) => {
            const s = (0, U.extrapolateBarsFrontToTime)(this._barBuilder, t - 1, e - 1, this._extrapolateLimit, true).times;
            if (s[s.length - 1] === t) {
              return s.slice(0, -1);
            } else {
              return s;
            }
          });
          if (this._historyBarsCache.length === 0 || this._historyBarsCache[0] > e) {
            this._ensureExtrapolatedToHistoryBar(this._historyBarsCache.length + 1);
          }
        }
      }
    }
    var ie = i(2060);
    var se = i.n(ie);
    var oe = i(76422);
    var ne = i(50503);
    var re = i(9447);
    function ae(e) {
      return e * 60 * 60 * 1000;
    }
    function le(e) {
      return e * 60 * 1000;
    }
    const ce = [{
      divisor: 1,
      weight: 18
    }, {
      divisor: (he = 1, he * 1000),
      weight: 19
    }, {
      divisor: le(1),
      weight: 20
    }, {
      divisor: le(5),
      weight: 21
    }, {
      divisor: le(30),
      weight: 22
    }, {
      divisor: ae(1),
      weight: 30
    }, {
      divisor: ae(3),
      weight: 31
    }, {
      divisor: ae(6),
      weight: 32
    }, {
      divisor: ae(12),
      weight: 33
    }];
    var he;
    var de;
    function ue(e, t) {
      if (t !== null) {
        if (e.getUTCFullYear() !== t.getUTCFullYear()) {
          return 70;
        }
        if (e.getUTCMonth() !== t.getUTCMonth()) {
          return 60;
        }
        if (e.getUTCDate() !== t.getUTCDate()) {
          return 50;
        }
        const i = t.getTime();
        const s = e.getTime();
        for (let e = ce.length - 1; e >= 0; --e) {
          if (Math.floor(i / ce[e].divisor) !== Math.floor(s / ce[e].divisor)) {
            return ce[e].weight;
          }
        }
      }
      return 18;
    }
    function _e(e, t, i = 0) {
      if (e.length === 0) {
        return [];
      }
      let s = i;
      let o = i;
      const n = [];
      while (s < e.length) {
        if (o >= t.length) {
          n.push({
            old: s,
            new: ne.INVALID_TIME_POINT_INDEX
          });
          s++;
        } else if (e[s].timeMs === t[o].timeMs) {
          if (s !== o) {
            n.push({
              old: s,
              new: o
            });
          }
          s++;
          o++;
        } else if (e[s].timeMs < t[o].timeMs) {
          n.push({
            old: s,
            new: ne.INVALID_TIME_POINT_INDEX
          });
          s++;
        } else {
          o++;
        }
      }
      return n.sort((e, t) => {
        if (e.new === t.new && e.new === ne.INVALID_TIME_POINT_INDEX) {
          return e.old - t.old;
        }
        if (e.new === ne.INVALID_TIME_POINT_INDEX) {
          return -1;
        }
        if (t.new === ne.INVALID_TIME_POINT_INDEX) {
          return 1;
        }
        const i = e.old - e.new;
        const s = t.old - t.new;
        if (i > 0) {
          if (s > 0) {
            return e.old - t.old;
          } else {
            return -1;
          }
        } else if (s < 0) {
          return t.new - e.new;
        } else {
          return 1;
        }
      });
    }
    function pe(e, t) {
      return {
        span: e.markWeight,
        time: e.displayTime,
        index: t
      };
    }
    (function (e) {
      e[e.FutureTickMarksLimit = 1000] = "FutureTickMarksLimit";
    })(de ||= {});
    const me = o.enabled("end_of_period_timescale_marks");
    const ge = o.enabled("align_dwm_bars_to_main_series");
    class fe {
      constructor() {
        this._completed = true;
        this._mainSymbolExtrapolator = null;
        this._pointDataByTimePoint = new Map();
        this._instanceIds = new Set();
        this._displayTimezone = null;
        this._minFutureBarsCount = 0;
        this._sortedTimePoints = [];
      }
      destroy() {
        this.clearTimeScale();
      }
      setCompleted(e) {
        this._completed = e;
      }
      isCompleted() {
        return this._completed;
      }
      clearTimeScale() {
        this._pointDataByTimePoint.clear();
        this._instanceIds.clear();
        this._sortedTimePoints = [];
        return {
          baseIndex: null,
          pointsIndex: 0,
          indexChange: [],
          marks: [],
          points: []
        };
      }
      indexOfTime(e) {
        if (this._sortedTimePoints.length === 0) {
          if (this._mainSymbolExtrapolator === null) {
            return null;
          } else {
            return this._mainSymbolExtrapolator.indexOfTime(e);
          }
        }
        if (e < this._sortedTimePoints[0].timeMs) {
          if (this._mainSymbolExtrapolator === null) {
            return null;
          }
          const t = this._mainSymbolExtrapolator.indexOfTime(e);
          const i = this._mainSymbolExtrapolator.indexOfTime(this._sortedTimePoints[0].timeMs);
          if (t === null || i === null) {
            return null;
          }
          let s = t.index - i.index;
          if (i.timeMs !== this._sortedTimePoints[0].timeMs) {
            s -= 1;
          }
          return {
            index: s,
            timeMs: t.timeMs
          };
        }
        if (e > this._sortedTimePoints[this._sortedTimePoints.length - 1].timeMs) {
          if (this._mainSymbolExtrapolator === null) {
            return null;
          }
          const t = this._mainSymbolExtrapolator.indexOfTime(e);
          const i = this._mainSymbolExtrapolator.indexOfTime(this._sortedTimePoints[this._sortedTimePoints.length - 1].timeMs);
          if (t === null || i === null) {
            return null;
          }
          const s = t.index - i.index - 1;
          return {
            index: this._sortedTimePoints.length + s,
            timeMs: t.timeMs
          };
        }
        let t = (0, _.lowerbound)(this._sortedTimePoints, e, (e, t) => e.timeMs < t);
        if (this._sortedTimePoints[t].timeMs !== e) {
          t -= 1;
        }
        return {
          index: t,
          timeMs: this._sortedTimePoints[t].timeMs
        };
      }
      setMainSymbolExtrapolator(e) {
        this._mainSymbolExtrapolator = e;
        this._updateFutureBars();
        this._fillPointsData(this._sortedTimePoints, 0);
      }
      setMinFutureBarsCount(e) {
        this._minFutureBarsCount = e;
        this._updateFutureBars();
      }
      minFutureBarsCount() {
        return this._minFutureBarsCount;
      }
      firstFutureBarIndex() {
        return this._sortedTimePoints.length;
      }
      firstSessionBarIndex() {
        if (this._sortedTimePoints.length === 0) {
          return null;
        } else {
          return 0;
        }
      }
      lastSessionBarIndex() {
        if (this._sortedTimePoints.length === 0) {
          return null;
        } else {
          return this._sortedTimePoints.length - 1;
        }
      }
      tickMarks(e = 0) {
        const t = this.firstFutureBarIndex();
        (0, d.assert)(e <= t, "tickmarks cannot be filtered in the future");
        const i = this._futureBars().map((e, t) => ({
          timeMs: e,
          markWeight: 0,
          displayTime: NaN
        }));
        this._fillPointsData(i, 0, this._sortedTimePoints.length !== 0 ? this._sortedTimePoints[this._sortedTimePoints.length - 1].displayTime : null);
        const s = [];
        for (let t = e; t < this._sortedTimePoints.length; ++t) {
          s.push(pe(this._sortedTimePoints[t], t));
        }
        const o = i.map((e, i) => pe(e, i + t));
        return s.concat(o);
      }
      setTimezone(e) {
        this._displayTimezone = e === "exchange" ? null : (0, P.get_timezone)(e);
        this._fillPointsData(this._sortedTimePoints, 0);
      }
      fillIndexesInRows(e) {
        if (e.length === 0) {
          return;
        }
        let t = -1;
        let i = (0, _.lowerbound)(this._sortedTimePoints, Math.round(e[0].value[0] * 1000), (e, t) => e.timeMs < t);
        for (const s of e) {
          const e = Math.round(s.value[0] * 1000);
          while (i < this._sortedTimePoints.length && this._sortedTimePoints[i].timeMs < e) {
            i += 1;
          }
          if (i === this._sortedTimePoints.length || this._sortedTimePoints[i].timeMs !== e) {
            i -= 1;
          }
          (0, d.assert)(i !== t, "data must have unique times");
          t = i;
          s.index = i;
        }
        (0, d.assert)(i < this._sortedTimePoints.length, "data must be within a data range");
      }
      convertTimesToIndexes(e, t = false) {
        if (e.length === 0) {
          return [];
        }
        let i = -1;
        let s = (0, _.lowerbound)(this._sortedTimePoints, e[0], (e, t) => e.timeMs < t);
        return e.map((e, o, n) => {
          while (s < this._sortedTimePoints.length && this._sortedTimePoints[s].timeMs < e) {
            s += 1;
          }
          if (s === 0 && e < this._sortedTimePoints[0].timeMs) {
            return ne.INVALID_TIME_POINT_INDEX;
          }
          if (s >= this._sortedTimePoints.length) {
            const t = this.indexOfTime(e);
            if (t === null) {
              return ne.INVALID_TIME_POINT_INDEX;
            }
            s = t.timeMs !== e ? t.index + 1 : t.index;
          }
          if (!t || o > 0 && e <= n[o - 1]) {
            (0, d.assert)(s > i, "data must have unique sorted times");
          }
          i = s;
          return s;
        });
      }
      firstSeriesBarTime() {
        if (this._sortedTimePoints.length === 0) {
          return null;
        } else {
          return this._sortedTimePoints[0].timeMs;
        }
      }
      replaceBarsTimesTail(e, t) {
        if (t.length === 0) {
          return null;
        }
        if (!this._instanceIds.has(e)) {
          return this.setSeriesBarsTimes(e, t);
        }
        const i = [];
        const s = (0, _.lowerbound)(this._sortedTimePoints, t[0], (e, t) => e.timeMs < t);
        for (let t = s; t < this._sortedTimePoints.length; ++t) {
          const s = this._sortedTimePoints[t];
          if (s.pointData.instances.delete(e) && s.pointData.instances.size === 0) {
            i.push(s);
          }
        }
        const o = this._addBarsTimesToInstance(e, t, true);
        this._cleanupPointsData(i);
        const n = o.map(e => ({
          timeMs: e.timeMs,
          pointData: e.pointData,
          markWeight: 0,
          displayTime: NaN
        }));
        for (let e = s; e < this._sortedTimePoints.length; ++e) {
          const t = this._sortedTimePoints[e];
          if (t.pointData.instances.size !== 0) {
            n.push(t);
          }
        }
        n.sort((e, t) => e.timeMs - t.timeMs);
        const r = this._updateTimeScalePointsTail(n);
        return this._applyTimeScaleChanges(r, false);
      }
      setSeriesBarsTimes(e, t) {
        return this._setBarsTimes(e, t);
      }
      setStudyBarsTimes(e, t) {
        return this._setBarsTimes(e, t);
      }
      _setBarsTimes(e, t) {
        const i = this._pointDataByTimePoint.size !== 0;
        if (this._instanceIds.has(e)) {
          for (const t of this._sortedTimePoints) {
            t.pointData.instances.delete(e);
          }
        }
        if (t.length === 0) {
          this._instanceIds.delete(e);
        } else {
          this._instanceIds.add(e);
        }
        this._addBarsTimesToInstance(e, t, false);
        if (i) {
          this._cleanupPointsData(this._sortedTimePoints);
        }
        const s = [];
        this._pointDataByTimePoint.forEach((e, t) => {
          s.push({
            markWeight: 0,
            timeMs: t,
            displayTime: NaN,
            pointData: e
          });
        });
        s.sort((e, t) => e.timeMs - t.timeMs);
        const o = this._updateTimeScalePoints(s);
        return this._applyTimeScaleChanges(o, false);
      }
      _updateFutureBars() {
        if (this._minFutureBarsCount === 0 || this._mainSymbolExtrapolator === null) {
          return;
        }
        if (this._sortedTimePoints.length !== 0) {
          const e = this._sortedTimePoints[this._sortedTimePoints.length - 1].timeMs;
          this._mainSymbolExtrapolator.ensureExtrapolatedToFutureTime(e);
        }
        const e = this._futureBarsFirstPointIndex();
        this._mainSymbolExtrapolator.setMinFutureBarsCount(e + this._minFutureBarsCount);
      }
      _addBarsTimesToInstance(e, t, i) {
        const s = i ? [] : null;
        for (const i of t) {
          const t = this._pointDataByTimePoint.get(i);
          if (t === undefined) {
            const t = new Set();
            t.add(e);
            const o = {
              index: 0,
              instances: t
            };
            this._pointDataByTimePoint.set(i, o);
            if (s !== null) {
              s.push({
                timeMs: i,
                pointData: o
              });
            }
          } else {
            t.instances.add(e);
          }
        }
        return s;
      }
      _futureBarsFirstPointIndex() {
        if (this._mainSymbolExtrapolator === null || this._sortedTimePoints.length === 0) {
          return 0;
        }
        const e = this._mainSymbolExtrapolator.futureBars();
        return (0, _.upperbound_int)(e, this._sortedTimePoints[this._sortedTimePoints.length - 1].timeMs);
      }
      _futureBars() {
        if (this._mainSymbolExtrapolator === null) {
          return [];
        } else {
          return this._mainSymbolExtrapolator.futureBars().slice(this._futureBarsFirstPointIndex(), this._futureBarsFirstPointIndex() + 1000);
        }
      }
      _cleanupPointsData(e) {
        for (const t of e) {
          if (t.pointData.instances.size === 0) {
            this._pointDataByTimePoint.delete(t.timeMs);
          }
        }
      }
      _updateTimeScalePoints(e) {
        let t = -1;
        for (let i = 0; i < this._sortedTimePoints.length && i < e.length; ++i) {
          const s = this._sortedTimePoints[i];
          const o = e[i];
          if (s.timeMs !== o.timeMs) {
            t = i;
            break;
          }
          o.markWeight = s.markWeight;
          o.displayTime = s.displayTime;
        }
        t = ye(t, this._sortedTimePoints.length, e.length);
        if (t === -1) {
          return null;
        }
        for (let i = t; i < e.length; ++i) {
          e[i].pointData.index = i;
        }
        this._fillPointsData(e, t);
        const i = _e(this._sortedTimePoints, e, t);
        this._sortedTimePoints = e;
        this._updateFutureBars();
        return {
          pointsIndex: t,
          indexChange: i
        };
      }
      _updateTimeScalePointsTail(e) {
        if (e.length === 0) {
          return null;
        }
        const t = (0, _.lowerbound)(this._sortedTimePoints, e[0].timeMs, (e, t) => e.timeMs < t);
        let i = -1;
        for (let s = 0; s < e.length; ++s) {
          const o = e[s];
          const n = t + s;
          o.pointData.index = n;
          if (n >= this._sortedTimePoints.length) {
            continue;
          }
          if (this._sortedTimePoints[n].timeMs !== o.timeMs && i === -1) {
            i = n;
          }
        }
        const s = t + e.length;
        i = ye(i, this._sortedTimePoints.length, s);
        if (i === -1) {
          return null;
        }
        this._fillPointsData(e, 0, t === 0 || this._sortedTimePoints.length === 0 ? null : this._sortedTimePoints[t - 1].displayTime);
        const o = _e(this._sortedTimePoints.slice(t), e).map(e => ({
          old: e.old + t,
          new: e.new === ne.INVALID_TIME_POINT_INDEX ? e.new : e.new + t
        }));
        {
          const i = this._sortedTimePoints;
          let o = 0;
          while (t + o < i.length && o < e.length) {
            i[t + o] = e[o];
            o += 1;
          }
          for (; o < e.length; ++o) {
            i.push(e[o]);
          }
          i.length = s;
        }
        this._updateFutureBars();
        return {
          pointsIndex: i,
          indexChange: o
        };
      }
      _getBaseIndex() {
        if (this._sortedTimePoints.length === 0) {
          return null;
        } else {
          return this._sortedTimePoints.length - 1;
        }
      }
      _fillPointsData(e, t, i = null) {
        this._fillDiplayTimeForPoints(e, t);
        (function (e, t = 0, i = null) {
          let s = t === 0 || e.length === 0 ? i : e[t - 1].displayTime;
          let o = s !== null ? new Date(s * 1000) : null;
          let n = 0;
          for (let i = t; i < e.length; ++i) {
            const t = e[i];
            const r = new Date(t.displayTime * 1000);
            t.markWeight = ue(r, o);
            n += t.displayTime - (s || t.displayTime);
            o = r;
            s = t.displayTime;
          }
          if (t === 0 && e.length > 1 && i === null) {
            const t = Math.ceil(n / (e.length - 1));
            const i = new Date((e[0].displayTime - t) * 1000);
            e[0].markWeight = ue(new Date(e[0].displayTime * 1000), i);
          }
        })(e, t, i);
      }
      _applyTimeScaleChanges(e, t) {
        if (e === null) {
          if (t) {
            this._fillPointsData(this._sortedTimePoints, 0);
            return {
              points: [],
              pointsIndex: 0,
              baseIndex: this._getBaseIndex(),
              indexChange: [],
              marks: this.tickMarks(0)
            };
          } else {
            return null;
          }
        }
        let i = e.pointsIndex;
        if (i !== 0 && t) {
          this._fillPointsData(this._sortedTimePoints, 0);
          i = 0;
        }
        if (this._sortedTimePoints.length === 0) {
          return {
            baseIndex: null,
            pointsIndex: 0,
            indexChange: [],
            marks: [],
            points: []
          };
        }
        const s = [];
        for (let t = e.pointsIndex; t < this._sortedTimePoints.length; ++t) {
          s.push(this._sortedTimePoints[t].timeMs / 1000);
        }
        return {
          ...e,
          points: s,
          baseIndex: this._getBaseIndex(),
          marks: this.tickMarks(i)
        };
      }
      _fillDiplayTimeForPoints(e, t = 0) {
        if (this._mainSymbolExtrapolator === null) {
          return;
        }
        const i = this._mainSymbolExtrapolator.interval();
        const s = this._mainSymbolExtrapolator.barBuilder();
        const o = this._mainSymbolExtrapolator.symbolInfo();
        const n = this._displayTimezone === null ? (0, P.get_timezone)(o.timezone) : this._displayTimezone;
        const r = this._instanceIds.size === 1;
        const a = i.isDWM();
        const l = a ? (0, m.createDwmAligner)(i.value(), {
          timezone: o.timezone,
          corrections: r ? o.corrections : undefined,
          session_holidays: r ? o.session_holidays : undefined,
          session: r ? o.session : "24x7"
        }) : null;
        const c = !a;
        for (let o = t; o < e.length; ++o) {
          let t = e[o].timeMs / 1000;
          if (me) {
            t = (0, re.barTimeToEndOfPeriod)(s, t, i);
          }
          if (l !== null && !ge) {
            t = Math.floor(l.timeToExchangeTradingDay(t * 1000) / 1000);
          }
          if (c) {
            t = Math.floor((0, P.utc_to_cal_ts)(n, t * 1000) / 1000);
          }
          e[o].displayTime = t;
        }
      }
    }
    function ye(e, t, i) {
      if (e === -1 && t !== i) {
        e = i < t ? Math.max(0, i - 1) : t;
      }
      return e;
    }
    const ve = new Map([["horizlines", e => [e.startIndex, e.endIndex]], ["hhists", e => [e.firstBarTime, e.firstBarTime]], ["vertlines", e => [e.index]], ["polygons", e => e.points.map(e => e.index)], ["horizlines", e => [e.startIndex, e.endIndex]], ["hhists", e => [e.firstBarTime, e.firstBarTime]], ["vertlines", e => [e.index]], ["polygons", e => e.points.map(e => e.index)], ["backgrounds", e => [e.start, e.stop]]]);
    const Se = new Map([["horizlines", (e, t) => {
      const i = e;
      i.startIndex = t.get(i.startIndex);
      i.endIndex = t.get(i.endIndex);
    }], ["hhists", (e, t) => {
      const i = e;
      i.firstBarTime = t.get(i.firstBarTime);
      i.lastBarTime = t.get(i.lastBarTime);
    }], ["vertlines", (e, t) => {
      const i = e;
      i.index = t.get(i.index);
    }], ["polygons", (e, t) => {
      const i = e;
      for (const e of i.points) {
        e.index = t.get(e.index);
      }
    }], ["backgrounds", (e, t) => {
      const i = e;
      i.start = t.get(i.start);
      i.stop = t.get(i.stop);
    }]]);
    var be = i(37265);
    function we(e, t, i) {
      if ((0, be.isArray)(e)) {
        return function (e, t, i) {
          return e.map(e => {
            const s = we(e, t, i);
            const o = t(s);
            if (o !== undefined) {
              return o;
            } else {
              return s;
            }
          });
        }(e, t, i);
      } else if ((0, be.isObject)(e) && ((0, be.isHashObject)(e) || i && i.visitInstances)) {
        return function (e, t, i) {
          const s = {};
          Object.keys(e).forEach(o => {
            const n = we(e[o], t, i);
            const r = t(n);
            s[o] = r !== undefined ? r : n;
          });
          return s;
        }(e, t, i);
      } else {
        return e;
      }
    }
    function Ce(e, t, i) {
      const s = we(e, t, i);
      const o = t(s);
      if (o !== undefined) {
        return o;
      } else {
        return s;
      }
    }
    class Pe {
      main(e) {
        return [L.Std.open(e), L.Std.high(e), L.Std.low(e), L.Std.close(e), L.Std.volume(e), L.Std.updatetime(e), undefined, undefined, undefined, undefined];
      }
    }
    const Te = (0, i(9343).getLogger)("ChartApi.PointsetsManager");
    class xe {
      constructor() {
        this._pointsetsDataBySymbol = new Map();
      }
      destroy() {
        this._pointsetsDataBySymbol.clear();
      }
      createPointset(e, t, i, s, o) {
        let n = this._pointsetsDataBySymbol.get(t);
        if (n === undefined) {
          n = new Map();
          this._pointsetsDataBySymbol.set(t, n);
        }
        const r = [];
        for (const t of s) {
          const [s, n, a] = t;
          if (typeof s != "number" || Number.isNaN(s)) {
            Te.logWarn(`Pointset time is invalid: id=${e}, ${s} of type ${typeof s}`);
            continue;
          }
          const l = o(a || i);
          r.push({
            point: t,
            extrapolation: l.extrapolateTimeWithOffsetToTime(s * 1000, n)
          });
        }
        if (s.length === r.length) {
          n.set(e, {
            resolution: i,
            points: r
          });
        }
      }
      removePointset(e) {
        const t = [];
        this._pointsetsDataBySymbol.forEach((i, s) => {
          i.delete(e);
          if (i.size === 0) {
            t.push(s);
          }
        });
        for (const e of t) {
          this._pointsetsDataBySymbol.delete(e);
        }
      }
      invalidatePointsetsForSymbol(e, t) {
        const i = this._pointsetsDataBySymbol.get(e);
        if (i !== undefined) {
          i.forEach((e, i) => {
            if (u.Interval.isEqual(e.resolution, t)) {
              for (const t of e.points) {
                if (t.extrapolation !== null && t.extrapolation.exact) {
                  t.extrapolation.exact = false;
                }
              }
            }
          });
        }
      }
      getUpdatesForSymbol(e, t, i, s) {
        const o = new Map();
        const n = this._pointsetsDataBySymbol.get(e);
        if (n !== undefined) {
          n.forEach((e, n) => {
            const r = this._refreshPointsetData(e, t, i, s);
            if (r !== null) {
              o.set(n, r);
            }
          });
        }
        return o;
      }
      _refreshPointsetData(e, t, i, s) {
        if (u.Interval.isEqual(e.resolution, t)) {
          for (let s = 0; s < e.points.length; ++s) {
            const o = e.points[s];
            if (o.extrapolation !== null && o.extrapolation.exact) {
              continue;
            }
            const [n, r, a] = o.point;
            const l = i(a || t);
            o.extrapolation = l.extrapolateTimeWithOffsetToTime(n * 1000, r);
          }
        }
        const o = [];
        for (let i = 0; i < e.points.length; ++i) {
          const n = e.points[i];
          if (n.extrapolation === null) {
            return null;
          }
          const r = s.indexOfTime(n.extrapolation.timeMs);
          if (r === null) {
            Te.logWarn(`Cannot get index of time: time=${n.extrapolation.timeMs}, ${e.resolution} -> ${t}`);
            return null;
          }
          o.push({
            index: i,
            value: [r.index, r.timeMs / 1000]
          });
        }
        return o;
      }
    }
    const Ie = -5000000;
    const Me = () => (0, d.ensure)(window.TradingView);
    const Ae = () => (0, d.ensure)(window.JSServer.studyLibrary);
    const Le = "pre_post_market_sessions";
    const ke = o.enabled(Le);
    const De = o.enabled("pay_attention_to_ticker_not_symbol");
    class Ee {
      constructor(e) {
        this._studiesCache = {};
        this._objectsDataCache = {};
        this._studiesNonSeriesTimes = {};
        this._metainfoCache = [];
        this._barsCoefficientsCache = {};
        this._externalDatafeed = e;
        if ((0, c.default)(e.getVolumeProfileResolutionForPeriod)) {
          (0, h.overwriteVolumeProfileResolutionForPeriodGetter)((t, i, s, o) => (0, d.ensure)(e.getVolumeProfileResolutionForPeriod)(t, i, s, o));
        }
        this._marketStatusWatchers = {};
        this._resolveRequests = {};
        this._resolvePromisesBySymbolId = new Map();
        this._symbolIdToSymbolRequestString = new Map();
        this._callbacks = {};
        this._serverTimeOffset = 0;
        this._logMessage("Datafeed settings received: {0}".format(JSON.stringify(window.configurationData)));
        this._datafeedConfiguration = this._adoptConfigurationData(window.configurationData);
        this._fireEvent("configuration_received");
        if (this._externalDatafeed.getServerTime) {
          this._externalDatafeed.getServerTime(e => {
            this._serverTimeOffset = e - new Date().valueOf() / 1000;
          });
        }
        this._invalidatedPointsetSessions = new Set();
        this._refreshPointsetsTimerId = null;
        this._pointsetsManagers = {};
        this._quotesInfo = {};
        this._depthInfo = {};
        this._endOfData = {};
        this._computeStudyCounter = 0;
        this._symbolExtrapolators = {};
        this._timeScales = {};
        this._cachedDatafeed = new b(e, this.serverTimeOffset.bind(this), this._datafeedConfiguration.reset_cache_timeout);
        const t = (e, t, i) => {
          const s = new p.SessionInfo(e.timezone, e.session, e.session_holidays, e.corrections);
          const o = (0, p.newBarBuilder)(t, s, s);
          return e => {
            if (e && e.count()) {
              const t = this.getCurrentUTCTime() * 1000;
              o.moveTo(t);
              if (o.indexOfBar(t) >= 0) {
                e.setLastBarClosed(false);
              }
            }
            i(e);
          };
        };
        G({
          resolve: (e, t, i, s) => {
            this._resolveSymbolByName(e, t, e => i(e), s);
          },
          subscribe: (e, i, s, o, n) => this._cachedDatafeed.subscribe(e, i, s, t(e, i, o), e => n(e ?? "Unknown datafeed error")),
          unsubscribe: e => this._cachedDatafeed.unsubscribe(e)
        });
      }
      destroy() {
        for (const e of Object.keys(this._quotesInfo)) {
          this._stopQuotesSubscription(e);
        }
        this._cachedDatafeed.destroy();
        this._externalDatafeed = null;
        for (const e of Object.keys(this._pointsetsManagers)) {
          this._pointsetsManagers[e].destroy();
        }
        this._quotesInfo = {};
        this._pointsetsManagers = {};
      }
      purgeCache() {
        this._endOfData = {};
        this._resolveRequests = {};
        this._objectsDataCache = {};
        this._studiesNonSeriesTimes = {};
        this._studiesCache = {};
        this._resolvePromisesBySymbolId.clear();
        this._symbolIdToSymbolRequestString.clear();
        Object.keys(this._pointsetsManagers).forEach(e => {
          this._pointsetsManagers[e].destroy();
        });
        this._pointsetsManagers = {};
        Object.keys(this._timeScales).forEach(e => {
          this._timeScales[e].destroy();
        });
        this._timeScales = {};
        Object.keys(this._symbolExtrapolators).forEach(e => {
          this._symbolExtrapolators[e].destroy();
        });
        this._symbolExtrapolators = {};
      }
      purgeDataCache() {
        this._cachedDatafeed.purgeCache();
      }
      resetCache() {
        this._cachedDatafeed.resetCache();
      }
      serverTimeOffset() {
        return this._serverTimeOffset;
      }
      getCurrentUTCTime() {
        return new Date().valueOf() / 1000 + this._serverTimeOffset;
      }
      serverTime() {
        return this.getCurrentUTCTime() * 1000;
      }
      switchTimezone(e, t) {
        this._timeScales[e].setTimezone(t);
        const i = this._timeScales[e].tickMarks();
        if (i !== null) {
          Me().ChartapiMessagerInstances[e].onTickmarksUpdated(0, i);
        }
      }
      on(e, t) {
        if (!this._callbacks.hasOwnProperty(e)) {
          this._callbacks[e] = [];
        }
        this._callbacks[e].push(t);
        return this;
      }
      supportedResolutions() {
        return this._datafeedConfiguration.supported_resolutions;
      }
      supportedCurrencies() {
        return this._datafeedConfiguration.currency_codes || [];
      }
      supportedUnits() {
        return this._datafeedConfiguration.units || {};
      }
      supportedPriceSources(e) {
        return new Promise((t, i) => {
          this._resolveSymbolImpl(e, e => {
            t(e.price_sources);
          }, e => {
            i(e);
          });
        });
      }
      supportedSymbolsTypes() {
        return this._datafeedConfiguration.symbols_types || [];
      }
      symbolsGrouping() {
        return this._datafeedConfiguration.symbols_grouping || {
          futures: /$a/
        };
      }
      getMarks(e, t, i, s, n) {
        const r = {
          red: 6,
          green: 5,
          blue: 4,
          yellow: 3
        };
        if (this._externalDatafeed.getMarks && this._datafeedConfiguration.supports_marks) {
          this._logMessage("Requesting bars marks: symbol {0}, resolution {1}, range [{2} ... {3}]".format((0, d.ensure)(e.full_name), n, new Date(t * 1000).toUTCString(), new Date(i * 1000).toUTCString()));
          this._externalDatafeed.getMarks(e, t, i, t => {
            const i = t.map(e => {
              e.time = Number(e.time);
              return e;
            });
            this._logMessage("Received bars marks: symbol {0}, resolution {1}, marks {2}".format((0, d.ensure)(e.full_name), n, JSON.stringify(i)));
            const a = (0, m.createDwmAligner)(n, e);
            const c = o.enabled("two_character_bar_marks_labels");
            const h = i.map(e => {
              const t = e;
              t.tickmark = a !== null ? a.timeToSessionStart(e.time * 1000) / 1000 : e.time;
              // vantan sửa direction của mark
              if (t.label == 'S' || (t.label != 'P' && t.label != 'B' && (!e.label.toLowerCase()?.includes('buy') && !e.label.toLowerCase()?.includes('gia tăng') && !e.label.toLowerCase()?.includes('pullback')))) {
                t.direction = (0, l.default)(e.color) ? r[e.color] : r.red; // 1 => down, 0, 2, 3, 4, 5, 6 => up
              } else {
                t.direction = 1; 
              }
              t.onClicked = () => {
                oe.emit("onMarkClick", e.id);
              };

              // vantan chỉnh lại cho mark label nhiều chữ
              // t.label = e.label ? c ? e.label.slice(0, 2) : e.label[0] : "";
              t.label = e.label ?? '';
              return t;
            });
            s(h);
          }, n);
        }
      }
      getTimescaleMarks(e, t, i, s, o) {
        if (this._externalDatafeed.getTimescaleMarks && this._datafeedConfiguration.supports_timescale_marks) {
          this._logMessage("Requesting timescale marks: symbol {0}, resolution {1}, range [{2} ... {3}]".format((0, d.ensure)(e.full_name), o, new Date(t * 1000).toUTCString(), new Date(i * 1000).toUTCString()));
          this._externalDatafeed.getTimescaleMarks(e, t, i, t => {
            this._logMessage("Received timescale marks: symbol {0}, resolution {1}, marks {2}".format((0, d.ensure)(e.full_name), o, JSON.stringify(t)));
            const i = (0, m.createDwmAligner)(o, e);
            const n = t.map(e => {
              const t = e;
              t.tickmark = i !== null ? i.timeToSessionStart(e.time * 1000) / 1000 : e.time;
              return t;
            });
            s(n);
          }, o);
        }
      }
      getSeriesLastBarTime(e, t) {
        const i = this._getSeriesData(e, t);
        if (i === null || i.length === 0) {
          return null;
        } else {
          return i[i.length - 1].timeMs;
        }
      }
      getSeriesInterval(e, t) {
        const i = this._studiesCache[e][t];
        if (i) {
          return i.resolution;
        } else {
          return null;
        }
      }
      onSessionSeriesError(e) {
        this.stopSources(e);
        const t = this._mainSeriesRecord(e);
        if (t !== null) {
          t.error = true;
        }
        this._applyTimeScaleUpdate(e, this._timeScales[e].clearTimeScale());
      }
      stopSources(e) {
        for (const t of this._getStudiesCacheSessionKeys(e)) {
          const i = this._studiesCache[e][t];
          if (i && i.type === "series") {
            this._stopSourcesTree(e, t);
          }
        }
      }
      getSeriesSymbolInfo(e, t) {
        const i = this._studiesCache[e][t];
        if (i) {
          return i.symbolInfo;
        } else {
          return null;
        }
      }
      modifySeries(e, t, i, s, o, n) {
        const r = this._mainSeriesRecord(e);
        if (r === null || r.guid !== t) {
          if (r !== null && r.error) {
            this._studiesCache[e][t].symbolId = i;
            this._studiesCache[e][t].resolution = s;
            this._studiesCache[e][t].turnaround = o;
            return;
          }
          this._stopSourcesTree(e, t);
          this.createSeries(e, t, o, i, s, {
            countBack: 0
          }, true);
          for (const i of this._getStudiesCacheSessionKeys(e)) {
            const s = this._studiesCache[e][i];
            if (s && s.type === "study" && s.parentId === t) {
              this._studiesNonSeriesTimes[e][i] = null;
              const t = this._studiesCache[e][s.parentId];
              this._createStudy(t.symbolId, t.resolution, s.studyObject, e, i, s.turnaround, s.parentId, (0, d.ensure)(s.inputs));
            }
          }
        } else {
          this._modifyMainSeries(e, i, s, o, n);
        }
      }
      createStudy(e, t, i, s, o, n) {
        const r = this._studiesCache[e][i];
        const a = this._findStudyObject(o);
        if (a === null) {
          Fe("Study does not exist: " + o);
          Me().ChartapiMessagerInstances[e].onStudyError(t, s, "unknown study name");
          return;
        }
        const l = new a.constructor();
        this._studiesCache[e] = this._studiesCache[e] || {};
        this._studiesCache[e][t] = {
          studyObject: l,
          guid: t,
          type: "study",
          inputs: n,
          metainfo: a.metainfo,
          turnaround: s,
          parentId: i
        };
        this._studiesNonSeriesTimes[e][t] = null;
        this._createStudy(r.symbolId, r.resolution, l, e, t, s, i, n);
      }
      modifyStudy(e, t, i, s) {
        const o = this._studiesCache[e][t];
        if (!o) {
          throw Error("This should never happen");
        }
        const n = this._studiesCache[e][o.parentId];
        o.inputs = s;
        o.turnaround = i;
        if (o.engine) {
          o.engine.stop();
          q();
        }
        this._studiesNonSeriesTimes[e][t] = null;
        this._createStudy(n.symbolId, n.resolution, o.studyObject, e, t, i, o.parentId, s);
      }
      sessionTimeScale(e) {
        return this._timeScales[e] || null;
      }
      isTimeScaleExtendedTo(e, t) {
        const i = (0, d.ensure)(this._mainSeriesRecord(e));
        if (u.Interval.isDWM(i.resolution) && i.symbolInfo != null) {
          const e = (0, m.createDwmAligner)(i.resolution, i.symbolInfo);
          if (e !== null) {
            t = e.timeToSessionStart(t);
          }
        }
        const s = this._timeScales[e].indexOfTime(t);
        return s !== null && s.index >= 0;
      }
      ensureExtendedTo(e, t, i) {
        if (!this._studiesCache[t][e]) {
          throw Error("This should never happen");
        }
        setTimeout(() => {
          this._recreateSourcesForDataRange(t, {
            to: i
          });
        }, 0);
      }
      extendSeriesRange(e, t) {
        let i = this._timeScales[e].firstSeriesBarTime();
        if (i === null) {
          this._logMessage("Nothing to extend - there is no points on time scale");
          return;
        }
        const s = (0, d.ensure)(this._mainSeriesRecord(e));
        if (u.Interval.isDWM(s.resolution) && s.symbolInfo != null) {
          const e = (0, m.createDwmAligner)(s.resolution, s.symbolInfo);
          if (e !== null) {
            i = e.timeToExchangeTradingDay(i);
          }
        }
        const o = (0, d.ensure)(this._symbolIdToSymbolRequestString.get(Ve(e, s.symbolId)));
        const n = this._barsCoefficients(o, s.resolution);
        const r = n.barsCoefficient || 1;
        if (!n.barsCoefficient) {
          const i = this._getSeriesData(e, s.guid);
          if (i !== null) {
            n.expectedBarsCount = i.length + t;
          }
        }
        setTimeout(() => {
          this._recreateSourcesForDataRange(e, {
            to: i,
            countBack: (t + 2) * r
          });
        }, 0);
      }
      seriesTurnaround(e, t) {
        return this._studiesCache[e] && this._studiesCache[e][t] && this._studiesCache[e][t].turnaround;
      }
      createSeries(e, t, i, s, n, r, a) {
        this._setEndOfData(e, t, i, false);
        const l = new Pe();
        this._studiesCache[e] = this._studiesCache[e] || {};
        const c = this._getSeriesData(e, t);
        const h = this._studiesCache[e][t];
        const _ = this._seriesCount(e);
        const p = this._mainSeriesRecord(e);
        if (!h || u.Interval.isEqual(h.resolution, n) && h.symbolId === s) {
          if (r.countBack !== undefined && c !== null && c.length !== 0) {
            r.to = c[0].timeMs;
          }
          if (h && h.firstLoadedTimeMs != null) {
            r.to = r.to !== undefined ? Math.min(h.firstLoadedTimeMs, r.to) : h.firstLoadedTimeMs;
          } else if (!h && _ !== 0) {
            if (p !== null) {
              if (p.firstLoadedTimeMs != null) {
                r.to = p.firstLoadedTimeMs;
                r.countBack = 0;
              } else {
                r = Object.assign({}, p.dataRange);
              }
            }
          }
        } else if (_ === 1) {
          r = Object.assign({}, h.initialDatarange);
        } else {
          const t = this._timeScales[e].firstSeriesBarTime();
          if (r.to === undefined || t !== null && t < r.to) {
            r.to = t;
            r.countBack = 0;
          }
        }
        if (r.countBack === undefined) {
          r.countBack = 0;
        }
        if (r.to === undefined && r.countBack === 0) {
          r.countBack = 100;
        }
        this._studiesCache[e][t] = {
          symbolId: s,
          resolution: n,
          studyObject: l,
          guid: t,
          type: "series",
          turnaround: i,
          dataRange: r,
          initialDatarange: h && h.initialDatarange || Object.assign({}, r),
          firstLoadedTimeMs: null,
          symbolInfo: null,
          isMain: h && h.isMain || _ === 0,
          completed: false
        };
        if (p !== null && p.guid !== t && p.error) {
          return;
        }
        this._updateMainTsBuilder(e);
        this._updateTimeScaleState(e);
        Me().ChartapiMessagerInstances[e].onSeriesLoading(t, i);
        const m = (s, o, r) => {
          const a = [];
          if (r !== undefined) {
            const e = (r.data || []).reduce((e, t) => Math.max(e, t[0] || 0), -1);
            if (r.projectionTime != null) {
              for (let t = 0; t <= e; ++t) {
                a.push(r.projectionTime + t);
              }
            }
          }
          let l = null;
          let c = null;
          const h = s ? this._getSymbolExtrapolator(e, s, n) : null;
          if (o !== undefined) {
            const i = o.map(e => e.timeMs).concat(a);
            if (h !== null) {
              h.replaceBarsTimesTail(i, o.length);
            }
            c = this._timeScales[e].replaceBarsTimesTail(t, i);
            l = o;
          } else {
            const i = this._getSeriesData(e, t) || [];
            const s = i.map(e => e.timeMs).concat(a);
            if (h !== null) {
              h.setBarsTimes(s, i.length);
            }
            c = this._timeScales[e].setSeriesBarsTimes(t, s);
            l = i;
          }
          this._applyTimeScaleUpdate(e, c);
          if (l.length === 0 && r === undefined) {
            return;
          }
          this._timeScales[e].fillIndexesInRows(l);
          const d = r !== undefined ? this._prepareSeriesNonSeriesData(e, t, r) : null;
          Me().ChartapiMessagerInstances[e].onDataUpdate(t, i, l, d);
        };
        const g = s => {
          const n = this._studiesCache[e][t];
          n.completed = true;
          Me().ChartapiMessagerInstances[e].onSeriesError(t, i, s);
          if (o.enabled("clear_bars_on_series_error")) {
            if (n.isMain) {
              this.onSessionSeriesError(e);
            } else {
              this._clearSeriesData(e, t);
            }
          }
        };
        this._computeStudy(e, l, s, n, t, [], r, Re(e, t), function () {
          return -Infinity;
        }, {
          onDataReadyCallback: (o, r, l, c) => {
            const h = this._studiesCache[e][t];
            if (!h) {
              throw Error("This should never happen");
            }
            h.symbolInfo = l;
            h.firstLoadedTimeMs = c.firstLoadedTimeMs;
            h.completed = true;
            this._updateMainTsBuilder(e);
            if (a) {
              this._pointsetsManagers[e].invalidatePointsetsForSymbol(l.full_name, n);
            }
            if (o.length !== 0) {
              const i = (0, d.ensure)(this._symbolIdToSymbolRequestString.get(Ve(e, s)));
              const r = this._barsCoefficients(i, n);
              if (r.expectedBarsCount && r.barsCount) {
                r.barsCoefficient = Math.min(Math.max(r.barsCoefficient || 1, Math.floor(r.expectedBarsCount / (o.length - r.barsCount) + 0.5)), 100);
              }
              r.barsCount = o.length;
              this._clearSeriesData(e, t);
            } else if (!c.endOfData && h.isMain) {
              setTimeout(() => {
                if (this._studiesCache[e]) {
                  this._recreateSourcesForDataRange(e, {
                    countBack: 10
                  });
                }
              }, 0);
            }
            m(l);
            if (c.endOfData) {
              this._logMessage("Series has no more data on server: {0}".format(l.full_name));
              this._setEndOfData(e, t, i);
            }
            if (o.length === 0) {
              this._clearSeriesData(e, t);
            }
            Me().ChartapiMessagerInstances[e].onSeriesCompleted(t, i, l.data_status);
            this._updateTimeScaleState(e);
          },
          onRealtimeCallback: (s, o, r, a, l) => {
            m(l, s);
            this._timeScales[e].fillIndexesInRows(s);
            const c = s[s.length - 1];
            if (o) {
              if (!this._studiesCache[e][t]) {
                throw Error("This should never happen");
              }
              this._logMessage("New bar arrived: symbol {0}, resolution {1}, bar {2}".format(l.full_name, n, JSON.stringify(c)));
            } else {
              this._logMessage("Last bar update: symbol {0}, resolution {1}, bar {2}".format(l.full_name, n, JSON.stringify(c)));
              Me().ChartapiMessagerInstances[e].onDataUpdate(t, i, s, null);
            }
            this._fireEvent("realtime_tick", s[s.length - 1], true);
          },
          onSymbolErrorCallback: e => {
            this._logMessage("Series symbol resolve error: " + e);
            g(e || "resolve error");
          },
          onErrorCallback: e => {
            this._logMessage("Series error: " + e);
            g(e);
          },
          onNonSeriesDataUpdate: (s, o) => {
            if (s.type !== "projection") {
              throw new Error("unexpected non-series data type for series " + s.type);
            }
            const n = this._getSeriesData(e, t);
            if (n !== null) {
              m(o, n.length === 0 ? undefined : [n[n.length - 1]], s);
            } else {
              const o = this._prepareSeriesNonSeriesData(e, t, s);
              Me().ChartapiMessagerInstances[e].onDataUpdate(t, i, [], o);
            }
          }
        });
      }
      removeStudy(e, t) {
        if (this._studiesCache[e] && this._studiesCache[e][t] && this._studiesCache[e][t].engine) {
          this._studiesCache[e][t].engine.stop();
          q();
        }
        if (this._studyCanExtendTimeScale(e, t)) {
          this._timeScales[e].setCompleted(false);
          const i = this._timeScales[e].setStudyBarsTimes(t, []);
          this._applyTimeScaleUpdate(e, i);
          this._updateTimeScaleState(e);
        }
        delete this._studiesCache[e][t];
        delete this._studiesNonSeriesTimes[e][t];
      }
      removeSeries(e, t) {
        this._stopSourcesTree(e, t);
        delete this._studiesCache[e][t];
        this._updateMainTsBuilder(e);
        if (this._timeScales[e].isCompleted()) {
          this._timeScales[e].setCompleted(false);
        }
        const i = this._timeScales[e].setSeriesBarsTimes(t, []);
        this._applyTimeScaleUpdate(e, i);
        this._updateTimeScaleState(e);
      }
      requestMoreTickmarks(e, t) {
        const i = this._timeScales[e];
        i.setMinFutureBarsCount(i.minFutureBarsCount() + t);
        const s = i.firstFutureBarIndex();
        const o = i.tickMarks(s);
        Me().ChartapiMessagerInstances[e].onTickmarksUpdated(s, o);
      }
      chartCreateSession(e) {
        this._pointsetsManagers[e] = new xe();
        this._timeScales[e] = new fe();
        this._studiesNonSeriesTimes[e] = {};
      }
      chartDeleteSession(e) {
        this._pointsetsManagers[e].destroy();
        delete this._pointsetsManagers[e];
        this._timeScales[e].destroy();
        delete this._timeScales[e];
        delete this._studiesNonSeriesTimes[e];
      }
      removePointset(e, t) {
        this._pointsetsManagers[e].removePointset(t);
      }
      async createPointset(e, t, i, s, o) {
        const n = this._resolvePromisesBySymbolId.get(Ve(e, i));
        if (n === undefined) {
          return;
        }
        let r;
        try {
          r = (await n).symbolInfo;
        } catch (e) {
          return;
        }
        this._pointsetsManagers[e].createPointset(t, r.full_name, s, o, (t = s) => this._getSymbolExtrapolator(e, r, t));
        if (this._refreshPointsetsTimerId === null) {
          this._refreshPointsetsTimerId = setTimeout(() => {
            this._refreshPointsetsTimerId = null;
            this._refreshPointsets(this._invalidatedPointsetSessions);
            this._invalidatedPointsetSessions.clear();
          }, 0);
        }
        this._invalidatedPointsetSessions.add(e);
      }
      studiesMetadata() {
        if (this._metainfoCache.length === 0) {
          this._metainfoCache = Ae().map(e => e.metainfo);
          this._metainfoCache.push({
            palettes: {},
            inputs: [],
            plots: [{
              id: "open",
              type: "line"
            }, {
              id: "high",
              type: "line"
            }, {
              id: "low",
              type: "line"
            }, {
              id: "close",
              type: "line"
            }, {
              id: "volume",
              type: "line"
            }],
            graphics: {},
            _metainfoVersion: 48,
            description: "Unnamed Study",
            format: {
              type: "inherit"
            },
            is_hidden_study: true,
            is_price_study: false,
            shortDescription: "Unnamed Study",
            description_localized: "Unnamed Study",
            id: "BarSetHeikenAshi@tv-prostudies",
            shortId: "BarSetHeikenAshi",
            packageId: "tv-basicstudies",
            version: "13",
            fullId: "BarSetHeikenAshi@tv-basicstudies-13",
            productId: "tv-basicstudies",
            name: "BarSetHeikenAshi@tv-basicstudies"
          });
        }
        return this._metainfoCache;
      }
      searchSymbols(e, t, i, s) {
        this._logMessage("Symbol search requested: search string `{0}`, exchange: `{1}`, type `{2}`".format(e, t, i));
        this._externalDatafeed.searchSymbols(e, t, i, e => {
          this._logMessage("Symbol search response: {0}".format(JSON.stringify(e)));
          e.forEach(e => {
            Ue(e.logo_urls, e.exchange_logo, e);
          });
          s(e);
        });
      }
      resolveSymbol(e, t, i) {
        this._symbolIdToSymbolRequestString.set(Ve(e, t), i);
        this._resolvePromisesBySymbolId.set(Ve(e, t), new Promise((s, o) => {
          this._resolveSymbolImpl(i, o => {
            Me().ChartapiMessagerInstances[e].onSymbolResolved(t, o);
            s({
              symbolInfo: o,
              requestedSymbol: i
            });
          }, i => {
            Me().ChartapiMessagerInstances[e].onSymbolError(t, i);
            o(i);
          });
        }));
      }
      quoteCreateSession(e) {
        this._quotesInfo[e] = {
          symbols: [],
          fastSymbols: [],
          listenerGUID: undefined
        };
      }
      quoteDeleteSession(e) {
        this._stopQuotesSubscription(e);
        delete this._quotesInfo[e];
      }
      quoteSetFields(e, t) { }
      quoteAddSymbols(e, t) {
        this._quotesInfo[e].symbols = this._filteredSymbols(this._quotesInfo[e].symbols.concat(t));
        this._restartQuotesSubscription(e);
      }
      quoteRemoveSymbols(e, t) {
        this._quotesInfo[e].symbols = this._quotesInfo[e].symbols.filter(e => t.indexOf(e) < 0);
        this._restartQuotesSubscription(e);
      }
      quoteFastSymbols(e, t) {
        this._quotesInfo[e].fastSymbols = this._filteredSymbols(t);
        this._restartQuotesSubscription(e);
      }
      quoteHibernateAll(e) { }
      depthCreateSession(e) {
        this._depthInfo[e] = {
          symbol: null,
          listenerGUID: undefined
        };
      }
      depthDeleteSession(e) {
        this._depthInfo[e].symbol = null;
        this._stopDepthSubscription(e);
        delete this._depthInfo[e];
      }
      depthSetSymbol(e, t) {
        this._depthInfo[e].symbol = t;
        this._restartDepthSubscription(e);
      }
      _stopDepthSubscription(e) {
        if (this._depthInfo[e].listenerGUID) {
          this._externalDatafeed.unsubscribeDepth?.(this._depthInfo[e].listenerGUID);
          this._depthInfo[e].listenerGUID = undefined;
        }
      }
      _restartDepthSubscription(e) {
        this._stopDepthSubscription(e);
        this._startDepthSubscription(e);
      }
      _startDepthSubscription(e) {
        const t = this._depthInfo[e].symbol;
        if (!t) {
          return;
        }
        const i = e => e.map(e => ({
          p: e.price,
          v: e.volume
        }));
        const s = e => ({
          s: t,
          bids: i(e.bids),
          asks: i(e.asks)
        });
        if (this._externalDatafeed.subscribeDepth) {
          this._depthInfo[e].listenerGUID = this._externalDatafeed.subscribeDepth(t, t => {
            var i;
            if (this._depthInfo[e]) {
              if ((i = t).snapshot) {
                Me().ChartapiMessagerInstances[e].onDepthData([e, s(i)]);
              } else {
                Me().ChartapiMessagerInstances[e].onDepthUpdate([e, s(i)]);
              }
            }
          });
        }
      }
      _restartQuotesSubscription(e) {
        this._stopQuotesSubscription(e);
        this._startQuotesSubscription(e);
      }
      async _startQuotesSubscription(e) {
        const t = {};
        const i = {};
        const s = (t, i) => {
          const s = t.s === "ok";
          const o = this._marketStatusWatchers[e][t.n];
          const n = {
            ...t,
            symbolname: t.n,
            status: t.s,
            values: {
              ...t.v,
              change: s ? t.v.ch : undefined,
              last_price: s ? t.v.lp : undefined,
              change_percent: s ? t.v.chp : undefined,
              current_session: s ? t.v.cs : o && o.marketStatus(),
              pricescale: i.pricescale,
              minmov: i.minmov,
              minmove2: i.minmove2 || 0,
              fractional: i.fractional || false
            }
          };
          Ue(i.logo_urls, i.exchange_logo, n.values);
          if (o && s ? t.v.cs : undefined) {
            o.stop();
          }
          Me().ChartapiMessagerInstances[e].onQuotesData([e, n]);
        };
        const n = r => {
          r.forEach(a => {
            const l = a.n;
            if (i[l]?.size > 0) {
              const t = [...i[l]].map(e => ({
                ...a,
                n: e
              }));
              if (o.enabled("charting_library_debug_mode")) {
                const t = this._quotesInfo[e].listenerGUID !== undefined ? `with listenerGUID ${this._quotesInfo[e].listenerGUID}` : "";
                this._logMessage(`QUOTES Data for symbol ${l} ${t}: ${JSON.stringify(r)}`);
              }
              setTimeout(() => n(t), 0);
            }
            if (t[a.n] !== undefined && t[a.n] !== null) {
              s(a, t[a.n]);
            } else if (o.enabled("charting_library_debug_mode")) {
              const t = this._quotesInfo[e].listenerGUID !== undefined ? `with listenerGUID ${this._quotesInfo[e].listenerGUID}` : "";
              this._logMessage(`QUOTES Data for unexpected symbol ${l} ${t}: ${JSON.stringify(r)}`);
            }
          });
        };
        const r = async e => {
          const [s, o] = We(e);
          const n = await new Promise((e, t) => {
            this._resolveSymbolByName(s, o, e, t);
          });
          const r = (0, d.ensure)(n.ticker);
          t[r] = t[e] = n;
          if (r !== e) {
            if (i[r] === undefined) {
              i[r] = new Set();
            }
            if (r !== e) {
              i[r].add(e);
            }
          }
          return r;
        };
        const a = async e => [...new Set(await Promise.all([...new Set(e)].map(r)))];
        if (this._externalDatafeed.getQuotes && !o.enabled("charting_library")) {
          const [t, i] = await Promise.all([a(this._quotesInfo[e].symbols), a(this._quotesInfo[e].fastSymbols)]);
          const s = {};
          if (o.enabled("charting_library_debug_mode")) {
            const e = Ee.debugGetQuotesRequestId++;
            this._logMessage(`QUOTES Requesting data for symbols ${JSON.stringify(t)} with request ID ${e}`);
            for (const i of t) {
              const t = 10000;
              s[i] = setTimeout(() => {
                this._logMessage(`QUOTES Timeout after waiting ${t / 1000} seconds for data symbol ${i} with request ID ${e}`);
              }, t);
            }
          }
          this._externalDatafeed.getQuotes(t, r => {
            if (o.enabled("charting_library_debug_mode")) {
              for (const e of r) {
                if (s[e.n] !== undefined) {
                  clearTimeout(s[e.n]);
                }
                delete s[e.n];
              }
            }
            if (this._quotesInfo[e] && this._quotesInfo[e].symbols.length !== 0) {
              n(r);
              this._quotesInfo[e].listenerGUID = e;
              if (o.enabled("charting_library_debug_mode")) {
                this._logMessage(`QUOTES Subscribing listenerGUID ${this._quotesInfo[e].listenerGUID} to data for symbols ${JSON.stringify(t)} and fast symbols ${JSON.stringify(i)}`);
              }
              this._externalDatafeed.subscribeQuotes(t, i, n, this._quotesInfo[e].listenerGUID);
            }
          }, e => {
            this._logMessage(`QUOTES Error getting data for symbols ${JSON.stringify(t)}: ${e}`);
          });
        } else if (!this._externalDatafeed.getQuotes && o.enabled("trading_terminal")) {
          setTimeout(() => {
            n(this._quotesInfo[e].symbols.map(e => ({
              n: e,
              s: "ok",
              v: {}
            })));
          });
        }
        this._createMarketStatusWatchers(e, this._quotesInfo[e].symbols);
      }
      _createMarketStatusWatchers(e, t) {
        if (this._marketStatusWatchers[e] === undefined) {
          this._marketStatusWatchers[e] = {};
        }
        for (let i = 0; i < t.length; i += 1) {
          const s = t[i];
          if (this._marketStatusWatchers[e][s] === undefined) {
            const [t, i] = We(s);
            this._marketStatusWatchers[e][s] = new (se())((o, n, r, a) => this._resolveSymbolByName(t, i, r, o => {
              Fe(`Error resolving for market status watcher ${Oe(t, i.currency, i.unit, i.session)}:\n${o}`);
              this.quoteRemoveSymbols(e, [s]);
              a(o);
            }), e, s);
          }
        }
      }
      _filteredSymbols(e) {
        const t = [];
        e.forEach(e => {
          if (!(e instanceof Object)) {
            if (t.indexOf(e) < 0) {
              t.push(e);
            }
          }
        });
        return t;
      }
      _refreshPointsets(e) {
        e.forEach(e => {
          const t = this._studiesCache[e];
          if (t == null) {
            return;
          }
          let i = null;
          for (const e of Object.keys(t)) {
            const s = t[e];
            if (s.type === "series") {
              i = s;
              break;
            }
          }
          if (i === null || i.symbolInfo == null) {
            return;
          }
          const s = i.symbolInfo;
          this._pointsetsManagers[e].getUpdatesForSymbol(i.symbolInfo.full_name, i.resolution, (t = i.resolution) => this._getSymbolExtrapolator(e, s, t), this._timeScales[e]).forEach((t, i) => {
            Me().ChartapiMessagerInstances[e].onPointsetDataUpdate(i, null, t);
          });
        });
      }
      _recreateSourcesForDataRange(e, t) {
        const i = [];
        for (const s of this._getStudiesCacheSessionKeys(e)) {
          const o = this._studiesCache[e][s];
          if (o && o.type === "series" && !this._isEndOfData(e, s, o.turnaround)) {
            this._stopSourcesTree(e, s);
            i.push(s);
          }
          if (o && o.type === "study" && this._studyCanExtendTimeScale(e, s) && !this._isEndOfData(e, s, o.turnaround)) {
            const i = this._studiesCache[e][(0, d.ensure)(o.parentId)];
            o.dataRange = t;
            this._createStudy(i.symbolId, i.resolution, o.studyObject, e, s, o.turnaround, (0, d.ensure)(o.parentId), (0, d.ensure)(o.inputs));
          }
        }
        i.forEach(i => {
          this._startSourcesTree(e, i, Object.assign({}, t));
        });
        for (const t of this._getStudiesCacheSessionKeys(e)) {
          const i = this._studiesCache[e][t];
          if (i.type === "series" && this._isEndOfData(e, t, i.turnaround)) {
            Me().ChartapiMessagerInstances[e].onSeriesCompleted(t, i.turnaround, (0, d.ensure)(i.engine).runner.host.symbolInfo.data_status);
          }
        }
        this._updateTimeScaleState(e);
      }
      _startSourcesTree(e, t, i) {
        const s = this._studiesCache[e][t];
        this.createSeries(e, t, s.turnaround, s.symbolId, s.resolution, i, true);
        for (const i of this._getStudiesCacheSessionKeys(e)) {
          const o = this._studiesCache[e][i];
          if (o && o.type === "study" && o.parentId === t) {
            this._createStudy(s.symbolId, s.resolution, o.studyObject, e, i, o.turnaround, o.parentId, (0, d.ensure)(o.inputs));
          }
        }
      }
      _clearSeriesData(e, t) {
        const i = {
          [t]: {
            turnaround: this._studiesCache[e][t].turnaround
          }
        };
        for (const s of this._getStudiesCacheSessionKeys(e)) {
          const o = this._studiesCache[e][s];
          if (o.type !== "study" || !this._studyCanExtendTimeScale(e, s)) {
            if (o.type === "study" && o.parentId === t && !this._studyCanExtendTimeScale(e, s)) {
              i[s] = {
                turnaround: o.turnaround
              };
            }
          }
        }
        Me().ChartapiMessagerInstances[e].onClearData(i);
      }
      _prepareSeriesNonSeriesData(e, t, i) {
        const s = i.data[i.data.length - 1];
        const o = this._getSeriesData(e, t);
        const n = o === null ? [] : i.data;
        return {
          data: {
            data: {
              reversalAmount: i.reversalAmount,
              boxSize: i.boxSize,
              price: s ? s[4] : i.price,
              bars: n.map((e, t) => ({
                time: t,
                open: e[1],
                high: e[2],
                low: e[3],
                close: e[4],
                volume: e[5],
                factor: e[6],
                additionalPrice: e[6]
              }))
            }
          },
          indexes: this._timeScales[e].convertTimesToIndexes(n.map(e => {
            const t = e[0] || 0;
            if (t < 0) {
              return (0, d.ensure)(o)[(0, d.ensure)(o).length + t].timeMs;
            } else {
              return i.projectionTime + t;
            }
          }))
        };
      }
      _seriesCount(e) {
        let t = 0;
        for (const i of this._getStudiesCacheSessionKeys(e)) {
          if (this._studiesCache[e][i].type === "series") {
            t += 1;
          }
        }
        return t;
      }
      _modifyMainSeries(e, t, i, s, r) {
        this.stopSources(e);
        const a = this._mainSeriesRecord(e);
        let l = false;
        for (const c of this._getStudiesCacheSessionKeys(e)) {
          const h = this._studiesCache[e][c];
          if (h && h.type === "series") {
            if ((0, n.default)(a) || h.guid !== a.guid) {
              this.createSeries(e, h.guid, h.turnaround, h.symbolId, i, {
                countBack: 0
              }, true);
            } else {
              l = a.symbolId !== t || a.resolution !== i;
              const n = ze(r);
              const c = {
                countBack: n || 0
              };
              if (o.enabled("request_only_visible_range_on_reset") && n) {
                delete this._objectsDataCache[Re(e, a.guid)];
                delete this._studiesCache[e][a.guid];
              }
              this.createSeries(e, a.guid, s, t, i, c, true);
            }
          }
        }
        for (const t of this._getStudiesCacheSessionKeys(e)) {
          const i = this._studiesCache[e][t];
          if (i && i.type === "study") {
            this._studiesNonSeriesTimes[e][t] = null;
            const s = this._studiesCache[e][(0, d.ensure)(i.parentId)];
            this._createStudy(s.symbolId, s.resolution, i.studyObject, e, t, i.turnaround, i.parentId, (0, d.ensure)(i.inputs));
          }
        }
        if (l) {
          this._applyTimeScaleUpdate(e, this._timeScales[e].clearTimeScale());
        }
      }
      _mainSeriesRecord(e) {
        let t = null;
        let i = null;
        for (const s of this._getStudiesCacheSessionKeys(e)) {
          const o = this._studiesCache[e][s];
          if (o.type === "series" && (t === null && (t = o), o.isMain)) {
            i = o;
            break;
          }
        }
        if (i === null) {
          i = t;
        }
        if (i !== null) {
          i.isMain = true;
        }
        return i;
      }
      _stopSourcesTree(e, t) {
        for (const i of this._getStudiesCacheSessionKeys(e)) {
          const s = this._studiesCache[e][i];
          if (s) {
            if (s.type === "series" && i === t || s.type === "study" && s.parentId === t) {
              if (s.engine && s.engine.isStarted()) {
                s.engine.stop();
              }
              s.activeResolve = -1;
            }
          }
        }
        q();
      }
      _getSeriesData(e, t) {
        return this._objectsDataCache[Re(e, t)] || null;
      }
      _findStudyObject(e) {
        if (e.endsWith("!")) {
          e = e.slice(0, -1);
        }
        const t = e.split("@")[0];
        const i = Ae().filter(i => i.metainfo.id === e || i.metainfo.shortDescription === t);
        if (i.length === 0) {
          return null;
        }
        return i[0];
      }
      _resolveSymbolImpl(e, t, i) {
        var s;
        if (!(0, C.isEncodedExtendedSymbol)(e)) {
          s = "Expect to get symbol encoded string, but got the following instead: " + e;
          console.error(`${new Date().toISOString()} ${s}`);
        }
        const [o, n] = We(e);
        this._resolveSymbolByName(o, n, t, i);
      }
      _getSymbolExtrapolator(e, t, i) {
        const s = (0, d.ensure)(u.Interval.normalize(i));
        const o = function (e, t, i) {
          const s = t.subsession_id !== undefined ? "," + t.subsession_id : "";
          return e + "," + t.full_name + "," + i + s;
        }(e, t, s);
        let n = this._symbolExtrapolators[o];
        if (n === undefined) {
          n = new te(t, s);
          this._symbolExtrapolators[o] = n;
        }
        return n;
      }
      _barsCoefficients(e, t) {
        const i = (0, C.decodeExtendedSymbol)(e);
        if (!("type" in i) || i.type === undefined) {
          return {};
        }
        const s = e + t;
        this._barsCoefficientsCache[s] ||= {};
        return this._barsCoefficientsCache[s];
      }
      _studyCanExtendTimeScale(e, t) {
        const i = this._studiesCache[e][t]?.metainfo;
        return i !== undefined && (o.enabled("studies_extend_time_scale") && i.canExtendTimeScale || o.enabled("secondary_series_extend_time_scale") && i.id === "Overlay@tv-basicstudies-1");
      }
      _stopQuotesSubscription(e) {
        if (this._quotesInfo[e].listenerGUID) {
          if (o.enabled("charting_library_debug_mode")) {
            this._logMessage(`QUOTES Unsubscribe listenerGUID=${this._quotesInfo[e].listenerGUID}`);
          }
          this._externalDatafeed.unsubscribeQuotes(this._quotesInfo[e].listenerGUID);
          this._quotesInfo[e].listenerGUID = undefined;
        }
        this._removeMarketStatusWatchers(e);
      }
      _removeMarketStatusWatchers(e) {
        Object.keys(this._marketStatusWatchers[e] || {}).forEach(t => {
          this._marketStatusWatchers[e][t].stop();
        });
        this._marketStatusWatchers[e] = {};
      }
      _logMessage(e) {
        if (o.enabled("charting_library_debug_mode")) {
          console.log(`${new Date().toISOString()} ${e}`);
        }
      }
      _adoptConfigurationData(e) {
        const t = (0, Z.merge)({}, e);
        const i = t.supported_resolutions;
        if (!i || i.length === 0) {
          t.supported_resolutions = undefined;
          return t;
        }
        const s = [];
        for (let e = 0; e < i.length; e++) {
          const t = i[e];
          if (s.indexOf(t) !== -1) {
            throw new Error("Duplicating resolution `" + t + "`");
          }
          s.push(t);
        }
        t.supported_resolutions = s;
        return t;
      }
      _resolveSymbolByName(e, t, i, s) {
        let o;
        const r = t && t.currency;
        const a = t && t.unit;
        const l = t && t.session;
        const c = Ne(e, r, a, l);
        if ((0, n.default)(this._resolveRequests[c])) {
          o = this._resolveSymbolInternal(e, r || undefined, a || undefined, l || undefined);
          this._resolveRequests[c] = o;
          o.then(t => {
            this._resolveRequests[Ne(e, t.currency_id, t.unit_id, t.subsession_id)] = o;
            this._resolveRequests[Ne((0, X.extractSymbolNameFromSymbolInfo)(t, null), t.currency_id, t.unit_id, t.subsession_id)] = o;
            this._resolveRequests[Ne((0, X.extractSymbolNameFromSymbolInfo)(t, null), r, a, l)] = o;
          }).catch(() => { });
        } else {
          o = this._resolveRequests[c];
        }
        o.then(i).catch(s);
      }
      _resolveSymbolInternal(e, t, i, s) {
        return new Promise((o, n) => {
          const r = Oe(e, t, i, s);
          this._logMessage("Symbol resolve requested: `{0}` ".format(r));
          let a = true;
          this._externalDatafeed.resolveSymbol(e, e => {
            if (a) {
              Fe("`resolveSymbol` should return result asynchronously. Use `setTimeout` with 0 interval to execute the callback function.");
            }
            this._logMessage("Symbol resolved: `{0}`, SymbolInfo in server response {1}".format(r, JSON.stringify(e)));
            const t = function (e, t) {
              e.ticker ||= e.symbol || e.name;
              e.full_name = t.shouldUseTickerNotSymbol ? e.ticker : `${e.exchange}:${e.name}`;
              e.pro_name = e.full_name;
              e.base_name ||= [e.name];
              e.legs ||= [e.name];
              e.exchange ||= e["exchange-listed"];
              e.data_status ||= "streaming";
              if (!e.session && e["session-regular"]) {
                e.session = e["session-regular"];
              }
              if (!e.minmov && e.minmovement) {
                e.minmov = e.minmovement;
              }
              if (e.currency_code) {
                e.currency_id = e.currency_code;
              }
              if (e.original_currency_code) {
                e.original_currency_id = e.original_currency_code;
              }
              if (e.holidays) {
                e.session_holidays = e.holidays;
              }
              if (e.has_no_volume !== undefined) {
                e.visible_plots_set = e.has_no_volume ? "ohlc" : "ohlcv";
              }
              if (e.visible_plots_set === undefined) {
                e.visible_plots_set = "ohlcv";
              }
              if (e.supported_resolutions) {
                for (let t = 0; t < e.supported_resolutions.length; t++) {
                  const i = u.Interval.parse(e.supported_resolutions[t]);
                  if (i.isValid()) {
                    e.supported_resolutions[t] = i.value();
                  }
                }
              }
              e.price_sources ||= [];
              e["is-tickbars-available"] = !!e.has_ticks;
              delete e.has_ticks;
              if (t.shouldUseSubsessions === true && Array.isArray(e.subsessions)) {
                for (let t = 0; t < e.subsessions.length; t++) {
                  const i = e.subsessions[t];
                  switch (i.id) {
                    case x.SubsessionId.Regular:
                    case x.SubsessionId.Extended:
                      i.private = false;
                      break;
                    case x.SubsessionId.PreMarket:
                    case x.SubsessionId.PostMarket:
                      i.private = true;
                  }
                }
              }
              e.build_seconds_from_ticks = false;
              return e;
            }(e, {
              shouldUseSubsessions: ke,
              shouldUseTickerNotSymbol: De
            });
            (function (e) {
              const t = e.ticker ?? e.name ?? ("symbol" in e ? e.symbol : undefined) ?? "unknown symbol";
              function i(e) {
                Fe(`SymbolInfo validation for ${t}: ${e}`);
              }
              if ((typeof e.ticker != "string" || e.ticker.length === 0) && !!De) {
                i("ticker must be a non-empty string when the \"pay_attention_to_ticker_not_symbol\" featureset is enabled");
              }
              if (e.exchange === undefined || e.exchange.length === 0) {
                i("exchange must be provided to the symbol information");
              }
              if (e.has_empty_bars && !(0, m.isAlignmentEnabled)()) {
                i("both has_empty_bars field and featureset \"disable_resolution_rebuild\" are enabled and may cause data issues (see #3329)");
              }
              if (e.minmov === undefined || e.minmov <= 0) {
                i("minmov must be positive");
              }
              if (e.pricescale === undefined || e.pricescale <= 0) {
                i("pricescale must be positive");
              }
              if (e.name === undefined || e.name.length === 0) {
                i("name must be non-empty string");
              }
              if (e.session === undefined || e.session.length === 0) {
                i("session must be non-empty string");
              }
              if ("holidays" in e) {
                i("field holidays is deprecated, use session_holidays instead");
              }
              if ("has_no_volume" in e) {
                i("field has_no_volume is deprecated, use visible_plots_set instead");
              }
              if (e.timezone === undefined || e.timezone.length === 0) {
                i("timezone must be non-empty string");
              } else if (e.timezone === "exchange" || !(0, Q.timezoneIsAvailable)(e.timezone)) {
                if (e.timezone !== "UTC") {
                  i("unsupported timezone \"{0}\"".format(e.timezone));
                }
              }
              if (e.intraday_multipliers !== undefined) {
                const t = e.intraday_multipliers;
                if (Array.isArray(t)) {
                  for (let e = 0; e < t.length; ++e) {
                    if (typeof t[e] != "string") {
                      i("intraday_multipliers[{0}] = \"{1}\" must be string (now: {2})".format(e + 1, t[e], typeof t[e]));
                    }
                  }
                } else {
                  i("intraday_multipliers must be array");
                }
              }
              (e.supported_resolutions || []).filter(e => !u.Interval.isValid(e)).forEach(e => {
                i("supported_resolutions field contains invalid value: " + e);
              });
              if (!ke) {
                if (e.subsessions !== undefined) {
                  i(`Symbol info contains subsessions but the ${Le} feature is not enabled, so the subsessions will be ignored`);
                }
                if (e.subsession_id !== undefined) {
                  i(`Symbol info contains a subsession ID but the ${Le} feature is not enabled, so the subsession ID will be ignored`);
                }
              }
              if (e.build_seconds_from_ticks === true) {
                i("build_seconds_from_ticks is true but building seconds from ticks is only available in Trading Platform.");
              }
            })(t);
            this._logMessage("Symbol info after post-processing: `{0}`, SymbolInfo {1}".format(r, JSON.stringify(t)));
            o(t);
          }, e => {
            this._logMessage("Symbol resolve failed: `{0}`, reason: `{1}`".format(r, e));
            n(e);
          }, {
            currencyCode: t,
            unitId: i,
            session: s
          });
          a = false;
        });
      }
      _fireEvent(e, t, i) {
        if (this._callbacks.hasOwnProperty(e)) {
          const s = this._callbacks[e];
          for (let e = 0; e < s.length; ++e) {
            s[e](t);
          }
          if (!i) {
            this._callbacks[e] = [];
          }
        }
      }
      async _computeStudy(e, t, i, s, l, h, d, _, g, f) {
        let y = true;
        const v = [];
        if (_ !== null) {
          this._objectsDataCache[_] = null;
        }
        this._timeScales[e].setCompleted(false);
        const S = this._computeStudyCounter++;
        function b(e, t) {
          if (e < g()) {
            return Ie;
          }
          if (t === 0) {
            return 0;
          }
          const i = v[t - 1].index;
          if (i === Ie) {
            return 0;
          } else {
            return i + 1;
          }
        }
        const w = new Map();
        let C = false;
        const P = (i, g) => {
          const S = u.Interval.parse(s);
          if ((0, r.default)(i.supported_resolutions) && i.supported_resolutions.length > 0 && (0, H.findSuitableResolutionToBuildFrom)(s, i).error) {
            f.onSymbolErrorCallback(`unsupported resolution: ${i.ticker}, ${s}`);
          } else {
            if (u.Interval.isDWM(s) && d.to !== undefined) {
              const e = (0, m.createDwmAligner)(s, i);
              if (e !== null) {
                d.to = e.timeToExchangeTradingDay(d.to);
              }
            }
            if (d.from && d.to) {
              const e = (0, p.getPeriodsBetweenDates)(i.session, i.session_holidays, i.corrections, S.letter(), S.multiplier(), d.from, d.to);
              d.countBack = Math.max(e, d.countBack);
            }
            try {
              const r = new O({
                unitId: i.unit_id,
                currencyCode: i.currency_code,
                tickerid: g,
                symbolInfo: i,
                period: s,
                body: t,
                sessionId: e,
                onErrorCallback: f.onErrorCallback,
                dataRange: d,
                subsessionId: i.subsession_id,
                forceAlignBars: !o.enabled("disable_sameinterval_aligning") && (0, m.isAlignmentEnabled)(),
                enableDwmAligning: o.enabled("align_dwm_bars_to_main_series") || !this._studyCanExtendTimeScale(e, l),
                input: e => h[e],
                out: (e, t) => {
                  (function (e, t, i) {
                    const s = e.time;
                    const o = typeof t == "number" ? [t] : t;
                    for (let e = 0; e < o.length; ++e) {
                      let t = o[e];
                      if (t && typeof t == "object" && !Array.isArray(t)) {
                        w.set(e, t.offset);
                        t = t.value;
                      }
                      if (typeof t == "number" && isNaN(t)) {
                        t = undefined;
                      }
                      o[e] = t;
                    }
                    const n = v.length - 1;
                    const r = n < 0 || s > v[n].timeMs;
                    if (r) {
                      v.push({
                        index: b(s, v.length),
                        value: [s / 1000].concat(o),
                        timeMs: s
                      });
                    } else {
                      v[n].index = b(s, n);
                      v[n].value = [s / 1000].concat(o);
                      v[n].timeMs = s;
                    }
                    if (!y) {
                      f.onRealtimeCallback([v[v.length - 1]], r, v.length, w, i);
                    }
                  })(e, t, i);
                },
                nonseriesOut: (e, t) => {
                  f.onNonSeriesDataUpdate(t, e);
                },
                setNoMoreData: () => {
                  C = true;
                },
                recalc: (e, s) => {
                  y = false;
                  v.endOfData = C;
                  v.emptyBarCount = s.emptyBarCount;
                  if (!("error" in t) || (0, n.default)(t.error) || (0, c.default)(t.error) && t.error() === null) {
                    if (_ !== null) {
                      this._objectsDataCache[_] = v;
                    }
                    f.onDataReadyCallback(v, w, i, s);
                  }
                }
              });
              if (!this._studiesCache[e] || !this._studiesCache[e][l]) {
                throw Error("This should never happen");
              }
              this._studiesCache[e][l].engine = r;
            } catch (e) {
              if (!(0, a.default)(e) || !("studyError" in e) || !e.studyError) {
                throw e;
              }
              f.onErrorCallback(Be(e, "unknown study error"));
            }
          }
        };
        const T = () => this._studiesCache[e] && this._studiesCache[e][l] && this._studiesCache[e][l].activeResolve === S;
        this._studiesCache[e][l].activeResolve = S;
        const x = this._resolvePromisesBySymbolId.get(Ve(e, i));
        if (x === undefined) {
          throw new Error("This should never happen");
        }
        let I;
        let M;
        try {
          const e = await x;
          I = e.symbolInfo;
          M = e.requestedSymbol;
        } catch (e) {
          if (T()) {
            f.onSymbolErrorCallback(Be(e, "unknown symbol error"));
          }
          return;
        }
        if (T()) {
          P(I, M);
        }
      }
      _getDataRangeForStudy(e, t) {
        const i = this._studiesCache[e][t];
        const s = {
          ...this._seriesDataRange(e, i.parentId)
        };
        if (this._studyCanExtendTimeScale(e, t)) {
          if (i.dataRange !== undefined) {
            return i.dataRange;
          } else {
            if (i.firstLoadedTimeMs) {
              s.to = i.firstLoadedTimeMs;
            }
            return s;
          }
        } else {
          return s;
        }
      }
      _seriesDataRange(e, t) {
        const i = this._studiesCache[e][t];
        if (i.firstLoadedTimeMs !== null) {
          return {
            to: i.firstLoadedTimeMs,
            countBack: 0
          };
        } else {
          return i.dataRange;
        }
      }
      _createStudy(e, t, i, s, o, n, l, c) {
        this._studiesCache[s][o].completed = false;
        const h = (e => {
          if (Array.isArray(e)) {
            return e;
          }
          const t = [];
          const i = this._studiesCache[s][o].metainfo.inputs;
          if ((0, r.default)(i)) {
            for (let s = 0; s < i.length; s++) {
              t[s] = e[i[s].id];
            }
          }
          return t;
        })(c);
        Me().ChartapiMessagerInstances[s].onStudyLoading(o, n);
        const u = (e, t, i) => {
          const r = this._studiesCache[s][o];
          r.completed = true;
          if (e.length > 0) {
            r.firstLoadedTimeMs = e[0].timeMs;
          }
          e = He(e);
          this._setEndOfData(s, o, n, !this._studyCanExtendTimeScale(s, o) || e.endOfData);
          if (this._studyCanExtendTimeScale(s, o)) {
            const t = e.map(e => e.timeMs);
            const i = this._timeScales[s].setStudyBarsTimes(o, t);
            this._applyTimeScaleUpdate(s, i);
          }
          this._timeScales[s].fillIndexesInRows(e);
          Me().ChartapiMessagerInstances[s].onDataUpdate(o, n, e, t);
          Me().ChartapiMessagerInstances[s].onStudyCompleted(o, n);
          this._updateTimeScaleState(s);
        };
        const _ = e => {
          if (e.size === 0) {
            return {};
          }
          const t = {};
          const i = this._studiesCache[s][o].metainfo;
          e.forEach((e, s) => {
            t[(0, d.ensure)(i.plots)[s].id] = e;
          });
          return {
            data: {
              offsets: t
            }
          };
        };
        let p = null;
        let m = false;
        this._computeStudy(s, i, e, t, o, h, this._getDataRangeForStudy(s, o), null, () => {
          if (this._studyCanExtendTimeScale(s, o)) {
            return -Infinity;
          }
          if (p === null) {
            const e = this._getSeriesData(s, l)?.[0];
            if (e === undefined) {
              return Infinity;
            }
            p = e.timeMs;
          }
          return p;
        }, {
          onDataReadyCallback: (e, t, i) => {
            if (!m || e.length !== 0) {
              u(e, _(t));
            }
          },
          onRealtimeCallback: (e, t, i, r, a) => {
            const l = He(e);
            if (this._studyCanExtendTimeScale(s, o)) {
              const e = l.map(e => e.timeMs);
              const t = this._timeScales[s].replaceBarsTimesTail(o, e);
              this._applyTimeScaleUpdate(s, t);
            }
            this._timeScales[s].fillIndexesInRows(l);
            Me().ChartapiMessagerInstances[s].onDataUpdate(o, n, l, _(r));
            this._updateTimeScaleState(s);
          },
          onSymbolErrorCallback: () => {
            this._studiesCache[s][o].completed = true;
            Me().ChartapiMessagerInstances[s].onStudyError(o, n, "error in series");
          },
          onErrorCallback: e => {
            this._studiesCache[s][o].completed = true;
            Me().ChartapiMessagerInstances[s].onStudyError(o, n, e);
          },
          onNonSeriesDataUpdate: (e, t) => {
            m = true;
            switch (e.type) {
              case "projection":
                break;
              case "study_graphics":
                {
                  const t = {
                    type: "study_graphics",
                    data: e.data,
                    indexes: [],
                    nonseries: true
                  };
                  const i = function (e) {
                    const t = e.data && e.data.graphicsCmds && e.data.graphicsCmds.create;
                    if (!t) {
                      return [];
                    }
                    const i = new Map();
                    const s = new Set();
                    ve.forEach((e, o) => {
                      const n = t[o];
                      if (n) {
                        for (const t of n) {
                          for (const o of t.data) {
                            const t = e(o);
                            for (const e of t) {
                              i.set(e, -1);
                              s.add(e);
                            }
                          }
                        }
                      }
                    });
                    const o = Array.from(s).sort((e, t) => e - t);
                    o.forEach((e, t) => i.set(e, t));
                    Se.forEach((e, s) => {
                      const o = t[s];
                      if (o) {
                        for (const t of o) {
                          for (const s of t.data) {
                            e(s, i);
                          }
                        }
                      }
                    });
                    return o;
                  }(t);
                  this._studiesNonSeriesTimes[s][o] = i;
                  t.indexes = this._timeScales[s].convertTimesToIndexes(i);
                  u([], t);
                  break;
                }
              case "non_series_data":
                {
                  const t = {
                    type: "non_series_data",
                    data: e.data,
                    nonseries: true,
                    indexes: []
                  };
                  const i = t?.data?.data?.pivots;
                  const n = i !== undefined;
                  let r = function (e) {
                    const t = {};
                    Ce(e, e => {
                      if ((0, a.default)(e)) {
                        Object.keys(e).forEach(i => {
                          if (i.endsWith("__t")) {
                            t[e[i]] = true;
                          }
                        });
                      }
                    }, {
                      visitInstances: true
                    });
                    const i = Object.keys(t).map(Number).sort((e, t) => e - t);
                    i.forEach((e, i) => {
                      t[e] = i;
                    });
                    Object.assign(e, Ce(e, e => {
                      if ((0, a.default)(e)) {
                        Object.keys(e).forEach(i => {
                          if (i.endsWith("__t")) {
                            e[i.slice(0, -3)] = t[e[i]];
                          }
                        });
                      }
                      return e;
                    }, {
                      visitInstances: true
                    }));
                    return i;
                  }(t);
                  let l = this._timeScales[s].convertTimesToIndexes(r, n);
                  if (n) {
                    const e = new Set();
                    const t = [];
                    const s = [];
                    let o = 0;
                    for (let n = l.length - 1; n >= 0; n--) {
                      const a = l[n];
                      if (e.has(a) || a === ne.INVALID_TIME_POINT_INDEX) {
                        i.splice(n, 1);
                        o++;
                      } else {
                        t.unshift(r[n]);
                        s.unshift(a);
                        e.add(a);
                      }
                    }
                    if (o > 0) {
                      i.forEach((e, t) => {
                        e.startIndex = t;
                        e.endIndex = t + 1;
                      });
                    }
                    r = t;
                    l = s;
                  }
                  this._studiesNonSeriesTimes[s][o] = r;
                  t.indexes = l;
                  u([], t);
                  break;
                }
              default:
                Fe("unsupported non-series data type for study " + e.type);
            }
          }
        });
      }
      _isEndOfData(e, t, i) {
        const s = e + "!" + t + "@" + i;
        return Boolean(this._endOfData[s]);
      }
      _setEndOfData(e, t, i, s) {
        const o = e + "!" + t + "@" + i;
        this._endOfData[o] = s !== false;
      }
      _applyTimeScaleUpdate(e, t) {
        if (t === null) {
          return;
        }
        const i = [];
        for (const t of this._getStudiesCacheSessionKeys(e)) {
          const s = this._studiesCache[e][t];
          if (s && s.type === "study") {
            const o = this._studiesNonSeriesTimes[e][t];
            if (o) {
              const n = {
                indexes: this._timeScales[e].convertTimesToIndexes(o),
                data: {
                  indexes_replace: true
                }
              };
              i.push({
                objId: t,
                turnaround: s.turnaround,
                data: [],
                nonSeriesData: n
              });
            }
          }
        }
        Me().ChartapiMessagerInstances[e].onTimescaleUpdate(t, i);
        Promise.resolve().then(() => {
          const t = this._mainSeriesRecord(e);
          if (t !== null && t.symbolInfo != null) {
            const i = t.symbolInfo;
            const s = (s = t.resolution) => this._getSymbolExtrapolator(e, i, s);
            this._pointsetsManagers[e].getUpdatesForSymbol(t.symbolInfo.full_name, t.resolution, s, this._timeScales[e]).forEach((t, i) => {
              Me().ChartapiMessagerInstances[e].onPointsetDataUpdate(i, null, t);
            });
          }
        });
      }
      _updateMainTsBuilder(e) {
        const t = this._mainSeriesRecord(e);
        if (t !== null && t.symbolInfo != null) {
          const i = this._getSymbolExtrapolator(e, t.symbolInfo, t.resolution);
          this._timeScales[e].setMainSymbolExtrapolator(i);
        }
      }
      _updateTimeScaleState(e) {
        if (!this._studiesCache[e]) {
          return;
        }
        let t = true;
        let i = true;
        for (const s of this._getStudiesCacheSessionKeys(e)) {
          const o = this._studiesCache[e][s];
          i = i && this._isEndOfData(e, s, o.turnaround);
          t = t && o.completed;
        }
        if (this._timeScales[e].isCompleted() !== t) {
          this._timeScales[e].setCompleted(t);
          if (t) {
            Me().ChartapiMessagerInstances[e].onTimescaleCompleted(i);
          }
        }
      }
      _getStudiesCacheSessionKeys(e) {
        if (this._studiesCache[e] !== undefined) {
          return Object.keys(this._studiesCache[e]);
        } else {
          return [];
        }
      }
    }
    Ee.debugGetQuotesRequestId = 1;
    function Be(e, t) {
      if (typeof e == "string") {
        return e;
      } else if ((0, a.default)(e) && e && "message" in e && (0, l.default)(e.message)) {
        return e.message;
      } else {
        return t;
      }
    }
    function Ve(e, t) {
      return e + "_" + t;
    }
    function Re(e, t) {
      return e + "_" + t;
    }
    function Ne(e, t, i, s) {
      return e + (t ? "_#_" + t : "") + (i ? "_#_" + i : "") + (s ? "_#_" + s : "");
    }
    function Oe(e, t, i, s) {
      return [e, t, i, s].filter(e => (0, l.default)(e) && e.length > 0).join("|");
    }
    function Fe(e) {
      console.warn(`${new Date().toISOString()} ${e}`);
    }
    function We(e) {
      const t = (0, C.decodeExtendedSymbol)(e);
      const i = typeof t.symbol == "string" ? t : t.symbol;
      return [i.symbol, {
        currency: "currency-id" in i && i["currency-id"],
        unit: "unit-id" in i && i["unit-id"],
        session: "session" in i ? i.session === x.SubsessionId.Regular ? undefined : i.session : undefined
      }];
    }
    function He(e) {
      const t = e.findIndex(e => e.index !== Ie);
      if (t === -1) {
        return [];
      } else if (t === 0) {
        return e;
      } else {
        return e.slice(t);
      }
    }
    function ze(e) {
      if (e === null || typeof e == "number") {
        return e;
      }
      if (typeof e == "object" && Array.isArray(e)) {
        switch (e[0]) {
          case "bar_count":
            return e[2];
          case "from_to":
            if (e.length >= 3) {
              return e[2] ?? null;
            } else {
              return null;
            }
        }
      }
      return null;
    }
    function Ue(e, t, i) {
      i.logoid = undefined;
      i["base-currency-logoid"] = undefined;
      i["currency-logoid"] = undefined;
      if (e) {
        if (typeof e == "string") {
          Fe("`logo_urls` should be an array of urls, not a string.");
          return;
        }
        const [t, s] = e;
        if (s) {
          i["base-currency-logoid"] = t;
          i["currency-logoid"] = s;
        } else {
          i.logoid = t;
        }
      }
      if (t) {
        i.provider_id = t;
        i.country = undefined;
      }
    }
  },
  39076: (e, t, i) => {
    "use strict";

    i.d(t, {
      backend: () => s
    });
    const s = i(64289);
  },
  18278: (e, t, i) => {
    "use strict";

    i.d(t, {
      HandlerInfo: () => s
    });
    class s {
      constructor(e, t, i) {
        this.handler = e;
        this.customId = t;
        this.singleShot = i;
      }
    }
  },
  82783: (e, t, i) => {
    "use strict";

    var s;
    var o;
    var n;
    var r;
    function a(e, t) {
      if (e.type === "period-back" && t.type === "period-back") {
        return e.value === t.value;
      } else {
        return e.type === "time-range" && t.type === "time-range" && e.from === t.from && e.to === t.to;
      }
    }
    i.d(t, {
      TIMEFRAMETYPE: () => r,
      areEqualTimeFrames: () => a
    });
    (function (e) {
      e.extractErrorReason = function (e) {
        return e.params[1];
      };
    })(s ||= {});
    (function (e) {
      e.Default = "default";
      e.FullSingleSession = "full_single_session";
    })(o ||= {});
    (function (e) {
      e.PeriodBack = "period-back";
      e.TimeRange = "time-range";
    })(n ||= {});
    (function (e) {
      e.PeriodBack = "period-back";
      e.TimeRange = "time-range";
    })(r ||= {});
  },
  80437: () => {
    "use strict";

    TradingView.Pro = function () {
      this.hasPackage = function () {
        return false;
      };
    };
    window.user = {
      is_pro: false,
      settings: {}
    };
    TradingView.Pro.prototype.isPaidPro = function () {
      return false;
    };
    TradingView.Pro.prototype.isSupportAvailable = function () {
      return false;
    };
    TradingView.Pro.prototype.getProduct = function () {
      return {};
    };
    TradingView.Pro.prototype.getStudiesOrder = function () {
      return [];
    };
  },
  92883: (e, t, i) => {
    "use strict";

    i.d(t, {
      getNewPeveCloseMode: () => o
    });
    let s = false;
    function o() {
      return s;
    }
  },
  97126: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      QUOTE_FIELDS: () => n,
      QUOTE_FIELDS_CACHE: () => r,
      QuoteCache: () => o
    });
    var s = i(50151);
    class o {
      constructor(e) {
        this._cache = new Map();
        this._fields = [...e.fields];
      }
      update(e, t, i) {
        const o = (0, s.ensureDefined)(e.symbolname);
        if (!this._cache.has(o)) {
          this._cache.set(o, {
            symbolname: o,
            status: e.status,
            values: {}
          });
        }
        if (e.status === "error") {
          return;
        }
        const n = (0, s.ensureDefined)(this._cache.get(o));
        n.status = e.status;
        for (const s of this._fields) {
          if (t.has(s) && (i || e.values[s] !== undefined)) {
            n.values[s] = e.values[s];
          }
        }
      }
      get(e) {
        return this._cache.get(e) ?? null;
      }
      fields() {
        return this._fields;
      }
    }
    const n = new Set(["pro_name", "base_name", "logoid", "currency-logoid", "base-currency-logoid", "source-logoid", "short_name", "web_site_url", "pro_perm", "timezone", "current_session", "last_price", "lp_time", "prev_close_price", "open_price", "high_price", "low_price", "price_52_week_high", "price_52_week_low", "ask", "ask_size", "bid", "bid_size", "rch", "rchp", "rtc", "rtc_time", "data_frequency", "reference-last-period-start", "business_description", "web_site_url", "figi", "number_of_employees", "float_shares_outstanding", "earnings_release_next_calendar_date", "root", "description", "exchange", "listed_exchange", "type", "country_code", "provider_id", "sector", "typespecs", "visible-plots-set", "industry", "currency_id", "last_price", "fractional", "minmov", "minmove2", "pricescale", "variable_tick_size", "change", "change_percent", "volume", "average_volume", "market_cap_basic", "market_cap_calc", "total_revenue", "earnings_per_share_basic_ttm", "price_earnings_ttm", "beta_1_year", "dps_common_stock_prim_issue_fy", "dividends_yield", "earnings_release_next_date", "earnings_per_share_forecast_next_fq", "earnings_publication_type_next_fq", "earnings_release_date", "earnings_per_share_fq", "earnings_per_share_forecast_fq", "forecast_raw", "last_release_date", "next_release_date", "reference_last_period", "fundamental_currency_code", "number_of_employees", "web_site_url", "business_description", "founded", "ceo", "float_shares_outstanding", "total_shares_outstanding", "dividend_payout_ratio_ttm", "dividends_yield_current", "dividend_ex_date_upcoming", "dividend_amount_upcoming", "dividend_amount_recent", "dividend_ex_date_recent", "total_revenue_fq_h", "total_revenue_fy_h", "net_income_fy_h", "net_income_fq_h", "total_assets_fy_h", "total_assets_fq_h", "total_liabilities_fy_h", "total_liabilities_fq_h", "cash_f_operating_activities_fy_h", "cash_f_operating_activities_fq_h", "cash_f_investing_activities_fy_h", "cash_f_investing_activities_fq_h", "cash_f_financing_activities_fy_h", "cash_f_financing_activities_fq_h", "fiscal_period_fy_h", "fiscal_period_fq_h", "fiscal_period_fh_h", "earnings_release_date_fq_h", "earnings_release_next_date_fq", "earnings_per_share_forecast_next_fq", "earnings_per_share_forecast_fq_h", "earnings_per_share_fq_h", "earnings_fiscal_period_fq_h", "next_earnings_fiscal_period_fq", "is_next_earnings_release_date_estimated", "symbol-primaryname", "currency_code", "rates_mc", "rates_fy", "rates_ttm", "measure", "value_unit_id", "value-unit-id", "update_mode", "language", "local_description", "short_description", "source", "source2", "format", "recommendation_mark", "last_report_frequency", "price_target_estimates_num", "price_target_average", "update_mode_seconds", "recommendation_total", "recommendation_buy", "recommendation_over", "recommendation_hold", "recommendation_under", "recommendation_sell", "recommendation_total", "price_target_high", "price_target_low", "rates_pt", "rates_pt", "total_revenue_fy_h", "total_revenue_fq_h", "total_revenue_fh_h", "net_income_fy_h", "net_income_fq_h", "net_income_fh_h", "total_assets_fy_h", "total_assets_fq_h", "total_assets_fh_h", "total_liabilities_fy_h", "total_liabilities_fq_h", "total_liabilities_fh_h", "cash_f_operating_activities_fy_h", "cash_f_operating_activities_fq_h", "cash_f_operating_activities_fh_h", "cash_f_investing_activities_fy_h", "cash_f_investing_activities_fq_h", "cash_f_investing_activities_fh_h", "cash_f_financing_activities_fy_h", "cash_f_financing_activities_fq_h", "cash_f_financing_activities_fh_h", "fiscal_period_fy", "fiscal_period_fq", "fiscal_period_fh", "earnings_release_date_fq_h", "earnings_release_date_fy_h", "earnings_release_date_fh_h", "earnings_release_next_date_fq", "earnings_release_next_date_fy", "earnings_release_next_date_fh", "earnings_release_next_time", "earnings_release_time", "is_next_earnings_release_date_estimated", "earnings_per_share_forecast_next_fq", "earnings_per_share_forecast_next_fy", "earnings_per_share_forecast_next_fh", "earnings_per_share_forecast_fq_h", "earnings_per_share_forecast_fy_h", "earnings_per_share_forecast_fh_h", "earnings_per_share_fq_h", "earnings_per_share_fy_h", "earnings_per_share_fh_h", "earnings_fiscal_period_fq_h", "earnings_fiscal_period_fy_h", "earnings_fiscal_period_fh_h", "next_earnings_fiscal_period_fq", "next_earnings_fiscal_period_fy", "next_earnings_fiscal_period_fh", "revenue_fq_h", "revenue_fy_h", "revenue_fh_h", "revenue_forecast_fq_h", "revenue_forecast_fy_h", "revenue_forecast_fh_h", "revenue_forecast_next_fq", "revenue_forecast_next_fy", "revenue_forecast_next_fh", "revenue_seg_by_business_h", "revenue_seg_by_region_h", "dividend_payout_ratio_ttm", "dividends_yield_current", "dividend_ex_date_upcoming", "dividend_amount_upcoming", "dividend_amount_recent", "dividend_ex_date_recent", "dividend_amount_h", "total_revenue_fy", "total_revenue_fq", "total_revenue_fh", "gross_profit_fy", "gross_profit_fq", "gross_profit_fh", "ebitda_fy", "ebit_fy", "net_income_fy", "net_income_fq", "net_income_fh", "total_debt_fy_h", "total_debt_fq_h", "total_debt_fh_h", "free_cash_flow_fy_h", "free_cash_flow_fq_h", "free_cash_flow_fh_h", "cash_n_equivalents_fy_h", "cash_n_equivalents_fq_h", "cash_n_equivalents_fh_h", "total_current_assets_fy", "total_current_assets_fq", "total_current_assets_fh", "total_current_liabilities_fy", "total_current_liabilities_fq", "total_current_liabilities_fh", "total_non_current_assets_fy", "total_non_current_assets_fq", "total_non_current_assets_fh", "total_non_current_liabilities_fy", "total_non_current_liabilities_fq", "total_non_current_liabilities_fh", "loans_net_fy", "loans_net_fy_h", "loans_net_fq_h", "loans_net_fh_h", "total_deposits_fy", "total_deposits_fy_h", "total_deposits_fq_h", "total_deposits_fh_h", "loan_loss_allowances_fy", "loan_loss_allowances_fy_h", "loan_loss_allowances_fq_h", "loan_loss_allowances_fh_h", "reserve_to_total_capital_fy_h", "reserve_to_total_capital_fq_h", "reserve_to_total_capital_fh_h", "unearned_premium_to_total_capital_fy_h", "unearned_premium_to_total_capital_fq_h", "unearned_premium_to_total_capital_fh_h", "insurance_reserves_fy_h", "insurance_reserves_fq_h", "insurance_reserves_fh_h", "policy_claims_fy_h", "policy_claims_fq_h", "policy_claims_fh_h", "premiums_earned_fy_h", "premiums_earned_fq_h", "premiums_earned_fh_h", "price_earnings_fq_h", "price_earnings_fy_h", "price_earnings_fh_h", "price_sales_fq_h", "price_sales_fy_h", "price_sales_fh_h", "diluted_net_income_ttm", "total_revenue_ttm", "price_earnings_current", "price_sales_current", "isin-displayed", "interest_income_fy_h", "interest_income_fq_h", "interest_income_fh_h", "non_interest_income_fy_h", "non_interest_income_fq_h", "non_interest_income_fh_h", "website", "doc", "explorer", "sources", "contracts", "crypto_common_categories", "crypto_asset", "community", "dividends_availability", "earnings_availability", "financials_availability", "etf_asset_type_exposure", "etf_region_exposure", "top_holdings", "unit-id", "options-info", "interest_income_fy", "interest_income_fq", "interest_income_fh", "non_interest_income_fy", "non_interest_income_fq", "non_interest_income_fh", "interest_expense_fy", "interest_expense_fq", "interest_expense_fh", "loan_loss_provision_fy", "loan_loss_provision_fq", "loan_loss_provision_fh", "non_interest_expense_fy", "non_interest_expense_fq", "non_interest_expense_fh", "non_oper_income_fy", "non_oper_income_fq", "non_oper_income_fh", "unusual_expense_inc_fy", "unusual_expense_inc_fq", "unusual_expense_inc_fh", "pretax_income_fy", "pretax_income_fq", "pretax_income_fh", "income_tax_fy", "income_tax_fq", "income_tax_fh", "after_tax_other_income_fy", "after_tax_other_income_fq", "after_tax_other_income_fh", "total_non_oper_income_fy", "total_non_oper_income_fq", "total_non_oper_income_fh", "oper_income_fy", "oper_income_fq", "oper_income_fh", "operating_expenses_fy", "operating_expenses_fq", "operating_expenses_fh", "cost_of_goods_fy", "cost_of_goods_fq", "cost_of_goods_fh", "equity_in_earnings_fy", "equity_in_earnings_fq", "equity_in_earnings_fh", "minority_interest_exp_fy", "minority_interest_exp_fq", "minority_interest_exp_fh", "discontinued_operations_fy", "discontinued_operations_fq", "discontinued_operations_fh", "front_contract", "pointvalue", "unit_id", "expiration", "aum", "asset_class", "focus", "expense_ratio", "launch_date", "issuer", "brand", "homepage", "index_tracked", "actively_managed", "fund_view_mode", "common_equity_tier1_ratio_fy_h", "common_equity_tier1_ratio_fq_h", "common_equity_tier1_ratio_fh_h", "tier1_capital_ratio_fy_h", "tier1_capital_ratio_fq_h", "tier1_capital_ratio_fh_h", "total_capital_ratio_fy_h", "total_capital_ratio_fq_h", "total_capital_ratio_fh_h", "preferred_stock_carrying_value_fh", "preferred_stock_carrying_value_fq", "total_debt_fq", "minority_interest_fh", "minority_interest_fq", "cash_n_short_term_invest_fq", "cash_n_due_f_banks_fh", "cash_n_due_f_banks_fq", "enterprise_value_current", "etf_holdings_count", "contract-description", "reference-last-period", "all_time_high", "all_time_high_day", "all_time_low", "all_time_low_day", "outstanding_amount", "nominal_value", "denom_min", "current_coupon", "coupon_type_general", "coupon_frequency", "yield_to_maturity", "maturity-date", "days_to_maturity", "bond_issuer", "issue_date", "bond_issuer_stock_symbol", "total_issued_amount", "paid_amount", "bond_snp_rating_lt_h", "placement_type", "duration_type", "maturity_type", "offer_type", "redemption_type", "conversion_option", "sinking_fund", "ownership_form", "daily-summary-ast", "issue_status", "coupon_h", "sinking_fund_next_date", "sinking_fund_min_amount_next", "call_next_date", "redemptions_h", "call_notice_days", "put_next_date", "put_notice_days_min", "seniority_level", "inflation_protection", "pledge_status", "bond_issuer_country_of_risk", "bond_issuer_cr_parent", "credit_enhancement_type", "credit_enhancement_status", "use_of_proceeds", "bond_issuer_snp_rating_lt_h", "bond_issuer_snp_rating_st_h", "bond_agents_tr", "first_bar_time_1d", "financial-indicator-id", "exchange-info", "underlying-symbol", "strike", "lotsize", "option-style"]);
    const r = new o({
      fields: n
    });
  },
  42003: (e, t, i) => {
    "use strict";

    i.d(t, {
      destroyQuoteSessions: () => r,
      getQuoteSessionInstance: () => n
    });
    var s = i(32783);
    const o = {};
    function n(e = "full") {
      if (!o[e]) {
        (function (e = "full", t) {
          o[e] = t;
        })(e, new s(e));
      }
      return o[e];
    }
    function r() {
      for (const e in o) {
        if (o.hasOwnProperty(e)) {
          const t = o[e];
          if (t !== undefined) {
            t.destroy();
          }
          delete o[e];
        }
      }
    }
  },
  64364: (e, t, i) => {
    "use strict";

    i.d(t, {
      QuoteSession: () => o
    });
    var s = i(92184);
    class o {
      constructor(e, t = (0, s.randomHash)()) {
        this._sessionstarted = false;
        this._globalHandler = null;
        this._chartApi = e;
        this._sessionid = "qs_" + t;
      }
      destroy() {
        if (this._sessionstarted) {
          this._chartApi.quoteDeleteSession(this._sessionid);
          this._sessionstarted = false;
        }
      }
      connected() {
        return this._chartApi.connected();
      }
      connect(e) {
        this._globalHandler = e;
        this._chartApi.createSession(this._sessionid, this);
        this._chartApi.connect();
      }
      disconnect() {
        this._chartApi.disconnect();
      }
      quoteAddSymbols(e) {
        this._chartApi.quoteAddSymbols(this._sessionid, e);
      }
      quoteRemoveSymbols(e) {
        this._chartApi.quoteRemoveSymbols(this._sessionid, e);
      }
      quoteFastSymbols(e) {
        this._chartApi.quoteFastSymbols(this._sessionid, e);
      }
      quoteSetFields(e) {
        this._chartApi.quoteSetFields(this._sessionid, e);
      }
      onMessage(e) {
        switch (e.method) {
          case "connected":
            if (!this._sessionstarted) {
              this._chartApi.quoteCreateSession(this._sessionid);
              this._sessionstarted = true;
            }
            break;
          case "disconnected":
            this._sessionstarted = false;
        }
        this._globalHandler?.(e);
      }
      quoteHibernateAll() {
        this._chartApi.quoteHibernateAll(this._sessionid);
      }
    }
    window.TradingView.QuoteSession = o;
  },
  32783: (e, t, i) => {
    "use strict";

    e = i.nmd(e);
    var s = i(20057).default;
    var o = i(90484).default;
    var n = i(725).PriceFormatter;
    const {
      uniq: r
    } = i(97144);
    var a = i(92184);
    const {
      normalizeUpdateMode: l
    } = i(89512);
    var c = i(31054).deepExtend;
    const {
      QUOTE_FIELDS_CACHE: h,
      QUOTE_FIELDS: d
    } = i(97126);
    var u;
    var _ = i(52033).Delegate;
    var p = i(92883).getNewPeveCloseMode;
    function m(e, t) {
      this.options = Object.assign({
        throttleTimeout: 125
      }, t);
      this._connected = false;
      this._symbol_data = {};
      this._subscriptions = {};
      this.onConnect = new _();
      this.onDisconnect = new _();
      this._quoteApi = new u(window.ChartApiInstance);
      this._type = e || "full";
      this._delayUpdateFastSymbols = o(this._updateFastSymbols, 250);
      this._throttledSymbolData = {};
      this._formatterValuesCache = {};
      this._waitingForFormatters = {};
      this._snapshotValuesCache = {};
      this._waitingForSnapshot = {};
      this.connect();
    }
    u = i(64364).QuoteSession;
    m.prototype.destroy = function () {
      this._quoteApi.destroy();
      this._quoteApi = null;
      this._connected = false;
      this.onDisconnect.fire();
    };
    m.prototype.typeFields = {};
    m.prototype.typeFields.simple = ["base-currency-logoid", "ch", "chp", "currency-logoid", "currency_code", "currency_id", "base_currency_id", "current_session", "description", "exchange", "format", "fractional", "is_tradable", "language", "local_description", "listed_exchange", "logoid", "lp", "lp_time", "minmov", "minmove2", "original_name", "pricescale", "pro_name", "short_name", "type", "typespecs", "update_mode", "volume", "variable_tick_size", "value_unit_id", "unit_id", "measure"];
    m.prototype.typeFields.simpleDetailed = [].concat(m.prototype.typeFields.simple, ["ask", "bid", "fundamentals", "high_price", "is_tradable", "low_price", "open_price", "prev_close_price", "rch", "rchp", "rtc", "rtc_time", "status", "basic_eps_net_income", "beta_1_year", "earnings_per_share_basic_ttm", "industry", "market_cap_basic", "price_earnings_ttm", "sector", "volume", "dividends_yield", "timezone"]);
    m.prototype.typeFields.full = [];
    m.prototype.typeFields.watchlist = [].concat(m.prototype.typeFields.simple, ["rchp", "rtc", "country_code", "provider_id"]);
    m.prototype.typeFields.portfolio = ["pro_name", "short_name", "exchange", "listed_exchange", "description", "local_description", "language", "sector", "type", "typespecs", "industry", "currency_code", "currency_id", "ch", "chp", "logoid", "currency-logoid", "base-currency-logoid", "earnings_per_share_forecast_next_fq", "earnings_release_next_date", "earnings_release_date", "earnings_per_share_fq", "lp", "fractional", "minmov", "minmove2", "pricescale", "volume", "average_volume", "market_cap_calc", "market_cap_basic", "total_revenue", "earnings_per_share_basic_ttm", "price_earnings_ttm", "beta_1_year", "dps_common_stock_prim_issue_fy", "dividends_yield", "fundamental_currency_code", "rates_mc", "rates_fy", "rates_ttm", "format", "value_unit_id", "unit_id", "measure"];
    m.prototype.typeFields.notes = ["short_name", "pro_name", "logoid", "currency-logoid", "base-currency-logoid", "symbol-primaryname", "type", "typespecs"];
    m.prototype.typeFields.estimates = ["fundamental_data", "type", "typespecs", "earnings_per_share_forecast_next_symbol_currency_fq", "earnings_release_next_aligned_date", "earnings_release_next_calendar_date", "earnings_release_next_date"];
    m.prototype.typeFields.economic = ["reference-last-period", "lp", "currency_code", "value_unit_id", "unit_id", "measure"];
    m.prototype.connect = function (e) {
      this._quoteApi.connect(this.quoteHandler.bind(this));
    };
    m.prototype.quoteHandler = function (e) {
      var t = e.method;
      var i = e.params;
      switch (t) {
        case "connected":
          if (!this._connected) {
            this._connected = true;
            this.onConnected();
          }
          break;
        case "quote_list_fields":
          break;
        case "quote_symbol_data":
          if (this._connected) {
            this.onSymbolData(i[0]);
          }
          break;
        case "quote_completed":
          if (this._connected) {
            this.onSymbolData({
              symbolname: i[0],
              complete: performance.now(),
              values: {}
            });
          }
          break;
        case "disconnected":
          if (this._connected) {
            this._connected = false;
            this.onDisconnect.fire();
          }
      }
    };
    m.prototype.onConnected = function () {
      this.setFields();
      var e = Object.keys(this._symbol_data);
      if (e.length) {
        this._quoteApi.quoteAddSymbols(e);
        this._delayUpdateFastSymbols();
      }
      this.onConnect.fire();
    };
    m.prototype.setFields = function () {
      var e = m.prototype.typeFields[this._type];
      if (e && e.length) {
        this._quoteApi.quoteSetFields(e);
      }
    };
    m.prototype.onSymbolData = function (e) {
      try {
        if (e.status) {
          h.update(e, d, false);
        }
      } catch (e) { }
      var t = e.symbolname;
      var i = this._throttledSymbolData[t];
      if (p()) {
        delete e.values.prev_close_price;
        if (e.values.regular_close !== undefined) {
          e.values.prev_close_price = e.values.regular_close;
        }
      }
      i ||= this._throttledSymbolData[t] = {
        fnDispatch: s(this.dipatchSymbolData.bind(this), this.options.throttleTimeout)
      };
      if (i.cache) {
        c(i.cache, e);
      } else {
        i.cache = e;
      }
      i.fnDispatch(t);
    };
    m.prototype._parseUpdateMode = function (e) {
      l(e);
    };
    m.prototype.dipatchSymbolData = function (e) {
      var t = this._symbol_data[e];
      var i = this._throttledSymbolData[e].cache;
      delete this._throttledSymbolData[e].cache;
      if (this._symbol_data[e]) {
        c(t, i);
        if (t.values) {
          this._parseUpdateMode(t.values);
        }
        for (var s in this._subscriptions) {
          var o = this._subscriptions[s];
          if (o.has(e)) {
            [...o.get(e)].forEach(function (e) {
              e(t, i);
            });
          }
        }
      }
    };
    m.prototype.subscribe = function (e, t, i) {
      this._subscriptions[e] = this._subscriptions[e] || new Map();
      var s = this._subscriptions[e];
      t = [].concat(t);
      var o = [];
      t.forEach(function (e) {
        if (this._symbol_data[e]) {
          if (!s || !s.has(e)) {
            this._symbol_data[e].subscribers_count++;
          }
        } else {
          this._symbol_data[e] = {
            subscribers_count: 1
          };
          o.push(e);
        }
        if (!s.has(e)) {
          s.set(e, []);
        }
        s.get(e).push(i);
        s.get(e).fast = true;
        if (this._symbol_data[e] && this._symbol_data[e].values) {
          i(this._symbol_data[e], this._symbol_data[e]);
        }
      }, this);
      if (o.length && this._connected) {
        this._quoteApi.quoteAddSymbols(o);
        this._delayUpdateFastSymbols();
      }
    };
    m.prototype.unsubscribe = function (e, t, i) {
      t = [].concat(t);
      var s = this._subscriptions[e];
      var o = [];
      for (var n = 0; n < t.length; n++) {
        var r = t[n];
        if (s) {
          if (s.has(r) && i) {
            var a = s.get(r).indexOf(i);
            if (~a) {
              s.get(r).splice(a, 1);
            }
            if (!s.get(r).length) {
              s.delete(r);
            }
          } else {
            s.delete(r);
          }
        }
        if (s && s.size === 0) {
          delete this._subscriptions[e];
        }
        if (this._symbol_data.hasOwnProperty(r)) {
          if (s && !s.has(r)) {
            this._symbol_data[r].subscribers_count--;
          }
          if (!this._symbol_data[r].subscribers_count) {
            delete this._symbol_data[r];
            o.push(r);
          }
        }
      }
      if (o.length && this._connected) {
        this._quoteApi.quoteRemoveSymbols(o);
        this._delayUpdateFastSymbols();
      }
    };
    m.prototype.setFastSymbols = function (e, t) {
      if (this._subscriptions[e]) {
        var i = this._subscriptions[e];
        for (var s = Array.from(i.keys()), o = 0; o < s.length; ++o) {
          var n = s[o];
          i.get(n).fast = t.indexOf(n) !== -1;
        }
      }
      this._delayUpdateFastSymbols();
    };
    m.prototype._updateFastSymbols = function () {
      if (this._connected) {
        var e = this._fastSymbols();
        if (e.length === 0) {
          this._quoteApi.quoteHibernateAll();
        } else {
          this._quoteApi.quoteFastSymbols(e);
        }
      }
    };
    m.prototype._delayUpdateFastSymbols = m.prototype._updateFastSymbols;
    m.prototype._fastSymbols = function () {
      var e = [];
      for (var t in this._subscriptions) {
        var i = this._subscriptions[t];
        for (var s = Array.from(i.keys()), o = 0; o < s.length; ++o) {
          var n = s[o];
          if (i.get(n).fast) {
            e.push(n);
          }
        }
      }
      return e = r(e);
    };
    m.prototype.formatter = function (e, t) {
      var i = this;
      if (this._waitingForFormatters[e]) {
        return this._waitingForFormatters[e];
      }
      function s(e) {
        var i = t && !e.fractional ? 1 : e.minmov;
        return new n({
          priceScale: e.pricescale,
          minMove: i,
          fractional: e.fractional,
          minMove2: e.minmove2
        });
      }
      var o = new Promise(function (t, o) {
        if (i._formatterValuesCache[e]) {
          t(s(i._formatterValuesCache[e]));
        } else {
          var n = a.guid();
          i.subscribe(n, [e], function (r) {
            if (r.status === "error") {
              i._waitingForFormatters[e] = null;
              o("Quotes snapshot is not received");
            }
            if (function (e) {
              return e && e.pricescale != null && e.minmov != null;
            }(r.values)) {
              i._waitingForFormatters[e] = null;
              i._formatterValuesCache[e] = r.values;
              t(s(r.values));
              i.unsubscribe(n, e);
            }
          });
        }
      });
      this._waitingForFormatters[e] = o;
      return o;
    };
    m.prototype.snapshot = function (e) {
      var t = this;
      if (this._waitingForSnapshot[e]) {
        return this._waitingForSnapshot[e];
      }
      var i = new Promise(function (i, s) {
        if (t._snapshotValuesCache[e]) {
          i(t._snapshotValuesCache[e]);
        } else {
          var o = a.guid();
          t.subscribe(o, [e], function (n) {
            if (n.status === "error") {
              t._waitingForSnapshot[e] = null;
              s("Quotes snapshot is not received");
            }
            var r = n.values;
            if (r && r.minmov && r.pricescale) {
              t._waitingForSnapshot[e] = null;
              t._snapshotValuesCache[e] = r;
              i(r);
              t.unsubscribe(o, e);
            }
          });
        }
      });
      this._waitingForSnapshot[e] = i;
      return i;
    };
    TradingView.QuoteSessionMultiplexer = m;
    if (e && e.exports) {
      e.exports = m;
    }
  },
  45687: (e, t, i) => {
    "use strict";

    i.d(t, {
      getServerInterval: () => o
    });
    var s = i(85049);
    function o(e) {
      if (s.Interval.isRange(e)) {
        return "1";
      } else {
        return e;
      }
    }
  },
  89512: (e, t, i) => {
    "use strict";

    function s(e) {
      if (e === undefined) {
        return null;
      }
      const t = e.match(/(delayed_streaming)_(\d+)/);
      if (t === null) {
        return null;
      } else {
        return {
          mode: t[1],
          interval: parseInt(t[2])
        };
      }
    }
    function o(e) {
      const t = s(e.update_mode);
      if (t !== null) {
        e.update_mode = t.mode;
        e.update_mode_seconds = t.interval;
      }
      return e;
    }
    i.r(t);
    i.d(t, {
      normalizeUpdateMode: () => o,
      parseUpdateMode: () => s
    });
  },
  63812: (e, t, i) => {
    "use strict";

    function s(e, t, i) {
      const s = e.get(t);
      if (s !== undefined) {
        return s;
      } else {
        e.set(t, i);
        return i;
      }
    }
    function o(e, t, i) {
      const s = e.get(t);
      if (s !== undefined) {
        return s;
      }
      const o = i();
      e.set(t, o);
      return o;
    }
    function n(e, t, i, n) {
      return o(s(e, t, new Map()), i, n);
    }
    function r(e, t, i, o, n) {
      const r = s(e, t, new Map());
      const a = s(r, i, new Map());
      return s(a, o, n);
    }
    i.d(t, {
      AbstractMapContainer: () => a,
      getDefault2Lazy: () => n,
      getDefault3: () => r
    });
    class a {
      constructor() {
        this._map = new Map();
        this._size = 0;
      }
      size() {
        return this._size;
      }
      clear() {
        this._map.clear();
        this._size = 0;
      }
    }
  },
  29981: (e, t, i) => {
    "use strict";

    i.d(t, {
      compareTwoCollectionsByIds: () => y,
      indexOf: () => f,
      intersect: () => p,
      join: () => m,
      lowerbound: () => r,
      lowerboundExt: () => n,
      lowerbound_int: () => a,
      mapEntriesGenerator: () => S,
      moveAfter: () => u,
      moveBefore: () => _,
      moveToHead: () => d,
      nestedMapGenerator: () => b,
      removeItemFromArray: () => g,
      subtract: () => h,
      sum: () => v,
      upperbound: () => l,
      upperbound_int: () => c
    });
    var s = i(50151);
    function o(e, t) {
      return e < t;
    }
    function n(e, t, i, s, o) {
      let n = o - s;
      while (n > 0) {
        const o = n >> 1;
        const r = s + o;
        if (i(e(r), t)) {
          s = r + 1;
          n -= o + 1;
        } else {
          n = o;
        }
      }
      return s;
    }
    function r(e, t, i, s = 0, o = e.length) {
      return n(t => e[t], t, i, s, o);
    }
    function a(e, t, i = 0, s = e.length) {
      return r(e, t, o, i, s);
    }
    function l(e, t, i, s = 0, o = e.length) {
      let n = o - s;
      while (n > 0) {
        const o = n >> 1;
        const r = s + o;
        if (i(t, e[r])) {
          n = o;
        } else {
          s = r + 1;
          n -= o + 1;
        }
      }
      return s;
    }
    function c(e, t, i = 0, s = e.length) {
      return l(e, t, o, i, s);
    }
    function h(e, t) {
      return e.filter(e => !t.includes(e));
    }
    function d(e, t) {
      const i = e.indexOf(t);
      if (i < 0) {
        return e.slice();
      } else {
        return [t].concat(e.slice(0, i)).concat(e.slice(i + 1));
      }
    }
    function u(e, t, i) {
      const s = new Set(t);
      const o = [];
      const n = [];
      const r = [];
      e.forEach((e, t) => {
        if (s.has(e)) {
          n.push(e);
        } else {
          o.push(e);
          r.push(t);
        }
      });
      i = i < e.length - 1 ? a(r, i + 1) : o.length;
      o.splice(i, 0, ...n);
      return {
        newItems: o,
        movedItemsStartIndex: i
      };
    }
    function _(e, t, i) {
      const s = new Set(t);
      const o = [];
      const n = [];
      const r = [];
      e.forEach((e, t) => {
        if (s.has(e)) {
          n.push(e);
        } else {
          o.push(e);
          r.push(t);
        }
      });
      i = i <= e.length - 1 ? a(r, i) : o.length;
      o.splice(i, 0, ...n);
      return {
        newItems: o,
        movedItemsStartIndex: i
      };
    }
    function p(e, t) {
      const i = new Set();
      e.forEach(e => {
        if (t.has(e)) {
          i.add(e);
        }
      });
      return i;
    }
    function m(e, t) {
      const i = new Set(e);
      t.forEach(e => i.add(e));
      return i;
    }
    function g(e, t) {
      const i = e.indexOf(t);
      (0, s.assert)(i !== -1, "Item is not found");
      e.splice(i, 1);
    }
    function f(e, t) {
      for (let i = 0; i < e.length; i++) {
        if (t(e[i])) {
          return i;
        }
      }
      return -1;
    }
    function y(e, t) {
      if (e.length !== t.length) {
        return false;
      }
      for (let i = 0; i < e.length; ++i) {
        if (e[i].id() !== t[i].id()) {
          return false;
        }
      }
      return true;
    }
    function v(e) {
      return e.reduce((e, t) => e + t, 0);
    }
    function* S(e) {
      for (const [t, i] of e) {
        yield [t, i];
      }
    }
    function* b(e, t) {
      for (const [i, s] of e) {
        if (t === undefined) {
          for (const [, e] of s) {
            yield [i, e];
          }
        } else {
          const e = s.get(t);
          if (e !== undefined) {
            yield [i, e];
          }
        }
      }
    }
  },
  2740: (e, t, i) => {
    "use strict";

    i.d(t, {
      DAY_OF_MONTH: () => S,
      DAY_OF_WEEK: () => w,
      DECEMBER: () => g,
      FIRST_DAY_OF_WEEK: () => _,
      FRIDAY: () => d,
      HOUR_OF_DAY: () => C,
      JANUARY: () => m,
      LAST_DAY_OF_WEEK: () => p,
      MINUTE: () => P,
      MONDAY: () => a,
      MONTH: () => y,
      SATURDAY: () => u,
      SECOND: () => T,
      SUNDAY: () => r,
      THURSDAY: () => h,
      TUESDAY: () => l,
      WEDNESDAY: () => c,
      WEEK_OF_YEAR: () => v,
      YEAR: () => f,
      add_date: () => H,
      add_days_considering_dst: () => F,
      add_minutes: () => z,
      add_years_considering_dst: () => W,
      cal_to_utc: () => ie,
      clone: () => j,
      days_per_year: () => q,
      get_cal: () => Q,
      get_cal_from_unix_timestamp_ms: () => ee,
      get_cal_utc: () => te,
      get_day_of_month: () => E,
      get_day_of_week: () => B,
      get_day_of_year: () => V,
      get_minutes_from_midnight: () => R,
      get_minutes_with_hours: () => N,
      get_month: () => L,
      get_part: () => K,
      get_timezone: () => se,
      get_year: () => A,
      is_leap_year: () => $,
      minutesPerDay: () => x,
      minutesPerWeek: () => I,
      setCustomTimezones: () => ne,
      set_hms: () => O,
      set_seconds: () => U,
      time_seconds: () => Y,
      time_seconds_diff: () => Z,
      utc_to_cal: () => X,
      utc_to_cal_ts: () => J
    });
    var s = i(23998);
    const o = {
      0: 0,
      1: 31,
      2: 59,
      3: 90,
      4: 120,
      5: 151,
      6: 181,
      7: 212,
      8: 243,
      9: 273,
      10: 304,
      11: 334
    };
    class n {
      constructor(e) {
        this._invalid = false;
        this._name = e;
        let t = s.tzData[e];
        if (!t && oe) {
          t = oe.instance().getTimezoneData(e);
        }
        if (!t) {
          t = {
            time: [],
            offset: []
          };
          this._invalid = true;
        }
        if (t.time.length !== t.offset.length) {
          t = {
            time: [],
            offset: []
          };
          this._invalid = true;
        }
        const i = t;
        if (!i.time_utc) {
          const e = t.time;
          const s = t.offset;
          const o = e.length;
          const n = new Array(o);
          for (let t = 0; t < o; t++) {
            e[t] *= 1000;
            s[t] *= 1000;
            n[t] = e[t] - s[t];
          }
          i.time_utc = n;
        }
        this.tz = i;
      }
      offset_utc(e) {
        return n.offset(this.tz.time_utc, this.tz.offset, e);
      }
      offset_loc(e) {
        return n.offset(this.tz.time, this.tz.offset, e);
      }
      name() {
        return this._name;
      }
      is_valid() {
        return !this._invalid;
      }
      correction_loc(e) {
        const t = this.tz.time;
        const i = this.tz.offset;
        const s = re(t, e);
        if (s < 1) {
          return 0;
        }
        const o = i[s] - i[s - 1];
        if (o > 0) {
          if (e - t[s - 1] <= o) {
            return o;
          }
        }
        return 0;
      }
      static offset(e, t, i) {
        const s = re(e, i);
        if (s === -1) {
          return 0;
        } else {
          return t[s];
        }
      }
    }
    const r = 1;
    const a = 2;
    const l = 3;
    const c = 4;
    const h = 5;
    const d = 6;
    const u = 7;
    const _ = r;
    const p = u;
    const m = 0;
    const g = 11;
    const f = 1;
    const y = 2;
    const v = 3;
    const S = 5;
    const b = 6;
    const w = 7;
    const C = 11;
    const P = 12;
    const T = 13;
    const x = 1440;
    const I = 10080;
    const M = 86400000;
    function A(e) {
      return e.getUTCFullYear();
    }
    function L(e) {
      return e.getUTCMonth();
    }
    function k(e) {
      return e.getUTCHours();
    }
    function D(e) {
      return e.getUTCMinutes();
    }
    function E(e) {
      return e.getUTCDate();
    }
    function B(e) {
      return e.getUTCDay() + 1;
    }
    function V(e) {
      const t = e.getUTCMonth();
      let i = o[t];
      if (t > m + 1 && $(e.getUTCFullYear())) {
        i += 1;
      }
      return i + e.getUTCDate();
    }
    function R(e) {
      return k(e) * 60 + D(e);
    }
    function N(e) {
      return R(e);
    }
    function O(e, t, i, s, o, n) {
      e.setUTCHours(t);
      e.setUTCMinutes(i);
      e.setUTCSeconds(s);
      e.setUTCMilliseconds(o);
      if (n !== undefined) {
        (function (e, t) {
          const i = e.getTime();
          const s = t.correction_loc(i);
          e.setTime(i + s);
        })(e, n);
      }
    }
    function F(e, t, i) {
      const s = e.offset_utc(t.getTime());
      const o = j(t);
      H(o, i);
      const n = e.offset_utc(o.getTime());
      o.setTime(o.getTime() + s - n);
      return o;
    }
    function W(e, t, i) {
      let s = t;
      for (let t = Math.abs(i); t > 0; t--) {
        s = F(e, s, G(s) * Math.sign(i));
      }
      return s;
    }
    function H(e, t) {
      e.setTime(e.getTime() + t * M);
    }
    function z(e, t) {
      e.setTime(e.getTime() + t * 60 * 1000);
    }
    function U(e, t) {
      const i = 86400;
      const s = t % i < 0 ? -1 : 0;
      const o = Math.trunc(t / i) + s;
      const n = t - o * i;
      const r = Math.trunc(n / 3600);
      const a = Math.trunc(n % 3600 / 60);
      O(e, r, a, n - r * 3600 - a * 60, 0);
      H(e, o);
    }
    function j(e) {
      return new Date(e.getTime());
    }
    function G(e) {
      return q(e.getUTCFullYear());
    }
    function q(e) {
      if ($(e)) {
        return 366;
      } else {
        return 365;
      }
    }
    function $(e) {
      return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);
    }
    function K(e, t) {
      switch (t) {
        case f:
          return A(e);
        case y:
          return L(e);
        case S:
          return E(e);
        case v:
          return function (e) {
            const t = new Date(Date.UTC(e.getUTCFullYear(), 0, 1)).getUTCDay();
            const i = t === 0 ? 1 : 8 - t;
            const s = V(e) - i;
            return Math.ceil(s / 7) + 1;
          }(e);
        case w:
          return B(e);
        case C:
          return k(e);
        case P:
          return D(e);
        case b:
          return V(e);
        case T:
          return function (e) {
            return e.getUTCSeconds();
          }(e);
        default:
          return e.getTime();
      }
    }
    function Y(e) {
      return e * 1000;
    }
    function Z(e, t) {
      return le(e) - le(t);
    }
    function X(e, t) {
      return new Date(J(e, t));
    }
    function J(e, t) {
      return t + e.offset_utc(t);
    }
    function Q(e, t, i, s, o, n, r) {
      const a = new Date(Date.UTC(t, i, s, o || 0, n || 0, r || 0));
      const l = e.offset_utc(+a);
      return new Date(a.valueOf() - l);
    }
    function ee(e, t) {
      return new Date(t + e.offset_utc(t));
    }
    function te(e, t, i, s = 0, o = 0, n = 0) {
      return new Date(Date.UTC(e, t, i, s, o, n));
    }
    function ie(e, t, i) {
      let s = t.getTime();
      if (i) {
        s += e.correction_loc(s);
      }
      return s - e.offset_loc(s);
    }
    function se(e) {
      return new n(e);
    }
    let oe;
    function ne(e) {
      oe = e;
    }
    function re(e, t) {
      const i = e.length;
      if (i === 0) {
        return -1;
      }
      if (isNaN(t)) {
        throw Error("Key is NaN");
      }
      let s = 0;
      let o = i - 1;
      let n = ae((s + o) / 2);
      while (true) {
        if (e[n] > t) {
          o = n - 1;
          if (o < s) {
            return n;
          }
        } else {
          s = n + 1;
          if (o < s) {
            if (n < i - 1) {
              return n + 1;
            } else {
              return -1;
            }
          }
        }
        n = ae((s + o) / 2);
      }
    }
    function ae(e) {
      return e | 0;
    }
    function le(e) {
      if (e < 0) {
        return ae(e / 1000) - (e % 1000 != 0 ? 1 : 0);
      } else {
        return ae(e / 1000);
      }
    }
  },
  51056: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      LINESTYLE_DASHED: () => n,
      LINESTYLE_DOTTED: () => o,
      LINESTYLE_LARGE_DASHED: () => r,
      LINESTYLE_SMALL_DASHED: () => l,
      LINESTYLE_SOLID: () => s,
      LINESTYLE_SPARSE_DOTTED: () => a
    });
    const s = 0;
    const o = 1;
    const n = 2;
    const r = 3;
    const a = 4;
    const l = 5;
  },
  5201: (e, t, i) => {
    "use strict";

    i.d(t, {
      CircularCacheBuffer: () => r
    });
    var s;
    var o = i(50151);
    function n(e) {
      const {
        prevItem: t,
        nextItem: i
      } = e;
      if (t !== null) {
        t.nextItem = i;
      }
      if (i !== null) {
        i.prevItem = t;
      }
    }
    (function (e) {
      e[e.CapacityFactor = 1.3] = "CapacityFactor";
    })(s ||= {});
    class r {
      constructor(e = 0, t = 1.3) {
        this._cache = new Map();
        this._lastItem = null;
        this._firstItem = null;
        this._size = e;
        this._sizeLimited = e > 0;
        this._capacityFactor = t;
      }
      set(e, t) {
        const i = {
          key: e,
          value: t,
          prevItem: this._lastItem,
          nextItem: null
        };
        if (this._lastItem !== null) {
          this._lastItem.nextItem = i;
        }
        const s = this._cache.get(e);
        if (s !== undefined) {
          n(s);
          if (s === this._firstItem) {
            this._firstItem = s.nextItem;
          }
        }
        this._cache.set(e, i);
        this._lastItem = i;
        if (this._firstItem === null) {
          this._firstItem = i;
        }
        if (this._sizeLimited && this._cache.size > this._size * this._capacityFactor) {
          this._removeExtraItems();
        }
        return this;
      }
      has(e) {
        return this._cache.has(e);
      }
      get(e) {
        const t = this._cache.get(e);
        if (t === undefined) {
          return t;
        }
        if (t === this._firstItem) {
          this._firstItem = t.nextItem ?? t;
        }
        if (t !== this._lastItem) {
          n(t);
          const e = (0, o.ensureNotNull)(this._lastItem);
          e.nextItem = t;
          t.prevItem = e;
          t.nextItem = null;
          this._lastItem = t;
        }
        return t.value;
      }
      clear() {
        this._cache.clear();
        this._firstItem = null;
        this._lastItem = null;
      }
      delete(e) {
        const t = this._cache.get(e);
        if (t !== undefined) {
          n(t);
          if (t === this._lastItem) {
            this._lastItem = t.prevItem;
          }
          if (t === this._firstItem) {
            this._firstItem = t.nextItem;
          }
        }
        return this._cache.delete(e);
      }
      *entries() {
        if (this._firstItem !== null) {
          for (let e = this._firstItem; e !== null; e = e.nextItem) {
            yield [e.key, e.value];
          }
        }
      }
      state() {
        const e = [];
        for (const [t, i] of this.entries()) {
          e.push([t, i]);
        }
        return e;
      }
      restoreState(e) {
        for (const t of e) {
          this.set(t[0], t[1]);
        }
      }
      _removeExtraItems() {
        const e = this._cache.size - this._size;
        let t = (0, o.ensureNotNull)(this._firstItem);
        for (let i = 0; i < e; i += 1) {
          this._cache.delete(t.key);
          t = (0, o.ensureNotNull)(t.nextItem);
        }
        t.prevItem = null;
        this._firstItem = t;
      }
    }
  },
  88960: (e, t, i) => {
    "use strict";

    i.d(t, {
      accumulate: () => a,
      combine: () => r,
      combineWithFilteredUpdate: () => n
    });
    var s = i(64147);
    function o(e, t, ...i) {
      let o = null;
      const n = (...t) => e(...t.map(e => e.value()), o?.value());
      const r = o = new s.WatchedValue(n(...i));
      const a = () => {
        if (t(...i.map(e => e.value()))) {
          r.setValue(n(...i));
        }
      };
      const l = i.map(e => e.spawn());
      for (const e of l) {
        e.subscribe(a);
      }
      return r.readonly().spawn(() => {
        l.forEach(e => e.destroy());
        i.forEach(e => e.release());
      });
    }
    function n(e, t, ...i) {
      return o(e, t, ...i);
    }
    function r(e, ...t) {
      return o(e, () => true, ...t);
    }
    function a(e, t, i) {
      const o = (t, i) => {
        const s = t.map(e => e.value());
        return e(s, i);
      };
      const n = new s.WatchedValue(o(t.value(), i?.value()));
      const r = t.spawn();
      let a = [];
      const l = i?.spawn() ?? new s.WatchedValue(undefined);
      const c = () => {
        n.setValue(o(a, l.value()));
      };
      const h = e => {
        a.forEach(e => e.destroy());
        a = e.map(e => e.spawn());
        a.forEach(e => {
          e.subscribe(c);
        });
        c();
      };
      h(r.value());
      r.subscribe(h);
      l.subscribe(c);
      return n.readonly().spawn(() => {
        a.forEach(e => e.destroy());
        r.destroy();
        l.destroy();
        t.release();
      });
    }
  },
  63950: (e, t, i) => {
    "use strict";

    i.d(t, {
      availableTimezones: () => l,
      timezoneIsAvailable: () => u,
      timezoneIsSupported: () => _,
      timezoneTitle: () => p,
      updateAvailableTimezones: () => d
    });
    var s = i(82112);
    var o = i(11542);
    const n = [{
      id: "Etc/UTC",
      get title() {
        return o.t(null, undefined, i(1833));
      }
    }, {
      id: "exchange",
      get title() {
        return o.t(null, undefined, i(86905));
      }
    }];
    const r = [{
      id: "Africa/Cairo",
      get title() {
        return o.t(null, undefined, i(65736));
      },
      offset: 0
    }, {
      id: "Africa/Casablanca",
      get title() {
        return o.t(null, undefined, i(70409));
      },
      offset: 0
    }, {
      id: "Africa/Johannesburg",
      get title() {
        return o.t(null, undefined, i(39585));
      },
      offset: 0
    }, {
      id: "Africa/Lagos",
      get title() {
        return o.t(null, undefined, i(19931));
      },
      offset: 0
    }, {
      id: "Africa/Nairobi",
      get title() {
        return o.t(null, undefined, i(40977));
      },
      offset: 0
    }, {
      id: "Africa/Tunis",
      get title() {
        return o.t(null, undefined, i(21007));
      },
      offset: 0
    }, {
      id: "America/Anchorage",
      get title() {
        return o.t(null, undefined, i(42630));
      },
      offset: 0
    }, {
      id: "America/Argentina/Buenos_Aires",
      get title() {
        return o.t(null, undefined, i(25282));
      },
      offset: 0
    }, {
      id: "America/Bogota",
      get title() {
        return o.t(null, undefined, i(73905));
      },
      offset: 0
    }, {
      id: "America/Caracas",
      get title() {
        return o.t(null, undefined, i(30948));
      },
      offset: 0
    }, {
      id: "America/Chicago",
      get title() {
        return o.t(null, undefined, i(72452));
      },
      offset: 0
    }, {
      id: "America/El_Salvador",
      get title() {
        return o.t(null, undefined, i(55502));
      },
      offset: 0
    }, {
      id: "America/Juneau",
      get title() {
        return o.t(null, undefined, i(67560));
      },
      offset: 0
    }, {
      id: "America/Lima",
      get title() {
        return o.t(null, undefined, i(59444));
      },
      offset: 0
    }, {
      id: "America/Los_Angeles",
      get title() {
        return o.t(null, undefined, i(28733));
      },
      offset: 0
    }, {
      id: "America/Mexico_City",
      get title() {
        return o.t(null, undefined, i(73332));
      },
      offset: 0
    }, {
      id: "America/New_York",
      get title() {
        return o.t(null, undefined, i(40544));
      },
      offset: 0
    }, {
      id: "America/Phoenix",
      get title() {
        return o.t(null, undefined, i(14055));
      },
      offset: 0
    }, {
      id: "America/Santiago",
      get title() {
        return o.t(null, undefined, i(30231));
      },
      offset: 0
    }, {
      id: "America/Sao_Paulo",
      get title() {
        return o.t(null, undefined, i(91912));
      },
      offset: 0
    }, {
      id: "America/Toronto",
      get title() {
        return o.t(null, undefined, i(10095));
      },
      offset: 0
    }, {
      id: "America/Vancouver",
      get title() {
        return o.t(null, undefined, i(32838));
      },
      offset: 0
    }, {
      id: "US/Mountain",
      get title() {
        return o.t(null, undefined, i(27358));
      },
      offset: 0
    }, {
      id: "Asia/Almaty",
      get title() {
        return o.t(null, undefined, i(98128));
      },
      offset: 0
    }, {
      id: "Asia/Ashkhabad",
      get title() {
        return o.t(null, undefined, i(63627));
      },
      offset: 0
    }, {
      id: "Asia/Bahrain",
      get title() {
        return o.t(null, undefined, i(90594));
      },
      offset: 0
    }, {
      id: "Asia/Bangkok",
      get title() {
        return o.t(null, undefined, i(47045));
      },
      offset: 0
    }, {
      id: "Asia/Chongqing",
      get title() {
        return o.t(null, undefined, i(50349));
      },
      offset: 0
    }, {
      id: "Asia/Colombo",
      get title() {
        return o.t(null, undefined, i(10871));
      },
      offset: 0
    }, {
      id: "Asia/Dhaka",
      get title() {
        return o.t(null, undefined, i(24959));
      },
      offset: 0
    }, {
      id: "Asia/Dubai",
      get title() {
        return o.t(null, undefined, i(23650));
      },
      offset: 0
    }, {
      id: "Asia/Ho_Chi_Minh",
      get title() {
        return o.t(null, undefined, i(34491));
      },
      offset: 0
    }, {
      id: "Asia/Hong_Kong",
      get title() {
        return o.t(null, undefined, i(48861));
      },
      offset: 0
    }, {
      id: "Asia/Jakarta",
      get title() {
        return o.t(null, undefined, i(14995));
      },
      offset: 0
    }, {
      id: "Asia/Jerusalem",
      get title() {
        return o.t(null, undefined, i(36057));
      },
      offset: 0
    }, {
      id: "Asia/Karachi",
      get title() {
        return o.t(null, undefined, i(70913));
      },
      offset: 0
    }, {
      id: "Asia/Kathmandu",
      get title() {
        return o.t(null, undefined, i(54533));
      },
      offset: 0
    }, {
      id: "Asia/Kolkata",
      get title() {
        return o.t(null, undefined, i(31561));
      },
      offset: 0
    }, {
      id: "Asia/Kuala_Lumpur",
      get title() {
        return o.t(null, undefined, i(38561));
      },
      offset: 0
    }, {
      id: "Asia/Kuwait",
      get title() {
        return o.t(null, undefined, i(76614));
      },
      offset: 0
    }, {
      id: "Asia/Manila",
      get title() {
        return o.t(null, undefined, i(48991));
      },
      offset: 0
    }, {
      id: "Asia/Muscat",
      get title() {
        return o.t(null, undefined, i(9865));
      },
      offset: 0
    }, {
      id: "Asia/Nicosia",
      get title() {
        return o.t(null, undefined, i(94600));
      },
      offset: 0
    }, {
      id: "Asia/Qatar",
      get title() {
        return o.t(null, undefined, i(28756));
      },
      offset: 0
    }, {
      id: "Asia/Riyadh",
      get title() {
        return o.t(null, undefined, i(37974));
      },
      offset: 0
    }, {
      id: "Asia/Seoul",
      get title() {
        return o.t(null, undefined, i(26820));
      },
      offset: 0
    }, {
      id: "Asia/Shanghai",
      get title() {
        return o.t(null, undefined, i(1852));
      },
      offset: 0
    }, {
      id: "Asia/Singapore",
      get title() {
        return o.t(null, undefined, i(77377));
      },
      offset: 0
    }, {
      id: "Asia/Taipei",
      get title() {
        return o.t(null, undefined, i(11034));
      },
      offset: 0
    }, {
      id: "Asia/Tehran",
      get title() {
        return o.t(null, undefined, i(6686));
      },
      offset: 0
    }, {
      id: "Asia/Tokyo",
      get title() {
        return o.t(null, undefined, i(69122));
      },
      offset: 0
    }, {
      id: "Asia/Yangon",
      get title() {
        return o.t(null, undefined, i(53168));
      },
      offset: 0
    }, {
      id: "Atlantic/Azores",
      get title() {
        return o.t(null, undefined, i(87580));
      },
      offset: 0
    }, {
      id: "Atlantic/Reykjavik",
      get title() {
        return o.t(null, undefined, i(13386));
      },
      offset: 0
    }, {
      id: "Australia/Adelaide",
      get title() {
        return o.t(null, undefined, i(426));
      },
      offset: 0
    }, {
      id: "Australia/Brisbane",
      get title() {
        return o.t(null, undefined, i(79336));
      },
      offset: 0
    }, {
      id: "Australia/Perth",
      get title() {
        return o.t(null, undefined, i(24436));
      },
      offset: 0
    }, {
      id: "Australia/Sydney",
      get title() {
        return o.t(null, undefined, i(31622));
      },
      offset: 0
    }, {
      id: "Europe/Amsterdam",
      get title() {
        return o.t(null, undefined, i(36485));
      },
      offset: 0
    }, {
      id: "Europe/Athens",
      get title() {
        return o.t(null, undefined, i(73702));
      },
      offset: 0
    }, {
      id: "Europe/Belgrade",
      get title() {
        return o.t(null, undefined, i(71797));
      },
      offset: 0
    }, {
      id: "Europe/Berlin",
      get title() {
        return o.t(null, undefined, i(64313));
      },
      offset: 0
    }, {
      id: "Europe/Bratislava",
      get title() {
        return o.t(null, undefined, i(70876));
      },
      offset: 0
    }, {
      id: "Europe/Brussels",
      get title() {
        return o.t(null, undefined, i(91499));
      },
      offset: 0
    }, {
      id: "Europe/Bucharest",
      get title() {
        return o.t(null, undefined, i(33672));
      },
      offset: 0
    }, {
      id: "Europe/Budapest",
      get title() {
        return o.t(null, undefined, i(20313));
      },
      offset: 0
    }, {
      id: "Europe/Copenhagen",
      get title() {
        return o.t(null, undefined, i(38917));
      },
      offset: 0
    }, {
      id: "Europe/Dublin",
      get title() {
        return o.t(null, undefined, i(79716));
      },
      offset: 0
    }, {
      id: "Europe/Helsinki",
      get title() {
        return o.t(null, undefined, i(48203));
      },
      offset: 0
    }, {
      id: "Europe/Istanbul",
      get title() {
        return o.t(null, undefined, i(78326));
      },
      offset: 0
    }, {
      id: "Europe/Lisbon",
      get title() {
        return o.t(null, undefined, i(53375));
      },
      offset: 0
    }, {
      id: "Europe/London",
      get title() {
        return o.t(null, undefined, i(19439));
      },
      offset: 0
    }, {
      id: "Europe/Luxembourg",
      get title() {
        return o.t(null, undefined, i(81038));
      },
      offset: 0
    }, {
      id: "Europe/Madrid",
      get title() {
        return o.t(null, undefined, i(52066));
      },
      offset: 0
    }, {
      id: "Europe/Malta",
      get title() {
        return o.t(null, undefined, i(38365));
      },
      offset: 0
    }, {
      id: "Europe/Moscow",
      get title() {
        return o.t(null, undefined, i(64039));
      },
      offset: 0
    }, {
      id: "Europe/Oslo",
      get title() {
        return o.t(null, undefined, i(75722));
      },
      offset: 0
    }, {
      id: "Europe/Paris",
      get title() {
        return o.t(null, undefined, i(61879));
      },
      offset: 0
    }, {
      id: "Europe/Prague",
      get title() {
        return o.t(null, undefined, i(81248));
      },
      offset: 0
    }, {
      id: "Europe/Riga",
      get title() {
        return o.t(null, undefined, i(94022));
      },
      offset: 0
    }, {
      id: "Europe/Rome",
      get title() {
        return o.t(null, undefined, i(52961));
      },
      offset: 0
    }, {
      id: "Europe/Stockholm",
      get title() {
        return o.t(null, undefined, i(86716));
      },
      offset: 0
    }, {
      id: "Europe/Tallinn",
      get title() {
        return o.t(null, undefined, i(79995));
      },
      offset: 0
    }, {
      id: "Europe/Vienna",
      get title() {
        return o.t(null, undefined, i(23160));
      },
      offset: 0
    }, {
      id: "Europe/Vilnius",
      get title() {
        return o.t(null, undefined, i(60534));
      },
      offset: 0
    }, {
      id: "Europe/Warsaw",
      get title() {
        return o.t(null, undefined, i(5959));
      },
      offset: 0
    }, {
      id: "Europe/Zurich",
      get title() {
        return o.t(null, undefined, i(62859));
      },
      offset: 0
    }, {
      id: "Pacific/Auckland",
      get title() {
        return o.t(null, undefined, i(66103));
      },
      offset: 0
    }, {
      id: "Pacific/Chatham",
      get title() {
        return o.t(null, undefined, i(36549));
      },
      offset: 0
    }, {
      id: "Pacific/Fakaofo",
      get title() {
        return o.t(null, undefined, i(98549));
      },
      offset: 0
    }, {
      id: "Pacific/Honolulu",
      get title() {
        return o.t(null, undefined, i(79668));
      },
      offset: 0
    }, {
      id: "Pacific/Norfolk",
      get title() {
        return o.t(null, undefined, i(67891));
      },
      offset: 0
    }];
    function a(e, t, i) {
      const o = function (e) {
        return e.map(e => {
          const {
            id: t
          } = e;
          const {
            string: i,
            offset: o
          } = (0, s.parseTzOffset)(t);
          return {
            id: t,
            offset: o,
            get title() {
              return `(${i}) ${e.title}`;
            }
          };
        });
      }(e);
      const n = i.filter(({
        alias: e
      }) => Boolean(e)).map(e => {
        const {
          alias: t,
          id: i
        } = e;
        const {
          string: o,
          offset: n
        } = (0, s.parseTzOffset)(t);
        return {
          id: i,
          offset: n,
          get title() {
            return `(${o}) ${e.title}`;
          },
          alias: t
        };
      });
      const r = function (e) {
        return e.sort((e, t) => {
          const i = e.offset - t.offset;
          if (i !== 0) {
            return i;
          } else {
            return e.title.localeCompare(t.title);
          }
        });
      }(o.concat(n));
      return t.concat(r);
    }
    const l = a(r, n, []);
    const c = new Map();
    l.forEach(e => {
      c.set(e.id, true);
    });
    const h = new Map();
    n.concat(r).forEach(e => {
      h.set(e.id, true);
    });
    const d = e => {
      l.splice(0, l.length, ...a(r, n, e));
      l.forEach(e => {
        c.set(e.id, true);
      });
    };
    function u(e) {
      return c.has(e);
    }
    function _(e) {
      return h.get(e) || false;
    }
    function p(e) {
      for (const {
        id: t,
        title: i
      } of r) {
        if (t === e) {
          return `${i} (${(0, s.parseTzOffset)(e).string})`;
        }
      }
      for (const {
        id: t,
        title: i
      } of l) {
        if (t === e) {
          return `${i}`;
        }
      }
      return e;
    }
  },
  52033: (e, t, i) => {
    "use strict";

    i.d(t, {
      Delegate: () => n
    });
    const s = (0, i(9343).getLogger)("Common.Delegate");
    function o(e) {
      return !e.singleShot;
    }
    class n {
      constructor() {
        this.fire = this._fireImpl.bind(this);
        this._listeners = [];
      }
      subscribe(e, t, i) {
        this._listeners.push({
          object: e,
          member: t,
          singleShot: !!i,
          skip: false
        });
      }
      unsubscribe(e, t) {
        for (let i = 0; i < this._listeners.length; ++i) {
          const s = this._listeners[i];
          if (s.object === e && s.member === t) {
            s.skip = true;
            this._listeners.splice(i, 1);
            break;
          }
        }
      }
      unsubscribeAll(e) {
        for (let t = this._listeners.length - 1; t >= 0; --t) {
          const i = this._listeners[t];
          if (i.object === e) {
            i.skip = true;
            this._listeners.splice(t, 1);
          }
        }
      }
      destroy() {
        this._listeners = [];
      }
      _fireImpl(...e) {
        const t = this._listeners;
        this._listeners = this._listeners.filter(o);
        const i = t.length;
        for (let o = 0; o < i; ++o) {
          const i = t[o];
          if (!i.skip) {
            try {
              i.member.apply(i.object || null, e);
            } catch (e) {
              s.logError(`${e && (e.stack || e.message)}`);
            }
          }
        }
      }
    }
  },
  30699: (e, t, i) => {
    "use strict";

    var s;
    var o;
    i.d(t, {
      HorizontalAlign: () => s,
      VerticalAlign: () => o
    });
    (function (e) {
      e.Left = "left";
      e.Right = "right";
      e.Center = "center";
    })(s ||= {});
    (function (e) {
      e.Top = "top";
      e.Bottom = "bottom";
      e.Middle = "middle";
    })(o ||= {});
  },
  82236: (e, t, i) => {
    "use strict";

    i.d(t, {
      formatStudyError: () => n,
      triesTranslateError: () => o
    });
    var s = i(11542);
    function o(e) {
      return r.get(e) || e;
    }
    function n(e) {
      return e.format({
        boldHighlightStart: "<b>",
        boldHighlightEnd: "</b>"
      });
    }
    const r = new Map([["You cannot see this pivot timeframe on this resolution", s.t(null, undefined, i(25059))], ["The data vendor doesn't provide volume data for this symbol.", s.t(null, undefined, i(81657))], ["Histogram is too large, please increase \"Row Size\" input.", s.t(null, undefined, i(72819))], ["Histogram is too large, please reduce 'Row Size' input.", s.t(null, undefined, i(66751))], ["Histogram is too large, please increase \"Ticks Per Row\" input.", s.t(null, undefined, i(94966))], ["This script is invite-only. To request access, please contact its author.", s.t(null, undefined, i(76989))], ["Volume Profile indicator available only on our upgraded plans.", s.t(null, undefined, i(39903))], ["VOLUME_BIST_MIXED", s.t(null, undefined, i(69156))], ["Runtime error", s.t(null, undefined, i(60630))], ["Access error", s.t(null, undefined, i(77401))], ["User-defined error", s.t(null, undefined, i(8580))], ["Compilation error", s.t(null, undefined, i(12086))], ["There's no data for your selected period and chart timeframe.", s.t(null, undefined, i(43716))], ["The request took too long to process. Ensure you have a stable internet connection. If the issue persists, try decreasing the length of the requested time interval.", s.t(null, undefined, i(99274))], ["Unexpected error in Deep Backtesting mode. Contact support for more information.", s.t(null, undefined, i(56815))], ["check study unexpected error", s.t(null, undefined, i(83524))]]);
  },
  19938: (e, t, i) => {
    "use strict";

    i.d(t, {
      getImage: () => n
    });
    const s = new Map();
    function o(e) {
      e.crossOrigin = "anonymous";
    }
    function n(e, t, i = o) {
      let n = s.get(e);
      if (n === undefined) {
        n = new Promise((e, s) => {
          const o = new Image();
          o.onload = () => {
            e(o);
            o.onload = null;
            o.onerror = null;
          };
          o.onerror = () => {
            s();
            o.onload = null;
            o.onerror = null;
          };
          i(o);
          o.src = t;
        });
        s.set(e, n);
      }
      return n;
    }
  },
  34776: (e, t, i) => {
    "use strict";

    function s(e) {
      const t = Object.create(e);
      t.release = () => { };
      t.ownership = () => t;
      return t;
    }
    function o(e) {
      const t = e;
      t.release = () => t.destroy();
      t.ownership = () => t;
      return t;
    }
    i.d(t, {
      ownership: () => o,
      weakReference: () => s
    });
  },
  9859: (e, t, i) => {
    "use strict";

    function s(e, t, i) {
      return Math.min(Math.max(e, t), i);
    }
    function o(e) {
      if (e < 0) {
        return -1;
      } else if (e > 0) {
        return 1;
      } else {
        return 0;
      }
    }
    function n(e) {
      if (e < 0) {
        return false;
      }
      if (e > 1000000000000000000) {
        return true;
      }
      for (let t = e; t > 1; t /= 10) {
        if (t % 10 != 0) {
          return false;
        }
      }
      return true;
    }
    function r(e, t, i) {
      return t - e <= i;
    }
    function a(e, t, i) {
      return Math.abs(e - t) < i;
    }
    function l(e) {
      if (e <= 0) {
        return NaN;
      } else {
        return Math.log(e) / Math.log(10);
      }
    }
    function c(e, t) {
      if (e < t) {
        return -1;
      } else if (e > t) {
        return 1;
      } else {
        return 0;
      }
    }
    function h(e, t = c) {
      if (e.length < 1) {
        throw Error("array is empty");
      }
      let i = e[0];
      for (let s = 0; s < e.length; ++s) {
        if (t(e[s], i) > 0) {
          i = e[s];
        }
      }
      return i;
    }
    function d(e) {
      const t = Math.ceil(e);
      if (t % 2 != 0) {
        return t - 1;
      } else {
        return t;
      }
    }
    function u(e) {
      if (e > 0) {
        return Math.floor(e);
      } else {
        return Math.ceil(e);
      }
    }
    i.d(t, {
      ceiledEven: () => d,
      clamp: () => s,
      equal: () => a,
      greaterOrEqual: () => r,
      isBaseDecimal: () => n,
      log10: () => l,
      max: () => h,
      sign: () => o,
      toInt: () => u
    });
  },
  82112: (e, t, i) => {
    "use strict";

    i.d(t, {
      parseTzOffset: () => o
    });
    var s = i(2740);
    function o(e, t = Date.now()) {
      const i = (0, s.get_timezone)(e).offset_utc(t);
      let o = "";
      const n = i / 1000 / 60 / 60;
      if (n % 1) {
        o = ":" + Math.round(Math.abs(n % 1 * 60)).toString().padStart(2, "0");
      }
      let r = "";
      r = n > 0 ? "+" + (n - n % 1) + o : n === 0 ? "" : String(n - n % 1 + o);
      return {
        offset: i,
        string: "UTC" + r
      };
    }
  },
  97085: (e, t, i) => {
    "use strict";

    function s(e) {
      return typeof e == "number" && isFinite(e);
    }
    function o(e) {
      if (!e || typeof e != "object") {
        return e;
      }
      let t;
      t = Array.isArray(e) ? [] : {};
      for (const i in e) {
        if (e.hasOwnProperty(i)) {
          const s = e[i];
          t[i] = s && typeof s == "object" ? o(s) : s;
        }
      }
      return t;
    }
    function n(e, t) {
      for (const i in t) {
        if (t[i] !== null && typeof t[i] == "object" && e.hasOwnProperty(i)) {
          n(e[i], t[i]);
        } else {
          e[i] = t[i];
        }
      }
      return e;
    }
    function r(e) {
      return typeof e == "object" && e !== null;
    }
    function a(e) {
      return e != null && (e.constructor === Function || Object.prototype.toString.call(e) === "[object Function]");
    }
    function l(e, t, i = "") {
      if (e === t) {
        return [true, i];
      }
      if (a(e)) {
        e = undefined;
      }
      if (a(t)) {
        t = undefined;
      }
      if (e == null || t == null) {
        return [e === t, i];
      }
      if (typeof e != "object" && typeof t != "object") {
        return [e === t, i];
      }
      if (Array.isArray(e) && Array.isArray(t)) {
        const s = e.length;
        if (s !== t.length) {
          return [false, i];
        }
        for (let o = 0; o < s; o++) {
          const s = l(e[o], t[o], i + "[" + o + "]");
          if (!s[0]) {
            return s;
          }
        }
        return [true, i];
      }
      if (Array.isArray(e) || Array.isArray(t)) {
        return [false, i];
      }
      if (Object.keys(e).length !== Object.keys(t).length) {
        return [false, i];
      }
      for (const s in e) {
        const o = l(e[s], t[s], i + "[" + s + "]");
        if (!o[0]) {
          return o;
        }
      }
      return [true, i];
    }
    i.r(t);
    i.d(t, {
      clone: () => o,
      deepEquals: () => l,
      isFunction: () => a,
      isNumber: () => s,
      isObject: () => r,
      merge: () => n
    });
  },
  13665: e => {
    "use strict";

    var t = [{
      d: "E-Mini S&P 500",
      t: "ES"
    }, {
      d: "E-Mini Nasdaq 100",
      t: "NQ"
    }, {
      d: "Gold",
      t: "GC"
    }, {
      d: "Silver",
      t: "SI"
    }, {
      d: "Crude Oil WTI",
      t: "CL"
    }, {
      d: "Natural Gas",
      t: "NG"
    }, {
      d: "Australian Dollar",
      t: "6A"
    }, {
      d: "Australian Dollar (Floor)",
      t: "AD"
    }, {
      d: "Euro FX",
      t: "6E"
    }, {
      d: "Euro FX (Floor)",
      t: "EC"
    }, {
      d: "Corn",
      t: "ZC"
    }, {
      d: "Corn (Floor)",
      t: "C"
    }, {
      d: "Eurodollar",
      t: "GE"
    }, {
      d: "Eurodollar (Floor)",
      t: "ED"
    }];
    var i = function () {
      var e = [{
        pattern: "(",
        ctor: n
      }, {
        pattern: ")",
        ctor: r
      }, {
        pattern: "+",
        ctor: l
      }, {
        pattern: "-",
        ctor: c
      }, {
        pattern: "*",
        ctor: h
      }, {
        pattern: "/",
        ctor: d
      }, {
        pattern: "^",
        ctor: u
      }, {
        pattern: /\d+(?:\.\d*|(?![a-zA-Z0-9_!:.&]))|\.\d+/,
        ctor: g
      }, {
        pattern: /\./,
        ctor: v
      }, {
        pattern: /[a-zA-Z0-9_\u0370-\u1FFF_\u2E80-\uFFFF^][a-zA-Z0-9_\u0020\u0370-\u1FFF_\u2E80-\uFFFF_!:.&]*|'.+?'/,
        ctor: m
      }, {
        pattern: /'[^']*/,
        ctor: y
      }, {
        pattern: /[\0-\x20\s]+/,
        ctor: o
      }];
      function i(e, t) {
        function i() { }
        i.prototype = t.prototype;
        e.prototype = new i();
        return e;
      }
      function s() { }
      function o(e) {
        this.value = e;
      }
      function n() { }
      function r() { }
      function a() { }
      function l() { }
      function c() { }
      function h() { }
      function d() { }
      function u() { }
      s.prototype.toString = function () {
        return this.value;
      };
      i(o, s);
      i(n, s);
      n.prototype.value = "(";
      i(r, s);
      r.prototype.value = ")";
      i(a, s);
      i(l, a);
      l.prototype.value = "+";
      l.prototype.precedence = 0;
      l.prototype.commutative = true;
      i(c, a);
      c.prototype.value = "-";
      c.prototype.precedence = 0;
      c.prototype.commutative = false;
      i(h, a);
      h.prototype.value = "*";
      h.prototype.precedence = 1;
      h.prototype.commutative = true;
      i(d, a);
      d.prototype.value = "/";
      d.prototype.precedence = 1;
      d.prototype.commutative = false;
      i(u, a);
      u.prototype.value = "^";
      u.prototype.precedence = 2;
      u.prototype.commutative = false;
      var _ = /^'?(?:([A-Z0-9_]+):)?(.*?)'?$/i;
      var p = /[+\-/*]/;
      function m(e) {
        this.value = e;
      }
      function g(e) {
        this.value = e;
      }
      function f(e) {
        this.value = e;
      }
      function y() {
        m.apply(this, arguments);
      }
      function v() {
        g.apply(this, arguments);
      }
      i(m, s);
      m.prototype.toString = function () {
        if (this.hasOwnProperty("_ticker")) {
          var e = p.test(this._ticker) ? "'" : "";
          return e + (this._exchange ? this._exchange + ":" : "") + this._ticker + e;
        }
        return this.value;
      };
      m.prototype.parse = function () {
        var e = _.exec(this.value);
        if (e[1]) {
          this._exchange = e[1];
        }
        this._ticker = e[2];
      };
      m.prototype.parseAsFutures = function () {
        if (!this.hasOwnProperty("_ticker")) {
          this.parse();
        }
        var e = function (e) {
          return t.some(function (t) {
            return t.t === e;
          });
        };
        for (var i = 2; i >= 1; --i) {
          var s = this._ticker.slice(0, i);
          if (e(s)) {
            this._root = s;
            this._contract = this._ticker.slice(i);
            break;
          }
        }
      };
      m.prototype.exchange = function (e) {
        if (!this.hasOwnProperty("_ticker")) {
          this.parse();
        }
        if (!(arguments.length > 0)) {
          return this._exchange;
        }
        if (e == null) {
          delete this._exchange;
        } else {
          this._exchange = e + "";
        }
      };
      m.prototype.ticker = function (e) {
        if (!this.hasOwnProperty("_ticker")) {
          this.parse();
        }
        if (!(arguments.length > 0)) {
          return this._ticker;
        }
        if (e == null) {
          delete this._ticker;
        } else {
          this._ticker = e + "";
        }
        delete this._root;
        delete this._contract;
      };
      m.prototype.root = function (e) {
        if (!this.hasOwnProperty("_root")) {
          this.parseAsFutures();
        }
        if (!(arguments.length > 0)) {
          return this._root;
        }
        if (e == null) {
          delete this._root;
        } else {
          this._root = e + "";
          if (this._root) {
            this._ticker = this._root + (this._contract || "");
          }
        }
      };
      m.prototype.contract = function (e) {
        if (!this.hasOwnProperty("_contract")) {
          this.parseAsFutures();
        }
        if (!(arguments.length > 0)) {
          return this._root;
        }
        if (e == null) {
          delete this._contract;
        } else {
          this._contract = e + "";
          if (this._root) {
            this._ticker = this._root + this._contract;
          }
        }
      };
      i(g, s);
      g.prototype.toString = function () {
        if (this.hasOwnProperty("_normalizedValue")) {
          return this._normalizedValue;
        } else {
          return this.value;
        }
      };
      g.prototype.parse = function () {
        this._normalizedValue = this.value.replace(/^0+|\.0*$/g, "").replace(/(\.\d*?)0+$/, "$1").replace(/^(\.|$)/, "0$1");
      };
      f.prototype.toString = function () {
        return this.value;
      };
      i(y, m);
      y.prototype.isIncomplete = true;
      y.prototype.incompleteSuggest = function () {
        if (this.value !== "'") {
          return String("'");
        }
      };
      i(v, g);
      v.prototype.isIncomplete = true;
      var S = new RegExp(e.map(function (e) {
        return "(" + (typeof e.pattern == "string" ? e.pattern.replace(/[\^$()[\]{}*+?|\\]/g, "\\$&") : e.pattern.source) + ")";
      }).concat(".").join("|"), "g");
      function b(t, i) {
        var s;
        var n = [];
        e: while (s = S.exec(t)) {
          for (var r = e.length; r--;) {
            if (s[r + 1]) {
              if (e[r].ctor) {
                var a = new e[r].ctor(s[r + 1]);
                a._offset = s.index;
                n.push(a);
              }
              continue e;
            }
          }
          var l = new f(s[0]);
          l._offset = s.index;
          n.push(l);
        }
        if (i && i.recover) {
          var c;
          for (r = n.length; r--;) {
            var h = n[r];
            if (h instanceof g || h instanceof m) {
              if (c !== undefined) {
                var d = new m("");
                var u = n.splice(r, c - r + 1, d);
                d.value = u.map(function (e) {
                  return e.value;
                }).join("");
              }
              c = r;
            } else if (!(h instanceof o)) {
              c = undefined;
            }
          }
        }
        return n;
      }
      function w(e) {
        var t = [];
        for (var i = 0; i < e.length; i++) {
          if (!(e[i] instanceof o)) {
            t.push(e[i]);
          }
        }
        return t;
      }
      function C(e) {
        e = w(e);
        var t;
        var i = [];
        var s = [];
        for (var o = 0; o < e.length; o++) {
          var l = e[o];
          if (l instanceof a) {
            if (s.length && s[s.length - 1].minPrecedence > l.precedence) {
              s[s.length - 1].minPrecedence = l.precedence;
            }
          } else if (l instanceof n) {
            s.push(t = {
              minPrecedence: Infinity,
              openBraceIndex: o
            });
          } else if (l instanceof r) {
            var c = e[(t = s.pop()).openBraceIndex - 1];
            var h = e[o + 1];
            if ((!(h instanceof a) || !!(h.precedence <= t.minPrecedence)) && (!(c instanceof a) || !!(c.precedence < t.minPrecedence) || c.precedence === t.minPrecedence && !!c.commutative)) {
              i.unshift(t.openBraceIndex);
              i.push(o);
              if (s.length && s[s.length - 1].minPrecedence > t.minPrecedence) {
                s[s.length - 1].minPrecedence = t.minPrecedence;
              }
            }
          }
        }
        for (o = i.length; o--;) {
          e.splice(i[o], 1);
        }
        return e;
      }
      function P(e) {
        if (typeof e != "string") {
          throw new TypeError("expression must be a string");
        }
        return (e = b(e)).filter(function (e) {
          return e instanceof m;
        }).map(function (e) {
          return e.exchange();
        }).filter(function (e) {
          return e;
        });
      }
      function T(e) {
        if ((e = P(e)).length !== 1) {
          return null;
        } else {
          return e[0];
        }
      }
      function x(e, t) {
        return (e = P(e)).some(function (e) {
          return t.includes((e || "").toUpperCase());
        });
      }
      function I(e) {
        return e.join("");
      }
      return {
        tokenize: b,
        validate: function (e) {
          return {
            currentState: "var"
          };
        },
        factorOutBraces: C,
        normalizeTokens: function (e) {
          for (var t = 0; t < e.length; t++) {
            if (e[t].parse) {
              e[t].parse();
            }
          }
          return e;
        },
        flip: function (e) {
          var t = function (e) {
            var t;
            var i = 0;
            var s = 1;
            var l = 2;
            var c = 3;
            var h = i;
            var u = 0;
            for (var _ = 0; _ < e.length; _++) {
              var p = e[_];
              if (!(p instanceof o)) {
                switch (h) {
                  case i:
                    if (!(p instanceof g) || +p.value != 1) {
                      return false;
                    }
                    h = s;
                    break;
                  case s:
                    if (h !== s || !(p instanceof d)) {
                      return false;
                    }
                    h = l;
                    t = _ + 1;
                    break;
                  case l:
                    if (p instanceof n) {
                      h = c;
                      u = 1;
                    } else if (p instanceof a) {
                      return false;
                    }
                    break;
                  case c:
                    if (p instanceof n) {
                      u++;
                    } else if (p instanceof r && --u <= 0) {
                      h = l;
                    }
                }
              }
            }
            return e.slice(t);
          }(e);
          return C(t || [new g("1"), new d(), new n()].concat(e).concat(new r()));
        },
        hasBatsSymbols: function (e) {
          return x(e, ["BATS"]);
        },
        hasEodSymbols: function (e) {
          return (e = T(e)) && e.toUpperCase().indexOf("_EOD") !== -1;
        },
        hasChxjpySymbols: function (e) {
          return x(e, ["CHXJPY"]);
        },
        hasFreeDelaySymbols: function (e) {
          return x(e, pro.getProductsByType(pro.PRODUCT_TYPES.exchange).map(function (e) {
            return e.exchange.toUpperCase() + "_DLY";
          }));
        },
        getExchange: T,
        getExchanges: P,
        isExchange: function (e, t) {
          return !!(e = T(e)) && e.substring(0, t.length) === t;
        },
        SymbolToken: m,
        IncompleteSymbolToken: y,
        NumberToken: g,
        BinaryOperatorToken: a,
        OpenBraceToken: n,
        CloseBraceToken: r,
        ticker: function (e) {
          return new m(e).ticker();
        },
        shortName: function (e) {
          if (typeof e != "string") {
            throw new TypeError("expression must be a string");
          }
          var t = C(w(b(e)));
          t.forEach(function (e) {
            if (e instanceof m) {
              e.exchange(null);
            }
          });
          return I(t);
        },
        normalize: function (e) {
          if (typeof e != "string") {
            throw new TypeError("expression must be a string");
          }
          return I(C(w(b(e))));
        }
      };
    }();
    e.exports = i;
  },
  45126: (e, t, i) => {
    "use strict";

    i.d(t, {
      TranslatedString: () => s
    });
    class s {
      constructor(e, t) {
        this._originalText = e;
        this._translatedText = t;
      }
      originalText() {
        return this._originalText;
      }
      translatedText() {
        return this._translatedText;
      }
      format(e) {
        const t = {};
        const i = {};
        for (const o of Object.keys(e)) {
          const n = e[o];
          if (n instanceof s) {
            t[o] = n.originalText();
            i[o] = n.translatedText();
          } else {
            t[o] = n.toString();
            i[o] = n.toString();
          }
        }
        const o = this._originalText.format(t);
        const n = this._translatedText.format(i);
        return new s(o, n);
      }
    }
  },
  23998: e => {
    e.exports.tzData = {
      "America/New_York": {
        time: [-2717668562, -1633298400, -1615154400, -1601848800, -1583704800, -1570399200, -1551650400, -1536530400, -1523224800, -1504476000, -1491775200, -1473026400, -1459720800, -1441576800, -1428271200, -1410127200, -1396821600, -1378677600, -1365372000, -1347228000, -1333922400, -1315173600, -1301868000, -1283724000, -1270418400, -1252274400, -1238968800, -1220824800, -1207519200, -1189375200, -1176069600, -1157320800, -1144620000, -1125871200, -1112565600, -1094421600, -1081116000, -1062972000, -1049666400, -1031522400, -1018216800, -1000072800, -986767200, -968018400, -955317600, -936568800, -923263200, -905119200, -891813600, -880236000, -769410000, -765410400, -747266400, -733960800, -715816800, -702511200, -684367200, -671061600, -652917600, -639612000, -620863200, -608162400, -589413600, -576108000, -557964000, -544658400, -526514400, -513208800, -495064800, -481759200, -463615200, -447285600, -431560800, -415836000, -400111200, -384386400, -368661600, -352936800, -337212000, -321487200, -305762400, -289432800, -273708000, -257983200, -242258400, -226533600, -210808800, -195084000, -179359200, -163634400, -147909600, -131580000, -116460000, -100130400, -84405600, -68680800, -52956000, -37231200, -21506400, -5781600, 9943200, 25668000, 41392800, 57722400, 73447200, 89172000, 104896800, 120621600, 126669600, 152071200, 162352800, 183520800, 199245600, 215575200, 230695200, 247024800, 262749600, 278474400, 294199200, 309924000, 325648800, 341373600, 357098400, 372823200, 388548000, 404877600, 419997600, 436327200, 452052000, 467776800, 483501600, 499226400, 514951200, 530676000, 544586400, 562125600, 576036000, 594180000, 607485600, 625629600, 638935200, 657079200, 670989600, 688528800, 702439200, 719978400, 733888800, 752032800, 765338400, 783482400, 796788000, 814932000, 828842400, 846381600, 860292000, 877831200, 891741600, 909280800, 923191200, 941335200, 954640800, 972784800, 986090400, 1004234400, 1018144800, 1035684000, 1049594400, 1067133600, 1081044000, 1099188000, 1112493600, 1130637600, 1143943200, 1162087200, 1173578400, 1194141600, 1205028000, 1225591200, 1236477600, 1257040800, 1268532000, 1289095200, 1299981600, 1320544800, 1331431200, 1351994400, 1362880800, 1383444000, 1394330400, 1414893600, 1425780000, 1446343200, 1457834400, 1478397600, 1489284000, 1509847200, 1520733600, 1541296800, 1552183200, 1572746400, 1583632800, 1604196000, 1615687200, 1636250400, 1647136800, 1667700000, 1678586400, 1699149600, 1710036000, 1730599200, 1741485600, 1762048800, 1772935200, 1793498400, 1804989600, 1825552800, 1836439200, 1857002400, 1867888800, 1888452000, 1899338400, 1919901600, 1930788000],
        offset: [-17762, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000]
      },
      "America/Los_Angeles": {
        time: [-2717668378, -1633298400, -1615154400, -1601848800, -1583704800, -880236000, -769420800, -765410400, -687995940, -662680800, -620866800, -608162400, -589417200, -576108000, -557967600, -544658400, -526518000, -513208800, -495068400, -481759200, -463618800, -450309600, -431564400, -418255200, -400114800, -386805600, -368665200, -355356000, -337215600, -323906400, -305766000, -292456800, -273711600, -261007200, -242262000, -226533600, -210812400, -195084000, -179362800, -163634400, -147913200, -131580000, -116463600, -100130400, -84405600, -68680800, -52956000, -37231200, -21506400, -5781600, 9943200, 25668000, 41392800, 57722400, 73447200, 89172000, 104896800, 120621600, 126669600, 152071200, 162352800, 183520800, 199245600, 215575200, 230695200, 247024800, 262749600, 278474400, 294199200, 309924000, 325648800, 341373600, 357098400, 372823200, 388548000, 404877600, 419997600, 436327200, 452052000, 467776800, 483501600, 499226400, 514951200, 530676000, 544586400, 562125600, 576036000, 594180000, 607485600, 625629600, 638935200, 657079200, 670989600, 688528800, 702439200, 719978400, 733888800, 752032800, 765338400, 783482400, 796788000, 814932000, 828842400, 846381600, 860292000, 877831200, 891741600, 909280800, 923191200, 941335200, 954640800, 972784800, 986090400, 1004234400, 1018144800, 1035684000, 1049594400, 1067133600, 1081044000, 1099188000, 1112493600, 1130637600, 1143943200, 1162087200, 1173578400, 1194141600, 1205028000, 1225591200, 1236477600, 1257040800, 1268532000, 1289095200, 1299981600, 1320544800, 1331431200, 1351994400, 1362880800, 1383444000, 1394330400, 1414893600, 1425780000, 1446343200, 1457834400, 1478397600, 1489284000, 1509847200, 1520733600, 1541296800, 1552183200, 1572746400, 1583632800, 1604196000, 1615687200, 1636250400, 1647136800, 1667700000, 1678586400, 1699149600, 1710036000, 1730599200, 1741485600, 1762048800, 1772935200, 1793498400, 1804989600, 1825552800, 1836439200, 1857002400, 1867888800, 1888452000, 1899338400, 1919901600, 1930788000],
        offset: [-28378, -28800, -25200, -28800, -25200, -28800, -25200, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800]
      },
      "America/Chicago": {
        time: [-2717668236, -1633298400, -1615154400, -1601848800, -1583704800, -1563746400, -1551650400, -1538949600, -1520200800, -1504476000, -1491775200, -1473026400, -1459720800, -1441576800, -1428271200, -1410127200, -1396821600, -1378677600, -1365372000, -1347228000, -1333922400, -1315173600, -1301868000, -1283724000, -1270418400, -1252274400, -1238968800, -1220824800, -1207519200, -1189375200, -1176069600, -1157320800, -1144620000, -1125871200, -1112565600, -1094421600, -1081116000, -1067810400, -1045432800, -1031522400, -1018216800, -1000072800, -986767200, -968018400, -955317600, -936568800, -923263200, -905119200, -891813600, -880236000, -769413600, -765410400, -747266400, -733960800, -715816800, -702511200, -684367200, -671061600, -652917600, -639612000, -620863200, -608162400, -589413600, -576108000, -557964000, -544658400, -526514400, -513208800, -495064800, -481759200, -463615200, -447285600, -431560800, -415836000, -400111200, -384386400, -368661600, -352936800, -337212000, -321487200, -305762400, -289432800, -273708000, -257983200, -242258400, -226533600, -210808800, -195084000, -179359200, -163634400, -147909600, -131580000, -116460000, -100130400, -84405600, -68680800, -52956000, -37231200, -21506400, -5781600, 9943200, 25668000, 41392800, 57722400, 73447200, 89172000, 104896800, 120621600, 126669600, 152071200, 162352800, 183520800, 199245600, 215575200, 230695200, 247024800, 262749600, 278474400, 294199200, 309924000, 325648800, 341373600, 357098400, 372823200, 388548000, 404877600, 419997600, 436327200, 452052000, 467776800, 483501600, 499226400, 514951200, 530676000, 544586400, 562125600, 576036000, 594180000, 607485600, 625629600, 638935200, 657079200, 670989600, 688528800, 702439200, 719978400, 733888800, 752032800, 765338400, 783482400, 796788000, 814932000, 828842400, 846381600, 860292000, 877831200, 891741600, 909280800, 923191200, 941335200, 954640800, 972784800, 986090400, 1004234400, 1018144800, 1035684000, 1049594400, 1067133600, 1081044000, 1099188000, 1112493600, 1130637600, 1143943200, 1162087200, 1173578400, 1194141600, 1205028000, 1225591200, 1236477600, 1257040800, 1268532000, 1289095200, 1299981600, 1320544800, 1331431200, 1351994400, 1362880800, 1383444000, 1394330400, 1414893600, 1425780000, 1446343200, 1457834400, 1478397600, 1489284000, 1509847200, 1520733600, 1541296800, 1552183200, 1572746400, 1583632800, 1604196000, 1615687200, 1636250400, 1647136800, 1667700000, 1678586400, 1699149600, 1710036000, 1730599200, 1741485600, 1762048800, 1772935200, 1793498400, 1804989600, 1825552800, 1836439200, 1857002400, 1867888800, 1888452000, 1899338400, 1919901600, 1930788000],
        offset: [-21036, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600]
      },
      "America/Phoenix": {
        time: [-2717670498, -1633298400, -1615154400, -1601848800, -1583704800, -880236000, -820540740, -812678340, -796867140, -84405600, -68680800, 1924966800],
        offset: [-26898, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200]
      },
      "America/Toronto": {
        time: [-2366755200, -1632088800, -1615154400, -1601771400, -1583712000, -1567375200, -1554681600, -1534716000, -1524088800, -1503266400, -1492380000, -1471816800, -1460930400, -1440972000, -1428876000, -1409522400, -1397426400, -1378072800, -1365976800, -1346623200, -1333922400, -1315173600, -1301868000, -1283724000, -1270418400, -1252274400, -1238968800, -1220824800, -1207519200, -1188770400, -1176069600, -1157320800, -1144015200, -1125871200, -1112565600, -1094421600, -1081116000, -1062972000, -1049666400, -1031522400, -1018216800, -1000072800, -986767200, -968018400, -955317600, -936568800, -880232400, -769410000, -765410400, -747266400, -733960800, -715816800, -702511200, -684367200, -671061600, -652917600, -634168800, -620863200, -602719200, -589413600, -576108000, -557964000, -544658400, -526514400, -513208800, -495064800, -481759200, -463615200, -450309600, -431560800, -418255200, -400111200, -384386400, -368661600, -352936800, -337212000, -321487200, -305762400, -289432800, -273708000, -257983200, -242258400, -226533600, -210808800, -195084000, -179359200, -163634400, -147909600, -131580000, -116460000, -100130400, -84405600, -68680800, -52956000, -37231200, -21506400, -5781600, 9943200, 25668000, 41392800, 57722400, 73447200, 89172000, 104896800, 120621600, 136346400, 152071200, 167796000, 183520800, 199245600, 215575200, 230695200, 247024800, 262749600, 278474400, 294199200, 309924000, 325648800, 341373600, 357098400, 372823200, 388548000, 404877600, 419997600, 436327200, 452052000, 467776800, 483501600, 499226400, 514951200, 530676000, 544586400, 562125600, 576036000, 594180000, 607485600, 625629600, 638935200, 657079200, 670989600, 688528800, 702439200, 719978400, 733888800, 752032800, 765338400, 783482400, 796788000, 814932000, 828842400, 846381600, 860292000, 877831200, 891741600, 909280800, 923191200, 941335200, 954640800, 972784800, 986090400, 1004234400, 1018144800, 1035684000, 1049594400, 1067133600, 1081044000, 1099188000, 1112493600, 1130637600, 1143943200, 1162087200, 1173578400, 1194141600, 1205028000, 1225591200, 1236477600, 1257040800, 1268532000, 1289095200, 1299981600, 1320544800, 1331431200, 1351994400, 1362880800, 1383444000, 1394330400, 1414893600, 1425780000, 1446343200, 1457834400, 1478397600, 1489284000, 1509847200, 1520733600, 1541296800, 1552183200, 1572746400, 1583632800, 1604196000, 1615687200, 1636250400, 1647136800, 1667700000, 1678586400, 1699149600, 1710036000, 1730599200, 1741485600, 1762048800, 1772935200, 1793498400, 1804989600, 1825552800, 1836439200, 1857002400, 1867888800, 1888452000, 1899338400, 1919901600, 1930788000],
        offset: [-19052, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -14400, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000]
      },
      "America/Vancouver": {
        time: [-2713910400, -1632088800, -1615154400, -880236000, -769420800, -765410400, -747266400, -733960800, -715816800, -702511200, -684367200, -671061600, -652917600, -639612000, -620863200, -608162400, -589413600, -576108000, -557964000, -544658400, -526514400, -513208800, -495064800, -481759200, -463615200, -450309600, -431560800, -418255200, -400111200, -386805600, -368661600, -355356000, -337212000, -323906400, -305762400, -292456800, -273708000, -261007200, -242258400, -226533600, -210808800, -195084000, -179359200, -163634400, -147909600, -131580000, -116460000, -100130400, -84405600, -68680800, -52956000, -37231200, -21506400, -5781600, 9943200, 25668000, 41392800, 57722400, 73447200, 89172000, 104896800, 120621600, 136346400, 152071200, 167796000, 183520800, 199245600, 215575200, 230695200, 247024800, 262749600, 278474400, 294199200, 309924000, 325648800, 341373600, 357098400, 372823200, 388548000, 404877600, 419997600, 436327200, 452052000, 467776800, 483501600, 499226400, 514951200, 530676000, 544586400, 562125600, 576036000, 594180000, 607485600, 625629600, 638935200, 657079200, 670989600, 688528800, 702439200, 719978400, 733888800, 752032800, 765338400, 783482400, 796788000, 814932000, 828842400, 846381600, 860292000, 877831200, 891741600, 909280800, 923191200, 941335200, 954640800, 972784800, 986090400, 1004234400, 1018144800, 1035684000, 1049594400, 1067133600, 1081044000, 1099188000, 1112493600, 1130637600, 1143943200, 1162087200, 1173578400, 1194141600, 1205028000, 1225591200, 1236477600, 1257040800, 1268532000, 1289095200, 1299981600, 1320544800, 1331431200, 1351994400, 1362880800, 1383444000, 1394330400, 1414893600, 1425780000, 1446343200, 1457834400, 1478397600, 1489284000, 1509847200, 1520733600, 1541296800, 1552183200, 1572746400, 1583632800, 1604196000, 1615687200, 1636250400, 1647136800, 1667700000, 1678586400, 1699149600, 1710036000, 1730599200, 1741485600, 1762048800, 1772935200, 1793498400, 1804989600, 1825552800, 1836439200, 1857002400, 1867888800, 1888452000, 1899338400, 1919901600, 1930788000],
        offset: [-29548, -28800, -25200, -28800, -25200, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800]
      },
      "America/Argentina/Buenos_Aires": {
        time: [-2372112000, -1567468800, -1233446400, -1222992000, -1205971200, -1194048000, -1172880000, -1162512000, -1141344000, -1130976000, -1109808000, -1099440000, -1078272000, -1067817600, -1046649600, -1036281600, -1015113600, -1004745600, -983577600, -973209600, -952041600, -941587200, -931046400, -900892800, -890352000, -833760000, -827280000, -752284800, -733795200, -197337600, -190857600, -184204800, -164505600, -152668800, -132969600, -121132800, -101433600, -86832000, -71107200, -54777600, -39052800, -23328000, -7603200, 128131200, 136598400, 596937600, 605059200, 624412800, 636508800, 656467200, 667958400, 687916800, 699408000, 719366400, 731462400, 938908800, 952041600, 1198972800, 1205625600, 1224374400, 1237075200, 1924981200],
        offset: [-14028, -15408, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -10800, -10800, -7200, -10800, -7200, -10800]
      },
      "America/El_Salvador": {
        time: [-1546300800, 546998400, 559699200, 578448000, 591148800, 1924970400],
        offset: [-21408, -21600, -18000, -21600, -18000, -21600]
      },
      "America/Sao_Paulo": {
        time: [-1767225600, -1206968400, -1191369600, -1175385600, -1159833600, -633830400, -622076400, -602294400, -591840000, -570758400, -560217600, -539136000, -531360000, -195436800, -184204800, -155174400, -150076800, -128908800, -121132800, -99964800, -89596800, -68428800, -57974400, 499737600, 511228800, 530582400, 540259200, 562118400, 571190400, 592963200, 602035200, 624412800, 634694400, 656467200, 666748800, 687916800, 697593600, 719971200, 728438400, 750816000, 761702400, 782265600, 793152000, 813715200, 823996800, 844560000, 856051200, 876096000, 888710400, 908064000, 919555200, 938908800, 951609600, 970963200, 982454400, 1003017600, 1013904000, 1036281600, 1045353600, 1066521600, 1076803200, 1099353600, 1108857600, 1129420800, 1140307200, 1162684800, 1172361600, 1192320000, 1203206400, 1224374400, 1234656000, 1255824000, 1266710400, 1287273600, 1298160000, 1318723200, 1330214400, 1350777600, 1361059200, 1382227200, 1392508800, 1413676800, 1424563200, 1445126400, 1456012800, 1476576000, 1487462400, 1508025600, 1518912000, 1541289600, 1550361600, 1924981200],
        offset: [-11188, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800, -7200, -10800]
      },
      "America/Bogota": {
        time: [-2707689600, -1739059200, 704851200, 729043200, 1924974000],
        offset: [-17776, -17776, -18000, -14400, -18000]
      },
      "America/Caracas": {
        time: [-2524521600, -1826755200, -157766400, 1197169200, 1462069800, 1924977600],
        offset: [-16064, -16060, -16200, -14400, -16200, -14400]
      },
      "America/Anchorage": {
        time: [-3225173303, -2188987200, -880236000, -769428000, -765410400, -86918400, -21506400, -5781600, 9943200, 25668000, 41392800, 57722400, 73447200, 89172000, 104896800, 120621600, 126669600, 152071200, 162352800, 183520800, 199245600, 215575200, 230695200, 247024800, 262749600, 278474400, 294199200, 309924000, 325648800, 341373600, 357098400, 372823200, 388548000, 404877600, 419997600, 436327200, 438998400, 452052000, 467776800, 483501600, 499226400, 514951200, 530676000, 544586400, 562125600, 576036000, 594180000, 607485600, 625629600, 638935200, 657079200, 670989600, 688528800, 702439200, 719978400, 733888800, 752032800, 765338400, 783482400, 796788000, 814932000, 828842400, 846381600, 860292000, 877831200, 891741600, 909280800, 923191200, 941335200, 954640800, 972784800, 986090400, 1004234400, 1018144800, 1035684000, 1049594400, 1067133600, 1081044000, 1099188000, 1112493600, 1130637600, 1143943200, 1162087200, 1173578400, 1194141600, 1205028000, 1225591200, 1236477600, 1257040800, 1268532000, 1289095200, 1299981600, 1320544800, 1331431200, 1351994400, 1362880800, 1383444000, 1394330400, 1414893600, 1425780000, 1446343200, 1457834400, 1478397600, 1489284000, 1509847200, 1520733600, 1541296800, 1552183200, 1572746400, 1583632800, 1604196000, 1615687200, 1636250400, 1647136800, 1667700000, 1678586400, 1699149600, 1710036000, 1730599200, 1741485600, 1762048800, 1772935200, 1793498400, 1804989600, 1825552800, 1836439200, 1857002400, 1867888800, 1888452000, 1899338400, 1919901600, 1930788000],
        offset: [50424, -35976, -36000, -32400, -32400, -36000, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -36000, -32400, -32400, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400]
      },
      "Europe/Moscow": {
        time: [-2840140800, -1688256000, -1656810000, -1641340800, -1627956000, -1618700400, -1596416400, -1593804521, -1589846400, -1542416400, -1539478800, -1525305600, -1522713600, -1491177600, -1247529600, 354931200, 370742400, 386467200, 402278400, 418003200, 433814400, 449625600, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 695786400, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1414288800, 1925002800],
        offset: [9017, 9017, 9079, 12679, 9079, 16279, 12679, 16279, 14400, 10800, 14400, 18000, 14400, 10800, 7200, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 10800, 7200, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800]
      },
      "Europe/Athens": {
        time: [-2344636800, -1686095940, -1182988800, -1178150400, -906854400, -904867200, -857250000, -844473600, -828230400, -812419200, -552355200, -541641600, 166492800, 186195600, 198036000, 213764400, 228880800, 244090800, 260330400, 275457600, 291805200, 307418400, 323395200, 338947200, 354682800, 370411200, 386132400, 401860800, 417582000, 433310400, 449031600, 465364800, 481086000, 496814400, 512535600, 528264000, 543985200, 559713600, 575434800, 591163200, 606884400, 622612800, 638334000, 654667200, 670388400, 686116800, 701838000, 717566400, 733287600, 749016000, 764737200, 780465600, 796186800, 811915200, 828241200, 846388800, 859690800, 877838400, 891140400, 909288000, 922590000, 941342400, 954039600, 972792000, 985489200, 1004241600, 1017543600, 1035691200, 1048993200, 1067140800, 1080442800, 1099195200, 1111892400, 1130644800, 1143342000, 1162094400, 1174791600, 1193544000, 1206846000, 1224993600, 1238295600, 1256443200, 1269745200, 1288497600, 1301194800, 1319947200, 1332644400, 1351396800, 1364698800, 1382846400, 1396148400, 1414296000, 1427598000, 1445745600, 1459047600, 1477800000, 1490497200, 1509249600, 1521946800, 1540699200, 1554001200, 1572148800, 1585450800, 1603598400, 1616900400, 1635652800, 1648350000, 1667102400, 1679799600, 1698552000, 1711854000, 1730001600, 1743303600, 1761451200, 1774753200, 1792900800, 1806202800, 1824955200, 1837652400, 1856404800, 1869102000, 1887854400, 1901156400, 1919304000, 1932606000],
        offset: [5692, 5692, 7200, 10800, 7200, 10800, 7200, 3600, 7200, 3600, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200]
      },
      "Europe/Belgrade": {
        time: [-2713910400, -905821200, -857250000, -844552800, -828219600, -812498400, -796770000, -777938400, -766616400, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [4920, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Berlin": {
        time: [-2422051200, -1693702800, -1680476400, -1663452000, -1650142800, -1632002400, -1618693200, -938901600, -857250000, -844552800, -828219600, -812498400, -796770000, -781048800, -776556000, -765925200, -761173200, -748476000, -733266000, -717627600, -714603600, -710370000, -701902800, -684972000, -670453200, -654127200, -639003600, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [3208, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 10800, 7200, 3600, 7200, 3600, 7200, 10800, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Bratislava": {
        time: [-3786825600, -2469398400, -1693702800, -1680476400, -1663452000, -1650142800, -1632002400, -1618693200, -938901600, -857250000, -844552800, -828219600, -812498400, -796770000, -781048800, -765320400, -746575200, -733352400, -728514000, -721260000, -716421600, -701902800, -684972000, -670453200, -654213600, -639003600, 291780000, 307508400, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [3464, 3464, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 0, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Bucharest": {
        time: [-2469398400, -1213142400, -1187049600, -1175468400, -1159747200, -1144018800, -1127692800, -1111964400, -1096243200, -1080514800, -1064793600, -1049065200, -1033344000, -1017615600, -1001894400, -986166000, -970444800, -954716400, 296611200, 307497600, 323823600, 338950800, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670377600, 686106000, 701827200, 717555600, 733276800, 749005200, 764726400, 780451200, 796176000, 811900800, 828230400, 846374400, 859690800, 877838400, 891140400, 909288000, 922590000, 941342400, 954039600, 972792000, 985489200, 1004241600, 1017543600, 1035691200, 1048993200, 1067140800, 1080442800, 1099195200, 1111892400, 1130644800, 1143342000, 1162094400, 1174791600, 1193544000, 1206846000, 1224993600, 1238295600, 1256443200, 1269745200, 1288497600, 1301194800, 1319947200, 1332644400, 1351396800, 1364698800, 1382846400, 1396148400, 1414296000, 1427598000, 1445745600, 1459047600, 1477800000, 1490497200, 1509249600, 1521946800, 1540699200, 1554001200, 1572148800, 1585450800, 1603598400, 1616900400, 1635652800, 1648350000, 1667102400, 1679799600, 1698552000, 1711854000, 1730001600, 1743303600, 1761451200, 1774753200, 1792900800, 1806202800, 1824955200, 1837652400, 1856404800, 1869102000, 1887854400, 1901156400, 1919304000, 1932606000],
        offset: [6264, 6264, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200]
      },
      "Europe/Budapest": {
        time: [-2498256000, -1693702800, -1680476400, -1663452000, -1650142800, -1632002400, -1618693200, -1600466400, -1587243600, -1569708000, -1555189200, -906771600, -857250000, -844552800, -828219600, -812498400, -796770000, -778467600, -762649200, -749685600, -733269600, -717631200, -701902800, -686181600, -670453200, -654127200, -639003600, -492652800, -481161600, -461196000, -449701200, -428536800, -418251600, -397087200, -386802000, 323827200, 338950800, 354672000, 370400400, 386121600, 401850000, 417571200, 433299600, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [4580, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/London": {
        time: [-3852662400, -1691964000, -1680469200, -1664143200, -1650142800, -1633903200, -1617483600, -1601848800, -1586034000, -1570399200, -1552165200, -1538344800, -1522530000, -1507500000, -1490562000, -1473631200, -1460926800, -1442786400, -1428872400, -1410732000, -1396213200, -1379282400, -1364763600, -1348437600, -1333314000, -1315778400, -1301259600, -1284328800, -1269810000, -1253484000, -1238360400, -1221429600, -1206910800, -1189980000, -1175461200, -1159135200, -1143406800, -1126476000, -1111957200, -1095631200, -1080507600, -1063576800, -1049058000, -1032127200, -1017608400, -1001282400, -986158800, -969228000, -950475600, -942012000, -904514400, -896043600, -875484000, -864594000, -844034400, -832539600, -812584800, -798066000, -781048800, -772059600, -764802000, -748476000, -733352400, -719445600, -717026400, -706741200, -699483600, -687996000, -668034000, -654732000, -636584400, -622072800, -605739600, -590623200, -574290000, -558568800, -542235600, -527119200, -512600400, -496274400, -481150800, -464220000, -449701200, -432165600, -417646800, -401320800, -386197200, -369266400, -354747600, -337816800, -323298000, -306972000, -291848400, -276732000, -257979600, -245282400, -226530000, -213228000, -195080400, -182383200, -163630800, -150933600, -132181200, -119484000, -100731600, -88034400, -68677200, -59004000, -37238400, 57726000, 69818400, 89175600, 101268000, 120625200, 132717600, 152074800, 164167200, 183524400, 196221600, 214974000, 227671200, 246423600, 259120800, 278478000, 290570400, 309927600, 322020000, 341377200, 354675600, 372823200, 386125200, 404272800, 417574800, 435722400, 449024400, 467776800, 481078800, 499226400, 512528400, 530676000, 543978000, 562125600, 575427600, 593575200, 606877200, 625629600, 638326800, 657079200, 670381200, 688528800, 701830800, 719978400, 733280400, 751428000, 764730000, 782877600, 796179600, 814327200, 828234000, 846381600, 859683600, 877831200, 891133200, 909280800, 922582800, 941335200, 954032400, 972784800, 985482000, 1004234400, 1017536400, 1035684000, 1048986000, 1067133600, 1080435600, 1099188000, 1111885200, 1130637600, 1143334800, 1162087200, 1174784400, 1193536800, 1206838800, 1224986400, 1238288400, 1256436000, 1269738000, 1288490400, 1301187600, 1319940000, 1332637200, 1351389600, 1364691600, 1382839200, 1396141200, 1414288800, 1427590800, 1445738400, 1459040400, 1477792800, 1490490000, 1509242400, 1521939600, 1540692000, 1553994000, 1572141600, 1585443600, 1603591200, 1616893200, 1635645600, 1648342800, 1667095200, 1679792400, 1698544800, 1711846800, 1729994400, 1743296400, 1761444000, 1774746000, 1792893600, 1806195600, 1824948000, 1837645200, 1856397600, 1869094800, 1887847200, 1901149200, 1919296800, 1932598800],
        offset: [-75, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 0, 3600, 0, 3600, 7200, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0]
      },
      "Europe/Luxembourg": {
        time: [-2069712000, -1692493200, -1680476400, -1662339600, -1650150000, -1632002400, -1618693200, -1612656000, -1604278800, -1585515600, -1574038800, -1552255200, -1539997200, -1520546400, -1507510800, -1490569200, -1473642000, -1459116000, -1444006800, -1427670000, -1411866000, -1396220400, -1379293200, -1364770800, -1348448400, -1333321200, -1316394000, -1301266800, -1284339600, -1269810000, -1253484000, -1238360400, -1221429600, -1206910800, -1191189600, -1175461200, -1160344800, -1143406800, -1127685600, -1111957200, -1096840800, -1080507600, -1063576800, -1049058000, -1033336800, -1017608400, -1002492000, -986158800, -969228000, -950475600, -942012000, -935182800, -857250000, -844552800, -828219600, -812498400, -797979600, -781048800, -766616400, -745452000, -733266000, 228880800, 244004400, 260330400, 276058800, 291780000, 307508400, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [1476, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Madrid": {
        time: [-2177453684, -1631926800, -1616886000, -1601168400, -1585350000, -1442451600, -1427670000, -1379293200, -1364770800, -1348448400, -1333321200, -1316390400, -1301266800, -1284339600, -1269817200, -1026954000, -1017615600, -1001898000, -999478800, -986083200, -954111600, -940208400, -873075600, -862614000, -842835600, -828313200, -811386000, -796863600, -779936400, -765414000, -748486800, -733964400, -652323600, -639010800, 135126000, 150253200, 166575600, 181702800, 196815600, 212547600, 228870000, 243997200, 260330400, 276058800, 291780000, 307508400, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [-884, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 7200, 3600, 0, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Paris": {
        time: [-2486592000, -1855958400, -1689814800, -1680393600, -1665363600, -1648339200, -1635123600, -1616889600, -1604278800, -1585440000, -1574038800, -1552262400, -1539997200, -1520553600, -1507510800, -1490572800, -1470618000, -1459123200, -1444006800, -1427673600, -1411952400, -1396224000, -1379293200, -1364774400, -1348448400, -1333324800, -1316394000, -1301270400, -1284339600, -1269820800, -1253494800, -1238371200, -1221440400, -1206921600, -1191200400, -1175472000, -1160355600, -1143417600, -1127696400, -1111968000, -1096851600, -1080518400, -1063587600, -1049068800, -1033347600, -1017619200, -1002502800, -986169600, -969238800, -950486400, -942012000, -932432400, -857250000, -844552800, -828219600, -812498400, -800064000, -796258800, -781048800, -766616400, 196822800, 212547600, 228880800, 244004400, 260330400, 276058800, 291780000, 307508400, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [561, 561, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 7200, 3600, 7200, 3600, 7200, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Prague": {
        time: [-3786825600, -2469398400, -1693702800, -1680476400, -1663452000, -1650142800, -1632002400, -1618693200, -938901600, -857250000, -844552800, -828219600, -812498400, -796770000, -781048800, -765320400, -746575200, -733352400, -728514000, -721260000, -716421600, -701902800, -684972000, -670453200, -654213600, -639003600, 291780000, 307508400, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [3464, 3464, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 0, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Rome": {
        time: [-3252096000, -2403562204, -1690761600, -1680480000, -1664755200, -1648944000, -1635120000, -1616889600, -1604275200, -1585526400, -1571011200, -1555286400, -932428800, -857250000, -844552800, -828219600, -812498400, -798066000, -781048800, -766710000, -750895200, -733352400, -719452800, -701910000, -689205600, -670453200, -114048000, -103161600, -81993600, -71708400, -50544000, -40258800, -18489600, -8204400, 12960000, 23245200, 43804800, 54694800, 75859200, 86749200, 107913600, 118198800, 138758400, 149648400, 170812800, 181098000, 202262400, 212547600, 233107200, 243997200, 265161600, 276051600, 296611200, 307501200, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [2996, 2996, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Vienna": {
        time: [-2422051200, -1693702800, -1680476400, -1663452000, -1650142800, -1632002400, -1618693200, -1569708000, -1555794000, -938901600, -857250000, -844552800, -828219600, -812498400, -796770000, -781048800, -780181200, -748476000, -733266000, -717631200, -701902800, -684972000, -670453200, 323827200, 338947200, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [3921, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Warsaw": {
        time: [-2840140800, -1717027200, -1693702800, -1680476400, -1663452000, -1650142800, -1632002400, -1618693200, -1600466400, -1587157200, -1501718400, -931730400, -857250000, -844552800, -828219600, -812498400, -796600800, -778723200, -762652800, -748483200, -733266000, -715212000, -701902800, -684972000, -670453200, -654127200, -639003600, -397090800, -386805600, -371084400, -355356000, -334191600, -323301600, -307580400, -291852000, -271292400, -260402400, -239842800, -228952800, -208393200, -197503200, -176338800, -166053600, 228877200, 244000800, 260326800, 276055200, 291776400, 307504800, 323830800, 338954400, 354675600, 370404000, 386125200, 401853600, 417574800, 433303200, 449024400, 465357600, 481078800, 496807200, 512528400, 528256800, 543978000, 559706400, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [5040, 5040, 3600, 7200, 3600, 7200, 3600, 7200, 7200, 10800, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Istanbul": {
        time: [-2840140800, -1869868800, -1693699200, -1680480000, -1570406400, -1552176000, -1538352000, -1522540800, -1507507200, -1490572800, -1440201600, -1428019200, -1409702400, -1396483200, -931046400, -922665600, -917827200, -892425600, -875836800, -764726400, -744336000, -733795200, -716428800, -701913600, -684979200, -670464000, -654134400, -639014400, -622080000, -606960000, -590025600, -575510400, -235612800, -194832000, -177724800, -165715200, 107917200, 121226400, 133927200, 152676000, 164685600, 184125600, 196221600, 215575200, 228880800, 245815200, 260330400, 267926400, 428464800, 433908000, 468122400, 482806800, 496720800, 512528400, 528256800, 543978000, 559706400, 575427600, 591156000, 606877200, 622605600, 638326800, 654660000, 670381200, 686109600, 701830800, 717559200, 733280400, 749008800, 764125200, 780458400, 796179600, 811908000, 828234000, 846381600, 859683600, 877831200, 891133200, 909280800, 922582800, 941335200, 954032400, 972784800, 985482000, 1004234400, 1017536400, 1035684000, 1048986000, 1067133600, 1080435600, 1099188000, 1111885200, 1130637600, 1143334800, 1162087200, 1174791600, 1193544000, 1206846000, 1224993600, 1238295600, 1256443200, 1269745200, 1288497600, 1301281200, 1319947200, 1332644400, 1351396800, 1364698800, 1382846400, 1396234800, 1414296000, 1427598000, 1446955200, 1459047600, 1473206400, 1925002800],
        offset: [6952, 7016, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 10800, 14400, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 10800]
      },
      "Europe/Zurich": {
        time: [-3675196800, -2385244800, -904431600, -891122400, -872982000, -859672800, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [2048, 1786, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Australia/Sydney": {
        time: [-2364076800, -1672524000, -1665349200, -883605600, -876085200, -860364000, -844635600, -828309600, -813186000, 57722400, 68007600, 89172000, 100062000, 120621600, 131511600, 152071200, 162961200, 183520800, 195015600, 215575200, 226465200, 247024800, 257914800, 278474400, 289364400, 309924000, 320814000, 341373600, 352263600, 372823200, 386737200, 404877600, 415767600, 436327200, 447217200, 467776800, 478666800, 499226400, 511326000, 530071200, 542775600, 562125600, 574830000, 594180000, 606279600, 625629600, 636519600, 657079200, 667969200, 688528800, 699418800, 719978400, 731473200, 752032800, 762922800, 783482400, 794372400, 814932000, 828241200, 846381600, 859690800, 877831200, 891140400, 909280800, 922590000, 941335200, 954039600, 967341600, 985489200, 1004234400, 1017543600, 1035684000, 1048993200, 1067133600, 1080442800, 1099188000, 1111892400, 1130637600, 1143946800, 1162087200, 1174791600, 1193536800, 1207450800, 1223172000, 1238900400, 1254621600, 1270350000, 1286071200, 1301799600, 1317520800, 1333249200, 1349575200, 1365303600, 1381024800, 1396753200, 1412474400, 1428202800, 1443924000, 1459652400, 1475373600, 1491102000, 1506823200, 1522551600, 1538877600, 1554606000, 1570327200, 1586055600, 1601776800, 1617505200, 1633226400, 1648954800, 1664676000, 1680404400, 1696125600, 1712458800, 1728180000, 1743908400, 1759629600, 1775358000, 1791079200, 1806807600, 1822528800, 1838257200, 1853978400, 1869706800, 1886032800, 1901761200, 1917482400, 1933210800],
        offset: [36292, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600]
      },
      "Australia/Brisbane": {
        time: [-2366755200, -1672524000, -1665349200, -883605600, -876085200, -860364000, -844635600, -828309600, -813186000, 57722400, 68007600, 625629600, 636519600, 657079200, 667969200, 688528800, 699418800, 1925028000],
        offset: [36728, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000]
      },
      "Australia/Adelaide": {
        time: [-2364076800, -2230156800, -1672524000, -1665349200, -883605600, -876085200, -860364000, -844635600, -828309600, -813186000, 57722400, 68007600, 89172000, 100062000, 120621600, 131511600, 152071200, 162961200, 183520800, 195015600, 215575200, 226465200, 247024800, 257914800, 278474400, 289364400, 309924000, 320814000, 341373600, 352263600, 372823200, 384318000, 404877600, 415767600, 436327200, 447217200, 467776800, 478666800, 499226400, 511326000, 530071200, 542775600, 562125600, 574830000, 594180000, 606279600, 625629600, 637729200, 657079200, 667969200, 688528800, 701233200, 719978400, 731473200, 752032800, 764132400, 783482400, 796186800, 814932000, 828241200, 846381600, 859690800, 877831200, 891140400, 909280800, 922590000, 941335200, 954039600, 972784800, 985489200, 1004234400, 1017543600, 1035684000, 1048993200, 1067133600, 1080442800, 1099188000, 1111892400, 1130637600, 1143946800, 1162087200, 1174791600, 1193536800, 1207450800, 1223172000, 1238900400, 1254621600, 1270350000, 1286071200, 1301799600, 1317520800, 1333249200, 1349575200, 1365303600, 1381024800, 1396753200, 1412474400, 1428202800, 1443924000, 1459652400, 1475373600, 1491102000, 1506823200, 1522551600, 1538877600, 1554606000, 1570327200, 1586055600, 1601776800, 1617505200, 1633226400, 1648954800, 1664676000, 1680404400, 1696125600, 1712458800, 1728180000, 1743908400, 1759629600, 1775358000, 1791079200, 1806807600, 1822528800, 1838257200, 1853978400, 1869706800, 1886032800, 1901761200, 1917482400, 1933210800],
        offset: [33260, 32400, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800, 34200, 37800]
      },
      "Australia/ACT": {
        time: [-2364076800, -1672524000, -1665349200, -883605600, -876085200, -860364000, -844635600, -828309600, -813186000, 57722400, 68007600, 89172000, 100062000, 120621600, 131511600, 152071200, 162961200, 183520800, 195015600, 215575200, 226465200, 247024800, 257914800, 278474400, 289364400, 309924000, 320814000, 341373600, 352263600, 372823200, 386737200, 404877600, 415767600, 436327200, 447217200, 467776800, 478666800, 499226400, 511326000, 530071200, 542775600, 562125600, 574830000, 594180000, 606279600, 625629600, 636519600, 657079200, 667969200, 688528800, 699418800, 719978400, 731473200, 752032800, 762922800, 783482400, 794372400, 814932000, 828241200, 846381600, 859690800, 877831200, 891140400, 909280800, 922590000, 941335200, 954039600, 967341600, 985489200, 1004234400, 1017543600, 1035684000, 1048993200, 1067133600, 1080442800, 1099188000, 1111892400, 1130637600, 1143946800, 1162087200, 1174791600, 1193536800, 1207450800, 1223172000, 1238900400, 1254621600, 1270350000, 1286071200, 1301799600, 1317520800, 1333249200, 1349575200, 1365303600, 1381024800, 1396753200, 1412474400, 1428202800, 1443924000, 1459652400, 1475373600, 1491102000, 1506823200, 1522551600, 1538877600, 1554606000, 1570327200, 1586055600, 1601776800, 1617505200, 1633226400, 1648954800, 1664676000, 1680404400, 1696125600, 1712458800, 1728180000, 1743908400, 1759629600, 1775358000, 1791079200, 1806807600, 1822528800, 1838257200, 1853978400, 1869706800, 1886032800, 1901761200, 1917482400, 1933210800],
        offset: [36292, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600, 36000, 39600]
      },
      "Asia/Almaty": {
        time: [-1441152000, -1247529600, 354931200, 370742400, 386467200, 402278400, 418003200, 433814400, 449625600, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 695786400, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1709251200, 1925010000],
        offset: [18468, 18000, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 21600, 18000, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 25200, 21600, 18000]
      },
      "Asia/Ashkhabad": {
        time: [-1441152000, -1247529600, 354931200, 370742400, 386467200, 402278400, 418003200, 433814400, 449625600, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 695786400, 1925010000],
        offset: [14012, 14400, 18000, 21600, 18000, 21600, 18000, 21600, 18000, 21600, 18000, 21600, 18000, 21600, 18000, 21600, 18000, 21600, 18000, 21600, 18000, 21600, 18000, 18000, 14400, 18000]
      },
      "Asia/Colombo": {
        time: [-2840140800, -2019686400, -883267200, -862617600, -764028000, 832982400, 846289800, 1145061000, 1925011800],
        offset: [19164, 19172, 19800, 21600, 23400, 19800, 23400, 21600, 19800]
      },
      "Asia/Dhaka": {
        time: [-2524521600, -891561600, -872035200, -862617600, -576115200, 1245452400, 1262303999, 1925013600],
        offset: [21700, 21200, 23400, 19800, 23400, 21600, 25200, 21600]
      },
      "Asia/Tokyo": {
        time: [-2587678861, -683769600, -672274800, -654739200, -640825200, -620265600, -609375600, -588816000, -577926000, 1925024400],
        offset: [33539, 32400, 36000, 32400, 36000, 32400, 36000, 32400, 36000, 32400]
      },
      "Asia/Taipei": {
        time: [-2335219200, -1017792000, -766191600, -745804800, -733795200, -716860800, -699580800, -683856000, -670636800, -652320000, -639100800, -620784000, -607564800, -589248000, -576028800, -562896000, -541728000, -528681600, -510192000, -497145600, -478656000, -465609600, -449798400, -433987200, -418176000, -402451200, -386640000, -370915200, -355104000, -339379200, -323568000, -302486400, -291945600, -270950400, -260409600, 134006400, 149817600, 165542400, 181353600, 299635200, 307584000, 1925020800],
        offset: [29160, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800]
      },
      "Asia/Singapore": {
        time: [-2177452800, -2038176000, -1167609600, -1073001600, -894153600, -879638400, -766972800, 378689400, 1925020800],
        offset: [24925, 24925, 25200, 26400, 26400, 27000, 32400, 27000, 28800]
      },
      "Asia/Karachi": {
        time: [-1988150400, -862617600, -764121600, -576115200, 38793600, 1018137600, 1033862400, 1212278400, 1225497600, 1239753600, 1257033600, 1925010000],
        offset: [16092, 19800, 23400, 19800, 18000, 18000, 21600, 18000, 21600, 18000, 21600, 18000]
      },
      "Asia/Manila": {
        time: [-3944678400, -2229292800, -1046649600, -1038700800, -873244800, -794188800, -496195200, -489283200, 259372800, 275184000, 1925020800],
        offset: [-57360, 29040, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800]
      },
      "Asia/Shanghai": {
        time: [-2177452800, -1600646400, -1585872000, -933638400, -922060800, -908841600, -888796800, -881020800, -767836800, -745804800, -733795200, -716860800, -699580800, -683856000, -670636800, -652320000, -649987200, 515556000, 527047200, 545191200, 558496800, 577245600, 589946400, 608695200, 622000800, 640144800, 653450400, 671594400, 684900000, 1925020800],
        offset: [29143, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800]
      },
      "Asia/Seoul": {
        time: [-1948752000, -1830384000, -767318400, -681177600, -672192000, -654739200, -640828800, -623376000, -609379200, -588816000, -577929600, -498096000, -462672000, -451699200, -429753600, -418262400, -399513600, -387417600, -368064000, -355968000, -336614400, -324518400, -305164800, -293068800, -264902400, 547610400, 560919600, 579060000, 592369200, 1925024400],
        offset: [30472, 30600, 32400, 32400, 36000, 32400, 36000, 32400, 36000, 32400, 36000, 32400, 30600, 34200, 30600, 34200, 30600, 34200, 30600, 34200, 30600, 34200, 30600, 34200, 30600, 32400, 36000, 32400, 36000, 32400]
      },
      "Asia/Tehran": {
        time: [-1704153600, -1090454400, 227833200, 246240000, 259632000, 271126800, 283996800, 296611200, 306547200, 322444800, 338515200, 673228800, 685497600, 701222400, 717120000, 732758400, 748656000, 764294400, 780192000, 795830400, 811728000, 827366400, 843264000, 858988800, 874886400, 890524800, 906422400, 922060800, 937958400, 953596800, 969494400, 985219200, 1001116800, 1016755200, 1032652800, 1048291200, 1064188800, 1079827200, 1095724800, 1111449600, 1127347200, 1206057600, 1221955200, 1237680000, 1253577600, 1269216000, 1285113600, 1300752000, 1316649600, 1332288000, 1348185600, 1363910400, 1379808000, 1395446400, 1411344000, 1426982400, 1442880000, 1458518400, 1474416000, 1490140800, 1506038400, 1521676800, 1537574400, 1553212800, 1569110400, 1584748800, 1600646400, 1616371200, 1632268800, 1647907200, 1663804800, 1925004600],
        offset: [12344, 12344, 12600, 16200, 14400, 18000, 14400, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600, 16200, 12600]
      },
      "Asia/Dubai": {
        time: [-1577923200, 1925006400],
        offset: [13272, 14400]
      },
      "Asia/Kolkata": {
        time: [-3645216000, -3155673600, -2019686400, -891561600, -872035200, -862617600, -764121600, 1925011800],
        offset: [21208, 21200, 19270, 19800, 23400, 19800, 23400, 19800]
      },
      "Asia/Hong_Kong": {
        time: [-2056663398, -900882000, -891547200, -884217600, -761176800, -747878400, -728508600, -717021000, -697059000, -683757000, -668028600, -654726600, -636579000, -623277000, -605129400, -591827400, -573679800, -559773000, -541625400, -528323400, -510179400, -498083400, -478729800, -466633800, -446675400, -435184200, -415225800, -403129800, -383776200, -371680200, -352326600, -340230600, -320877000, -308781000, -288822600, -277331400, -257373000, -245881800, -225923400, -213827400, -194473800, -182377800, -163024200, -148509000, -132784200, -117059400, -101334600, -85609800, -69280200, -53555400, -37830600, -22105800, -6381000, 9343800, 25068600, 40793400, 56518200, 72243000, 88572600, 104297400, 120022200, 126070200, 151471800, 167196600, 182921400, 198646200, 214371000, 295414200, 309324600, 1925020800],
        offset: [27402, 28800, 32400, 30600, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800]
      },
      "Asia/Bangkok": {
        time: [-2840140800, -1570060800, 1925017200],
        offset: [24124, 24124, 25200]
      },
      "Asia/Chongqing": {
        time: [-2177452800, -1600646400, -1585872000, -933638400, -922060800, -908841600, -888796800, -881020800, -767836800, -745804800, -733795200, -716860800, -699580800, -683856000, -670636800, -652320000, -649987200, 515556000, 527047200, 545191200, 558496800, 577245600, 589946400, 608695200, 622000800, 640144800, 653450400, 671594400, 684900000, 1925020800],
        offset: [29143, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800]
      },
      "Asia/Jerusalem": {
        time: [-2840140800, -1640995200, -933631200, -923086800, -919029600, -857336400, -844293600, -825800400, -812671200, -794178000, -779839200, -762642000, -748303200, -731106000, -681948000, -673214400, -667947600, -652312800, -636411600, -622072800, -608936400, -591832800, -572475600, -558568800, -542840400, -527724000, -514414800, -490831200, -482965200, -459381600, -451515600, -428536800, -418251600, -400111200, -387406800, 142387200, 150854400, 167184000, 178675200, 334108800, 337741200, 452649600, 462330000, 482284800, 494380800, 516758400, 526435200, 545443200, 558489600, 576633600, 589334400, 609897600, 620784000, 638323200, 651628800, 669772800, 683683200, 701827200, 715737600, 733708800, 747187200, 765158400, 778032000, 796608000, 810086400, 826848000, 842832000, 858902400, 874195200, 890352000, 905040000, 923018400, 936324000, 955677600, 970794000, 986778000, 1001293200, 1017363600, 1033952400, 1048813200, 1065142800, 1081299600, 1095814800, 1112320800, 1128823200, 1143770400, 1159668000, 1175220000, 1189908000, 1206669600, 1223172000, 1238119200, 1254016800, 1269568800, 1284256800, 1301623200, 1317520800, 1333072800, 1348365600, 1364522400, 1382839200, 1395972000, 1414288800, 1427421600, 1445738400, 1458871200, 1477792800, 1490320800, 1509242400, 1521770400, 1540692000, 1553824800, 1572141600, 1585274400, 1603591200, 1616724000, 1635645600, 1648173600, 1667095200, 1679623200, 1698544800, 1711677600, 1729994400, 1743127200, 1761444000, 1774576800, 1792893600, 1806026400, 1824948000, 1837476000, 1856397600, 1868925600, 1887847200, 1900980000, 1919296800, 1932429600],
        offset: [8454, 8440, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 14400, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200]
      },
      "Asia/Kuala_Lumpur": {
        time: [-2177452800, -2038176000, -1167609600, -1073001600, -894153600, -879638400, -766972800, 378689400, 1925020800],
        offset: [24406, 24925, 25200, 26400, 26400, 27000, 32400, 27000, 28800]
      },
      "Asia/Kuwait": {
        time: [-631152000, 1925002800],
        offset: [11516, 10800]
      },
      "Asia/Muscat": {
        time: [-1577923200, 1925006400],
        offset: [14064, 14400]
      },
      "Asia/Nicosia": {
        time: [-1518912000, 166579200, 182304000, 200966400, 213840000, 228873600, 243993600, 260323200, 276134400, 291772800, 307497600, 323827200, 338947200, 354672000, 370396800, 386121600, 401846400, 417571200, 433296000, 449020800, 465350400, 481075200, 496800000, 512524800, 528249600, 543974400, 559699200, 575424000, 591148800, 606873600, 622598400, 638323200, 654652800, 670377600, 686102400, 701827200, 717552000, 733276800, 749001600, 764726400, 780451200, 796176000, 811900800, 828230400, 843955200, 859680000, 875404800, 891129600, 909288000, 922590000, 941342400, 954039600, 972792000, 985489200, 1004241600, 1017543600, 1035691200, 1048993200, 1067140800, 1080442800, 1099195200, 1111892400, 1130644800, 1143342000, 1162094400, 1174791600, 1193544000, 1206846000, 1224993600, 1238295600, 1256443200, 1269745200, 1288497600, 1301194800, 1319947200, 1332644400, 1351396800, 1364698800, 1382846400, 1396148400, 1414296000, 1427598000, 1445745600, 1459047600, 1477800000, 1490497200, 1509249600, 1521946800, 1540699200, 1554001200, 1572148800, 1585450800, 1603598400, 1616900400, 1635652800, 1648350000, 1667102400, 1679799600, 1698552000, 1711854000, 1730001600, 1743303600, 1761451200, 1774753200, 1792900800, 1806202800, 1824955200, 1837652400, 1856404800, 1869102000, 1887854400, 1901156400, 1919304000, 1932606000],
        offset: [8008, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200]
      },
      "Asia/Qatar": {
        time: [-1577923200, 76204800, 1925002800],
        offset: [12368, 14400, 10800]
      },
      "Asia/Riyadh": {
        time: [-719625600, 1925002800],
        offset: [11212, 10800]
      },
      "Asia/Yangon": {
        time: [-2840140800, -1577923200, -873244800, -778377600, 1925015400],
        offset: [23087, 23087, 23400, 32400, 23400]
      },
      "Pacific/Auckland": {
        time: [-3192393600, -1330293600, -1320012000, -1300658400, -1287352800, -1269208800, -1255903200, -1237759200, -1224453600, -1206309600, -1192399200, -1174860000, -1160949600, -1143410400, -1125871200, -1112565600, -1094421600, -1081116000, -1062972000, -1049666400, -1031522400, -1018216800, -1000072800, -986767200, -968018400, -955317600, -936568800, -923263200, -757382400, 152676000, 162356400, 183520800, 195015600, 215575200, 226465200, 247024800, 257914800, 278474400, 289364400, 309924000, 320814000, 341373600, 352263600, 372823200, 384318000, 404877600, 415767600, 436327200, 447217200, 467776800, 478666800, 499226400, 510116400, 530676000, 541566000, 562125600, 573620400, 594180000, 605070000, 623815200, 637729200, 655264800, 669178800, 686714400, 700628400, 718164000, 732682800, 749613600, 764132400, 781063200, 795582000, 812512800, 827031600, 844567200, 858481200, 876016800, 889930800, 907466400, 921985200, 938916000, 953434800, 970365600, 984884400, 1002420000, 1016334000, 1033869600, 1047783600, 1065319200, 1079838000, 1096768800, 1111287600, 1128218400, 1142737200, 1159668000, 1174186800, 1191117600, 1207450800, 1222567200, 1238900400, 1254016800, 1270350000, 1285466400, 1301799600, 1316916000, 1333249200, 1348970400, 1365303600, 1380420000, 1396753200, 1411869600, 1428202800, 1443319200, 1459652400, 1474768800, 1491102000, 1506218400, 1522551600, 1538272800, 1554606000, 1569722400, 1586055600, 1601172000, 1617505200, 1632621600, 1648954800, 1664071200, 1680404400, 1695520800, 1712458800, 1727575200, 1743908400, 1759024800, 1775358000, 1790474400, 1806807600, 1821924000, 1838257200, 1853373600, 1869706800, 1885428000, 1901761200, 1916877600, 1933210800],
        offset: [41944, 41400, 45000, 41400, 43200, 41400, 43200, 41400, 43200, 41400, 43200, 41400, 43200, 41400, 43200, 41400, 43200, 41400, 43200, 41400, 43200, 41400, 43200, 41400, 43200, 41400, 43200, 41400, 43200, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800, 43200, 46800]
      },
      "Pacific/Chatham": {
        time: [-3192393600, -757382400, 152678700, 162359100, 183523500, 195018300, 215577900, 226467900, 247027500, 257917500, 278477100, 289367100, 309926700, 320816700, 341376300, 352266300, 372825900, 384320700, 404880300, 415770300, 436329900, 447219900, 467779500, 478669500, 499229100, 510119100, 530678700, 541568700, 562128300, 573623100, 594182700, 605072700, 623817900, 637731900, 655267500, 669181500, 686717100, 700631100, 718166700, 732685500, 749616300, 764135100, 781065900, 795584700, 812515500, 827034300, 844569900, 858483900, 876019500, 889933500, 907469100, 921987900, 938918700, 953437500, 970368300, 984887100, 1002422700, 1016336700, 1033872300, 1047786300, 1065321900, 1079840700, 1096771500, 1111290300, 1128221100, 1142739900, 1159670700, 1174189500, 1191120300, 1207453500, 1222569900, 1238903100, 1254019500, 1270352700, 1285469100, 1301802300, 1316918700, 1333251900, 1348973100, 1365306300, 1380422700, 1396755900, 1411872300, 1428205500, 1443321900, 1459655100, 1474771500, 1491104700, 1506221100, 1522554300, 1538275500, 1554608700, 1569725100, 1586058300, 1601174700, 1617507900, 1632624300, 1648957500, 1664073900, 1680407100, 1695523500, 1712461500, 1727577900, 1743911100, 1759027500, 1775360700, 1790477100, 1806810300, 1821926700, 1838259900, 1853376300, 1869709500, 1885430700, 1901763900, 1916880300, 1933213500],
        offset: [44028, 44100, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500, 45900, 49500]
      },
      "Pacific/Fakaofo": {
        time: [-2177452800, 1325203200, 1925038800],
        offset: [-41096, -39600, 46800]
      },
      "Pacific/Honolulu": {
        time: [-2334139200, -1157320800, -1155470400, -880236000, -769429800, -765410400, -712188000, 1924956000],
        offset: [-37886, -37800, -34200, -37800, -34200, -34200, -37800, -36000]
      },
      "America/Mexico_City": {
        time: [-1514763396, -1343091600, -1234828800, -1220317200, -1207180800, -1191369600, -975283200, -963187200, -917136000, -907372800, -821923200, -810086400, -627523200, -613008000, 828842400, 846381600, 860292000, 877831200, 891741600, 909280800, 923191200, 941335200, 954640800, 972784800, 989114400, 1001815200, 1018144800, 1035684000, 1049594400, 1067133600, 1081044000, 1099188000, 1112493600, 1130637600, 1143943200, 1162087200, 1175392800, 1193536800, 1207447200, 1224986400, 1238896800, 1256436000, 1270346400, 1288490400, 1301796000, 1319940000, 1333245600, 1351389600, 1365300000, 1382839200, 1396749600, 1414288800, 1428199200, 1445738400, 1459648800, 1477792800, 1491098400, 1509242400, 1522548000, 1540692000, 1554602400, 1572141600, 1586052000, 1603591200, 1617501600, 1635645600, 1648951200, 1667095200, 1924970400],
        offset: [-23796, -25200, -21600, -25200, -21600, -25200, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600, -18000, -21600]
      },
      "Africa/Cairo": {
        time: [-2185401600, -929836800, -923097600, -906163200, -892857600, -875836800, -857779200, -844300800, -825811200, -812678400, -794188800, -779846400, -762652800, -399081600, -386640000, -368323200, -355104000, -336783600, -323643600, -305161200, -292021200, -273625200, -260485200, -242089200, -228949200, -210553200, -197413200, -178930800, -165790800, -147394800, -134254800, -115858800, -102632400, -84322800, -71096400, -52700400, -39474000, -21164400, -7938000, 10371600, 23598000, 41907600, 55134000, 73530000, 86756400, 105066000, 118292400, 136602000, 149828400, 168138000, 181364400, 199760400, 212986800, 231296400, 244522800, 262832400, 276058800, 294368400, 307594800, 325990800, 339217200, 357526800, 370753200, 396406800, 402289200, 426819600, 433825200, 452221200, 465447600, 483757200, 496983600, 515293200, 528519600, 546829200, 560055600, 578451600, 591678000, 610419600, 623214000, 641523600, 654750000, 673059600, 686286000, 704682000, 717908400, 736218000, 749444400, 767754000, 780980400, 799027200, 812332800, 830476800, 843782400, 861926400, 875232000, 893376000, 906681600, 925430400, 938736000, 956880000, 970185600, 988329600, 1001635200, 1019779200, 1033084800, 1051228800, 1064534400, 1083283200, 1096588800, 1114732800, 1128038400, 1146182400, 1158883200, 1177632000, 1189123200, 1209081600, 1219968000, 1240531200, 1250812800, 1272585600, 1281484800, 1284076800, 1285891200, 1400198400, 1403827200, 1406851200, 1411689600, 1682640000, 1698364800, 1714089600, 1730419200, 1745539200, 1761868800, 1776988800, 1793318400, 1809043200, 1824768000, 1840492800, 1856217600, 1871942400, 1887667200, 1903392000, 1919721600, 1934841600],
        offset: [7509, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200]
      },
      "Africa/Casablanca": {
        time: [-1773014400, -956361600, -950486400, -942019200, -761184000, -617241600, -605145600, -81432000, -71107200, 141264000, 147225600, 199756800, 207705600, 231292800, 244252800, 265507200, 271036800, 448243200, 504921600, 1212278400, 1220227200, 1243814400, 1250812800, 1272758400, 1281225600, 1301788800, 1312070400, 1335664800, 1342753200, 1345428000, 1348974000, 1367114400, 1373166000, 1376100000, 1382842800, 1396144800, 1403924400, 1406944800, 1414292400, 1427594400, 1434250800, 1437271200, 1445742000, 1459044000, 1465095600, 1468116000, 1477796400, 1490493600, 1495335600, 1498960800, 1509246000, 1521943200, 1526180400, 1529200800, 1540695600, 1557025200, 1560045600, 1587265200, 1590890400, 1618110000, 1621130400, 1648350000, 1651975200, 1679194800, 1682215200, 1710039600, 1713060000, 1740279600, 1743904800, 1771124400, 1774144800, 1801969200, 1804989600, 1832209200, 1835834400, 1863054000, 1866074400, 1893294000, 1896919200, 1924138800, 1927159200],
        offset: [-1820, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0]
      },
      "Africa/Johannesburg": {
        time: [-2458166400, -2109283200, -860968800, -845244000, -829519200, -813794400, 1924999200],
        offset: [6720, 5400, 7200, 10800, 7200, 10800, 7200]
      },
      "Africa/Nairobi": {
        time: [-1946160000, -1309737600, -1261958400, -1041379200, -865296000, 1925002800],
        offset: [8836, 9000, 10800, 9000, 9900, 10800]
      },
      "Africa/Tunis": {
        time: [-2797200000, -1855958400, -969238800, -950486400, -941936400, -891129600, -877824000, -857250000, -844552800, -842911200, -842220000, -828223200, -812498400, -796262400, -781048800, -766627200, 231206400, 243910800, 262828800, 276051600, 581126400, 591152400, 606873600, 622602000, 641520000, 654656400, 1114905600, 1128045600, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1924995600],
        offset: [2444, 561, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Asia/Kathmandu": {
        time: [-1577923200, 504921600, 1925012700],
        offset: [20476, 19800, 20700]
      },
      "US/Mountain": {
        time: [-2717668796, -1633298400, -1615154400, -1601848800, -1583704800, -1570399200, -1551650400, -1538949600, -1534111200, -880236000, -769417200, -765410400, -147909600, -131580000, -116460000, -100130400, -84405600, -68680800, -52956000, -37231200, -21506400, -5781600, 9943200, 25668000, 41392800, 57722400, 73447200, 89172000, 104896800, 120621600, 126669600, 152071200, 162352800, 183520800, 199245600, 215575200, 230695200, 247024800, 262749600, 278474400, 294199200, 309924000, 325648800, 341373600, 357098400, 372823200, 388548000, 404877600, 419997600, 436327200, 452052000, 467776800, 483501600, 499226400, 514951200, 530676000, 544586400, 562125600, 576036000, 594180000, 607485600, 625629600, 638935200, 657079200, 670989600, 688528800, 702439200, 719978400, 733888800, 752032800, 765338400, 783482400, 796788000, 814932000, 828842400, 846381600, 860292000, 877831200, 891741600, 909280800, 923191200, 941335200, 954640800, 972784800, 986090400, 1004234400, 1018144800, 1035684000, 1049594400, 1067133600, 1081044000, 1099188000, 1112493600, 1130637600, 1143943200, 1162087200, 1173578400, 1194141600, 1205028000, 1225591200, 1236477600, 1257040800, 1268532000, 1289095200, 1299981600, 1320544800, 1331431200, 1351994400, 1362880800, 1383444000, 1394330400, 1414893600, 1425780000, 1446343200, 1457834400, 1478397600, 1489284000, 1509847200, 1520733600, 1541296800, 1552183200, 1572746400, 1583632800, 1604196000, 1615687200, 1636250400, 1647136800, 1667700000, 1678586400, 1699149600, 1710036000, 1730599200, 1741485600, 1762048800, 1772935200, 1793498400, 1804989600, 1825552800, 1836439200, 1857002400, 1867888800, 1888452000, 1899338400, 1919901600, 1930788000],
        offset: [-25196, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200, -21600, -25200]
      },
      "Europe/Helsinki": {
        time: [-2890252800, -1535932800, -875664000, -859762800, 354679200, 370407600, 386128800, 401857200, 417582000, 433310400, 449031600, 465364800, 481086000, 496814400, 512535600, 528264000, 543985200, 559713600, 575434800, 591163200, 606884400, 622612800, 638334000, 654667200, 670388400, 686116800, 701838000, 717566400, 733287600, 749016000, 764737200, 780465600, 796186800, 811915200, 828241200, 846388800, 859690800, 877838400, 891140400, 909288000, 922590000, 941342400, 954039600, 972792000, 985489200, 1004241600, 1017543600, 1035691200, 1048993200, 1067140800, 1080442800, 1099195200, 1111892400, 1130644800, 1143342000, 1162094400, 1174791600, 1193544000, 1206846000, 1224993600, 1238295600, 1256443200, 1269745200, 1288497600, 1301194800, 1319947200, 1332644400, 1351396800, 1364698800, 1382846400, 1396148400, 1414296000, 1427598000, 1445745600, 1459047600, 1477800000, 1490497200, 1509249600, 1521946800, 1540699200, 1554001200, 1572148800, 1585450800, 1603598400, 1616900400, 1635652800, 1648350000, 1667102400, 1679799600, 1698552000, 1711854000, 1730001600, 1743303600, 1761451200, 1774753200, 1792900800, 1806202800, 1824955200, 1837652400, 1856404800, 1869102000, 1887854400, 1901156400, 1919304000, 1932606000],
        offset: [5989, 5989, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200]
      },
      "Europe/Stockholm": {
        time: [-2871676800, -2208988800, -1692493200, -1680476400, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [4332, 3614, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Copenhagen": {
        time: [-2524521600, -2398291200, -1692493200, -1680483600, -935107200, -857250000, -844552800, -828219600, -812498400, -796770000, -781048800, -769381200, -747007200, -736376400, -715212000, -706741200, -683157600, -675291600, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [3020, 3020, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Atlantic/Reykjavik": {
        time: [-1956614400, -1668214800, -1647212400, -1636678800, -1613430000, -1605142800, -1581894000, -1539565200, -1531350000, -968029200, -952293600, -942012000, -920239200, -909961200, -888789600, -877906800, -857944800, -846457200, -826495200, -815007600, -795045600, -783558000, -762991200, -752108400, -731541600, -717634800, -700092000, -686185200, -668642400, -654735600, -636588000, -623286000, -605743200, -591836400, -573688800, -559782000, -542239200, -528332400, -510789600, -496882800, -479340000, -465433200, -447890400, -433983600, -415836000, -401929200, -384386400, -370479600, -352936800, -339030000, -321487200, -307580400, -290037600, -276130800, -258588000, -244681200, -226533600, -212626800, -195084000, -181177200, -163634400, -149727600, -132184800, -118278000, -100735200, -86828400, -68680800, -54774000, 1924992000],
        offset: [-5280, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0]
      },
      "Europe/Tallinn": {
        time: [-2840140800, -1638316800, -1632002400, -1618693200, -1593820800, -1535932800, -927936000, -892944000, -857250000, -844552800, -828219600, -812498400, -797644800, 354931200, 370742400, 386467200, 402278400, 418003200, 433814400, 449625600, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909288000, 922590000, 941342400, 1017543600, 1035691200, 1048993200, 1067140800, 1080442800, 1099195200, 1111892400, 1130644800, 1143342000, 1162094400, 1174791600, 1193544000, 1206846000, 1224993600, 1238295600, 1256443200, 1269745200, 1288497600, 1301194800, 1319947200, 1332644400, 1351396800, 1364698800, 1382846400, 1396148400, 1414296000, 1427598000, 1445745600, 1459047600, 1477800000, 1490497200, 1509249600, 1521946800, 1540699200, 1554001200, 1572148800, 1585450800, 1603598400, 1616900400, 1635652800, 1648350000, 1667102400, 1679799600, 1698552000, 1711854000, 1730001600, 1743303600, 1761451200, 1774753200, 1792900800, 1806202800, 1824955200, 1837652400, 1856404800, 1869102000, 1887854400, 1901156400, 1919304000, 1932606000],
        offset: [5940, 5940, 3600, 7200, 3600, 5940, 7200, 10800, 7200, 3600, 7200, 3600, 7200, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200]
      },
      "Europe/Riga": {
        time: [-2840140800, -1632002400, -1618693200, -1601676000, -1597266000, -1377302400, -928022400, -899510400, -857250000, -844552800, -828219600, -812498400, -796770000, -795830400, 354931200, 370742400, 386467200, 402278400, 418003200, 433814400, 449625600, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 843966000, 859690800, 877838400, 891140400, 909288000, 922590000, 941342400, 985489200, 1004241600, 1017543600, 1035691200, 1048993200, 1067140800, 1080442800, 1099195200, 1111892400, 1130644800, 1143342000, 1162094400, 1174791600, 1193544000, 1206846000, 1224993600, 1238295600, 1256443200, 1269745200, 1288497600, 1301194800, 1319947200, 1332644400, 1351396800, 1364698800, 1382846400, 1396148400, 1414296000, 1427598000, 1445745600, 1459047600, 1477800000, 1490497200, 1509249600, 1521946800, 1540699200, 1554001200, 1572148800, 1585450800, 1603598400, 1616900400, 1635652800, 1648350000, 1667102400, 1679799600, 1698552000, 1711854000, 1730001600, 1743303600, 1761451200, 1774753200, 1792900800, 1806202800, 1824955200, 1837652400, 1856404800, 1869102000, 1887854400, 1901156400, 1919304000, 1932606000],
        offset: [5794, 5794, 9394, 5794, 9394, 5794, 7200, 10800, 7200, 3600, 7200, 3600, 7200, 3600, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200]
      },
      "Europe/Vilnius": {
        time: [-2840140800, -1672531200, -1585094400, -1561248000, -1553558400, -928195200, -900115200, -857250000, -844552800, -828219600, -812498400, -802137600, 354931200, 370742400, 386467200, 402278400, 418003200, 433814400, 449625600, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891140400, 909284400, 922586400, 941338800, 1048993200, 1067140800, 1080442800, 1099195200, 1111892400, 1130644800, 1143342000, 1162094400, 1174791600, 1193544000, 1206846000, 1224993600, 1238295600, 1256443200, 1269745200, 1288497600, 1301194800, 1319947200, 1332644400, 1351396800, 1364698800, 1382846400, 1396148400, 1414296000, 1427598000, 1445745600, 1459047600, 1477800000, 1490497200, 1509249600, 1521946800, 1540699200, 1554001200, 1572148800, 1585450800, 1603598400, 1616900400, 1635652800, 1648350000, 1667102400, 1679799600, 1698552000, 1711854000, 1730001600, 1743303600, 1761451200, 1774753200, 1792900800, 1806202800, 1824955200, 1837652400, 1856404800, 1869102000, 1887854400, 1901156400, 1919304000, 1932606000],
        offset: [6076, 5040, 5736, 3600, 7200, 3600, 10800, 7200, 3600, 7200, 3600, 7200, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 14400, 10800, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 7200, 3600, 7200, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200, 10800, 7200]
      },
      "America/Lima": {
        time: [-2524521600, -1938556800, -1009843200, -1002067200, -986774400, -971049600, -955324800, -939600000, 504921600, 512697600, 536457600, 544233600, 631152000, 638928000, 757382400, 765158400, 1924974000],
        offset: [-18492, -18516, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000]
      },
      "America/Santiago": {
        time: [-2524521600, -1892678400, -1688428800, -1619222400, -1593820800, -1336003200, -1317600000, -1304380800, -1286064000, -1272844800, -1254528000, -1241308800, -1222992000, -1209772800, -1191369600, -1178150400, -870566400, -865296000, -740534400, -736646400, -718070400, -713667600, -36633600, -23932800, -3369600, 7516800, 24451200, 37756800, 55900800, 69206400, 87955200, 100656000, 118195200, 132105600, 150854400, 163555200, 182304000, 195609600, 213753600, 227059200, 245203200, 258508800, 277257600, 289958400, 308707200, 321408000, 340156800, 353462400, 371606400, 384912000, 403056000, 416361600, 434505600, 447811200, 466560000, 479260800, 498009600, 510710400, 529459200, 545184000, 560908800, 574214400, 592358400, 605664000, 624412800, 637113600, 653443200, 668563200, 687312000, 700617600, 718761600, 732067200, 750211200, 763516800, 781660800, 794966400, 813715200, 826416000, 845164800, 859680000, 876614400, 889920000, 906854400, 923184000, 939513600, 952819200, 971568000, 984268800, 1003017600, 1015718400, 1034467200, 1047168000, 1065916800, 1079222400, 1097366400, 1110672000, 1128816000, 1142121600, 1160870400, 1173571200, 1192320000, 1206835200, 1223769600, 1237075200, 1255219200, 1270339200, 1286668800, 1304812800, 1313884800, 1335657600, 1346544000, 1367107200, 1378598400, 1398556800, 1410048000, 1463270400, 1471132800, 1494720000, 1502582400, 1526169600, 1534032000, 1554595200, 1567900800, 1586044800, 1599350400, 1617494400, 1630800000, 1648944000, 1662854400, 1680393600, 1693699200, 1712448000, 1725753600, 1743897600, 1757203200, 1775347200, 1788652800, 1806796800, 1820102400, 1838246400, 1851552000, 1870300800, 1883001600, 1901750400, 1915056000, 1933200000],
        offset: [-16965, -16965, -18000, -16965, -14400, -16965, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -18000, -14400, -10800, -14400, -18000, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800, -14400, -10800]
      },
      "Asia/Bahrain": {
        time: [-897868800, -820540800, 76204800, 1925002800],
        offset: [12140, 12600, 14400, 10800]
      },
      "Asia/Jakarta": {
        time: [-3231273600, -1451693568, -1172880000, -876614400, -766022400, -683856000, -620784000, -189388800, 1925017200],
        offset: [25632, 25632, 26400, 27000, 32400, 27000, 28800, 27000, 25200]
      },
      "Africa/Lagos": {
        time: [-2035584000, -1940889600, -1767225600, -1588464000, 1924995600],
        offset: [815, 0, 815, 1800, 3600]
      },
      "Pacific/Norfolk": {
        time: [-2177452800, -599616000, 152071200, 162961200, 1443924000, 1570327200, 1586055600, 1601776800, 1617505200, 1633226400, 1648954800, 1664676000, 1680404400, 1696125600, 1712458800, 1728180000, 1743908400, 1759629600, 1775358000, 1791079200, 1806807600, 1822528800, 1838257200, 1853978400, 1869706800, 1886032800, 1901761200, 1917482400, 1933210800],
        offset: [40312, 40320, 41400, 45000, 41400, 39600, 43200, 39600, 43200, 39600, 43200, 39600, 43200, 39600, 43200, 39600, 43200, 39600, 43200, 39600, 43200, 39600, 43200, 39600, 43200, 39600, 43200, 39600, 43200]
      },
      "America/Juneau": {
        time: [-3225169588, -2188987200, -880236000, -769420800, -765410400, -21506400, -5781600, 9943200, 25668000, 41392800, 57722400, 73447200, 89172000, 104896800, 120621600, 126669600, 152071200, 162352800, 183520800, 199245600, 215575200, 230695200, 247024800, 262749600, 278474400, 294199200, 309924000, 325648800, 341373600, 357098400, 372823200, 388548000, 404877600, 419997600, 436327200, 438998400, 452052000, 467776800, 483501600, 499226400, 514951200, 530676000, 544586400, 562125600, 576036000, 594180000, 607485600, 625629600, 638935200, 657079200, 670989600, 688528800, 702439200, 719978400, 733888800, 752032800, 765338400, 783482400, 796788000, 814932000, 828842400, 846381600, 860292000, 877831200, 891741600, 909280800, 923191200, 941335200, 954640800, 972784800, 986090400, 1004234400, 1018144800, 1035684000, 1049594400, 1067133600, 1081044000, 1099188000, 1112493600, 1130637600, 1143943200, 1162087200, 1173578400, 1194141600, 1205028000, 1225591200, 1236477600, 1257040800, 1268532000, 1289095200, 1299981600, 1320544800, 1331431200, 1351994400, 1362880800, 1383444000, 1394330400, 1414893600, 1425780000, 1446343200, 1457834400, 1478397600, 1489284000, 1509847200, 1520733600, 1541296800, 1552183200, 1572746400, 1583632800, 1604196000, 1615687200, 1636250400, 1647136800, 1667700000, 1678586400, 1699149600, 1710036000, 1730599200, 1741485600, 1762048800, 1772935200, 1793498400, 1804989600, 1825552800, 1836439200, 1857002400, 1867888800, 1888452000, 1899338400, 1919901600, 1930788000],
        offset: [54139, -32261, -28800, -25200, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -25200, -28800, -28800, -28800, -25200, -28800, -25200, -28800, -25200, -32400, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400, -28800, -32400]
      },
      "Asia/Ho_Chi_Minh": {
        time: [-2004048000, -1851552000, -852080400, -782614800, -767836800, -718070400, -457743600, -315622800, 171849600, 1925017200],
        offset: [25590, 25590, 25200, 28800, 32400, 25200, 28800, 25200, 28800, 25200]
      },
      "Australia/Perth": {
        time: [-2337897600, -1672524000, -1665349200, -883605600, -876085200, -860364000, -844635600, 152071200, 162961200, 436327200, 447217200, 690343200, 699418800, 1165111200, 1174791600, 1193536800, 1206846000, 1224986400, 1238295600, 1925020800],
        offset: [27804, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800, 32400, 28800]
      },
      "Europe/Malta": {
        time: [-2403475200, -1690761600, -1680480000, -1664755200, -1648944000, -1635120000, -1616889600, -1604275200, -1585526400, -1571011200, -1555286400, -932428800, -857250000, -844552800, -828219600, -812584800, -798066000, -781048800, -766710000, -750895200, -733352400, -719452800, -701910000, -689205600, -670453200, -114048000, -103161600, -81993600, -71708400, -50544000, -40258800, -18489600, -8204400, 12960000, 23245200, 43804800, 54694800, 75859200, 86749200, 102384000, 118112400, 135734400, 148525200, 167191200, 180496800, 198640800, 211946400, 230090400, 243396000, 261540000, 274845600, 292989600, 306295200, 323316000, 338349600, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [3484, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Amsterdam": {
        time: [-4260211200, -1693699200, -1680480000, -1663452000, -1650142800, -1633212000, -1617483600, -1601157600, -1586034000, -1569708000, -1554584400, -1538258400, -1523134800, -1507500000, -1490562000, -1470175200, -1459112400, -1443996000, -1427662800, -1406671200, -1396213200, -1376949600, -1364763600, -1345413600, -1333314000, -1313791200, -1301259600, -1282255200, -1269810000, -1250719200, -1238360400, -1219183200, -1206910800, -1186956000, -1175461200, -1156024800, -1143406800, -1124488800, -1111957200, -1092952800, -1080507600, -1061330400, -1049058000, -1029189600, -1025740800, -1017608400, -998258400, -986158800, -966722400, -954104400, -935020800, -857250000, -844552800, -828219600, -812498400, -796770000, -781048800, -766616400, 228880800, 244004400, 260330400, 276058800, 291780000, 307508400, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [1172, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 1172, 4772, 4800, 1200, 4800, 1200, 4800, 1200, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Brussels": {
        time: [-2840140800, -2450994150, -1740355200, -1693699200, -1680476400, -1663452000, -1650142800, -1632002400, -1618693200, -1613822400, -1604278800, -1585526400, -1574038800, -1552262400, -1539997200, -1520553600, -1507510800, -1490572800, -1473642000, -1459123200, -1444006800, -1427673600, -1411952400, -1396224000, -1379293200, -1364774400, -1348448400, -1333324800, -1316394000, -1301259600, -1284328800, -1269810000, -1253484000, -1238360400, -1221429600, -1206910800, -1191189600, -1175461200, -1160344800, -1143406800, -1127685600, -1111957200, -1096840800, -1080507600, -1063576800, -1049058000, -1033336800, -1017608400, -1002492000, -986158800, -969228000, -950475600, -942012000, -934664400, -857250000, -844552800, -828219600, -812498400, -798066000, -781048800, -766616400, -745452000, -733266000, 228880800, 244004400, 260330400, 276058800, 291780000, 307508400, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [1050, 1050, 0, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Europe/Lisbon": {
        time: [-1830386205, -1689555600, -1677798000, -1667437200, -1647734400, -1635814800, -1616198400, -1604365200, -1584662400, -1572742800, -1553040000, -1541206800, -1521504000, -1442451600, -1426809600, -1379293200, -1364774400, -1348448400, -1333324800, -1316394000, -1301270400, -1284339600, -1269820800, -1221440400, -1206921600, -1191200400, -1175472000, -1127696400, -1111968000, -1096851600, -1080518400, -1063587600, -1049068800, -1033347600, -1017619200, -1002502800, -986169600, -969238800, -950486400, -942022800, -922665600, -906944400, -891129600, -877309200, -873680400, -864000000, -857952000, -845859600, -842835600, -831340800, -825897600, -814410000, -810781200, -799891200, -794448000, -782960400, -779331600, -768441600, -762998400, -749091600, -733363200, -717631200, -701902800, -686181600, -670453200, -654732000, -639003600, -623282400, -607554000, -591832800, -575499600, -559778400, -544050000, -528328800, -512600400, -496879200, -481150800, -465429600, -449701200, -433980000, -417646800, -401925600, -386197200, -370476000, -354747600, -339026400, -323298000, -307576800, -291848400, -276127200, -260398800, -244677600, -228344400, -212623200, -196894800, -181173600, -165445200, -149724000, -133995600, -118274400, 212547600, 228268800, 243997200, 260323200, 276051600, 291772800, 307504800, 323222400, 338954400, 354675600, 370404000, 386125200, 401853600, 417578400, 433303200, 449024400, 465357600, 481078800, 496807200, 512528400, 528256800, 543978000, 559706400, 575427600, 591156000, 606877200, 622605600, 638326800, 654660000, 670381200, 686109600, 701830800, 717559200, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846381600, 859683600, 877831200, 891133200, 909280800, 922582800, 941335200, 954032400, 972784800, 985482000, 1004234400, 1017536400, 1035684000, 1048986000, 1067133600, 1080435600, 1099188000, 1111885200, 1130637600, 1143334800, 1162087200, 1174784400, 1193536800, 1206838800, 1224986400, 1238288400, 1256436000, 1269738000, 1288490400, 1301187600, 1319940000, 1332637200, 1351389600, 1364691600, 1382839200, 1396141200, 1414288800, 1427590800, 1445738400, 1459040400, 1477792800, 1490490000, 1509242400, 1521939600, 1540692000, 1553994000, 1572141600, 1585443600, 1603591200, 1616893200, 1635645600, 1648342800, 1667095200, 1679792400, 1698544800, 1711846800, 1729994400, 1743296400, 1761444000, 1774746000, 1792893600, 1806195600, 1824948000, 1837645200, 1856397600, 1869094800, 1887847200, 1901149200, 1919296800, 1932598800],
        offset: [-2205, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 7200, 3600, 0, 3600, 7200, 3600, 0, 3600, 7200, 3600, 0, 3600, 7200, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0]
      },
      "Europe/Dublin": {
        time: [-2821651200, -1691964000, -1680469200, -1664143200, -1650142800, -1633903200, -1617483600, -1601848800, -1586034000, -1570399200, -1552165200, -1538344800, -1522530000, -1507500000, -1490562000, -1473631200, -1460926800, -1442786400, -1428872400, -1410732000, -1396213200, -1379282400, -1364763600, -1348437600, -1333314000, -1315778400, -1301259600, -1284328800, -1269810000, -1253484000, -1238360400, -1221429600, -1206910800, -1189980000, -1175461200, -1159135200, -1143406800, -1126476000, -1111957200, -1095631200, -1080507600, -1063576800, -1049058000, -1032127200, -1017608400, -1001282400, -986158800, -969228000, -950475600, -942012000, -733352400, -719445600, -699483600, -684972000, -668034000, -654732000, -636584400, -622072800, -605739600, -590623200, -574290000, -558568800, -542235600, -527119200, -512600400, -496274400, -481150800, -464220000, -449701200, -432165600, -417646800, -401320800, -386197200, -369266400, -354747600, -337816800, -323298000, -306972000, -291848400, -276732000, -257979600, -245282400, -226530000, -213228000, -195080400, -182383200, -163630800, -150933600, -132181200, -119484000, -100731600, -88034400, -68677200, -59004000, 57726000, 69818400, 89175600, 101268000, 120625200, 132717600, 152074800, 164167200, 183524400, 196221600, 214974000, 227671200, 246423600, 259120800, 278478000, 290570400, 309927600, 322020000, 341377200, 354675600, 372823200, 386125200, 404272800, 417574800, 435722400, 449024400, 467776800, 481078800, 499226400, 512528400, 530676000, 543978000, 562125600, 575427600, 593575200, 606877200, 625629600, 638326800, 657079200, 670381200, 688528800, 701830800, 719978400, 733280400, 751428000, 764730000, 782877600, 796179600, 814327200, 828234000, 846381600, 859683600, 877831200, 891133200, 909280800, 922582800, 941335200, 954032400, 972784800, 985482000, 1004234400, 1017536400, 1035684000, 1048986000, 1067133600, 1080435600, 1099188000, 1111885200, 1130637600, 1143334800, 1162087200, 1174784400, 1193536800, 1206838800, 1224986400, 1238288400, 1256436000, 1269738000, 1288490400, 1301187600, 1319940000, 1332637200, 1351389600, 1364691600, 1382839200, 1396141200, 1414288800, 1427590800, 1445738400, 1459040400, 1477792800, 1490490000, 1509242400, 1521939600, 1540692000, 1553994000, 1572141600, 1585443600, 1603591200, 1616893200, 1635645600, 1648342800, 1667095200, 1679792400, 1698544800, 1711846800, 1729994400, 1743296400, 1761444000, 1774746000, 1792893600, 1806195600, 1824948000, 1837645200, 1856397600, 1869094800, 1887847200, 1901149200, 1919296800, 1932598800],
        offset: [-1521, -1521, 2079, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0, 3600, 0]
      },
      "Europe/Oslo": {
        time: [-2366755200, -1691881200, -1680566400, -927507600, -857250000, -844552800, -828219600, -812498400, -796770000, -781048800, -765320400, -340840800, -324507600, -308786400, -293058000, -277336800, -261608400, -245887200, -230158800, -214437600, -198709200, -182988000, -166654800, -147909600, -135205200, 323834400, 338958000, 354679200, 370407600, 386128800, 401857200, 417578400, 433306800, 449028000, 465361200, 481082400, 496810800, 512532000, 528260400, 543981600, 559710000, 575431200, 591159600, 606880800, 622609200, 638330400, 654663600, 670384800, 686113200, 701834400, 717562800, 733284000, 749012400, 764733600, 780462000, 796183200, 811911600, 828237600, 846385200, 859687200, 877834800, 891136800, 909284400, 922586400, 941338800, 954036000, 972788400, 985485600, 1004238000, 1017540000, 1035687600, 1048989600, 1067137200, 1080439200, 1099191600, 1111888800, 1130641200, 1143338400, 1162090800, 1174788000, 1193540400, 1206842400, 1224990000, 1238292000, 1256439600, 1269741600, 1288494000, 1301191200, 1319943600, 1332640800, 1351393200, 1364695200, 1382842800, 1396144800, 1414292400, 1427594400, 1445742000, 1459044000, 1477796400, 1490493600, 1509246000, 1521943200, 1540695600, 1553997600, 1572145200, 1585447200, 1603594800, 1616896800, 1635649200, 1648346400, 1667098800, 1679796000, 1698548400, 1711850400, 1729998000, 1743300000, 1761447600, 1774749600, 1792897200, 1806199200, 1824951600, 1837648800, 1856401200, 1869098400, 1887850800, 1901152800, 1919300400, 1932602400],
        offset: [2580, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600, 7200, 3600]
      },
      "Atlantic/Azores": {
        time: [-2713910400, -1830383672, -1689555600, -1677798000, -1667437200, -1647734400, -1635814800, -1616198400, -1604365200, -1584662400, -1572742800, -1553040000, -1541206800, -1521504000, -1442451600, -1426809600, -1379293200, -1364774400, -1348448400, -1333324800, -1316394000, -1301270400, -1284339600, -1269820800, -1221440400, -1206921600, -1191200400, -1175472000, -1127696400, -1111968000, -1096851600, -1080518400, -1063587600, -1049068800, -1033347600, -1017619200, -1002502800, -986169600, -969238800, -950486400, -942022800, -922665600, -906944400, -891129600, -877309200, -873680400, -864000000, -857952000, -845859600, -842835600, -831340800, -825897600, -814410000, -810781200, -799891200, -794448000, -782960400, -779331600, -768441600, -762998400, -749091600, -733363200, -717631200, -701902800, -686181600, -670453200, -654732000, -639003600, -623282400, -607554000, -591832800, -575499600, -559778400, -544050000, -528328800, -512600400, -496879200, -481150800, -465429600, -449701200, -433980000, -417646800, -401925600, -386197200, -370476000, -354747600, -339026400, -323298000, -307576800, -291848400, -276127200, -260398800, -244677600, -228344400, -212623200, -196894800, -181173600, -165445200, -149724000, -133995600, -118274400, 228268800, 243997200, 260323200, 276051600, 291772800, 307504800, 323222400, 338954400, 354675600, 370404000, 386125200, 401853600, 417578400, 433303200, 449024400, 465357600, 481078800, 496807200, 512528400, 528256800, 543978000, 559706400, 575427600, 591156000, 606877200, 622605600, 638326800, 654660000, 670381200, 686109600, 701830800, 717559200, 733280400, 749005200, 764726400, 780454800, 796176000, 811904400, 828230400, 846378000, 859680000, 877827600, 891129600, 909277200, 922579200, 941331600, 954028800, 972781200, 985478400, 1004230800, 1017532800, 1035680400, 1048982400, 1067130000, 1080432000, 1099184400, 1111881600, 1130634000, 1143331200, 1162083600, 1174780800, 1193533200, 1206835200, 1224982800, 1238284800, 1256432400, 1269734400, 1288486800, 1301184000, 1319936400, 1332633600, 1351386000, 1364688000, 1382835600, 1396137600, 1414285200, 1427587200, 1445734800, 1459036800, 1477789200, 1490486400, 1509238800, 1521936000, 1540688400, 1553990400, 1572138000, 1585440000, 1603587600, 1616889600, 1635642000, 1648339200, 1667091600, 1679788800, 1698541200, 1711843200, 1729990800, 1743292800, 1761440400, 1774742400, 1792890000, 1806192000, 1824944400, 1837641600, 1856394000, 1869091200, 1887843600, 1901145600, 1919293200, 1932595200],
        offset: [-6160, -6872, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, 0, -3600, -7200, -3600, 0, -3600, -7200, -3600, 0, -3600, -7200, -3600, 0, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, -7200, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, 0, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600, 0, -3600]
      }
    };
  },
  1640: (e, t, i) => {
    "use strict";

    i.d(t, {
      Version: () => o
    });
    var s = i(50151);
    class o {
      constructor(e, t) {
        this._major = e;
        this._minor = t;
      }
      major() {
        return this._major;
      }
      minor() {
        return this._minor;
      }
      isZero() {
        return this._major === 0 && this._minor === 0;
      }
      toString() {
        return this._major + "." + this._minor;
      }
      compareTo(e) {
        if (this._major < e._major) {
          return -1;
        } else if (this._major > e._major) {
          return 1;
        } else if (this._minor < e._minor) {
          return -1;
        } else if (this._minor > e._minor) {
          return 1;
        } else {
          return 0;
        }
      }
      isLess(e) {
        return this.compareTo(e) < 0;
      }
      isLessOrEqual(e) {
        return this.compareTo(e) <= 0;
      }
      isEqual(e) {
        return this.compareTo(e) === 0;
      }
      isGreater(e) {
        return this.compareTo(e) > 0;
      }
      isGreaterOrEqual(e) {
        return this.compareTo(e) >= 0;
      }
      static parse(e) {
        if (e instanceof o) {
          return new o(e.major(), e.minor());
        }
        if (typeof e == "number") {
          (0, s.assert)(Math.floor(e) === e, "Version should not be a float number");
          return new o(e, 0);
        }
        if (typeof e == "string") {
          const t = e.split(".");
          if (t.length === 1) {
            const i = parseInt(t[0], 10);
            (0, s.assert)(!isNaN(i), "Bad version string: " + e);
            return new o(i, 0);
          }
          if (t.length === 2) {
            const i = parseInt(t[0], 10);
            (0, s.assert)(!isNaN(i), "Bad version string: " + e);
            const n = parseInt(t[1], 10);
            (0, s.assert)(!isNaN(n), "Bad version string: " + e);
            return new o(i, n);
          }
          throw new Error("Bad version string (one dot expected): " + e);
        }
        throw new Error("Bad version: " + e);
      }
    }
    o.ZERO = new o(0, 0);
  },
  64147: (e, t, i) => {
    "use strict";

    i.d(t, {
      WatchedValue: () => n
    });
    const s = (0, i(9343).getLogger)("Common.WatchedValue");
    function o(e) {
      s.logError(`${e && (e.stack || e.message)}`);
    }
    class n {
      constructor(...e) {
        this._listeners = [];
        if (e.length > 0) {
          this._value = e[0];
        }
      }
      destroy() {
        this.unsubscribe();
      }
      value() {
        if (this._owner) {
          return this._owner._value;
        } else {
          return this._value;
        }
      }
      setValue(e, t) {
        const i = this._owner ? this._owner : this;
        if (i.writeLock) {
          return;
        }
        const s = i._value === e || Number.isNaN(i._value) && Number.isNaN(e);
        if (!t && s && i.hasOwnProperty("_value")) {
          return;
        }
        i._value = e;
        const n = i._listeners.slice();
        let r = 0;
        for (let t = 0; t < n.length; t++) {
          if (n[t].once) {
            i._listeners.splice(t - r, 1);
            r++;
          }
          try {
            n[t].cb(e);
          } catch (e) {
            o(e);
          }
        }
      }
      deleteValue() {
        this.setValue(undefined);
      }
      subscribe(e, t) {
        if (typeof e != "function") {
          throw new TypeError("callback must be a function");
        }
        const i = !!t && !!t.once;
        const s = !!t && !!t.callWithLast;
        const n = this._owner ? this._owner : this;
        if (s && n.hasOwnProperty("_value")) {
          try {
            e(n._value);
          } catch (e) {
            o(e);
          }
          if (i) {
            return;
          }
        }
        n._listeners.push({
          cb: e,
          owner: this,
          once: !!t && !!t.once
        });
      }
      unsubscribe(e) {
        const t = this._owner ? this._owner : this;
        if (e === undefined) {
          e = null;
        }
        const i = t._listeners;
        for (let s = i.length; s--;) {
          if ((i[s].owner === this || t === this) && (i[s].cb === e || e === null)) {
            i.splice(s, 1);
          }
        }
      }
      readonly() {
        if (this._readonlyInstance) {
          return this._readonlyInstance;
        }
        const e = {
          subscribe: this.subscribe.bind(this),
          unsubscribe: this.unsubscribe.bind(this),
          value: this.value.bind(this),
          when: this.when.bind(this),
          ownership: this.ownership.bind(this),
          spawnOwnership: this.spawnOwnership.bind(this),
          weakReference: this.weakReference.bind(this),
          spawn: e => this.spawn(e).readonly(),
          destroy: this.destroy.bind(this)
        };
        this._readonlyInstance = e;
        return e;
      }
      spawn(e) {
        return this._spawn(e);
      }
      when(e) {
        (function (e, t, i) {
          if (t(e.value())) {
            i();
            return;
          }
          const s = o => {
            if (t(o)) {
              e.unsubscribe(s);
              i();
            }
          };
          e.subscribe(s, {
            callWithLast: true
          });
        })(this, e => Boolean(e), () => {
          try {
            e(this.value());
          } catch (e) {
            o(e);
          }
        });
      }
      assertNoSubscriptions() {
        0;
      }
      ownership() {
        return this;
      }
      release() {
        this.destroy();
      }
      spawnOwnership() {
        return this._spawn();
      }
      weakReference() {
        return this._spawn(undefined, true);
      }
      _spawn(e, t) {
        return new r(this._owner || this, e, t);
      }
    }
    class r extends n {
      constructor(e, t, i) {
        super();
        delete this._listeners;
        this._owner = e;
        this._onDestroy = t;
        this._weakReference = !!i;
      }
      destroy() {
        try {
          this._onDestroy?.();
        } catch (e) {
          o(e);
        }
        super.destroy();
      }
      readonly() {
        return super.readonly();
      }
      release() {
        if (!this._weakReference) {
          super.release();
        }
      }
    }
  },
  91676: (e, t, i) => {
    "use strict";

    i.d(t, {
      WatchedObject: () => r
    });
    var s = i(64147);
    var o = i(37265);
    function n(e, t) {
      return (0, o.deepEquals)(e, t)[0];
    }
    class r extends s.WatchedValue {
      constructor(e, t = n) {
        super(e);
        this._comparator = t;
      }
      setValue(e, t) {
        if (t || this._comparator(this.value(), e) === false) {
          super.setValue(e, t);
        }
      }
    }
  },
  7047: (e, t, i) => {
    "use strict";

    i.d(t, {
      MouseClickAutoBlurHandler: () => r,
      initMouseClickAutoBlurHandler: () => a
    });
    var s = i(81251);
    var o = i(76460);
    const n = "data-mouse-click-auto-blur";
    class r {
      constructor() {
        this._handler = e => {
          if (document.activeElement instanceof HTMLElement) {
            if (!(0, o.isKeyboardClick)(e)) {
              if (e.target instanceof Element && document.activeElement.tagName !== "INPUT" && document.activeElement.closest(`[${n}]`) !== null) {
                document.activeElement.blur();
              }
            }
          }
        };
        window.addEventListener("click", this._handler, true);
      }
      static attributes(e = true) {
        if (e) {
          return {
            [n]: true
          };
        } else {
          return {};
        }
      }
    }
    const a = (0, s.default)(() => new r());
  },
  19291: (e, t, i) => {
    "use strict";

    i.d(t, {
      mapKeyCodeToDirection: () => h,
      navigationOrderComparator: () => r,
      queryFocusableElements: () => l,
      queryTabbableElements: () => a,
      updateTabIndexes: () => c
    });
    var s;
    var o = i(63273);
    var n = i(15754);
    function r(e, t) {
      if (e === t) {
        return 0;
      } else if (e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING) {
        return -1;
      } else {
        return 1;
      }
    }
    function a(e) {
      return Array.from(e.querySelectorAll("button:not([disabled]):not([aria-disabled]):not([tabindex=\"-1\"]), [tabindex]:not([disabled]):not([aria-disabled]):not([tabindex=\"-1\"])")).filter((0, n.createScopedVisibleElementFilter)(e));
    }
    function l(e) {
      return Array.from(e.querySelectorAll("button:not([disabled]):not([aria-disabled=\"true\"]):not([aria-disabled=\"\"]), [tabindex]:not([disabled]):not([aria-disabled=\"true\"]):not([aria-disabled=\"\"])")).filter((0, n.createScopedVisibleElementFilter)(e));
    }
    function c() {
      window.dispatchEvent(new CustomEvent("keyboard-navigation-activation", {
        bubbles: true
      }));
    }
    function h(e) {
      const t = (0, o.isRtl)();
      switch (e) {
        case 38:
          return "blockPrev";
        case 40:
          return "blockNext";
        case 37:
          if (t) {
            return "inlineNext";
          } else {
            return "inlinePrev";
          }
        case 39:
          if (t) {
            return "inlinePrev";
          } else {
            return "inlineNext";
          }
        default:
          return null;
      }
    }
    (function (e) {
      e.BlockPrev = "blockPrev";
      e.BlockNext = "blockNext";
      e.InlinePrev = "inlinePrev";
      e.InlineNext = "inlineNext";
    })(s ||= {});
  },
  27235: (e, t, i) => {
    "use strict";

    i.d(t, {
      TOOLBAR_WIDTH_COLLAPSED: () => o,
      TOOLBAR_WIDTH_EXPANDED: () => s
    });
    const s = 52;
    const o = 5;
  },
  6307: (e, t, i) => {
    "use strict";

    i.d(t, {
      isDrawingToolbarVisible: () => l
    });
    var s = i(56840);
    var o = i(56570);
    var n = i(64147);
    const r = !o.enabled("hide_left_toolbar_by_default");
    const a = s.getBool("ChartDrawingToolbarWidget.visible", r);
    const l = new n.WatchedValue(a);
  },
  72894: (e, t, i) => {
    "use strict";

    i.d(t, {
      HEADER_TOOLBAR_HEIGHT_COLLAPSED: () => n,
      HEADER_TOOLBAR_HEIGHT_EXPANDED: () => o
    });
    var s = i(61223);
    const o = parseInt(s["css-value-header-toolbar-height"]);
    const n = 3;
  },
  27514: (e, t, i) => {
    "use strict";

    i.d(t, {
      shouldShowQuickSearchOnLib: () => r
    });
    var s = i(49483);
    var o = i(84015);
    var n = i(56570);
    function r() {
      return !s.CheckMobile.any() && !(0, o.isOnMobileAppPage)("any") && !n.enabled("widget") && n.enabled("header_quick_search");
    }
  },
  81199: (e, t, i) => {
    "use strict";

    i.d(t, {
      ActionWithStandardIcon: () => n
    });
    var s = i(29023);
    var o = i(67375);
    class n extends s.Action {
      constructor(e) {
        const {
          options: t,
          customActionOptions: i
        } = e;
        if (t.iconId) {
          t.icon = t.icon ?? o.icons.get(t.iconId);
        }
        if (i && i.iconId) {
          i.icon = i.icon ?? o.icons.get(i.iconId);
        }
        super(e);
      }
    }
  },
  29023: (e, t, i) => {
    "use strict";

    i.d(t, {
      Action: () => c,
      Separator: () => h
    });
    var s;
    var o = i(50151);
    var n = i(68335);
    var r = i(92184);
    var a = i(52033);
    class l extends a.Delegate {
      constructor(e) {
        super();
        this._onStartListening = null;
        this._onStopListening = null;
        this._onStartListening = e || null;
      }
      subscribe(e, t, i) {
        const s = this._listeners.length === 0;
        super.subscribe(e, t, i);
        if (s && this._listeners.length > 0 && this._onStartListening) {
          this._onStopListening = this._onStartListening();
        }
      }
      unsubscribe(e, t) {
        const i = this._listeners.length === 0;
        super.unsubscribe(e, t);
        if (!i && this._listeners.length === 0 && this._onStopListening) {
          this._onStopListening();
          this._onStopListening = null;
        }
      }
      unsubscribeAll(e) {
        const t = this._listeners.length === 0;
        super.unsubscribeAll(e);
        if (!t && this._listeners.length === 0 && this._onStopListening) {
          this._onStopListening();
          this._onStopListening = null;
        }
      }
      destroy() {
        if (this._onStopListening) {
          this._onStopListening();
          this._onStopListening = null;
        }
        super.destroy();
      }
    }
    (function (e) {
      e.Normal = "normal";
      e.Big = "big";
    })(s ||= {});
    class c {
      constructor(e) {
        this.type = "action";
        this._destroyed = false;
        this._loadOptionsPromise = null;
        this._customAction = null;
        const {
          actionId: t,
          options: i,
          optionsLoader: s,
          customActionOptions: n,
          customActionOptionsLoader: a,
          id: h = r.guid(),
          onStartListening: d
        } = e;
        (0, o.assert)(t !== undefined, "actionId must be defined");
        this.id = h;
        this._onUpdate = new l(d);
        this._options = {
          actionId: t,
          ...i
        };
        this.update(i);
        this._loadOptionsGetter = s ?? null;
        if (this._loadOptionsGetter) {
          this._options.loading = true;
        }
        if (n) {
          this._customAction = new c({
            actionId: t,
            options: n,
            optionsLoader: a,
            id: h
          });
        }
      }
      custom() {
        return this._customAction;
      }
      execute() {
        if (this._options.checkable) {
          this.update({
            checked: !this._options.checked
          });
        }
        if (this._options.onExecute) {
          this._options.onExecute(this);
        }
      }
      getLabel() {
        return this._options.label || "";
      }
      getSubItems() {
        return this._options.subItems || [];
      }
      isDisabled() {
        return this._options.disabled === true;
      }
      isActive() {
        return this._options.active === true;
      }
      isCheckable() {
        return this._options.checkable === true;
      }
      isChecked() {
        return this._options.checked === true;
      }
      isLoading() {
        return this._options.loading === true;
      }
      loadOptions() {
        if (this._loadOptionsPromise) {
          return this._loadOptionsPromise;
        } else if (this._loadOptionsGetter) {
          this._loadOptionsPromise = this._loadOptionsGetter().then(e => this.update({
            ...e,
            loading: false
          }));
          return this._loadOptionsPromise;
        } else {
          return null;
        }
      }
      getSize() {
        return this._options.size ?? "normal";
      }
      getPayload() {
        return this._options.payload;
      }
      update(e) {
        if (!this._destroyed) {
          this._unbindShortcut();
          if (e.hotkeyHash) {
            this._options.shortcutHint = (0, n.humanReadableHash)(e.hotkeyHash);
          }
          this._options = Object.assign(this._options, e);
          this._bindShortcut();
          this._onUpdate.fire(this);
        }
      }
      onUpdate() {
        return this._onUpdate;
      }
      getState() {
        this.loadOptions();
        return {
          actionId: this._options.actionId,
          label: this.getLabel(),
          styledLabel: this._options.styledLabel,
          disabled: this.isDisabled(),
          active: this.isActive(),
          subItems: this.getSubItems(),
          checkable: this.isCheckable(),
          checked: this.isChecked(),
          loading: this.isLoading(),
          size: this.getSize(),
          doNotCloseOnClick: this._options.doNotCloseOnClick || false,
          shortcutHint: this._options.shortcutHint,
          hint: this._options.hint,
          icon: this._options.icon,
          iconId: this._options.iconId,
          iconChecked: this._options.iconChecked,
          toolbox: this._options.toolbox,
          showToolboxOnHover: this._options.showToolboxOnHover || false,
          statName: this._options.statName,
          name: this._options.name,
          invisibleHotkey: this._options.invisibleHotkey,
          noInteractive: this._options.noInteractive,
          jsxLabel: "jsxLabel" in this._options ? this._options.jsxLabel : undefined,
          isRepeatAccepted: this._options.isRepeatAccepted
        };
      }
      destroy() {
        this._destroyed = true;
        this._onUpdate.destroy();
        this._unbindShortcut();
        this._options.onDestroy?.();
        this._customAction?.destroy();
      }
      options() {
        return this._options;
      }
      _bindShortcut() {
        if (!this._options.hotkeyGroup || !this._options.hotkeyHash) {
          return;
        }
        const e = typeof this._options.label == "string" ? this._options.label : this._options.name;
        this._hotkeyAction = this._options.hotkeyGroup.add({
          hotkey: this._options.hotkeyHash,
          isRepeatAccepted: this._options.isRepeatAccepted,
          desc: e,
          handler: () => this.execute(),
          isDisabled: () => this.isDisabled()
        });
      }
      _unbindShortcut() {
        if (this._hotkeyAction) {
          this._hotkeyAction.destroy();
          delete this._hotkeyAction;
        }
      }
    }
    class h {
      constructor(e) {
        this.type = "separator";
        this.id = r.guid();
        this._hint = e;
      }
      getHint() {
        return this._hint;
      }
    }
  },
  67375: (e, t, i) => {
    "use strict";

    i.d(t, {
      icons: () => w
    });
    var s;
    var o = i(53573);
    var n = i(34369);
    var r = i(39267);
    var a = i(93544);
    var l = i(84959);
    var c = i(37924);
    var h = i(77067);
    var d = i(16911);
    var u = i(25191);
    var _ = i(54190);
    var p = i(6862);
    var m = i(97874);
    var g = i(2872);
    var f = i(29453);
    var y = i(94839);
    var v = i(5845);
    var S = i(1457);
    var b = i(93379);
    (function (e) {
      e.ChartShowDataWindow = "Chart.ShowDataWindow";
      e.ChartReset = "Chart.Reset";
      e.ChartRemoveSelectedObject = "Chart.RemoveSelectedObject";
      e.Settings = "Settings";
      e.ChartHide = "Chart.Hide";
      e.ChartSymbolInfo = "Chart.SymbolInfo";
      e.ChartFinancials = "Chart.Financials";
      e.ChartTechnicals = "Chart.Technicals";
      e.ChartDetailsMetrics = "Chart.DetailsMetrics";
      e.AlertAdd = "Alert.Add";
      e.AlertEdit = "Alert.Edit";
      e.AlertRestart = "Alert.Restart";
      e.AlertStop = "Alert.Stop";
      e.AlertEventsExport = "Alert.EventsExport";
      e.ClearAll = "Alert.Clear";
      e.ChartVisualOrder = "Chart.VisualOrder";
      e.ChartShowObject = "Chart.ShowObject";
      e.ChartPriceScale = "Chart.PriceScale";
      e.ChartMove = "Chart.Move";
      e.ChartApplyIndicator = "Chart.ApplyIndicator";
      e.ChartUnlockObject = "Chart.UnlockObject";
      e.ChartLockObject = "Chart.LockObject";
      e.ChartAnchorLineTool = "Chart.AnchorLineTool";
      e.ChartInsertRowTable = "Chart.InsertRowTable";
      e.ChartInsertColumnTable = "Chart.InsertColumnTable";
      e.ChartRemoveRowTable = "Chart.RemoveRowTable";
      e.ChartRemoveColumnTable = "Chart.RemoveColumnTable";
      e.ChartClone = "Chart.Clone";
      e.ChartAddHorzLine = "Chart.AddHorzLine";
      e.WatchlistAddSymbol = "Watchlist.AddSymbol";
      e.WatchlistCreateNew = "Watchlist.CreateNew";
      e.TextNoteAdd = "TextNote.Add";
      e.TradingSell = "Trading.Sell";
      e.TradingBuy = "Trading.Buy";
      e.ObjectsTreeCreateGroup = "ObjectsTree.CreateGroup";
      e.ObjectsTreeRenameItem = "ObjectsTree.RenameItem";
      e.IndicatorAddToFavorites = "Indicator.AddToFavorites";
    })(s ||= {});
    const w = new Map([["Chart.Reset", r], ["Chart.RemoveSelectedObject", a], ["Settings", n], ["Chart.Hide", l], ["Chart.SymbolInfo", c], ["Chart.VisualOrder", h], ["Chart.ShowObject", d], ["Chart.PriceScale", u], ["Chart.Move", _], ["Chart.ApplyIndicator", p], ["Chart.UnlockObject", m], ["Chart.LockObject", g], ["Chart.AnchorLineTool", f], ["Chart.InsertRowTable", y], ["Chart.InsertColumnTable", v], ["Chart.RemoveRowTable", a], ["Chart.RemoveColumnTable", a], ["Chart.Clone", S], ["Chart.AddHorzLine", b], ["Indicator.AddToFavorites", o]]);
  },
  56657: (e, t, i) => {
    "use strict";

    i.d(t, {
      ActionsProvider: () => st,
      createActionCopyPrice: () => Je,
      createActionToggleVisibilityDataSources: () => tt,
      createChangeIntervalsVisibilitiesAction: () => Xe,
      createLinesAction: () => Qe,
      createPasteAction: () => Ye,
      createSyncDrawingActions: () => et,
      createVisualOrderAction: () => Ze,
      defaultContextMenuOptions: () => Ke
    });
    var s = i(50151);
    var o = i(9343);
    i(60521);
    var n = i(37265);
    var r = i(11542);
    var a = i(56570);
    var l = i(29023);
    var c = i(96152);
    var h = i(19466);
    var d = i(79036);
    i(26023);
    var u = i(25149);
    var _ = i(28388);
    var p = i(68335);
    i(25812);
    var m = i(85604);
    var g = i(80387);
    var f = i(86920);
    var y = i(32755);
    var v = i(60074);
    var S = i(34585);
    var b = i(45126);
    i(928);
    var w = i(85049);
    var C = i(85719);
    var P = i(10892);
    var T = i(56616);
    var x = i(65383);
    var I = i(12988);
    var M = i(300);
    var A = i(81199);
    i(77336);
    (0, o.getLogger)("Chart.ActionsProvider");
    const L = new b.TranslatedString("change visibility", r.t(null, undefined, i(1924)));
    const k = new b.TranslatedString("pin to scale {label}", r.t(null, undefined, i(81566)));
    const D = new b.TranslatedString("pin to right scale", r.t(null, undefined, i(7495)));
    const E = new b.TranslatedString("pin to left scale", r.t(null, undefined, i(78690)));
    new b.TranslatedString("change earnings visibility", r.t(null, undefined, i(6819)));
    new b.TranslatedString("change dividends visibility", r.t(null, undefined, i(53929)));
    new b.TranslatedString("change splits visibility", r.t(null, undefined, i(47474)));
    new b.TranslatedString("change continuous contract switch visibility", r.t(null, undefined, i(18867)));
    new b.TranslatedString("change futures contract expiration visibility", r.t(null, undefined, i(85532)));
    new b.TranslatedString("change latest news and Minds visibility", r.t(null, undefined, i(50243)));
    const B = new b.TranslatedString("show all ideas", r.t(null, undefined, i(13336)));
    const V = new b.TranslatedString("show ideas of followed users", r.t(null, undefined, i(91395)));
    const R = new b.TranslatedString("show my ideas only", r.t(null, undefined, i(57460)));
    new b.TranslatedString("change events visibility on chart", r.t(null, undefined, i(6119)));
    const N = new b.TranslatedString("add this symbol to entire layout", r.t(null, undefined, i(79290)));
    const O = new b.TranslatedString("add this indicator to entire layout", r.t(null, undefined, i(96677)));
    new b.TranslatedString("add this strategy to entire layout", r.t(null, undefined, i(58156)));
    new b.TranslatedString("add this financial metric to entire layout", r.t(null, undefined, i(67608)));
    new b.TranslatedString("apply drawing template", r.t(null, undefined, i(89720)));
    const F = new b.TranslatedString("lock objects", r.t(null, undefined, i(18942)));
    const W = new b.TranslatedString("unlock objects", r.t(null, undefined, i(23230)));
    const H = new b.TranslatedString("anchor objects", r.t(null, undefined, i(63869)));
    const z = new b.TranslatedString("unanchor objects", r.t(null, undefined, i(99234)));
    const U = new b.TranslatedString("change visibility at current interval and above", r.t(null, undefined, i(45800)));
    const j = new b.TranslatedString("change visibility at current interval and below", r.t(null, undefined, i(75645)));
    const G = new b.TranslatedString("change visibility at current interval", r.t(null, undefined, i(84331)));
    const q = new b.TranslatedString("change visibility at all intervals", r.t(null, undefined, i(57916)));
    r.t(null, undefined, i(66823));
    (0, S.appendEllipsis)(r.t(null, undefined, i(264)));
    const $ = r.t(null, undefined, i(98334));
    const K = r.t(null, undefined, i(27298));
    const Y = r.t(null, undefined, i(3564));
    const Z = r.t(null, undefined, i(94559));
    const X = r.t(null, undefined, i(2165));
    const J = r.t(null, undefined, i(16986));
    const Q = r.t(null, undefined, i(12645));
    const ee = r.t(null, undefined, i(44579));
    const te = r.t(null, undefined, i(29436));
    const ie = r.t(null, undefined, i(81054));
    const se = r.t(null, undefined, i(32538));
    const oe = r.t(null, undefined, i(72046));
    const ne = r.t(null, undefined, i(90095));
    const re = r.t(null, undefined, i(14115));
    const ae = r.t(null, undefined, i(33110));
    const le = r.t(null, undefined, i(28280));
    const ce = r.t(null, undefined, i(76150));
    const he = r.t(null, undefined, i(94210));
    const de = r.t(null, undefined, i(60035));
    const ue = r.t(null, undefined, i(10761));
    const _e = r.t(null, undefined, i(11254));
    const pe = r.t(null, undefined, i(35049));
    const me = r.t(null, undefined, i(19271));
    const ge = r.t(null, undefined, i(15512));
    const fe = r.t(null, undefined, i(46545));
    const ye = r.t(null, undefined, i(52160));
    const ve = r.t(null, undefined, i(17293));
    const Se = r.t(null, undefined, i(21973));
    const be = r.t(null, undefined, i(55481));
    const we = r.t(null, undefined, i(71179));
    const Ce = r.t(null, undefined, i(4077));
    const Pe = r.t(null, undefined, i(54853));
    const Te = r.t(null, undefined, i(20177));
    const xe = r.t(null, undefined, i(494));
    const Ie = r.t(null, undefined, i(60668));
    const Me = r.t(null, undefined, i(58026));
    const Ae = r.t(null, undefined, i(56982));
    (0, S.appendEllipsis)(r.t(null, undefined, i(35088)));
    (0, S.appendEllipsis)(r.t(null, undefined, i(2439)));
    const Le = (0, S.appendEllipsis)(r.t(null, undefined, i(32514)));
    r.t(null, undefined, i(78358));
    (0, S.appendEllipsis)(r.t(null, undefined, i(76266)));
    const ke = r.t(null, undefined, i(49680));
    const De = r.t(null, undefined, i(12537));
    r.t(null, undefined, i(93553));
    const Ee = r.t(null, undefined, i(74975));
    const Be = r.t(null, undefined, i(99894));
    const Ve = r.t(null, undefined, i(51077));
    const Re = r.t(null, undefined, i(24185));
    r.t(null, undefined, i(37113));
    r.t(null, undefined, i(29449));
    r.t(null, undefined, i(50849));
    r.t(null, undefined, i(33158));
    r.t(null, undefined, i(81465));
    r.t(null, undefined, i(62986));
    const Ne = r.t(null, undefined, i(55418));
    const Oe = r.t(null, undefined, i(10261));
    const Fe = r.t(null, undefined, i(44020));
    (0, S.appendEllipsis)(r.t(null, undefined, i(32514)));
    r.t(null, undefined, i(97878));
    const We = r.t(null, undefined, i(39010));
    const He = r.t(null, undefined, i(26090));
    r.t(null, undefined, i(95754));
    r.t(null, undefined, i(35679));
    r.t(null, undefined, i(9140));
    r.t(null, undefined, i(46607));
    r.t(null, undefined, i(39079));
    const ze = (0, S.appendEllipsis)(r.t(null, undefined, i(75594)));
    const Ue = (0, S.appendEllipsis)(r.t(null, undefined, i(88853)));
    const je = r.t(null, undefined, i(35140));
    const Ge = r.t(null, undefined, i(63553));
    const qe = r.t(null, undefined, i(92957));
    const $e = r.t(null, undefined, i(58764));
    r.t(null, undefined, i(10996));
    r.t(null, undefined, i(3061));
    const Ke = {
      general: true,
      mainSeries: true,
      mainSeriesTrade: false,
      esdStudies: true,
      studies: true,
      fundamentals: true,
      lineTools: true,
      publishedCharts: true,
      ordersAndPositions: true,
      alerts: true,
      chartEvents: true,
      objectTree: true,
      gotoLineTool: false
    };
    function Ye(e, t) {
      if (!t.isEmpty() && a.enabled("datasource_copypaste")) {
        return new A.ActionWithStandardIcon({
          actionId: "Chart.Clipboard.PasteSource",
          options: {
            label: je.trim(),
            shortcutHint: (0, p.humanReadableHash)(p.Modifiers.Mod + 86),
            statName: "Paste",
            onExecute: () => e.chartWidgetCollection().clipboard.uiRequestPaste(t)
          }
        });
      } else {
        return null;
      }
    }
    function Ze(e, t) {
      const i = e.model();
      const s = i.availableZOrderOperations(t);
      const o = [new A.ActionWithStandardIcon({
        actionId: "Chart.Source.VisualOrder.BringToFront",
        options: {
          label: ve,
          statName: "BringToFront",
          disabled: !s.bringToFrontEnabled,
          onExecute: () => i.bringToFront(t)
        }
      }), new A.ActionWithStandardIcon({
        actionId: "Chart.Source.VisualOrder.SendToBack",
        options: {
          label: Se,
          statName: "SendToBack",
          disabled: !s.sendToBackEnabled,
          onExecute: () => i.sendToBack(t)
        }
      }), new A.ActionWithStandardIcon({
        actionId: "Chart.Source.VisualOrder.BringForward",
        options: {
          label: be,
          statName: "BringForward",
          disabled: !s.bringForwardEnabled,
          onExecute: () => i.bringForward(t)
        }
      }), new A.ActionWithStandardIcon({
        actionId: "Chart.Source.VisualOrder.SendBackward",
        options: {
          label: we,
          statName: "SendBackward",
          disabled: !s.sendBackwardEnabled,
          onExecute: () => i.sendBackward(t)
        }
      })];
      return new A.ActionWithStandardIcon({
        actionId: "Chart.Source.VisualOrder",
        options: {
          label: Ce,
          iconId: "Chart.VisualOrder",
          statName: "VisualOrder",
          subItems: o
        }
      });
    }
    function Xe(e, t) {
      const i = e.model();
      const s = (e, s) => {
        const o = w.Interval.parse(i.mainSeries().interval());
        const n = (0, P.getIntervalsVisibilitiesForMode)(o, e);
        const r = [];
        const a = [];
        t.forEach(e => {
          const t = e.properties().intervalsVisibilities.childs();
          r.push(t.ticks);
          a.push(n.ticks);
          r.push(t.seconds);
          a.push(n.seconds);
          r.push(t.secondsFrom);
          a.push(n.secondsFrom);
          r.push(t.secondsTo);
          a.push(n.secondsTo);
          r.push(t.minutes);
          a.push(n.minutes);
          r.push(t.minutesFrom);
          a.push(n.minutesFrom);
          r.push(t.minutesTo);
          a.push(n.minutesTo);
          r.push(t.hours);
          a.push(n.hours);
          r.push(t.hoursFrom);
          a.push(n.hoursFrom);
          r.push(t.hoursTo);
          a.push(n.hoursTo);
          r.push(t.days);
          a.push(n.days);
          r.push(t.daysFrom);
          a.push(n.daysFrom);
          r.push(t.daysTo);
          a.push(n.daysTo);
          r.push(t.weeks);
          a.push(n.weeks);
          r.push(t.weeksFrom);
          a.push(n.weeksFrom);
          r.push(t.weeksTo);
          a.push(n.weeksTo);
          r.push(t.months);
          a.push(n.months);
          r.push(t.monthsFrom);
          a.push(n.monthsFrom);
          r.push(t.monthsTo);
          a.push(n.monthsTo);
          r.push(t.ranges);
          a.push(n.ranges);
        });
        i.setProperties(r, a, s, (0, M.sourcesAffectState)(t));
      };
      const o = [new A.ActionWithStandardIcon({
        actionId: "Chart.Source.IntervalsVisibility.CurrentAndAbove",
        options: {
          label: Te,
          statName: "currentAndAboveIntervals",
          onExecute: () => s(3, U)
        }
      }), new A.ActionWithStandardIcon({
        actionId: "Chart.Source.IntervalsVisibility.CurrentAndBelow",
        options: {
          label: xe,
          statName: "currentAndBelowIntervals",
          onExecute: () => s(2, j)
        }
      }), new A.ActionWithStandardIcon({
        actionId: "Chart.Source.IntervalsVisibility.Current",
        options: {
          label: Ie,
          statName: "currentInterval",
          onExecute: () => s(1, G)
        }
      }), new A.ActionWithStandardIcon({
        actionId: "Chart.Source.IntervalsVisibility.All",
        options: {
          label: Me,
          statName: "allIntervals",
          onExecute: () => s(0, q)
        }
      })];
      return new A.ActionWithStandardIcon({
        actionId: "Chart.Source.IntervalsVisibility",
        options: {
          label: Pe,
          statName: "IntervalsVisibility",
          subItems: o
        }
      });
    }
    function Je(e, t) {
      const i = e.defaultPriceScale();
      const s = t !== undefined ? i.coordinateToPrice(t, e.mainDataSource()?.firstValue() ?? 0) : e.model().mainSeries().lastValueData(4, true, true).price;
      const o = e.mainDataSource()?.formatter();
      if (s === undefined || !o) {
        return null;
      }
      const n = o.format(s);
      const r = o.format(s, {
        ignoreLocaleNumberFormat: true
      });
      return new A.ActionWithStandardIcon({
        actionId: "Chart.Clipboard.CopyPrice",
        options: {
          label: `${Ge} ${n}`,
          statName: "CopyPrice",
          onExecute: () => (0, T.getClipboard)().writeText(r)
        }
      });
    }
    function Qe(e) {
      const t = e.actions();
      const i = [t.showPriceLine];
      i.push(t.showHighLowPriceLines);
      if (a.enabled("show_average_close_price_line_and_label")) {
        i.push(t.showAverageClosePriceLine);
      }
      return new A.ActionWithStandardIcon({
        actionId: "Chart.Lines",
        options: {
          label: Ae,
          statName: "Lines",
          subItems: i
        }
      });
    }
    function et(e, t) {
      return [];
    }
    function tt(e, t) {
      const i = t[0].properties().visible.value();
      const s = i ? K : $;
      const o = i ? "Chart.Hide" : "Chart.ShowObject";
      const n = i ? "Chart.SelectedObject.Hide" : "Chart.SelectedObject.Show";
      return new A.ActionWithStandardIcon({
        actionId: n,
        options: {
          checkable: true,
          statName: "ToggleVisibilitySelectedObject",
          label: s,
          iconId: o,
          onExecute: () => {
            const s = e.model();
            s.withMacro(L, () => {
              t.forEach(e => {
                s.setProperty(e.properties().visible, !i, L, C.lineToolsDoNotAffectChartInvalidation && (0, y.isLineTool)(e));
              });
            });
          }
        }
      });
    }
    var it;
    (function (e) {
      e.Copy = "Copy";
    })(it ||= {});
    class st {
      constructor(e, t) {
        this._chartWidget = e;
        this._options = (0, n.merge)((0, n.clone)(Ke), t || {});
      }
      async contextMenuActionsForSources(e, t, i, o, n) {
        const r = e[0];
        const a = this._options;
        const c = [];
        if (r === this._chartWidget.model().mainSeries() && a.mainSeries) {
          c.push(...(await this._contextMenuActionsForSeries(r, i)));
        } else if ((0, d.isStudy)(r) && a.studies) {
          c.push(...(await this._contextMenuActionsForStudy(r, (0, s.ensureDefined)(t), i)));
        } else if ((0, y.isLineTool)(r) && a.lineTools) {
          const t = e.filter(y.isLineTool);
          c.push(...(await this._contextMenuActionsForLineTool(t)));
        } else {
          0;
        }
        if (c.length && n?.length) {
          c.push(new l.Separator());
        }
        c.push(...(n ?? []));
        return c;
      }
      async actionForLineTools(e, t) {
        switch (t) {
          case "Chart.SelectedObject.ToggleAnchored":
            return this._createActionToggleAnchorLineTools(e);
          case "Chart.SelectedObject.InsertRowTable":
            {
              if (e.length !== 1) {
                return null;
              }
              const t = e[0];
              return ((await t.additionalActions?.(this._chartWidget.model()))?.actions ?? []).filter(e => e.type === "action" && e.getState().actionId === "Chart.SelectedObject.InsertRowTable")[0] ?? null;
            }
          case "Chart.SelectedObject.InsertColumnTable":
            {
              if (e.length !== 1) {
                return null;
              }
              const t = e[0];
              return ((await t.additionalActions?.(this._chartWidget.model()))?.actions ?? []).filter(e => e.type === "action" && e.getState().actionId === "Chart.SelectedObject.InsertColumnTable")[0] ?? null;
            }
        }
        throw new Error(`Unsupported actionId: ${t}`);
      }
      _isReadOnly() {
        return this._chartWidget.readOnly();
      }
      _createActionScale(e) {
        const t = (0, s.ensureNotNull)(e.priceScale());
        const i = this._chartWidget.model().model();
        const o = (0, s.ensureNotNull)(i.paneForSource(e));
        const n = o.priceScalePosition(t);
        const r = (n === "left" ? o.leftPriceScales() : o.rightPriceScales()).indexOf(t);
        const a = i.priceScaleSlotsCount().totallySlots < 2 ? "dontneedname" : "needname";
        const l = n === "overlay" ? "" : (0, c.getPriceAxisNameInfo)(n, r).label;
        const h = ce.format({
          label: l
        });
        const d = {
          "left-needname": h,
          "left-dontneedname": de,
          "right-needname": h,
          "right-dontneedname": ue,
          "overlay-needname": he,
          "overlay-dontneedname": he
        }[n + "-" + a];
        return new A.ActionWithStandardIcon({
          actionId: "Chart.Source.ChangePriceScale",
          options: {
            label: d,
            iconId: "Chart.PriceScale",
            subItems: this._createActionScaleItems(e)
          }
        });
      }
      _createActionResetInputPoints(e) {
        const t = e.metaInfo();
        const s = t.inputs.filter(x.isTimeOrPriceNotHiddenInput);
        if (s.length === 0) {
          return null;
        } else {
          return new A.ActionWithStandardIcon({
            actionId: "Chart.Source.ResetInputPoints",
            options: {
              label: Ue,
              onExecute: async () => {
                let o;
                try {
                  const n = e.properties().childs().inputs.state();
                  for (const e of Object.keys(n)) {
                    if (!s.find(t => t.id === e)) {
                      delete n[e];
                    }
                  }
                  const r = new I.Property({
                    inputs: n
                  });
                  const a = await Promise.all([i.e(9003), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(9481), i.e(4600), i.e(2564), i.e(6445), i.e(7384), i.e(3799), i.e(2197), i.e(5480), i.e(5323), i.e(1072), i.e(9325), i.e(116), i.e(8985), i.e(8222), i.e(4106), i.e(7444), i.e(2440), i.e(9296), i.e(625), i.e(5083), i.e(9255), i.e(7935), i.e(422), i.e(1531), i.e(6316), i.e(2227), i.e(4931), i.e(9418), i.e(3202), i.e(2751), i.e(9928), i.e(7223), i.e(9443), i.e(3030)]).then(i.bind(i, 73339));
                  o = (await a.selectInputValuesOnChart(this._chartWidget, s, r, t.shortDescription, t.inputs)).customSourceId;
                  e.properties().mergeAndFire(r.state());
                } finally {
                  if (o !== undefined) {
                    this._chartWidget.model().model().removeCustomSource(o);
                  }
                }
              }
            }
          });
        }
      }
      _createActionLayoutChartsSync() {
        return new LayoutChartsSyncContextMenuAction(this._chartWidget.linkingGroupIndex().readonly(), e => this._chartWidget.model().setLinkingGroupIndex(e));
      }
      _createActionScaleDetach(e, t, i, o) {
        const n = this._chartWidget.model().model();
        const r = (0, s.ensureNotNull)(n.paneForSource(e));
        if (!r.canCreateNewPriceScale()) {
          return null;
        }
        const a = (0, s.ensureNotNull)(e.priceScale());
        const l = a.canDetachSource(e);
        const h = r.priceScalePosition(a);
        const d = l || h !== t;
        if (!d) {
          return null;
        }
        const u = n.priceScaleSlotsCount();
        const _ = {
          left: {
            labelled: te,
            sided: ae
          },
          right: {
            labelled: te,
            sided: le
          }
        };
        const p = t === "left" ? r.leftPriceScales().length : r.rightPriceScales().length;
        const m = u[t] > p ? "labelled" : "sided";
        const g = (0, c.getPriceAxisNameInfo)(t, p).label;
        const f = _[t][m].format({
          label: g
        });
        return new A.ActionWithStandardIcon({
          actionId: "Chart.Source.ChangePriceScale",
          options: {
            checkable: false,
            disabled: !d,
            label: f,
            statName: o,
            payload: e,
            onExecute: i
          }
        });
      }
      _onDetachLeft(e) {
        const t = e.getPayload();
        const i = this._chartWidget.model().model();
        const o = (0, s.ensureNotNull)(i.paneForSource(t));
        this._chartWidget.model().detachToLeft(t, o);
      }
      _onDetachRight(e) {
        const t = e.getPayload();
        const i = this._chartWidget.model().model();
        const o = (0, s.ensureNotNull)(i.paneForSource(t));
        this._chartWidget.model().detachToRight(t, o);
      }
      _createActionScaleDetachLeft(e) {
        return this._createActionScaleDetach(e, "left", this._onDetachLeft.bind(this), "ToggleScaleLeft");
      }
      _createActionScaleDetachRight(e) {
        return this._createActionScaleDetach(e, "right", this._onDetachRight.bind(this), "ToggleScaleRight");
      }
      _onMoveToScale(e) {
        const t = e.getPayload();
        if (t.datasource.priceScale() === t.priceScale) {
          return;
        }
        const i = this._chartWidget.model().model();
        const o = (0, s.ensureNotNull)(i.paneForSource(t.datasource));
        this._chartWidget.model().moveToScale(t.datasource, o, t.priceScale, t.undoText);
      }
      _createMoveToScaleAction(e, t, i, s) {
        const o = e.priceScale() === t;
        return new A.ActionWithStandardIcon({
          actionId: "Chart.Source.MoveToOtherScale",
          options: {
            checkable: true,
            checked: o,
            label: i,
            statName: "ToggleScale",
            payload: {
              datasource: e,
              priceScale: t,
              undoText: s
            },
            onExecute: this._onMoveToScale.bind(this)
          }
        });
      }
      _onNoScale(e) {
        const t = e.getPayload().datasource;
        const i = this._chartWidget.model().model();
        const o = (0, s.ensureNotNull)(i.paneForSource(t));
        if (!o.isOverlay(t)) {
          this._chartWidget.model().detachNoScale(t, o);
        }
      }
      _createActionNoScale(e) {
        const t = this._chartWidget.model().model();
        const i = (0, s.ensureNotNull)(t.paneForSource(e));
        const o = i.actionNoScaleIsEnabled(e);
        return new A.ActionWithStandardIcon({
          actionId: "Chart.Source.MoveToNoScale",
          options: {
            checkable: true,
            checked: i.isOverlay(e),
            label: _e,
            disabled: !o,
            statName: "ToggleNoScale",
            payload: {
              datasource: e
            },
            onExecute: this._onNoScale.bind(this)
          }
        });
      }
      _createActionScaleItems(e) {
        const t = [];
        const i = this._chartWidget.model().model();
        const o = (0, s.ensureNotNull)(i.paneForSource(e));
        const n = i.priceScaleSlotsCount().totallySlots > 1;
        const r = o.rightPriceScales();
        const a = o.leftPriceScales();
        const h = this._createActionScaleDetachRight(e);
        const d = this._createActionScaleDetachLeft(e);
        const u = r.length + a.length + (h === null ? 0 : 1) + (d === null ? 0 : 1) > 2;
        const _ = {
          right: {
            hidden: {
              checked: {
                labelled: Y,
                sided: Z
              },
              unchecked: {
                labelled: X,
                sided: J
              }
            },
            visible: {
              checked: {
                labelled: Q,
                sided: ee
              },
              unchecked: {
                labelled: te,
                sided: ie
              }
            }
          },
          left: {
            hidden: {
              checked: {
                labelled: Y,
                sided: se
              },
              unchecked: {
                labelled: X,
                sided: oe
              }
            },
            visible: {
              checked: {
                labelled: Q,
                sided: ne
              },
              unchecked: {
                labelled: te,
                sided: re
              }
            }
          }
        };
        const p = {
          right: D,
          left: E
        };
        const m = {
          left: o.visibleLeftPriceScales(),
          right: o.visibleRightPriceScales()
        };
        const g = (t, i) => {
          const s = (i === "right" ? r : a)[t];
          const o = m[i].includes(s) ? "visible" : "hidden";
          const l = e.priceScale() === s ? "checked" : "unchecked";
          const h = n ? "labelled" : "sided";
          const d = _[i];
          const u = (0, c.getPriceAxisNameInfo)(i, t).label;
          return {
            actionText: d[o][l][h].format({
              label: u
            }),
            undoText: n ? k.format({
              label: u
            }) : p[i]
          };
        };
        t.push(...r.map((t, i) => {
          const s = g(i, "right");
          return this._createMoveToScaleAction(e, t, s.actionText, s.undoText);
        }));
        if (h !== null) {
          t.push(h);
        }
        if (u && (r.length > 0 || h !== null)) {
          t.push(new l.Separator());
        }
        t.push(...a.map((t, i) => {
          const s = g(i, "left");
          return this._createMoveToScaleAction(e, t, s.actionText, s.undoText);
        }));
        if (d !== null) {
          t.push(d);
        }
        if (u && (a.length > 0 || d !== null)) {
          t.push(new l.Separator());
        }
        t.push(this._createActionNoScale(e));
        return t;
      }
      _createActionMergeUp(e) {
        const t = this._chartWidget.model();
        if (t.model().isMergeUpAvailableForSource(e)) {
          return new A.ActionWithStandardIcon({
            actionId: "Chart.Source.MergeUp",
            options: {
              label: me,
              statName: "MergeUp",
              onExecute: () => t.mergeSourceUp(e)
            }
          });
        } else {
          return null;
        }
      }
      _createActionUnmergeUp(e) {
        const t = this._chartWidget.model();
        if (t.model().isUnmergeAvailableForSource(e)) {
          return new A.ActionWithStandardIcon({
            actionId: "Chart.Source.UnmergeUp",
            options: {
              label: ge,
              statName: "UnmergeUp",
              onExecute: () => t.unmergeSourceUp(e)
            }
          });
        } else {
          return null;
        }
      }
      _createActionMergeDown(e) {
        const t = this._chartWidget.model();
        if (t.model().isMergeDownAvailableForSource(e)) {
          return new A.ActionWithStandardIcon({
            actionId: "Chart.Source.MergeDown",
            options: {
              label: fe,
              statName: "MergeDown",
              onExecute: () => t.mergeSourceDown(e)
            }
          });
        } else {
          return null;
        }
      }
      _createActionUnmergeDown(e) {
        const t = this._chartWidget.model();
        if (t.model().isUnmergeAvailableForSource(e)) {
          return new A.ActionWithStandardIcon({
            actionId: "Chart.Source.UnmergeDown",
            options: {
              label: ye,
              statName: "UnmergeDown",
              onExecute: () => t.unmergeSourceDown(e)
            }
          });
        } else {
          return null;
        }
      }
      _mergeContentMenuItems(e) {
        return [this._createActionMergeUp(e), this._createActionUnmergeUp(e), this._createActionMergeDown(e), this._createActionUnmergeDown(e)].filter(n.notNull);
      }
      _createActionMove(e) {
        const t = this._mergeContentMenuItems(e);
        if (t.length > 0) {
          return new A.ActionWithStandardIcon({
            actionId: "Chart.Source.MoveToPane",
            options: {
              label: pe,
              iconId: "Chart.Move",
              subItems: t
            }
          });
        } else {
          return null;
        }
      }
      async _createDetailsMetricsAction(e) {
        return null;
      }
      async _contextMenuActionsForSeries(e, t) {
        const i = [];
        const o = this._chartWidget.model().model();
        const n = (0, s.ensureNotNull)(o.paneForSource(e));
        const r = this._chartWidget.actions();
        const c = t && "localY" in t ? t.localY : undefined;
        if (this._isReadOnly()) {
          i.push(tt(this._chartWidget, [e]));
          i.push(new l.Separator());
          i.push(this._createActionScale(e));
        } else {
          0;
          if (i.length > 0 && !(i[i.length - 1] instanceof l.Separator)) {
            i.push(new l.Separator());
          }
          if (a.enabled("symbol_info")) {
            i.push(r.showSymbolInfoDialog);
          }
          const t = await this._createDetailsMetricsAction(e);
          if (t) {
            i.push(t);
          }
          if (i.length > 0 && !(i[i.length - 1] instanceof l.Separator)) {
            i.push(new l.Separator());
          }
          if (!n.isEmpty() && a.enabled("datasource_copypaste")) {
            const e = Je(n, c);
            const t = Ye(this._chartWidget, n);
            if (e || t) {
              if (e) {
                i.push(e);
              }
              if (t) {
                i.push(t);
              }
              i.push(new l.Separator());
            }
          }
          i.push(Ze(this._chartWidget, [e]));
          const s = this._createActionMove(e);
          if (s !== null) {
            i.push(s);
          }
          i.push(this._createActionScale(e));
          i.push(tt(this._chartWidget, [e]));
          i.push(new l.Separator());
          if (Boolean(window.widgetbar?.widget("watchlist")) && r.addToWatchlist) {
            r.addToWatchlist.prepare();
            i.push(r.addToWatchlist);
          }
          if (a.enabled("text_notes")) {
            i.push(r.addToTextNotes);
          }
          if (!(i[i.length - 1] instanceof l.Separator)) {
            i.push(new l.Separator());
          }
          if (a.enabled("show_chart_property_page") && !this._chartWidget.onWidget()) {
            i.push(r.mainSeriesPropertiesAction);
          }
          if (i[i.length - 1] instanceof l.Separator) {
            i.pop();
          }
        }
        return i;
      }
      _createActionAddChildStudy(e) {
        throw new Error("unsupported");
      }
      _createActionAddFundamentals(e) {
        return null;
      }
      _createActionShowSymbolInfoDialog(e, t) {
        const i = this._chartWidget.model().model();
        return new A.ActionWithStandardIcon({
          actionId: "Chart.Dialogs.ShowSymbolInfo",
          options: {
            label: ze,
            iconId: "Chart.SymbolInfo",
            checkable: false,
            statName: "SymbolInfo",
            onExecute: () => {
              const s = {
                symbolInfo: e.symbolInfo(),
                unitDescription: e => e ? t.description(e) : "",
                dateFormatter: i.dateFormatter()
              };
              (0, g.showSymbolInfoDialog)(s);
            }
          }
        });
      }
      _createActionShowProperties(e) {
        return new A.ActionWithStandardIcon({
          actionId: "Chart.Indicator.ShowSettingsDialog",
          options: {
            label: Le,
            iconId: "Settings",
            statName: "EditSelectedObject",
            onExecute: () => this._chartWidget.showSourceProperties(e)
          }
        });
      }
      async _contextMenuActionsForStudy(e, t, i) {
        const s = t !== this._chartWidget.model().paneForSource(e);
        const o = this._chartWidget.actions();
        if (i && "localY" in i) {
          i.localY;
        }
        const n = [];
        if (!e.userEditEnabled()) {
          return n;
        }
        if (this._chartWidget.readOnly()) {
          n.push(tt(this._chartWidget, [e]));
          n.push(new l.Separator());
          if (!(0, u.isNonSeriesStudy)(e)) {
            n.push(this._createActionScale(e));
          }
        } else {
          0;
          if (a.enabled("study_on_study") && e.canHaveChildren()) {
            n.push(this._createActionAddChildStudy(e));
          }
          const t = this._createApplyToEntireLayoutCommand(e);
          if (t !== null) {
            n.push(t);
          }
          const i = this._createAddIndicatorToFavoritesCommand(e);
          if (i) {
            n.push(i);
          }
          if (n.length > 0 && !(n[n.length - 1] instanceof l.Separator)) {
            n.push(new l.Separator());
          }
          if (a.enabled("symbol_info") && (0, d.isCompareOrOverlayStudy)(e) && e.symbolInfo() !== null) {
            n.push(this._createActionShowSymbolInfoDialog(e, this._chartWidget.model().model().availableUnits()));
            n.push(new l.Separator());
          }
          if (!s) {
            n.push(Ze(this._chartWidget, [e]));
          }
          n.push(Xe(this._chartWidget, [e]));
          if (!(0, u.isNonSeriesStudy)(e) && !s) {
            const t = this._createActionMove(e);
            if (t !== null) {
              n.push(t);
            }
            n.push(this._createActionScale(e));
          }
          n.push(new l.Separator());
          const r = e.metaInfo();
          if (e.copiable()) {
            const t = new A.ActionWithStandardIcon({
              actionId: "Chart.Clipboard.CopySource",
              options: {
                label: ke,
                shortcutHint: (0, p.humanReadableHash)(p.Modifiers.Mod + 67),
                statName: "Copy",
                onExecute: () => {
                  this._chartWidget.chartWidgetCollection().clipboard.uiRequestCopy([e]);
                }
              }
            });
            n.push(t);
          }
          n.push(tt(this._chartWidget, [e]));
          n.push(o.studyRemove);
          const c = this._options.objectTree && o.paneObjectTree;
          const h = false;
          if (c || h) {
            n.push(new l.Separator());
            if (c) {
              n.push(o.paneObjectTree);
            }
            if (h) {
              n.push(this._chartWidget.actions().showDataWindow);
            }
          }
          n.push(new l.Separator());
          if (a.enabled("property_pages") && new _.MetaInfoHelper(r).hasUserEditableOptions()) {
            n.push(this._createActionShowProperties(e));
          }
          if (n[n.length - 1] instanceof l.Separator) {
            n.pop();
          }
        }
        return n;
      }
      _createLineToolTemplateAction(e) {
        return null;
      }
      _createActionToggleLockLineTools(e) {
        const t = e[0].properties().frozen.value();
        const i = t ? Be : Ve;
        return new A.ActionWithStandardIcon({
          actionId: "Chart.SelectedObject.ToggleLocked",
          options: {
            label: i,
            statName: "ToggleLockSelectedObject",
            checkable: true,
            iconId: t ? "Chart.UnlockObject" : "Chart.LockObject",
            onExecute: () => {
              if (e.length === 1) {
                this._chartWidget.toggleLockSelectedObject();
              } else {
                const i = t ? W : F;
                const s = this._chartWidget.model();
                s.withMacro(i, () => {
                  e.forEach(e => {
                    s.setProperty(e.properties().frozen, !t, i, C.lineToolsDoNotAffectChartInvalidation);
                  });
                });
              }
            }
          }
        });
      }
      _createActionToggleAnchorLineTools(e) {
        const t = e.filter(e => e.anchorable());
        if (t.length === 0) {
          return null;
        }
        const i = t[0].properties().anchored.value();
        return new A.ActionWithStandardIcon({
          actionId: "Chart.SelectedObject.ToggleAnchored",
          options: {
            label: Re,
            statName: "ToggleAnchoredSelectedObject",
            checkable: true,
            checked: i,
            onExecute: () => {
              const e = i ? z : H;
              const s = this._chartWidget.model();
              s.withMacro(e, () => {
                t.forEach(t => {
                  s.setProperty(t.properties().childs().anchored, !i, e, C.lineToolsDoNotAffectChartInvalidation);
                });
              });
            }
          }
        });
      }
      async _contextMenuActionsForLineTool(e) {
        const t = [];
        const i = this._chartWidget.actions();
        this._chartWidget.model().model();
        const s = () => {
          t.push(Ze(this._chartWidget, e));
        };
        const o = () => {
          t.push(Xe(this._chartWidget, e));
        };
        const n = () => {
          const i = e.filter(e => e.cloneable());
          if (i.length > 0) {
            const e = new A.ActionWithStandardIcon({
              actionId: "Chart.LineTool.Clone",
              options: {
                label: De,
                iconId: "Chart.Clone",
                shortcutHint: (0, p.humanReadableModifiers)(p.Modifiers.Mod) + "Drag",
                statName: "Clone",
                onExecute: () => this._chartWidget.model().cloneLineTools(i, false)
              },
              id: "Clone"
            });
            t.push(e);
          }
          return !!i.length;
        };
        const r = () => {
          const i = e.filter(e => e.copiable());
          if (i.length > 0) {
            const e = new l.Action({
              actionId: "Chart.Clipboard.CopyLineTools",
              options: {
                label: ke,
                shortcutHint: (0, p.humanReadableHash)(p.Modifiers.Mod + 67),
                statName: "Copy",
                onExecute: () => this._chartWidget.chartWidgetCollection().clipboard.uiRequestCopy(i)
              },
              id: "Copy"
            });
            t.push(e);
          }
          return !!i.length;
        };
        const c = () => {
          this._chartWidget;
          const e = [];
          t.push(...e);
          return e.length > 0;
        };
        const d = e => {
          const i = new A.ActionWithStandardIcon({
            actionId: "Chart.ScrollToLineTool",
            options: {
              label: Ee.format({
                lineToolName: e.title(h.TitleDisplayTarget.StatusLine)
              }),
              statName: "GoToLineTool",
              checkable: false,
              onExecute: async () => this._chartWidget.model().scrollToLineTool(e)
            }
          });
          t.push(i);
        };
        const u = e => {
          const t = this._chartWidget.model().model().lineToolsGroupModel();
          const i = e.map(e => t.groupForLineTool(e));
          return new Set(i).size <= 1;
        };
        if (e.length === 1) {
          const h = e[0];
          let u = {
            actions: [],
            placement: "CustomAction"
          };
          if (h.additionalActions) {
            u = await h.additionalActions(this._chartWidget.model());
          }
          if (u.actions.length > 0 && u.placement === "BeforeAll") {
            t.push(...u.actions);
            t.push(new l.Separator());
          }
          if (this._chartWidget.readOnly()) {
            t.push(tt(this._chartWidget, [h]));
          } else if (h.userEditEnabled()) {
            0;
            s();
            o();
            if (this._options.objectTree && i.paneObjectTree) {
              t.push(i.paneObjectTree);
            }
            t.push(new l.Separator());
            let e = n();
            e = r() || e;
            if (e) {
              t.push(new l.Separator());
            }
            e = c();
            if (e) {
              t.push(new l.Separator());
            }
            if (u.actions.length > 0 && u.placement === "CustomAction") {
              t.push(...u.actions);
              t.push(new l.Separator());
            }
            const _ = this._createActionToggleAnchorLineTools([h]);
            if (_) {
              t.push(_);
              t.push(new l.Separator());
            }
            t.push(this._createActionToggleLockLineTools([h]));
            t.push(tt(this._chartWidget, [h]));
            t.push(i.lineRemove);
            if (h.points().length > 0 && this._options.gotoLineTool) {
              t.push(new l.Separator());
              d(h);
            }
            const p = await this._chartWidget.propertiesDefinitionsForSource(h);
            if (a.enabled("property_pages") && p !== null) {
              t.push(new l.Separator());
              t.push(i.format);
            }
          }
        } else {
          if (this._options.objectTree && i.paneObjectTree) {
            t.push(i.paneObjectTree);
          }
          if (u(e)) {
            s();
          }
          o();
          if (t.length > 0) {
            t.push(new l.Separator());
          }
          let h = n();
          h = r() || h;
          if (h) {
            t.push(new l.Separator());
          }
          h = c();
          if (h) {
            t.push(new l.Separator());
          }
          t.push(this._createActionToggleLockLineTools(e));
          t.push(tt(this._chartWidget, e));
          t.push(i.lineRemove);
          if (a.enabled("property_pages")) {
            t.push(new l.Separator());
            t.push(i.format);
          }
        }
        return t;
      }
      _createEarningsShow() {
        return null;
      }
      _createDividendsShow() {
        return null;
      }
      _createSplitsShow() {
        return null;
      }
      _contextMenuActionsForESD() {
        return [];
      }
      _contextMenuActionsForRollDates() {
        return [];
      }
      _contextMenuActionsForFuturesContractExpiration() {
        return [];
      }
      _contextMenuActionsForisLatestUpdates() {
        return [];
      }
      _contextMenuActionsForPublishedTimeline(e) {
        const t = this._chartWidget.actions();
        const i = [];
        i.push(t.lineHide);
        if (window.is_authenticated) {
          const t = e.properties().childs().filter;
          const s = new l.Action({
            actionId: "Chart.ShowAllIdeas",
            options: {
              checked: t.value() === PublishedChartsFilter.None,
              checkable: true,
              label: Ne,
              name: "ToggleAllIdeas",
              statName: "ToggleAllIdeas",
              onExecute: () => this._chartWidget.model().setProperty(t, PublishedChartsFilter.None, B)
            }
          });
          const o = new l.Action({
            actionId: "Chart.ShowIdeasOfFollowedUsers",
            options: {
              checked: t.value() === PublishedChartsFilter.Following,
              checkable: true,
              label: Oe,
              name: "ToggleIdeasOfPeopleAndUser",
              statName: "ToggleIdeasOfPeopleAndUser",
              onExecute: () => this._chartWidget.model().setProperty(t, PublishedChartsFilter.Following, V)
            }
          });
          const n = new l.Action({
            actionId: "Chart.ShowMyIdeasOnly",
            options: {
              checked: t.value() === PublishedChartsFilter.Private,
              checkable: true,
              label: Fe,
              name: "ToggleUserIdeas",
              statName: "ToggleUserIdeas",
              onExecute: () => this._chartWidget.model().setProperty(t, PublishedChartsFilter.Private, R)
            }
          });
          i.push(new l.Separator(), s, o, n);
        }
        return i;
      }
      _contextMenuActionsForTradingDrawings(e) {
        return e.contextMenuItems();
      }
      async _contextMenuActionsForAlertLabel(e, t) {
        return [];
      }
      _contextMenuActionsForChartEvents(e) {
        return [];
      }
      _createApplyToEntireLayoutCommand(e) {
        if (!this._chartWidget.chartWidgetCollection().applyIndicatorsToAllChartsAvailable()) {
          return null;
        }
        const t = this._chartWidget.model().model();
        if (e.parentSources().length > 0) {
          return null;
        }
        const i = (0, s.ensureNotNull)(t.paneForSource(e));
        const o = t.paneForSource(t.mainSeries()) === i;
        const n = e instanceof m.StudyCompare && e.priceScale() === t.mainSeries().priceScale() && (0, s.ensureNotNull)(e.priceScale()).isPercentage();
        const r = o ? undefined : t.panes().indexOf(i);
        let a = He;
        let c = O;
        let h = "AddStudyToEntireLayout";
        if ((0, v.isActingAsSymbolSource)(e)) {
          a = We;
          c = N;
          h = "AddSymbolToEntireLayout";
        }
        return new l.Action({
          actionId: "Chart.AddIndicatorToAllCharts",
          options: {
            label: a,
            statName: h,
            onExecute: () => {
              const i = (0, s.ensureNotNull)((0, f.clipboardDataForSources)(t.id(), [e]));
              const a = this._chartWidget.chartWidgetCollection();
              const l = {
                isOnMainPane: o,
                asCompare: n,
                paneIndex: r
              };
              a.applyIndicatorToAllCharts(this._chartWidget, i, l, c);
            }
          },
          id: "applyStudyToEntireLayout"
        });
      }
      _createAddIndicatorToFavoritesCommand(e) {
        const t = e.metaInfo();
        let s;
        if (!a.enabled("items_favoriting") || (0, d.isCompareOrOverlayStudy)(e)) {
          return null;
        }
        {
          const {
            description_localized: e,
            description: o
          } = t;
          const n = e || r.t(o, {
            context: "study"
          }, i(83477));
          s = () => i.e(9790).then(i.bind(i, 23390)).then(({
            isFavorite: e,
            toggleFavorite: t
          }) => ({
            label: e(n) ? $e : qe,
            onExecute: () => t(n)
          }));
        }
        return new A.ActionWithStandardIcon({
          actionId: "Chart.Indicator.AddFavorites",
          id: "addIndicatorToFavorites",
          optionsLoader: s,
          options: {
            statName: "AddIndicatorToFavorites",
            iconId: "Indicator.AddToFavorites"
          }
        });
      }
    }
  },
  86920: (e, t, i) => {
    "use strict";

    i.d(t, {
      clipboardDataForSources: () => l,
      isLineToolClipboardData: () => a
    });
    var s = i(50151);
    var o = i(19466);
    var n = i(79036);
    var r = i(32755);
    function a(e) {
      return e.type === "drawing";
    }
    function l(e, t) {
      if (t.length === 1 && (0, n.isStudy)(t[0])) {
        const e = t[0];
        return {
          title: e.title(o.TitleDisplayTarget.StatusLine),
          sources: [{
            source: (0, s.ensureNotNull)(e.state()),
            type: "study"
          }]
        };
      }
      const i = {
        sources: [],
        title: ""
      };
      i.sources = t.filter(e => e.copiable() && (0, r.isLineTool)(e)).map(t => {
        const i = {
          type: "drawing",
          geometry: t.geometry(),
          source: {
            ...t.state(false),
            points: t.normalizedPoints()
          },
          modelId: e
        };
        delete i.source.alertId;
        return i;
      });
      if (i.sources.length > 0) {
        if (i.sources.length === 1) {
          i.title = t[0].title(o.TitleDisplayTarget.StatusLine);
        } else {
          i.title = "Drawings";
        }
        return i;
      } else {
        return null;
      }
    }
  },
  7114: (e, t, i) => {
    "use strict";

    i.d(t, {
      addExclusionArea: () => P,
      addExclusionAreaByScope: () => C,
      calcTextHorizontalShift: () => b,
      clearRect: () => p,
      createBoundCanvas: () => v,
      createDisconnectedCanvas: () => g,
      createDisconnectedCanvasByRenderingInfo: () => f,
      disableSelection: () => w,
      drawScaled: () => m,
      drawWithExclusionAreaByScope: () => T,
      fillRect: () => _,
      getBindingRenderingInfo: () => h,
      getContext2D: () => d,
      getPrescaledContext2D: () => u,
      measureText: () => I,
      tryApplySuggestedCanvasBitmapSize: () => S
    });
    var s = i(27714);
    var o = i(50151);
    var n = i(776);
    var r = i(2844);
    var a = i(63273);
    var l = i(49483);
    function c(e) {
      return {
        horizontalPixelRatio: Math.max(1, e.bitmapSize.width / e.canvasElementClientSize.width),
        verticalPixelRatio: Math.max(1, e.bitmapSize.height / e.canvasElementClientSize.height)
      };
    }
    function h(e) {
      return {
        ...c(e),
        bitmapSize: e.bitmapSize,
        mediaSize: e.canvasElementClientSize
      };
    }
    function d(e) {
      const t = (0, o.ensureNotNull)(e.getContext("2d"));
      t.setTransform(1, 0, 0, 1, 0, 0);
      return t;
    }
    function u(e) {
      const t = (0, o.ensureNotNull)(e.getContext("2d"));
      const i = (0, n.getCanvasDevicePixelRatio)(e);
      t.setTransform(i, 0, 0, i, 0, 0);
      return t;
    }
    function _(e, t, i, s, o, n) {
      e.save();
      e.fillStyle = n;
      e.fillRect(t, i, s, o);
      e.restore();
    }
    function p(e, t, i, s, o, n) {
      e.save();
      e.globalCompositeOperation = "copy";
      e.fillStyle = n;
      e.fillRect(t, i, s, o);
      e.restore();
    }
    function m(e, t, i, s) {
      e.save();
      e.scale(t, i);
      s();
      e.restore();
    }
    function g(e, t, i) {
      const s = y(e);
      if (i === undefined) {
        i = (0, n.getCanvasDevicePixelRatio)(s);
      }
      s.width = t.width * i;
      s.height = t.height * i;
      return s;
    }
    function f(e, t) {
      const {
        bitmapSize: i,
        mediaSize: s
      } = t;
      const o = y(e);
      o.style.width = `${s.width}px`;
      o.style.height = `${s.height}px`;
      o.width = i.width;
      o.height = i.height;
      return o;
    }
    function y(e) {
      const t = e.createElement("canvas");
      w(t);
      return t;
    }
    function v(e, t) {
      const i = y((0, o.ensureNotNull)(e.ownerDocument));
      e.appendChild(i);
      const n = (0, s.bindCanvasElementBitmapSizeTo)(i, {
        type: "device-pixel-content-box",
        transform: (e, t) => e.width === 0 || e.height === 0 ? e : {
          width: Math.max(e.width, t.width),
          height: Math.max(e.height, t.height)
        }
      });
      n.resizeCanvasElement(t);
      return n;
    }
    function S(e) {
      const t = e.suggestedBitmapSize;
      return t !== null && t.width > 0 && t.height > 0 && (e.applySuggestedBitmapSize(), true);
    }
    function b(e, t) {
      if (e.textAlign === "center") {
        return 0;
      } else if ((0, a.isRtl)()) {
        if (e.textAlign === "start" || e.textAlign === "right") {
          return t;
        } else {
          return 0;
        }
      } else if (e.textAlign === "start" || e.textAlign === "left") {
        return 0;
      } else {
        return t;
      }
    }
    function w(e) {
      e.style.userSelect = "none";
      e.style.webkitUserSelect = "none";
      e.style.msUserSelect = "none";
      e.style.MozUserSelect = "none";
      e.style.webkitTapHighlightColor = "transparent";
    }
    function C(e, t) {
      const {
        context: i,
        horizontalPixelRatio: s,
        verticalPixelRatio: o,
        bitmapSize: n
      } = e;
      i.beginPath();
      i.rect(0, 0, n.width, n.height);
      for (let e = 0; e < t.length; e++) {
        let {
          x: n,
          y: r
        } = t[e];
        n *= s;
        r *= o;
        if (e !== 0) {
          i.lineTo(n, r);
        } else {
          i.moveTo(n, r);
        }
      }
      i.closePath();
      i.clip("evenodd");
    }
    function P(e, t, i) {
      C({
        context: e,
        ...t
      }, i);
    }
    function T(e, t, i) {
      e.context.save();
      C(e, t);
      i();
      e.context.restore();
    }
    let x;
    function I(e, t, i) {
      if (!x) {
        (function () {
          const e = document.createElement("canvas");
          e.width = 0;
          e.height = 0;
          if ((0, l.isMac)()) {
            e.style.display = "none";
            document.body.append(e);
          }
          x = (0, o.ensureNotNull)(e.getContext("2d"));
          x.textBaseline = "alphabetic";
          x.textAlign = "center";
        })();
      }
      if (t && x.font !== t) {
        x.font = t;
      }
      if (i) {
        return i.getMetrics(x, e);
      } else {
        return (0, r.getMinTextMetrics)(x.measureText(e));
      }
    }
  },
  97990: (e, t, i) => {
    "use strict";

    i.d(t, {
      ChartChangesWatcher: () => a,
      changedAll: () => r
    });
    var s;
    var o = i(84425);
    var n = i(52033);
    (function (e) {
      e[e.NothingChanged = 0] = "NothingChanged";
      e[e.ContentChanged = 1] = "ContentChanged";
      e[e.LineToolsChanged = 2] = "LineToolsChanged";
    })(s ||= {});
    const r = 3;
    class a {
      constructor(e, t, i) {
        this._undoHistoryHasChanges = false;
        this._changesMask = 0;
        this._recursiveLoopingGuard = false;
        this._handleMetainfoChanged = () => {
          this._changesMask = this._changesMask | 1;
        };
        this._recalculateHaveChanges = (e, t) => {
          if (!this._recursiveLoopingGuard) {
            try {
              this._recursiveLoopingGuard = true;
              const e = this._undoHistoryHasChanges ? 1 : 0;
              let i = this._lineToolsHaveChanges.value() ? 2 : 0;
              const s = this._changesMask;
              this._changesMask = e | i;
              if (s !== this._changesMask) {
                if (this._changesMask) {
                  this._chartWidgetCollection.getAll().forEach(e => {
                    e.lineToolsSynchronizer()?.markAsValidatedBecauseOfSavingToContent(!!t);
                  });
                  i = this._lineToolsHaveChanges.value() ? 2 : 0;
                  this._changesMask = e | i;
                }
                this._onValueChanged.fire(this._changesMask !== 0);
              }
            } finally {
              this._recursiveLoopingGuard = false;
            }
          }
        };
        this._chartWidgetCollection = e;
        this._undoHistory = e.undoHistory;
        this._lineToolsHaveChanges = e.lineToolsSynchronizerHasChanges;
        this._chartSaver = t;
        this._globalEvents = i;
        this._onValueChanged = new n.Delegate();
        this._hasChangesWV = (0, o.createWVFromGetterAndSubscription)(() => this.hasChanges(), this.getOnChange());
        this._subscribe();
      }
      destroy() {
        this._unsubscribe();
        this._onValueChanged.destroy();
        this._hasChangesWV.destroy();
      }
      changes() {
        return this._changesMask;
      }
      hasChanges() {
        return this._changesMask > 0;
      }
      hasChangesWV() {
        return this._hasChangesWV;
      }
      getOnChange() {
        return this._onValueChanged;
      }
      _subscribe() {
        this._globalEvents.subscribe("chart_loaded", this._handleChartLoaded, this);
        this._globalEvents.subscribe("layout_loaded", this._handleLayoutLoaded, this);
        this._globalEvents.subscribe("chart_migrated", this._handleChartMigrated, this);
        this._undoHistory.undoStack().onChange().subscribe(this, this._handleUndoHistoryChange);
        this._chartSaver?.chartSaved().subscribe(this, this._handleChartSaved);
        this._lineToolsHaveChanges.subscribe(this._recalculateHaveChanges);
        this._chartWidgetCollection.metaInfo.name.subscribe(this._handleMetainfoChanged);
      }
      _unsubscribe() {
        this._globalEvents.unsubscribe("chart_loaded", this._handleChartLoaded, this);
        this._globalEvents.unsubscribe("layout_loaded", this._handleLayoutLoaded, this);
        this._globalEvents.unsubscribe("chart_migrated", this._handleChartMigrated, this);
        this._undoHistory.undoStack().onChange().unsubscribe(this, this._handleUndoHistoryChange);
        this._chartSaver?.chartSaved().unsubscribe(this, this._handleChartSaved);
        this._lineToolsHaveChanges.unsubscribe(this._recalculateHaveChanges);
        this._chartWidgetCollection.metaInfo.name.unsubscribe(this._handleMetainfoChanged);
      }
      _setUndoHistoryHasChanges(e, t) {
        this._undoHistoryHasChanges = e;
        this._recalculateHaveChanges(e, t);
      }
      _handleChartLoaded() {
        this._setUndoHistoryHasChanges(false);
      }
      _handleLayoutLoaded() {
        this._setUndoHistoryHasChanges(false, true);
      }
      _handleUndoHistoryChange(e) {
        if (e?.affectsState()) {
          this._setUndoHistoryHasChanges(true);
        }
      }
      _handleChartMigrated() {
        this._setUndoHistoryHasChanges(true);
      }
      _handleChartSaved(e) {
        if (e) {
          this._setUndoHistoryHasChanges(false, true);
        }
      }
    }
  },
  43550: (e, t, i) => {
    "use strict";

    i.d(t, {
      ChartHotkeysListener: () => g,
      globalEnvironmentState: () => m,
      modifierPressed: () => p,
      shiftPressed: () => _
    });
    var s = i(26709);
    var o = i(68335);
    var n = i(35749);
    var r = i(32755);
    var a = i(64147);
    var l = i(28331);
    const c = new a.WatchedValue(Boolean((s.pressedKeys.value() ?? 0) & o.Modifiers.Shift));
    const h = new a.WatchedValue(Boolean((s.pressedKeys.value() ?? 0) & o.Modifiers.Mod));
    const d = new a.WatchedValue(Boolean((s.pressedKeys.value() ?? 0) & o.Modifiers.Alt));
    const u = [o.Modifiers.None, o.Modifiers.Alt, o.Modifiers.Mod, o.Modifiers.Alt + o.Modifiers.Shift];
    function _() {
      return c;
    }
    function p() {
      return h;
    }
    function m() {
      return new l.EnvironmentState({
        altKey: d.value(),
        ctrlKey: p().value(),
        metaKey: p().value(),
        shiftKey: _().value()
      });
    }
    s.pressedKeys.subscribe((e = 0) => {
      c.setValue(Boolean(e & o.Modifiers.Shift));
      h.setValue(Boolean(e & o.Modifiers.Mod));
      d.setValue(Boolean(e & o.Modifiers.Alt));
    });
    class g {
      constructor(e, t) {
        this._pressedKeyCode = null;
        this._boundKeydownHandler = null;
        this._boundKeyupHandler = null;
        this._chartWidget = e;
        this._parent = t;
        this._boundKeydownHandler = this._keydownHandler.bind(this);
        this._boundKeyupHandler = this._keyupHandler.bind(this);
        this._parent.ownerDocument.addEventListener("keydown", this._boundKeydownHandler);
        this._parent.ownerDocument.addEventListener("keyup", this._boundKeyupHandler);
      }
      destroy() {
        if (this._boundKeydownHandler !== null) {
          this._parent.ownerDocument.removeEventListener("keydown", this._boundKeydownHandler);
          this._boundKeydownHandler = null;
        }
        if (this._boundKeyupHandler !== null) {
          this._parent.ownerDocument.removeEventListener("keyup", this._boundKeyupHandler);
          this._boundKeyupHandler = null;
        }
      }
      _keydownHandler(e) {
        if (this._chartWidget.hasModel() && this._chartWidget.isActive().value()) {
          if (!e.defaultPrevented) {
            if (window.document.activeElement?.getAttribute("data-name") === "text-editor" && this._handleTabKeyDown(e) || window.document.activeElement === window.document.body && (this._handleMoveDrawingsKeyDown(e) || this._handleScrollKeyDown(e) || this._handleZoomKeyDown(e))) {
              e.preventDefault();
            }
          }
        }
      }
      _keyupHandler(e) {
        if (this._chartWidget.hasModel()) {
          this._handleScrollKeyUp(e);
        }
      }
      _handleTabKeyDown(e) {
        const t = (0, o.hashFromEvent)(e) & 255;
        const i = this._chartWidget.model();
        if (t === 9) {
          const t = i.selection().dataSources()[0];
          if (t !== undefined && (s = t, (0, r.isLineTool)(s) && s.state().type === "LineToolTable")) {
            const i = (0, o.modifiersFromEvent)(e);
            return t.switchActiveCell(i === o.Modifiers.Shift);
          }
          return false;
        }
        var s;
        return false;
      }
      _handleMoveDrawingsKeyDown(e) {
        const t = (0, o.hashFromEvent)(e) & 255;
        const i = this._chartWidget.model();
        switch (t) {
          case 37:
            return i.moveSelectedToolsLeft();
          case 39:
            return i.moveSelectedToolsRight();
          case 38:
            return i.moveSelectedToolsUp();
          case 40:
            return i.moveSelectedToolsDown();
        }
        return false;
      }
      _handleScrollKeyDown(e) {
        if (this._pressedKeyCode !== null) {
          return false;
        }
        const t = (0, o.hashFromEvent)(e);
        const i = t & 255;
        const s = (0, o.modifiersFromEvent)(e);
        let r;
        if (i === 37) {
          r = 1;
        } else {
          if (i !== 39) {
            return false;
          }
          r = -1;
        }
        return (!o.isMacKeyboard || s !== o.Modifiers.Mod) && !!u.includes(s) && !(0, n.isNativeUIInteraction)(t, e.target) && (this._pressedKeyCode = i, s === o.Modifiers.None ? this._chartWidget.scrollHelper().moveByBar(r) : s === o.Modifiers.Alt || s === o.Modifiers.Mod ? this._chartWidget.scrollHelper().move(r) : r === -1 ? this._chartWidget.model().timeScale().scrollToRealtime(true) : this._chartWidget.model().timeScale().scrollToFirstBar(), true);
      }
      _handleScrollKeyUp(e) {
        if (this._pressedKeyCode === null) {
          return false;
        }
        const t = (0, o.hashFromEvent)(e);
        if ((0, n.isNativeUIInteraction)(t, e.target)) {
          return false;
        }
        return (t & 255) === this._pressedKeyCode && (this._pressedKeyCode = null, this._chartWidget.scrollHelper().stopMove(), true);
      }
      _handleZoomKeyDown(e) {
        const t = (0, o.hashFromEvent)(e);
        const i = t & 255;
        if ((0, o.modifiersFromEvent)(e) !== o.Modifiers.Mod || (0, n.isNativeUIInteraction)(t, e.target)) {
          return false;
        }
        const s = this._chartWidget.model();
        if (i === 38) {
          s.zoomIn();
        } else {
          if (i !== 40) {
            return false;
          }
          s.zoomOut();
        }
        return true;
      }
    }
  },
  17730: (e, t, i) => {
    "use strict";

    i.d(t, {
      getChartWidgetApiTimeConverter: () => r
    });
    var s = i(50151);
    var o = i(53388);
    const n = i(56570).enabled("end_of_period_timescale_marks");
    function r(e, t, i) {
      return new l(function (e, t) {
        const i = function (e, t) {
          return e + t.session + t.timezone + (t.corrections || "") + (t.session_holidays || "");
        }(e, t);
        let s = a.get(i);
        if (s === undefined) {
          s = (0, o.createDwmAligner)(e, t);
          a.set(i, s);
        }
        return s;
      }(e, t), i);
    }
    const a = new Map();
    class l {
      constructor(e, t) {
        this._dwmAligner = e;
        this._chartModel = t;
      }
      convertPublicTimeToInternalTime(e) {
        if (this._dwmAligner !== null) {
          return this._dwmAligner.timeToSessionStart(e * 1000) / 1000;
        } else {
          return e;
        }
      }
      convertInternalTimeToPublicTime(e) {
        if (this._dwmAligner !== null) {
          return this._dwmAligner.timeToExchangeTradingDay(e * 1000) / 1000;
        } else {
          return e;
        }
      }
      convertTimePointIndexToPublicTime(e) {
        const t = this._chartModel.timeScale();
        if (t.isEmpty()) {
          return null;
        }
        let i = n ? function (e, t) {
          const i = e.indexToUserTime(t);
          if (i === null) {
            return null;
          }
          return i.getTime() / 1000;
        }(t, e) : this.convertTimePointIndexToInternalTime(e);
        if (i !== null) {
          i = this.convertInternalTimeToPublicTime(i);
        }
        return i;
      }
      convertTimePointIndexToInternalTime(e) {
        const t = this._chartModel.timeScale();
        if (t.isEmpty()) {
          return null;
        }
        const i = t.points();
        const {
          firstIndex: o,
          lastIndex: n
        } = (0, s.ensureNotNull)(i.range().value());
        let r = null;
        if (o <= e && e <= n) {
          r = i.valueAt(e);
        } else if (e > n) {
          const i = this._chartModel.mainSeries().syncModel();
          if (i !== null) {
            const o = (0, s.ensureNotNull)(t.indexToTimePoint(n));
            r = i.projectTime(o, e - n);
          }
        }
        return r;
      }
    }
  },
  15938: (e, t, i) => {
    "use strict";

    i.d(t, {
      CHART_FONT_FAMILY: () => n,
      setChartFontFamily: () => o
    });
    const s = "'Trebuchet MS', Roboto, Ubuntu, sans-serif";
    function o(e) {
      n = e;
    }
    let n = `-apple-system, BlinkMacSystemFont, ${s}`;
  },
  40443: (e, t, i) => {
    "use strict";

    i.d(t, {
      ContextMenuManager: () => s
    });
    var s;
    var o = i(29981);
    var n = i(29023);
    var r = i(59064);
    (function (e) {
      let t = null;
      let s = null;
      const a = [];
      const l = {
        createAction: e => new n.Action({
          actionId: "Chart.CustomActionId",
          options: e
        }),
        createAsyncAction: e => new n.Action({
          actionId: "Chart.CustomActionId",
          options: {},
          optionsLoader: e
        }),
        createSeparator: () => new n.Separator()
      };
      async function c(e, n = {}, r = {
        menuName: ""
      }, c) {
        if (t !== null) {
          e = await t(e, l, r);
        }
        let d = null;
        const u = () => {
          const e = (0, o.indexOf)(a, e => e.renderer === d);
          if (e !== -1) {
            a.splice(e, 1);
          }
          if (c !== undefined) {
            c();
          }
        };
        let _ = false;
        if (s !== null) {
          d = await s(e, r, u);
        }
        if (d) {
          _ = true;
          h();
        } else {
          const t = await Promise.all([i.e(4109), i.e(3953), i.e(5826), i.e(5323), i.e(2736), i.e(4066), i.e(6489), i.e(7001), i.e(6262), i.e(2227), i.e(2544), i.e(2157), i.e(1584)]).then(i.bind(i, 11785));
          d = new t.ContextMenuRenderer(e, n, u, h);
        }
        a.push({
          renderer: d,
          isExternal: _
        });
        return d;
      }
      function h() {
        (0, r.globalCloseMenu)();
        a.forEach(e => {
          if (e.isExternal && e.renderer.isShown()) {
            e.renderer.hide();
          }
        });
      }
      e.createMenu = c;
      e.showMenu = function (e, t, i = {}, s, o) {
        return c(e, i, s, o).then(e => e.show(t));
      };
      e.setCustomRendererFactory = function (e) {
        s = e;
      };
      e.setCustomItemsProcessor = function (e) {
        t = e;
      };
      e.hideAll = h;
      e.getShown = function () {
        for (let e = 0; e < a.length; e++) {
          if (a[e].renderer.isShown()) {
            return a[e].renderer;
          }
        }
        return null;
      };
    })(s ||= {});
  },
  69293: (e, t, i) => {
    "use strict";

    i.d(t, {
      doNotShowDeleteLockedLineConfirmProperty: () => a,
      doNotShowDeleteLockedLineKey: () => n
    });
    var s = i(56840);
    var o = i(17625);
    const n = "do_not_show_delete_locked_line_confirm";
    function r() {
      return s.getBool(n, false);
    }
    const a = (0, o.createPrimitiveProperty)(r());
    a.subscribe(null, () => s.setValue(n, a.value()));
    s.onSync.subscribe(null, () => a.setValue(r()));
  },
  29280: (e, t, i) => {
    "use strict";

    i.d(t, {
      DialogRenderer: () => o
    });
    var s = i(64147);
    class o {
      constructor() {
        this._container = document.createElement("div");
        this._visibility = new s.WatchedValue(false);
        this._rootInstance = null;
      }
      visible() {
        return this._visibility.readonly();
      }
      _setVisibility(e) {
        this._visibility.setValue(e);
      }
    }
  },
  26023: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      TabNames: () => s
    });
    (function (e) {
      e.background = "Background";
      e.coordinates = "Coordinates";
      e.drawings = "Drawings";
      e.events = "Events";
      e.alerts = "Alerts";
      e.inputs = "Inputs";
      e.properties = "Properties";
      e.scales = "Scales";
      e.legend = "Legend";
      e.sourceCode = "Source Code";
      e.style = "Style";
      e.symbol = "Symbol";
      e.timezoneSessions = "Timezone/Sessions";
      e.trading = "Trading";
      e.visibility = "Visibility";
      e.text = "Text";
    })(s ||= {});
  },
  9726: (e, t, i) => {
    "use strict";

    i.d(t, {
      createFavoriteDrawingToolbar: () => a,
      getFavoriteDrawingToolbarPromise: () => r
    });
    var s = i(72894);
    let o = null;
    let n = null;
    function r() {
      return n;
    }
    function a() {
      if (n === null) {
        n = Promise.all([i.e(7827), i.e(3703), i.e(3953), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(6445), i.e(7384), i.e(5323), i.e(2736), i.e(4066), i.e(6489), i.e(4353), i.e(2440), i.e(9255), i.e(7001), i.e(3745), i.e(6262), i.e(6842), i.e(5099), i.e(2227), i.e(2544), i.e(1890), i.e(2157), i.e(7843), i.e(2306)]).then(i.bind(i, 17815)).then(({
          FavoriteDrawingToolbar: e
        }) => {
          o = o !== null ? o : new e({
            left: window.innerWidth / 2,
            top: s.HEADER_TOOLBAR_HEIGHT_EXPANDED + 61
          });
          return o;
        });
      }
    }
  },
  776: (e, t, i) => {
    "use strict";

    function s(e) {
      return Math.max(1, e.ownerDocument?.defaultView?.devicePixelRatio || 1);
    }
    i.d(t, {
      getCanvasDevicePixelRatio: () => s
    });
  },
  96152: (e, t, i) => {
    "use strict";

    i.d(t, {
      getPriceAxisNameInfo: () => r
    });
    const s = ["Z", "Y", "X", "W", "V", "U", "T", "S"];
    const o = ["A", "B", "C", "D", "E", "F", "G", "H"];
    class n {
      constructor(e) {
        this.label = e;
      }
      equals(e) {
        return e !== null && this.label === e.label;
      }
    }
    function r(e, t) {
      const i = e === "left" ? s : o;
      const r = t < i.length ? i[t] : "";
      return new n(r);
    }
  },
  56530: (e, t, i) => {
    "use strict";

    i.d(t, {
      getTranslatedInputTitle: () => n
    });
    var s = i(11542);
    const o = {
      PercentageLTP: "Percentage LTP"
    };
    function n(e) {
      return s.t(o[e] ?? e, {
        context: "input"
      }, i(32856));
    }
  },
  77788: (e, t, i) => {
    "use strict";

    i.d(t, {
      CHART_WIDGET_COLLECTION_SERVICE: () => o,
      chartWidgetCollectionService: () => n
    });
    var s = i(16216);
    const o = {
      id: "ChartWidgetCollectionService"
    };
    function n() {
      if ((0, s.hasService)(o)) {
        return (0, s.service)(o);
      } else {
        return null;
      }
    }
    var r;
    (function (e) {
      e.Multichart = "multichart";
      e.ForceFullscreen = "force-fullscreen";
    })(r ||= {});
  },
  62288: (e, t, i) => {
    "use strict";

    i.d(t, {
      InvalidationLevel: () => s,
      InvalidationMask: () => l,
      defaultInvalidationLevel: () => r
    });
    var s;
    var o = i(50151);
    class n {
      constructor(e = r) {
        this._paneInvalidationLevel = r;
        this._leftPriceScalesInvalidationMap = new Map();
        this._rightPriceScalesInvalidationMap = new Map();
        this._legendWidgetInvalidated = false;
        this._priceScalesPriceRangeAnimationsInvalidationMap = new Map();
        this._invalidationLevel = e;
      }
      fullInvalidation() {
        return this._invalidationLevel;
      }
      invalidateAll(e) {
        this._invalidationLevel = Math.max(this._invalidationLevel, e);
      }
      invalidatePane(e) {
        this._paneInvalidationLevel = Math.max(this._invalidationLevel, e);
      }
      invalidateLegendWidgetLayout() {
        this._legendWidgetInvalidated = true;
      }
      invalidatePriceScale(e, t, i) {
        const s = e === "left" ? this._leftPriceScalesInvalidationMap : this._rightPriceScalesInvalidationMap;
        const o = s.get(t) || r;
        s.set(t, Math.max(o, i));
      }
      setPriceScaleRangeAnimation(e, t) {
        this._priceScalesPriceRangeAnimationsInvalidationMap.set(e, t);
      }
      priceScaleRangeAnimations() {
        return this._priceScalesPriceRangeAnimationsInvalidationMap;
      }
      invalidationLevelForPane() {
        return Math.max(this._paneInvalidationLevel, this._invalidationLevel);
      }
      legendWidgetLayoutInvalidated() {
        return this._legendWidgetInvalidated || this._invalidationLevel === s.Full;
      }
      getterForPriceScaleInvalidationLevelBySide(e) {
        const t = e === "left" ? this._leftPriceScalesInvalidationMap : this._rightPriceScalesInvalidationMap;
        return e => Math.max(t.get(e) || r, this._invalidationLevel);
      }
      priceScaleSideMaxLevel(e) {
        const t = e === "left" ? this._leftPriceScalesInvalidationMap : this._rightPriceScalesInvalidationMap;
        let i = this._invalidationLevel;
        if (t.size > 0) {
          t.forEach(e => {
            if (e > i) {
              i = e;
            }
          });
        }
        return i;
      }
      merge(e) {
        this._invalidationLevel = Math.max(this._invalidationLevel, e._invalidationLevel);
        this._paneInvalidationLevel = Math.max(this._paneInvalidationLevel, e._paneInvalidationLevel);
        e._leftPriceScalesInvalidationMap.forEach((e, t) => {
          const i = this._leftPriceScalesInvalidationMap.get(t) || r;
          this._leftPriceScalesInvalidationMap.set(t, Math.max(i, e));
        });
        e._rightPriceScalesInvalidationMap.forEach((e, t) => {
          const i = this._rightPriceScalesInvalidationMap.get(t) || r;
          this._rightPriceScalesInvalidationMap.set(t, Math.max(i, e));
        });
        this._legendWidgetInvalidated = this._legendWidgetInvalidated || e._legendWidgetInvalidated;
        e._priceScalesPriceRangeAnimationsInvalidationMap.forEach((e, t) => {
          this._priceScalesPriceRangeAnimationsInvalidationMap.set(t, e);
        });
      }
    }
    (function (e) {
      e[e.None = 0] = "None";
      e[e.Cursor = 1] = "Cursor";
      e[e.Light = 2] = "Light";
      e[e.Full = 3] = "Full";
    })(s ||= {});
    const r = s.None;
    var a;
    (function (e) {
      e[e.ScrollAnimation = 0] = "ScrollAnimation";
      e[e.StopAnimation = 1] = "StopAnimation";
    })(a ||= {});
    class l {
      constructor(e = r) {
        this._panesOrderChanged = false;
        this._keepVisibleTimeRangeOnResize = false;
        this._timeAxisInvalidationLevel = r;
        this._invalidatedPanes = new Map();
        this._additionalActions = [];
        this._timeScaleInvalidations = [];
        this._invalidationLevel = e;
      }
      invalidateAll(e) {
        if (this._invalidationLevel !== e) {
          this._invalidationLevel = Math.max(this._invalidationLevel, e);
          this._invalidatedPanes.forEach(e => {
            e.invalidateAll(this._invalidationLevel);
          });
        }
      }
      invalidateAllPane(e, t) {
        if (!this._invalidatedPanes.has(e)) {
          this._invalidatedPanes.set(e, new n(this._invalidationLevel));
        }
        (0, o.ensureDefined)(this._invalidatedPanes.get(e)).invalidateAll(t);
      }
      invalidatePriceScale(e, t, i, s) {
        if (!this._invalidatedPanes.has(e)) {
          this._invalidatedPanes.set(e, new n(this._invalidationLevel));
        }
        (0, o.ensureDefined)(this._invalidatedPanes.get(e)).invalidatePriceScale(t, i, s);
      }
      setPriceScaleRangeAnimation(e, t, i) {
        this._invalidationLevel = Math.max(this._invalidationLevel, s.Light);
        if (!this._invalidatedPanes.has(e)) {
          this._invalidatedPanes.set(e, new n(this._invalidationLevel));
        }
        (0, o.ensureDefined)(this._invalidatedPanes.get(e)).setPriceScaleRangeAnimation(t, i);
      }
      invalidateTimeScale(e) {
        this._timeAxisInvalidationLevel = Math.max(this._timeAxisInvalidationLevel, e);
      }
      invalidatePanesOrder() {
        this._panesOrderChanged = true;
      }
      lockVisibleTimeRangeOnResize() {
        this._keepVisibleTimeRangeOnResize = true;
      }
      fullInvalidation() {
        return this._invalidationLevel;
      }
      maxPaneInvalidation() {
        const e = [];
        this._invalidatedPanes.forEach(t => {
          e.push(t.fullInvalidation());
        });
        return Math.max(...e, this._invalidationLevel);
      }
      invalidateForPane(e) {
        return this._invalidatedPanes.get(e) || new n(this._invalidationLevel);
      }
      invalidateForTimeScale() {
        return Math.max(this._timeAxisInvalidationLevel, this._invalidationLevel);
      }
      validationActions() {
        return this._additionalActions;
      }
      addValidationAction(e) {
        this._additionalActions.push(e);
      }
      merge(e) {
        this._invalidationLevel = Math.max(this._invalidationLevel, e._invalidationLevel);
        this._panesOrderChanged = this._panesOrderChanged || e._panesOrderChanged;
        this._keepVisibleTimeRangeOnResize = this._keepVisibleTimeRangeOnResize || e._keepVisibleTimeRangeOnResize;
        this._invalidatedPanes.forEach(e => {
          e.invalidateAll(this._invalidationLevel);
        });
        e._invalidatedPanes.forEach((e, t) => {
          if (!this._invalidatedPanes.has(t)) {
            this._invalidatedPanes.set(t, new n(this._invalidationLevel));
          }
          (0, o.ensureDefined)(this._invalidatedPanes.get(t)).merge(e);
        });
        this._timeAxisInvalidationLevel = Math.max(this._timeAxisInvalidationLevel, e._timeAxisInvalidationLevel);
        for (let t = 0; t < e._additionalActions.length; t++) {
          this._additionalActions.push(e._additionalActions[t]);
        }
        for (const t of e._timeScaleInvalidations) {
          this._applyTimeScaleInvalidation(t);
        }
      }
      panesOrderInvalidated() {
        return this._panesOrderChanged;
      }
      isVisibleTimeRangeLockedOnResize() {
        return this._keepVisibleTimeRangeOnResize;
      }
      setTimeScaleAnimation(e, t) {
        this._removeTimeScaleAnimation();
        this._timeScaleInvalidations.push({
          type: 0,
          value: e,
          rightOffsetPx: t
        });
        this._invalidationLevel = Math.max(this._invalidationLevel, s.Light);
      }
      stopTimeScaleAnimation() {
        this._removeTimeScaleAnimation();
        this._timeScaleInvalidations.push({
          type: 1
        });
        this._invalidationLevel = Math.max(this._invalidationLevel, s.Light);
      }
      timeScaleInvalidations() {
        return this._timeScaleInvalidations;
      }
      static cursor() {
        return new l(s.Cursor);
      }
      static light() {
        return new l(s.Light);
      }
      static full() {
        return new l(s.Full);
      }
      static panesOrder() {
        const e = l.full();
        e.invalidatePanesOrder();
        return e;
      }
      static invalidateLegendWidgetLayout(e) {
        const t = new l();
        t._invalidatedPanes.set(e, new n());
        t._invalidatedPanes.get(e)?.invalidateLegendWidgetLayout();
        return t;
      }
      static validateAction(e) {
        const t = new l();
        t._additionalActions.push(e);
        return t;
      }
      _applyTimeScaleInvalidation(e) {
        switch (e.type) {
          case 0:
            this.setTimeScaleAnimation(e.value, e.rightOffsetPx);
            break;
          case 1:
            this._removeTimeScaleAnimation();
        }
      }
      _removeTimeScaleAnimation() {
        const e = this._timeScaleInvalidations.findIndex(e => e.type === 0);
        if (e !== -1) {
          const [t] = this._timeScaleInvalidations.splice(e, 1);
          t.value.onFinish?.(false);
        }
      }
    }
  },
  69186: (e, t, i) => {
    "use strict";

    i.d(t, {
      lastMouseOrTouchEventInfo: () => o,
      setLastMouseOrTouchEventInfo: () => n
    });
    let s = (0, i(49483).supportTouch)() ? {
      isTouch: true,
      stylus: false
    } : {
      isTouch: false
    };
    function o() {
      return s;
    }
    function n(e) {
      s = e.isTouch ? {
        isTouch: true,
        stylus: e.stylus
      } : {
        isTouch: false
      };
    }
  },
  65952: (e, t, i) => {
    "use strict";

    i.d(t, {
      layoutInitialSizingState: () => n
    });
    var s = i(69708);
    i(50151);
    function o(e) {
      return e.map(t => {
        if ((0, s.default)(t)) {
          return {
            percent: 1 / e.length
          };
        }
        {
          const i = t.slice(1);
          return {
            percent: 1 / e.length,
            substate: o(i)
          };
        }
      });
    }
    function n(e) {
      return o(e.slice(1));
    }
  },
  68993: (e, t, i) => {
    "use strict";

    i.d(t, {
      isMultipleLayout: () => r,
      isSupportedLayout: () => a,
      layouts: () => o,
      tryGuessingTheMostSuitableLayout: () => l
    });
    i(87489);
    i(65952);
    let s;
    s = {};
    const o = {
      ...{
        s: {
          title: "1 chart",
          count: 1,
          layoutType: "s",
          sizer: (e, t) => {
            if (t !== 0) {
              throw new RangeError("invalid index");
            }
            return e;
          },
          splitters: () => [],
          resizeApplier: (e, t, i, s, o) => o,
          syncSublayoutsBySplitter: (e, t) => t,
          expression: ["h", 0]
        }
      },
      ...s
    };
    function n(e) {
      return e === "s";
    }
    function r(e) {
      return !n(e);
    }
    function a(e) {
      return n(e) || s.hasOwnProperty(e);
    }
    function l(e) {
      return "s";
    }
  },
  17402: (e, t, i) => {
    "use strict";

    i.d(t, {
      lineToolsSelectHotkeys: () => o
    });
    i(21251);
    var s = i(68335);
    const o = {
      LineToolFibRetracement: {
        hash: s.Modifiers.Alt + 70,
        action: "setTool",
        description: "Draw Fib Retracement"
      },
      LineToolHorzLine: {
        hash: s.Modifiers.Alt + 72,
        action: "drawRightThere",
        description: "Draw Horizontal Line here"
      },
      LineToolHorzRay: {
        hash: s.Modifiers.Alt + 74,
        action: "drawRightThere",
        description: "Draw Horizontal Ray here"
      },
      LineToolRectangle: {
        hash: s.Modifiers.Alt + s.Modifiers.Shift + 82,
        action: "setTool",
        description: "Draw Rectangle"
      },
      LineToolTrendLine: {
        hash: s.Modifiers.Alt + 84,
        action: "setTool",
        description: "Draw Trend Line"
      },
      LineToolVertLine: {
        hash: s.Modifiers.Alt + 86,
        action: "drawRightThere",
        description: "Draw Vertical Line here"
      },
      LineToolCrossLine: {
        hash: s.Modifiers.Alt + 67,
        action: "drawRightThere",
        description: "Draw Cross Line here"
      }
    };
  },
  35236: (e, t, i) => {
    "use strict";

    i.d(t, {
      MouseEventHandler: () => f,
      defaultPreventedHandler: () => m,
      getClickPosition: () => _,
      isTouchMouseEvent: () => p
    });
    var s = i(81251);
    var o = i(50151);
    var n = i(49483);
    var r = i(37265);
    var a = i(80007);
    var l = i(69186);
    const c = n.isSafari ? "click" : "auxclick";
    var h;
    var d;
    (function (e) {
      e[e.ResetClick = 500] = "ResetClick";
      e[e.LongTap = 240] = "LongTap";
      e[e.PreventFiresTouchEvents = 500] = "PreventFiresTouchEvents";
    })(h ||= {});
    (function (e) {
      e[e.CancelClickManhattanDistance = 5] = "CancelClickManhattanDistance";
      e[e.CancelTapManhattanDistance = 5] = "CancelTapManhattanDistance";
      e[e.DoubleClickManhattanDistance = 5] = "DoubleClickManhattanDistance";
      e[e.DoubleTapManhattanDistance = 30] = "DoubleTapManhattanDistance";
    })(d ||= {});
    const u = {
      treatVertTouchDragAsPageScroll: false,
      treatHorzTouchDragAsPageScroll: false,
      ignoreClickAndTapOnDblClickOrDblTap: false
    };
    function _(e) {
      if (p(e)) {
        return {
          x: e.clientX,
          y: e.clientY
        };
      }
      if ("touches" in (t = e) && t.touches !== undefined) {
        if (e.touches.length === 1) {
          const t = (0, o.ensureNotNull)(e.target).getBoundingClientRect();
          const i = e.touches[0];
          return {
            x: i.clientX - t.left,
            y: i.clientY - t.top
          };
        }
        return null;
      }
      var t;
      return {
        x: e.offsetX,
        y: e.offsetY
      };
    }
    function p(e) {
      return "isTouch" in e && "stylus" in e;
    }
    function m(e) {
      return t => {
        t.preventDefault();
        e(t);
      };
    }
    function g(e, t) {
      let i = false;
      return {
        clickOrTap: (...s) => {
          if (t?.()) {
            e.clickOrTap(...s);
          } else {
            i = false;
            setTimeout(() => !i && e.clickOrTap(...s), 501);
          }
        },
        doubleClickOrDoubleTap: (...t) => {
          i = true;
          e.doubleClickOrDoubleTap?.(...t);
        }
      };
    }
    class f {
      constructor(e, t, i) {
        this._clickCount = 0;
        this._clickTimeoutId = null;
        this._clickPosition = {
          x: Number.NEGATIVE_INFINITY,
          y: Number.POSITIVE_INFINITY
        };
        this._tapCount = 0;
        this._tapTimeoutId = null;
        this._tapPosition = {
          x: Number.NEGATIVE_INFINITY,
          y: Number.POSITIVE_INFINITY
        };
        this._longTapTimeoutId = null;
        this._longTapActive = false;
        this._mouseMoveStartPosition = null;
        this._touchMoveStartPosition = null;
        this._touchMoveExceededManhattanDistance = false;
        this._cancelClick = false;
        this._cancelTap = false;
        this._unsubscribeOutsideMouseEvents = null;
        this._unsubscribeOutsideTouchEvents = null;
        this._unsubscribeMobileSafariEvents = null;
        this._unsubscribeMousemove = null;
        this._unsubscribeRootMouseEvents = null;
        this._unsubscribeRootTouchEvents = null;
        this._pinchInfo = null;
        this._pinchPrevented = false;
        this._preventTouchDragProcess = false;
        this._mousePressed = false;
        this._lastTouchEventTimeStamp = 0;
        this._activeTouchId = null;
        this._acceptMouseLeave = !n.CheckMobile.iOS();
        this._onFirefoxOutsideMouseUp = e => {
          this._mouseUpHandler(e);
        };
        this._onMobileSafariDoubleClick = e => {
          if (this._firesTouchEvents(e)) {
            const t = this._makeCompatEvent(e);
            ++this._tapCount;
            if (this._tapTimeoutId && this._tapCount > 1) {
              const {
                manhattanDistance: i
              } = this._touchMouseMoveWithDownInfo(v(e), this._tapPosition);
              if (i < 30 && !this._cancelTap) {
                this._processTouchEvent(t, this._handlers.doubleTapEvent);
              }
              this._resetTapTimeout();
            }
          } else {
            const t = this._makeCompatEvent(e);
            ++this._clickCount;
            if (this._clickTimeoutId && this._clickCount > 1) {
              const {
                manhattanDistance: i
              } = this._touchMouseMoveWithDownInfo(v(e), this._clickPosition);
              if (i < 5 && !this._cancelClick) {
                this._processMouseEvent(t, this._handlers.mouseDoubleClickEvent);
              }
              this._resetClickTimeout();
            }
          }
        };
        this._target = e;
        this._options = (0, r.merge)((0, r.clone)(u), i || {});
        if (this._options.ignoreClickAndTapOnDblClickOrDblTap) {
          if (t.mouseClickEvent && t.mouseDoubleClickEvent) {
            const e = g({
              clickOrTap: t.mouseClickEvent.bind(t),
              doubleClickOrDoubleTap: t.mouseDoubleClickEvent.bind(t)
            });
            t.mouseClickEvent = e.clickOrTap;
            t.mouseDoubleClickEvent = e.doubleClickOrDoubleTap;
          }
          if (t.tapEvent && t.doubleTapEvent) {
            const e = g({
              clickOrTap: t.tapEvent.bind(t),
              doubleClickOrDoubleTap: t.doubleTapEvent.bind(t)
            });
            t.tapEvent = e.clickOrTap;
            t.doubleTapEvent = e.doubleClickOrDoubleTap;
          }
        }
        this._handlers = t;
        this._init();
      }
      destroy() {
        if (this._unsubscribeOutsideMouseEvents !== null) {
          this._unsubscribeOutsideMouseEvents();
          this._unsubscribeOutsideMouseEvents = null;
        }
        if (this._unsubscribeOutsideTouchEvents !== null) {
          this._unsubscribeOutsideTouchEvents();
          this._unsubscribeOutsideTouchEvents = null;
        }
        if (this._unsubscribeMousemove !== null) {
          this._unsubscribeMousemove();
          this._unsubscribeMousemove = null;
        }
        if (this._unsubscribeRootMouseEvents !== null) {
          this._unsubscribeRootMouseEvents();
          this._unsubscribeRootMouseEvents = null;
        }
        if (this._unsubscribeRootTouchEvents !== null) {
          this._unsubscribeRootTouchEvents();
          this._unsubscribeRootTouchEvents = null;
        }
        if (this._unsubscribeMobileSafariEvents !== null) {
          this._unsubscribeMobileSafariEvents();
          this._unsubscribeMobileSafariEvents = null;
        }
        this._clearLongTapTimeout();
        this._resetClickTimeout();
      }
      _mouseEnterHandler(e) {
        if (this._unsubscribeMousemove) {
          this._unsubscribeMousemove();
        }
        const t = this._mouseMoveHandler.bind(this);
        this._unsubscribeMousemove = () => {
          this._target.removeEventListener("mousemove", t);
        };
        this._target.addEventListener("mousemove", t);
        if (this._firesTouchEvents(e)) {
          return;
        }
        const i = this._makeCompatEvent(e);
        this._processMouseEvent(i, this._handlers.mouseEnterEvent);
        this._acceptMouseLeave = true;
      }
      _resetClickTimeout() {
        if (this._clickTimeoutId !== null) {
          clearTimeout(this._clickTimeoutId);
        }
        this._clickCount = 0;
        this._clickTimeoutId = null;
        this._clickPosition = {
          x: Number.NEGATIVE_INFINITY,
          y: Number.POSITIVE_INFINITY
        };
      }
      _resetTapTimeout() {
        if (this._tapTimeoutId !== null) {
          clearTimeout(this._tapTimeoutId);
        }
        this._tapCount = 0;
        this._tapTimeoutId = null;
        this._tapPosition = {
          x: Number.NEGATIVE_INFINITY,
          y: Number.POSITIVE_INFINITY
        };
      }
      _mouseMoveHandler(e) {
        if (this._mousePressed || this._touchMoveStartPosition !== null) {
          return;
        }
        if (this._firesTouchEvents(e)) {
          return;
        }
        const t = this._makeCompatEvent(e);
        this._processMouseEvent(t, this._handlers.mouseMoveEvent);
        this._acceptMouseLeave = true;
      }
      _touchMoveHandler(e) {
        const t = w(e.changedTouches, (0, o.ensureNotNull)(this._activeTouchId));
        if (t === null) {
          return;
        }
        this._lastTouchEventTimeStamp = b(e);
        if (this._pinchInfo !== null) {
          return;
        }
        if (this._preventTouchDragProcess) {
          return;
        }
        this._pinchPrevented = true;
        const i = this._touchMouseMoveWithDownInfo(v(t), (0, o.ensureNotNull)(this._touchMoveStartPosition));
        const {
          xOffset: s,
          yOffset: n,
          manhattanDistance: r
        } = i;
        if (this._touchMoveExceededManhattanDistance || !(r < 5)) {
          if (!this._touchMoveExceededManhattanDistance) {
            const e = s * 0.5;
            const t = n >= e && !this._options.treatVertTouchDragAsPageScroll;
            const i = e > n && !this._options.treatHorzTouchDragAsPageScroll;
            if (!t && !i) {
              this._preventTouchDragProcess = true;
            }
            this._touchMoveExceededManhattanDistance = true;
            this._cancelTap = true;
            this._clearLongTapTimeout();
            this._resetTapTimeout();
          }
          if (!this._preventTouchDragProcess) {
            const i = this._makeCompatEvent(e, t);
            this._processTouchEvent(i, this._handlers.touchMoveEvent);
            (0, a.preventDefault)(e);
          }
        }
      }
      _mouseMoveWithDownHandler(e) {
        if (e.button !== 0) {
          return;
        }
        if (this._options.isMouseMoveHandlingEnabled && !this._options.isMouseMoveHandlingEnabled?.()) {
          return;
        }
        const t = this._touchMouseMoveWithDownInfo(v(e), (0, o.ensureNotNull)(this._mouseMoveStartPosition));
        const {
          manhattanDistance: i
        } = t;
        if (i >= 5) {
          this._cancelClick = true;
          this._resetClickTimeout();
        }
        if (this._cancelClick) {
          const t = this._makeCompatEvent(e);
          this._processMouseEvent(t, this._handlers.pressedMouseMoveEvent);
        }
      }
      _touchMouseMoveWithDownInfo(e, t) {
        const i = Math.abs(t.x - e.x);
        const s = Math.abs(t.y - e.y);
        return {
          xOffset: i,
          yOffset: s,
          manhattanDistance: i + s
        };
      }
      _touchEndHandler(e) {
        let t = w(e.changedTouches, (0, o.ensureNotNull)(this._activeTouchId));
        if (t === null && e.touches.length === 0) {
          t = e.changedTouches[0];
        }
        if (t === null) {
          return;
        }
        this._activeTouchId = null;
        this._lastTouchEventTimeStamp = b(e);
        this._clearLongTapTimeout();
        this._touchMoveStartPosition = null;
        if (this._unsubscribeRootTouchEvents) {
          this._unsubscribeRootTouchEvents();
          this._unsubscribeRootTouchEvents = null;
        }
        const i = this._makeCompatEvent(e, t);
        this._processTouchEvent(i, this._handlers.touchEndEvent);
        ++this._tapCount;
        if (this._tapTimeoutId && this._tapCount > 1) {
          const {
            manhattanDistance: e
          } = this._touchMouseMoveWithDownInfo(v(t), this._tapPosition);
          if (e < 30 && !this._cancelTap) {
            this._processTouchEvent(i, this._handlers.doubleTapEvent);
          }
          this._resetTapTimeout();
        } else if (!this._cancelTap) {
          this._processTouchEvent(i, this._handlers.tapEvent);
          if (this._handlers.tapEvent) {
            (0, a.preventDefault)(e);
          }
        }
        if (this._tapCount === 0) {
          (0, a.preventDefault)(e);
        }
        if (e.touches.length === 0 && this._longTapActive) {
          this._longTapActive = false;
          (0, a.preventDefault)(e);
        }
      }
      _touchCancelHandler(e) {
        this._touchEndHandler(e);
      }
      _mouseUpHandler(e) {
        if (e.button !== 0) {
          return;
        }
        const t = this._makeCompatEvent(e);
        this._mouseMoveStartPosition = null;
        this._mousePressed = false;
        if (this._unsubscribeRootMouseEvents) {
          this._unsubscribeRootMouseEvents();
          this._unsubscribeRootMouseEvents = null;
        }
        if (n.isFF) {
          this._target.ownerDocument.documentElement.removeEventListener("mouseleave", this._onFirefoxOutsideMouseUp);
        }
        if (!this._firesTouchEvents(e)) {
          this._processMouseEvent(t, this._handlers.mouseUpEvent);
          ++this._clickCount;
          if (this._clickTimeoutId && this._clickCount > 1) {
            const {
              manhattanDistance: i
            } = this._touchMouseMoveWithDownInfo(v(e), this._clickPosition);
            if (i < 5 && !this._cancelClick) {
              this._processMouseEvent(t, this._handlers.mouseDoubleClickEvent);
            }
            this._resetClickTimeout();
          } else if (!this._cancelClick) {
            this._processMouseEvent(t, this._handlers.mouseClickEvent);
          }
        }
      }
      _clearLongTapTimeout() {
        if (this._longTapTimeoutId !== null) {
          clearTimeout(this._longTapTimeoutId);
          this._longTapTimeoutId = null;
        }
      }
      _touchStartHandler(e) {
        if (this._activeTouchId !== null) {
          this._clearLongTapTimeout();
          this._resetTapTimeout();
          return;
        }
        const t = e.changedTouches[0];
        this._activeTouchId = t.identifier;
        this._lastTouchEventTimeStamp = b(e);
        const i = this._target.ownerDocument.documentElement;
        this._cancelTap = false;
        this._touchMoveExceededManhattanDistance = false;
        this._preventTouchDragProcess = false;
        this._touchMoveStartPosition = v(t);
        if (this._unsubscribeRootTouchEvents) {
          this._unsubscribeRootTouchEvents();
          this._unsubscribeRootTouchEvents = null;
        }
        {
          const t = this._touchMoveHandler.bind(this);
          const s = this._touchEndHandler.bind(this);
          this._unsubscribeRootTouchEvents = () => {
            i.removeEventListener("touchmove", t);
            i.removeEventListener("touchend", s);
          };
          i.addEventListener("touchmove", t, {
            passive: false
          });
          i.addEventListener("touchend", s, {
            passive: false
          });
          this._clearLongTapTimeout();
          this._longTapTimeoutId = setTimeout(this._longTapHandler.bind(this, e), 240);
        }
        const s = this._makeCompatEvent(e, t);
        this._processTouchEvent(s, this._handlers.touchStartEvent);
        if (!this._tapTimeoutId) {
          this._tapCount = 0;
          this._tapTimeoutId = setTimeout(this._resetTapTimeout.bind(this), 500);
          this._tapPosition = v(t);
        }
      }
      _wheelClickHandler(e) {
        if (e.button !== 1) {
          return;
        }
        if (this._firesTouchEvents(e)) {
          return;
        }
        const t = this._makeCompatEvent(e);
        this._processMouseEvent(t, this._handlers.wheelClickEvent);
      }
      _mouseDownHandler(e) {
        if (e.button !== 0) {
          return;
        }
        if (this._options.isMouseMoveHandlingEnabled && !this._options.isMouseMoveHandlingEnabled?.()) {
          return;
        }
        const t = this._target.ownerDocument.documentElement;
        if (n.isFF) {
          t.addEventListener("mouseleave", this._onFirefoxOutsideMouseUp);
        }
        this._cancelClick = false;
        this._mouseMoveStartPosition = v(e);
        if (this._unsubscribeRootMouseEvents) {
          this._unsubscribeRootMouseEvents();
          this._unsubscribeRootMouseEvents = null;
        }
        {
          const e = this._mouseMoveWithDownHandler.bind(this);
          const i = this._mouseUpHandler.bind(this);
          this._unsubscribeRootMouseEvents = () => {
            t.removeEventListener("mousemove", e);
            t.removeEventListener("mouseup", i);
          };
          t.addEventListener("mousemove", e);
          t.addEventListener("mouseup", i);
        }
        this._mousePressed = true;
        if (this._firesTouchEvents(e)) {
          return;
        }
        const i = this._makeCompatEvent(e);
        this._processMouseEvent(i, this._handlers.mouseDownEvent);
        if (!this._clickTimeoutId) {
          this._clickCount = 0;
          this._clickTimeoutId = setTimeout(this._resetClickTimeout.bind(this), 500);
          this._clickPosition = v(e);
        }
      }
      _init() {
        this._target.addEventListener("mouseenter", this._mouseEnterHandler.bind(this));
        this._target.addEventListener("touchcancel", this._touchCancelHandler.bind(this));
        {
          const e = this._target.ownerDocument;
          const t = e => !e.target || !this._target.contains(e.target);
          const i = e => {
            if (!t(e)) {
              return;
            }
            const i = e.changedTouches[0];
            this._lastTouchEventTimeStamp = b(e);
            this._processTouchEvent(this._makeCompatEvent(e, i), this._handlers.touchStartOutsideEvent);
          };
          const s = e => {
            if (t(e) && !this._firesTouchEvents(e)) {
              this._processMouseEvent(this._makeCompatEvent(e), this._handlers.mouseDownOutsideEvent);
            }
          };
          this._unsubscribeOutsideTouchEvents = () => {
            e.removeEventListener("touchstart", i);
          };
          this._unsubscribeOutsideMouseEvents = () => {
            e.removeEventListener("mousedown", s);
          };
          e.addEventListener("mousedown", s);
          e.addEventListener("touchstart", i, {
            passive: true
          });
        }
        if (n.CheckMobile.iOS()) {
          this._unsubscribeMobileSafariEvents = () => {
            this._target.removeEventListener("dblclick", this._onMobileSafariDoubleClick);
          };
          this._target.addEventListener("dblclick", this._onMobileSafariDoubleClick);
        }
        this._target.addEventListener("mouseleave", this._mouseLeaveHandler.bind(this));
        this._target.addEventListener("contextmenu", this._contextMenuHandler.bind(this));
        this._target.addEventListener("touchstart", this._touchStartHandler.bind(this), {
          passive: true
        });
        (0, a.preventScrollByWheelClick)(this._target);
        this._target.addEventListener("mousedown", this._mouseDownHandler.bind(this));
        this._target.addEventListener(c, this._wheelClickHandler.bind(this));
        this._initPinch();
        this._target.addEventListener("touchmove", () => { }, {
          passive: false
        });
      }
      _initPinch() {
        if (this._handlers.pinchStartEvent !== undefined || this._handlers.pinchEvent !== undefined || this._handlers.pinchEndEvent !== undefined) {
          this._target.addEventListener("touchstart", e => this._checkPinchState(e.touches), {
            passive: true
          });
          this._target.addEventListener("touchmove", e => {
            if (this._pinchInfo === null) {
              return;
            }
            const t = w(e.touches, (0, o.ensureNotNull)(this._activeTouchId));
            const i = w(e.touches, this._pinchInfo.secondTouchId);
            if (t && i && this._handlers.pinchEvent !== undefined) {
              const {
                startPinchDistance: s,
                startPinchMiddlePoint: o
              } = this._pinchInfo;
              const n = S(t, i) / s;
              const r = y(this._target);
              this._handlers.pinchEvent(o, {
                x: t.clientX - r.left,
                y: t.clientY - r.top
              }, {
                x: i.clientX - r.left,
                y: i.clientY - r.top
              }, n);
              (0, a.preventDefault)(e);
            }
          }, {
            passive: false
          });
          this._target.addEventListener("touchend", e => {
            this._checkPinchState(e.touches);
          });
        }
      }
      _checkPinchState(e) {
        if (e.length === 1) {
          this._pinchPrevented = false;
        }
        if (e.length !== 2 || this._pinchPrevented || this._longTapActive) {
          this._stopPinch();
        } else {
          this._startPinch(e);
        }
      }
      _startPinch(e) {
        if (this._handlers.pinchStartEvent !== undefined && this._pinchInfo === null) {
          const t = y(this._target);
          let i;
          let s;
          if (e[0].identifier === this._activeTouchId) {
            i = e[0];
            s = e[1];
          } else {
            i = e[1];
            s = e[0];
          }
          const o = {
            x: i.clientX - t.left,
            y: i.clientY - t.top
          };
          const n = {
            x: s.clientX - t.left,
            y: s.clientY - t.top
          };
          const r = {
            x: (o.x + n.x) / 2,
            y: (o.y + n.y) / 2
          };
          if (this._handlers.pinchStartEvent(r, o, n, {
            bothPointsOnTargetElement: this._target.contains(s.target)
          })) {
            this._pinchInfo = {
              startPinchDistance: S(i, s),
              startPinchMiddlePoint: r,
              secondTouchId: s.identifier
            };
          }
        }
        this._clearLongTapTimeout();
      }
      _stopPinch() {
        if (this._pinchInfo !== null) {
          this._pinchInfo = null;
          this._handlers.pinchEndEvent?.();
        }
      }
      _mouseLeaveHandler(e) {
        if (this._unsubscribeMousemove) {
          this._unsubscribeMousemove();
        }
        if (this._firesTouchEvents(e)) {
          return;
        }
        if (!this._acceptMouseLeave) {
          return;
        }
        const t = this._makeCompatEvent(e);
        this._processMouseEvent(t, this._handlers.mouseLeaveEvent);
        this._acceptMouseLeave = !n.CheckMobile.iOS();
      }
      _longTapHandler(e) {
        const t = w(e.touches, (0, o.ensureNotNull)(this._activeTouchId));
        if (t === null) {
          return;
        }
        const i = this._makeCompatEvent(e, t);
        this._processTouchEvent(i, this._handlers.longTapEvent);
        this._processTouchEvent(i, this._handlers.touchContextMenuEvent);
        this._cancelTap = true;
        this._longTapActive = true;
      }
      _contextMenuHandler(e) {
        (0, a.preventDefault)(e);
        if (this._touchMoveStartPosition !== null) {
          return;
        }
        if (this._firesTouchEvents(e)) {
          return;
        }
        const t = this._makeCompatEvent(e);
        this._processMouseEvent(t, this._handlers.contextMenuEvent);
        this._cancelClick = true;
      }
      _firesTouchEvents(e) {
        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents !== undefined) {
          return e.sourceCapabilities.firesTouchEvents;
        } else {
          return b(e) < this._lastTouchEventTimeStamp + 500;
        }
      }
      _processTouchEvent(e, t) {
        (0, l.setLastMouseOrTouchEventInfo)(e);
        if (t) {
          t.call(this._handlers, e);
        }
      }
      _processMouseEvent(e, t) {
        if (e.srcType !== "mouseleave") {
          (0, l.setLastMouseOrTouchEventInfo)(e);
        }
        if (t) {
          t.call(this._handlers, e);
        }
      }
      _makeCompatEvent(e, t) {
        const i = t || e;
        const o = (0, s.default)(() => this._target.getBoundingClientRect() || {
          left: 0,
          top: 0
        });
        return {
          clientX: i.clientX,
          clientY: i.clientY,
          pageX: i.pageX,
          pageY: i.pageY,
          screenX: i.screenX,
          screenY: i.screenY,
          get localX() {
            return i.clientX - o().left;
          },
          get localY() {
            return i.clientY - o().top;
          },
          ctrlKey: e.ctrlKey,
          altKey: e.altKey,
          shiftKey: e.shiftKey,
          metaKey: e.metaKey,
          isTouch: !e.type.startsWith("mouse") && e.type !== "contextmenu" && e.type !== "click",
          stylus: t?.touchType === "stylus",
          srcType: e.type,
          target: i.target,
          view: e.view,
          preventDefault: () => {
            if (e.type !== "touchstart") {
              (0, a.preventDefault)(e);
            }
          }
        };
      }
    }
    function y(e) {
      return e.getBoundingClientRect() || {
        left: 0,
        top: 0
      };
    }
    function v(e) {
      return {
        x: e.pageX,
        y: e.pageY
      };
    }
    function S(e, t) {
      const i = e.clientX - t.clientX;
      const s = e.clientY - t.clientY;
      return Math.sqrt(i * i + s * s);
    }
    function b(e) {
      return e.timeStamp || performance.now();
    }
    function w(e, t) {
      for (let i = 0; i < e.length; ++i) {
        if (e[i].identifier === t) {
          return e[i];
        }
      }
      return null;
    }
  },
  60859: (e, t, i) => {
    "use strict";

    i.d(t, {
      actualBehavior: () => a,
      availableValues: () => r,
      navigationButtonsVisibilityKey: () => o,
      property: () => n,
      restoreNavigationButtonsVisibilitySettingsValue: () => l
    });
    var s = i(17656);
    const o = "NavigationButtons.visibility";
    const {
      property: n,
      availableValues: r,
      actualBehavior: a,
      restoreDefaultValue: l
    } = (0, s.createVisibilityController)(o);
  },
  51613: (e, t, i) => {
    "use strict";

    i.d(t, {
      actualBehavior: () => a,
      availableValues: () => r,
      property: () => n,
      restorePaneButtonsVisibilitySettingsValue: () => l
    });
    var s = i(17656);
    var o = i(60859);
    const {
      property: n,
      availableValues: r,
      actualBehavior: a,
      restoreDefaultValue: l
    } = (0, s.createVisibilityController)("PaneButtons.visibility", o.navigationButtonsVisibilityKey);
  },
  65388: (e, t, i) => {
    "use strict";

    i.d(t, {
      isCustomStudy: () => o
    });
    const s = {
      VbPFixed: true,
      PivotPointsStandard: true,
      VbPVisible: true,
      VbPAnchored: true
    };
    function o(e) {
      return e in s;
    }
  },
  28388: (e, t, i) => {
    "use strict";

    i.d(t, {
      MetaInfoHelper: () => u
    });
    var s = i(50151);
    var o = i(9343);
    var n = i(68159);
    var r = i(94113);
    var a = i(37265);
    var l = i(65383);
    function c(e) {
      return !e.groupId && !e.isHidden && e.id !== l.RangeDependentStudyInputNames.FirstBar && e.id !== l.RangeDependentStudyInputNames.LastBar;
    }
    var h = i(65388);
    const d = (0, o.getLogger)("Platform.GUI.PropertyDialog.Indicators.MetaInfo");
    class u {
      constructor(e) {
        this._metaInfo = e;
      }
      hasUserEditableInputs() {
        return this._metaInfo.inputs.some(c);
      }
      getUserEditableInputs() {
        return this._metaInfo.inputs.filter(c);
      }
      hasUserEditableProperties() {
        return n.StudyMetaInfo.isScriptStrategy(this._metaInfo);
      }
      hasUserEditableStyles() {
        const e = this._metaInfo;
        return e.plots.length > 0 || e.bands !== undefined || e.filledAreas !== undefined || (0, h.isCustomStudy)(e.shortId) || n.StudyMetaInfo.isScriptStrategy(this._metaInfo) || Object.values(e.graphics).some(e => e !== undefined);
      }
      getUserEditablePlots() {
        const e = new Set();
        const t = this._metaInfo;
        return t.plots.filter(i => {
          if ((0, r.isColorerPlot)(i) || (0, r.isTextColorerPlot)(i) || (0, r.isDataOffsetPlot)(i) || (0, r.isOhlcColorerPlot)(i) || (0, r.isAlertConditionPlot)(i) || (0, r.isDataPlot)(i)) {
            return false;
          }
          if ((0, r.isOhlcPlot)(i)) {
            const o = i.target;
            if (e.has(o)) {
              return false;
            }
            e.add(o);
            const n = (0, s.ensureDefined)(t.ohlcPlots);
            return !(0, s.ensureDefined)(n[o]).isHidden;
          }
          {
            const e = t.styles ? t.styles[i.id] : undefined;
            return e === undefined || !e.isHidden;
          }
        });
      }
      hasUserEditableOptions() {
        return this.hasUserEditableInputs() || this.hasUserEditableProperties() || this.hasUserEditableStyles();
      }
      getStrategyProperties() {
        const e = this._metaInfo;
        const t = e.inputs.filter(p);
        const i = {
          ..._
        };
        for (const s of t) {
          const t = s.internalID;
          i[t] = s;
          if (!_.hasOwnProperty(t)) {
            d.logWarn(`Unknown strategy input internal id ${t} in ${e.fullId}`);
          }
        }
        return (0, a.clone)(i);
      }
    }
    const _ = {
      currency: undefined,
      backtest_fill_limits_assumption: undefined,
      calc_on_every_tick: undefined,
      calc_on_order_fills: undefined,
      commission_value: undefined,
      commission_type: undefined,
      initial_capital: undefined,
      pyramiding: undefined,
      slippage: undefined,
      default_qty_type: undefined,
      default_qty_value: undefined,
      margin_long: undefined,
      margin_short: undefined,
      use_bar_magnifier: undefined,
      process_orders_on_close: undefined,
      fill_orders_on_standard_ohlc: undefined
    };
    function p(e) {
      return e.groupId === "strategy_props";
    }
  },
  59063: (e, t, i) => {
    "use strict";

    i.d(t, {
      AbstractJsonStoreService: () => o,
      CommonJsonStoreService: () => n
    });
    var s = i(52033);
    class o {
      constructor(e, t, i, o, n) {
        this._onChange = new s.Delegate();
        this._handleChange = () => {
          this._onChange.fire(this.get());
        };
        this._crossTabEvents = e;
        this._jsonKeyValueStore = t;
        this.CROSSTAB_EVENT_NAME = i;
        this.JSON_STORE_KEY = o;
        this.defaultStoreValue = this._serialize(n);
        this._subscribe();
      }
      get() {
        const e = this._jsonKeyValueStore.getJSON(this.JSON_STORE_KEY, this.defaultStoreValue);
        return this._deserialize(e);
      }
      set(e, t) {
        const i = this._serialize(e);
        this._jsonKeyValueStore.setJSON(this.JSON_STORE_KEY, i, t);
        this._crossTabEvents.emit(this.CROSSTAB_EVENT_NAME);
        this._onChange.fire(e);
      }
      getOnChange() {
        return this._onChange;
      }
      destroy() {
        this._unsubscribe();
        this._onChange.destroy();
        delete this._onChange;
      }
      _subscribe() {
        this._crossTabEvents.on(this.CROSSTAB_EVENT_NAME, this._handleChange);
        this._jsonKeyValueStore.onSync.subscribe(this, this._handleChange);
      }
      _unsubscribe() {
        this._crossTabEvents.off(this.CROSSTAB_EVENT_NAME, this._handleChange);
        this._jsonKeyValueStore.onSync.unsubscribe(this, this._handleChange);
      }
    }
    class n extends o {
      _serialize(e) {
        return e;
      }
      _deserialize(e) {
        return e;
      }
    }
  },
  38119: (e, t, i) => {
    "use strict";

    i.d(t, {
      CustomStatusModel: () => c
    });
    var s = i(64147);
    const o = "#9598a1";
    const n = false;
    const r = null;
    const a = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\"></svg>";
    class l {
      constructor(e) {
        this._visible = new s.WatchedValue(n);
        this._tooltip = new s.WatchedValue(r);
        this._icon = new s.WatchedValue(a);
        this._color = new s.WatchedValue(o);
        this._tooltipContent = new s.WatchedValue(null);
        this._symbol = e;
      }
      symbol() {
        return this._symbol;
      }
      tooltip() {
        return this._tooltip;
      }
      icon() {
        return this._icon;
      }
      color() {
        return this._color;
      }
      visible() {
        return this._visible;
      }
      tooltipContent() {
        return this._tooltipContent;
      }
    }
    class c {
      constructor() {
        this._symbolCustomStatuses = new Map();
      }
      getSymbolCustomStatus(e) {
        if (this._symbolCustomStatuses.has(e)) {
          return this._symbolCustomStatuses.get(e);
        }
        const t = new l(e);
        this._symbolCustomStatuses.set(e, t);
        return t;
      }
      hideAll() {
        for (const e of this._symbolCustomStatuses.values()) {
          e.visible().setValue(false);
        }
      }
      static getInstance() {
        if (this._instance === null) {
          this._instance = new c();
        }
        return this._instance;
      }
    }
    c._instance = null;
  },
  30141: (e, t, i) => {
    "use strict";

    i.d(t, {
      restoreShowMarketOpenStatusProperty: () => c,
      showMarketOpenStatusProperty: () => l
    });
    var s = i(17625);
    var o = i(56840);
    const n = "Chart.ShowMarketOpenStatus";
    const r = true;
    function a() {
      return o.getBool(n, r);
    }
    const l = (0, s.createPrimitiveProperty)(a());
    function c() {
      l.setValue(r);
      o.remove(n);
    }
    o.onSync.subscribe(null, () => l.setValue(a()));
    l.subscribe(null, () => o.setValue(n, l.value()));
  },
  90823: (e, t, i) => {
    "use strict";

    i.d(t, {
      MarketStatusModel: () => u
    });
    var s;
    var o = i(50151);
    var n = i(64147);
    var r = i(88960);
    var a = i(68805);
    var l = i(17326);
    var c = i(2740);
    function h(e) {
      return window.ChartApiInstance.serverTime() / 1000 - e;
    }
    function d(e, t, i) {
      if (e <= i) {
        if (t <= i) {
          return Infinity;
        } else {
          return t / 1000;
        }
      } else {
        return Math.min(e, t) / 1000;
      }
    }
    (function (e) {
      e.Open = "market";
      e.Pre = "pre_market";
      e.Post = "post_market";
      e.Close = "out_of_session";
      e.Holiday = "holiday";
      e.Delisted = "delisted";
      e.Expired = "expired";
    })(s ||= {});
    class u {
      constructor(e) {
        this._currentSession = new n.WatchedValue(null);
        this._delistedByTypespecs = new n.WatchedValue(false);
        this._sessionsSpec = null;
        this._nextSessionEdgeInternal = null;
        this._nextSessionEdge = new n.WatchedValue(null);
        this._recalcNextSessionEdgeTimerId = null;
        this._delay = 0;
        this._futuresContractExpirationTime = null;
        this._quotesProvider = e;
        this._marketStatus = (0, r.combine)((e, t, i) => e === null ? e : t ? "delisted" : i ? "expired" : function (e) {
          switch (e) {
            case "market":
              return "market";
            case "pre_market":
              return "pre_market";
            case "post_market":
              return "post_market";
            case "out_of_session":
              return "out_of_session";
            case "holiday":
              return "holiday";
          }
          (0, o.ensureNever)(e);
        }(e), this._currentSession.weakReference(), this._delistedByTypespecs.weakReference(), (this._futuresContractExpirationTime?.expired() ?? new n.WatchedValue(false)).weakReference());
        e.quotesUpdate().subscribe(this, e => {
          this._currentSession.setValue(e?.values.current_session ?? null);
        });
        e.quoteSymbolChanged().subscribe(this, () => {
          this._currentSession.setValue(null);
        });
      }
      destroy() {
        this._quotesProvider.quotesUpdate().unsubscribeAll(this);
        this._quotesProvider.quoteSymbolChanged().unsubscribeAll(this);
        if (this._recalcNextSessionEdgeTimerId !== null) {
          clearTimeout(this._recalcNextSessionEdgeTimerId);
        }
        this._marketStatus.destroy();
      }
      futuresContractExpirationTime() {
        return this._futuresContractExpirationTime;
      }
      setSymbolInfo(e) {
        this._nextSessionEdgeInternal = null;
        if (e === null) {
          this._sessionsSpec = null;
          return;
        }
        this._delay = (0, a.getSymbolDelaySeconds)(e);
        const t = new l.SessionsSpec(e.timezone, e.session_display ?? e.session, e.session_holidays, e.corrections);
        let i;
        let s;
        const o = e.subsessions?.find(e => e.id === "premarket");
        const n = e.subsessions?.find(e => e.id === "postmarket");
        if (o !== undefined) {
          i = new l.SessionsSpec(e.timezone, o["session-display"] ?? o.session, e.session_holidays, o["session-correction"]);
        }
        if (n !== undefined) {
          s = new l.SessionsSpec(e.timezone, n["session-display"] ?? n.session, e.session_holidays, n["session-correction"]);
        }
        this._sessionsSpec = {
          general: t,
          preMarket: i,
          postMarket: s
        };
        this._recalculateNextSessionEdge();
      }
      status() {
        return this._marketStatus;
      }
      currentSession() {
        return this._currentSession;
      }
      nextSessionEdge() {
        return this._nextSessionEdge;
      }
      _getNextSessionEdgeInternal() {
        if (this._sessionsSpec === null) {
          return null;
        }
        const e = h(this._delay) * 1000;
        if (this._nextSessionEdgeInternal === null || (this._nextSessionEdgeInternal.timestamp ?? Infinity) <= e / 1000) {
          const {
            general: t,
            preMarket: i,
            postMarket: s
          } = this._sessionsSpec;
          const o = (0, c.get_timezone)(t.timezone());
          const n = (0, c.utc_to_cal)(o, e);
          const r = d((0, c.cal_to_utc)(o, t.alignToNearestSessionStart(n, 1)), (0, c.cal_to_utc)(o, t.alignToNearestSessionEnd(n, 1)), e);
          const a = d(i !== undefined ? (0, c.cal_to_utc)(o, i.alignToNearestSessionStart(n, 1)) : Infinity, i !== undefined ? (0, c.cal_to_utc)(o, i.alignToNearestSessionEnd(n, 1)) : Infinity, e);
          const l = d(s !== undefined ? (0, c.cal_to_utc)(o, s.alignToNearestSessionStart(n, 1)) : Infinity, s !== undefined ? (0, c.cal_to_utc)(o, s.alignToNearestSessionEnd(n, 1)) : Infinity, e);
          let u = Math.min(r, a, l);
          if (u === Infinity) {
            const e = h(this._delay);
            const i = 60000;
            const s = new Date(Math.round(new Date(e * 1000).getTime() / i) * i).getTime() + i;
            const n = (0, c.utc_to_cal)(o, s);
            const r = d((0, c.cal_to_utc)(o, t.alignToNearestSessionStart(n, 1)), (0, c.cal_to_utc)(o, t.alignToNearestSessionEnd(n, 1)), s);
            const _ = Math.min(r, a, l);
            if (_ !== Infinity) {
              this._nextSessionEdgeInternal = {
                timestamp: u
              };
              u = _;
            } else {
              this._nextSessionEdgeInternal = {
                timestamp: null
              };
            }
          }
          this._nextSessionEdgeInternal = u === l ? {
            timestamp: u,
            status: "post_market"
          } : u === a ? {
            timestamp: u,
            status: "pre_market"
          } : {
            timestamp: u
          };
        }
        return this._nextSessionEdgeInternal;
      }
      _recalculateNextSessionEdge() {
        const e = this._getNextSessionEdgeInternal();
        if (e === null || e.timestamp === null) {
          this._nextSessionEdge.setValue(null);
          return;
        }
        const t = {
          status: e.status,
          remainingSeconds: Math.max(0, e.timestamp - h(this._delay))
        };
        if (this._recalcNextSessionEdgeTimerId === null) {
          const e = Number.isFinite(t.remainingSeconds) ? Math.ceil(t.remainingSeconds % 60) : 1;
          this._recalcNextSessionEdgeTimerId = setTimeout(() => this._recalculateNextSessionEdgeByTimer(), e * 1000);
        }
        this._nextSessionEdge.setValue(t);
      }
      _recalculateNextSessionEdgeByTimer() {
        this._recalcNextSessionEdgeTimerId = null;
        this._recalculateNextSessionEdge();
      }
    }
  },
  22118: (e, t, i) => {
    "use strict";

    i.d(t, {
      CRUCIAL_REALTIME_BATS: () => l,
      firstReplacedByBatsExchange: () => c,
      isAmexToCboeMigratedSymbol: () => _,
      isDelay: () => d,
      isEod: () => h,
      witoutRealtime: () => u
    });
    i(50151);
    var s = i(13665);
    var o = i.n(s);
    const n = ["DJ", "JSE", "BELEX"];
    const r = ["NZX"];
    const a = ["BIVA"];
    const l = ["AMEX", "NASDAQ", "NYSE"];
    function c(e) {
      return null;
    }
    function h(e, t) {
      return o().hasEodSymbols(e.full_name) || t === 6;
    }
    function d(e) {
      return e !== undefined && e > 0;
    }
    function u(e) {
      return e.type === "index" && n.includes(e.listed_exchange) || e.type === "futures" && r.includes(e.listed_exchange) || a.includes(e.listed_exchange);
    }
    function _(e, t) {
      return t === "amex" && e === "CBOE";
    }
  },
  76032: (e, t, i) => {
    "use strict";

    i.d(t, {
      getStudyTemplateDescString: () => a,
      getStudyTemplateMetaInfo: () => n,
      getStudyTemplateSaveData: () => r
    });
    var s = i(19466);
    var o = i(79036);
    function n(e, t) {
      return {
        indicators: e.orderedDataSources(true).filter(e => (0, o.isStudy)(e) && true).map(e => ({
          id: e.metaInfo().id,
          description: e.title(s.TitleDisplayTarget.StatusLine, true, undefined, true)
        })),
        interval: t
      };
    }
    function r(e, t, i, s) {
      const o = t.studyTemplate(i, s);
      return {
        name: e,
        content: JSON.stringify(o),
        meta_info: n(t, o.interval)
      };
    }
    function a(e) {
      const t = new Map();
      e.forEach(e => {
        const [i, s] = t.get(e.id) || [e.description, 0];
        t.set(e.id, [i, s + 1]);
      });
      return Array.from(t.values()).map(([e, t]) => `${e}${t > 1 ? ` x ${t}` : ""}`).join(", ");
    }
  },
  79652: (e, t, i) => {
    "use strict";

    i.d(t, {
      canShowSpreadActions: () => o,
      globalKeypressMatches: () => n
    });
    var s = i(56570);
    function o() {
      let e = false;
      if (s.enabled("show_spread_operators")) {
        e = true;
      }
      return e;
    }
    function n(e) {
      if (e.ctrlKey) {
        return false;
      }
      if (e.metaKey) {
        return false;
      }
      if (!e.charCode) {
        return false;
      }
      if (!e.which || e.which <= 32) {
        return false;
      }
      const t = e.target;
      return !t || !/^(input|textarea)$/i.test(t.tagName) && t.getAttribute("role") !== "listbox";
    }
  },
  50340: (e, t, i) => {
    "use strict";

    function s() {
      return Promise.all([i.e(359), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(9481), i.e(4600), i.e(2564), i.e(7384), i.e(2197), i.e(1072), i.e(9325), i.e(116), i.e(8985), i.e(4106), i.e(7444), i.e(2227), i.e(4931), i.e(9418), i.e(2544), i.e(3202), i.e(2751), i.e(1754)]).then(i.bind(i, 89324));
    }
    i.d(t, {
      loadNewSymbolSearch: () => s
    });
  },
  79320: (e, t, i) => {
    "use strict";

    i.d(t, {
      tradingService: () => n
    });
    var s = i(16216);
    const o = {
      id: "TradingService"
    };
    function n() {
      if ((0, s.hasService)(o)) {
        return (0, s.service)(o);
      } else {
        return null;
      }
    }
  },
  96000: (e, t, i) => {
    "use strict";

    i.d(t, {
      AbstractBarColorer: () => s
    });
    class s {
      constructor() {
        this._backColorers = [];
      }
      barStyle(e, t, i) {
        const s = {};
        for (const o of this._backColorers) {
          o.applyBarStyle(e, t, s, i);
        }
        this.applyBarStyle(e, t, s, i);
        return s;
      }
      pushBackBarColorer(e) {
        this._backColorers.unshift(e);
      }
      firstColoredBar(e) {
        return null;
      }
    }
  },
  19475: (e, t, i) => {
    "use strict";

    i.d(t, {
      addPlusButtonProperty: () => p,
      restoreAddPlusButtonSettingsValue: () => m,
      showPlusButtonOnCursor: () => d
    });
    var s = i(26709);
    var o = i(56570);
    var n = i(56840);
    var r = i(17625);
    var a = i(64147);
    const l = "add_plus_button";
    function c() {
      const e = s.keyboardPressedKeysState.value();
      return e !== undefined && Boolean(e.modifiers & s.Modifiers.Alt && e.modifiers & s.Modifiers.Mod) && (e.code === undefined || e.altOrOptionCode() || e.controlOrMetaCode());
    }
    const h = new a.WatchedValue(c());
    s.keyboardPressedKeysState.subscribe(() => h.setValue(c()));
    const d = h.readonly();
    function u() {
      return o.enabled("chart_crosshair_menu");
    }
    function _() {
      return n.getBool(l, u());
    }
    const p = (0, r.createPrimitiveProperty)(_());
    function m() {
      p.setValue(u());
      n.remove(l);
    }
    n.onSync.subscribe(null, () => p.setValue(_()));
    p.subscribe(null, () => {
      n.setValue(l, p.value());
      o.setEnabled("chart_crosshair_menu", !o.enabled("chart_crosshair_menu"));
    });
  },
  92934: (e, t, i) => {
    "use strict";

    i.d(t, {
      alignToStep: () => n
    });
    var s = i(60521);
    var o = i.n(s);
    function n(e, t) {
      return o()(e).div(t).round(0, o().roundHalfUp).mul(t).toNumber();
    }
  },
  92158: (e, t, i) => {
    "use strict";

    i.d(t, {
      actualAutoLogButtonsVisibility: () => l,
      autoLogButtonsVisibilityOptions: () => r,
      autoLogButtonsVisibilityProperty: () => n,
      restoreAutoLogButtonsVisibilitySettingsValue: () => a
    });
    var s;
    var o = i(17656);
    (function (e) {
      e.SettingsKey = "PriceAxisAutoLogButtons.visibility";
    })(s ||= {});
    const {
      property: n,
      availableValues: r,
      restoreDefaultValue: a,
      actualBehavior: l
    } = (0, o.createVisibilityController)("PriceAxisAutoLogButtons.visibility");
  },
  57596: (e, t, i) => {
    "use strict";

    i.d(t, {
      axisLabelBackgroundColor: () => o
    });
    var s = i(19625);
    const o = {
      common: s.colorsPalette["color-tv-blue-500"],
      active: s.colorsPalette["color-tv-blue-800"]
    };
    var n;
    (function (e) {
      e.BorderColor = "#2E84A6";
    })(n ||= {});
  },
  53388: (e, t, i) => {
    "use strict";

    i.d(t, {
      createDwmAligner: () => c,
      createTimeToBarTimeAligner: () => d,
      isAlignmentEnabled: () => h
    });
    var s = i(2740);
    var o = i(56570);
    var n = i(85049);
    var r = i(42217);
    var a = i(14381);
    const l = new r.SessionInfo("Etc/UTC", "0000-0000:1234567");
    function c(e, t) {
      if (!h() || !n.Interval.isDWM(e)) {
        return null;
      }
      const i = new r.SessionInfo(t.timezone, t.session, t.session_holidays, t.corrections);
      const o = (0, a.newBarBuilder)(e, i, l);
      return {
        timeToSessionStart: e => o.tradingDayToSessionStart(e),
        timeToExchangeTradingDay: e => {
          const t = (0, s.utc_to_cal)(i.timezone, e);
          const o = i.spec.correctTradingDay(t);
          (0, s.set_hms)(o, 0, 0, 0, 0, (0, s.get_timezone)("Etc/UTC"));
          return o.getTime();
        }
      };
    }
    function h() {
      return !o.enabled("disable_resolution_rebuild");
    }
    function d(e, t) {
      if (!h()) {
        return e => e;
      }
      const i = new r.SessionInfo(t.timezone, t.session, t.session_holidays, t.corrections);
      const s = (0, a.newBarBuilder)(e, i, i, false);
      return e => s.alignTimeIfPossible(e);
    }
  },
  42217: (e, t, i) => {
    "use strict";

    i.d(t, {
      BarBuilderBase: () => a,
      SessionInfo: () => r
    });
    var s = i(2740);
    var o = i(83910);
    var n = i(17326);
    class r {
      constructor(e, t, i, s) {
        this.init(e, t, i, s);
        this._state = {
          timezone: e,
          spec: t,
          holidays: i,
          corrections: s
        };
      }
      init(e, t, i, o) {
        this.timezone = (0, s.get_timezone)(e);
        this.spec = new n.SessionsSpec(e, t, i, o);
      }
      state() {
        return this._state;
      }
      static fromState(e) {
        return new r(e.timezone, e.spec, e.holidays, e.corrections);
      }
      static wrap(e) {
        const t = new r("Etc/UTC", "24x7");
        t.spec = e;
        return t;
      }
      static create(e, t, i, s) {
        return new r(e, t, i, s);
      }
    }
    class a {
      alignTime(e) {
        if (isNaN(e)) {
          return NaN;
        }
        let t = this.indexOfBar(e);
        if (t === o.SessionStage.POST_SESSION) {
          this.moveTo(e);
          t = this.indexOfBar(e);
        }
        if (t < 0) {
          return NaN;
        } else {
          return this.startOfBar(t);
        }
      }
    }
  },
  14381: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      SessionInfo: () => r.SessionInfo,
      alignExchangeTimeToSessionStartAndReturnUTC: () => D,
      alignPeriodsBackForDataRequest: () => M,
      alignPeriodsBackForVisibleRange: () => A,
      getPeriodsBetweenDates: () => k,
      isTradingNow: () => E,
      newBarBuilder: () => I
    });
    var s = i(2740);
    var o = i(85049);
    var n = i(9859);
    var r = i(42217);
    var a = i(83910);
    class l extends r.BarBuilderBase {
      constructor(e, t) {
        super();
        this._sessionStartMs = -Number.MAX_VALUE;
        this._sessionEndMs = -Number.MAX_VALUE;
        this._periodSec = e;
        this._session = t;
      }
      alignTimeIfPossible(e) {
        const t = this.alignTime(e);
        if (isNaN(t)) {
          return e;
        } else {
          return t;
        }
      }
      indexOfBar(e) {
        if (e < this._sessionStartMs) {
          return a.SessionStage.PRE_SESSION;
        } else if (e >= this._sessionEndMs) {
          return a.SessionStage.POST_SESSION;
        } else {
          return (0, n.toInt)((0, s.time_seconds_diff)(e, this._sessionStartMs) / this._periodSec);
        }
      }
      startOfBar(e) {
        if (e === a.SessionStage.PRE_SESSION) {
          const e = (0, s.get_cal_from_unix_timestamp_ms)(this._session.timezone, this._sessionStartMs - 1);
          const t = this._session.spec.alignToNearestSessionEnd(e, -1);
          return (0, s.cal_to_utc)(this._session.timezone, t);
        }
        if (e === a.SessionStage.POST_SESSION) {
          return this._sessionEndMs;
        }
        if (e < 0) {
          throw new Error("Negative offset is not supported");
        }
        return this._sessionStartMs + (0, s.time_seconds)(this._periodSec * e);
      }
      endOfBar(e) {
        if (e < 0) {
          throw new Error("Index cannot be negative");
        }
        const t = this.startOfBar(e) + this._periodSec * 1000;
        if (t > this._sessionEndMs) {
          return this._sessionEndMs;
        } else {
          return t;
        }
      }
      isLastBar(e, t) {
        return t >= this._sessionStartMs + (0, s.time_seconds)(this._periodSec * (e + 1) - 1);
      }
      moveTo(e) {
        const t = this._session.timezone;
        const i = (0, s.utc_to_cal)(t, e);
        const o = this._session.spec.alignToSessionStart(i);
        this._sessionStartMs = (0, s.cal_to_utc)(t, i);
        (0, s.add_minutes)(i, o);
        this._sessionEndMs = (0, s.cal_to_utc)(t, i);
      }
      indexOfLastBarInSession() {
        return (0, n.toInt)((this._sessionEndMs - 1 - this._sessionStartMs) / 1000 / this._periodSec);
      }
      moveNext() {
        this.moveTo(this._sessionEndMs);
      }
      static minutes(e, t) {
        return new l(e * 60, t);
      }
      static seconds(e, t) {
        return new l(e, t);
      }
    }
    var c = i(50151);
    var h = i(79324);
    const d = (0, s.get_timezone)("Etc/UTC");
    function u(e, t, i) {
      const o = (0, s.clone)(t);
      const n = e.businessDaysToCalendarDays(o, 1);
      if (n > 1) {
        (0, s.add_date)(o, n - 1);
      }
      const r = e.leftBorderOfDailyBar(o);
      if (r === null) {
        throw new Error("Cannot calculate left border of daily bar");
      }
      return (0, s.cal_to_utc)(i, r, true);
    }
    class _ {
      constructor(e, t) {
        this.from = e;
        this.to = t;
      }
      toString() {
        return `${this.from.toString()} - ${this.to.toString()}`;
      }
    }
    class p extends r.BarBuilderBase {
      constructor(e, t, i, s, o = false) {
        super();
        this._periodStart = -Number.MAX_VALUE;
        this._periodEnd = -Number.MAX_VALUE;
        this._periodLastBarStart = -Number.MAX_VALUE;
        this._periodStartDay = new h.BusinessDay(0, 0, 0);
        this._periodEndDay = new h.BusinessDay(0, 0, 0);
        this._period = i;
        this._sessionTgt = e;
        this._builder = s;
        this._useBusinessDays = o;
        if (o) {
          (0, c.assert)(t === null, "useBusinessDays and sessionSrc are mutually exclusive arguments");
          this._sessionSrc = new r.SessionInfo("Etc/UTC", "24x7");
        } else {
          this._sessionSrc = t || e;
        }
      }
      builder() {
        return this._builder;
      }
      alignTimeIfPossible(e) {
        return this.tradingDayToSessionStart(e);
      }
      tradingDayToSessionStart(e) {
        this.moveTo(e);
        return this.startOfBar(0);
      }
      indexOfBar(e) {
        if (this._useBusinessDays) {
          const t = h.BusinessDay.fromCalendar((0, s.get_cal_from_unix_timestamp_ms)(this._sessionSrc.timezone, e));
          if (t.before(this._periodStartDay)) {
            return a.SessionStage.PRE_SESSION;
          } else if (this._periodEndDay.before(t)) {
            return a.SessionStage.POST_SESSION;
          } else {
            return 0;
          }
        }
        if (e < this._periodStart) {
          return a.SessionStage.PRE_SESSION;
        } else if (e >= this._periodEnd) {
          return a.SessionStage.POST_SESSION;
        } else {
          return 0;
        }
      }
      startOfBar(e) {
        if (e === a.SessionStage.PRE_SESSION) {
          const e = (0, s.get_cal_from_unix_timestamp_ms)(this._sessionTgt.timezone, this._periodStart - 1);
          const t = this._sessionTgt.spec.alignToNearestSessionEnd(e, -1);
          return (0, s.cal_to_utc)(this._sessionTgt.timezone, t) - 1;
        }
        if (e === a.SessionStage.POST_SESSION || e > 0) {
          return this._periodEnd;
        } else if (e === a.SessionStage.LASTBAR_SESSION) {
          return this._periodLastBarStart;
        } else {
          return this._periodStart;
        }
      }
      moveTo(e) {
        let t = (0, s.get_cal_from_unix_timestamp_ms)(this._sessionSrc.timezone, e);
        t = this._sessionSrc.spec.correctTradingDay(t);
        const i = (0, s.get_year)(t);
        const o = this._indexOfPeriodInYear(t);
        const n = o + this._period;
        const r = this._sessionTgt.spec;
        const a = this._sessionTgt.timezone;
        const l = this._builder.startOfPeriod(o, i);
        this._periodStart = u(r, l, a);
        const c = r.businessDaysToCalendarDays(l, 1);
        if (c > 1) {
          (0, s.add_date)(l, c - 1);
        }
        this._periodStartDay = h.BusinessDay.fromCalendar(l);
        let d = this._builder.startOfPeriod(n, i);
        this._periodEnd = u(r, d, a);
        const _ = (0, s.clone)(d);
        for ((0, s.add_date)(_, -1); r.isCalWeekEnd(_);) {
          (0, s.add_date)(_, -1);
        }
        this._periodEndDay = h.BusinessDay.fromCalendar(_);
        (0, s.add_date)(d, -1);
        d = function (e, t) {
          const i = (0, s.clone)(t);
          while (e.isCalWeekEnd(i)) {
            (0, s.add_date)(i, -1);
          }
          return i;
        }(this._sessionTgt.spec, d);
        this._periodLastBarStart = u(r, d, a);
        if (this._periodLastBarStart < this._periodStart || this._periodLastBarStart === this._periodEnd) {
          this._periodLastBarStart = this._periodStart;
        }
      }
      endOfBar(e) {
        if (e === a.SessionStage.LAST_SESSION_END) {
          return this._getZonedDateTimeOfBorder(a.SessionStage.LAST_SESSION_END).getTime() + 1000;
        } else {
          (0, c.assert)(e === 0);
          return this._periodEnd;
        }
      }
      isLastBar(e, t) {
        if (e !== 0) {
          throw new Error("index should be 0");
        }
        return t >= this._periodLastBarStart;
      }
      moveBarsForward(e, t) {
        (0, c.assert)(t > 0);
        const i = (0, s.get_cal_from_unix_timestamp_ms)(this._sessionTgt.timezone, e);
        let o = this._sessionTgt.spec.correctTradingDay(i);
        for (let e = 0; e < t; e++) {
          const e = this._period + this._builder.indexOfPeriod(o);
          o = this._builder.startOfPeriod(e, (0, s.get_year)(o));
          o = this._sessionTgt.spec.correctTradingDay(o);
        }
        this.moveTo((0, s.cal_to_utc)(this._sessionTgt.timezone, o));
        return this.startOfBar(0);
      }
      currentRange() {
        return new _(this._periodStartDay, this._periodEndDay);
      }
      indexOfBarInYear(e) {
        const t = (0, s.get_cal_from_unix_timestamp_ms)(this._sessionSrc.timezone, e);
        const i = (0, s.get_year)(t);
        const o = this._builder.indexOfPeriod(t);
        const r = this._sessionTgt.timezone;
        let a = this._builder.startOfPeriod(o, i);
        let l = u(this._sessionTgt.spec, a, r);
        a = (0, s.get_cal_from_unix_timestamp_ms)(d, l);
        if (i < (0, s.get_year)(a)) {
          a = this._builder.startOfPeriod(o - 1, i);
          l = u(this._sessionTgt.spec, a, r);
          return {
            index: (o - 1) / this._period,
            time: l
          };
        } else {
          return {
            index: (0, n.toInt)(o / this._period),
            time: l
          };
        }
      }
      sessionSrc() {
        return this._sessionSrc;
      }
      sessionTgt() {
        return this._sessionTgt;
      }
      static days(e, t, i) {
        return new p(t, i, e, new S(t), false);
      }
      static weeks(e, t, i) {
        return new p(t, i, e, new C(t), false);
      }
      static months(e, t, i) {
        return new p(t, i, e, new P(t), false);
      }
      static daysFromBusinessDays(e, t) {
        return new p(t, null, e, new S(t), true);
      }
      static weeksFromBusinessDays(e, t) {
        return new p(t, null, e, new C(t), true);
      }
      static monthsFromBusinessDays(e, t) {
        return new p(t, null, e, new P(t), true);
      }
      _getZonedDateTimeOfBorder(e) {
        (0, c.assert)(e === a.SessionStage.FIRST_SESSION_START || e === a.SessionStage.LAST_SESSION_END);
        const t = this._sessionTgt.spec.timezoneObj();
        if (e === a.SessionStage.FIRST_SESSION_START) {
          const e = this.currentRange().from.toCalendar(t);
          return (0, c.ensureNotNull)(this._sessionTgt.spec.bordersOfDailyBar(e)).from;
        }
        {
          const e = this.currentRange().to.toCalendar(t);
          return (0, c.ensureNotNull)(this._sessionTgt.spec.bordersOfDailyBar(e)).to;
        }
      }
      _indexOfPeriodInYear(e) {
        const t = this._builder.indexOfPeriod(e);
        let i = (0, n.toInt)(t / this._period) * this._period;
        if (t === -1) {
          i = -this._period;
        }
        return i;
      }
    }
    function m(e, t) {
      const i = e.getWeekIndex(t);
      const o = (0, s.get_day_of_week)(t) - e.getEntriesForWeek(i).firstDayOfWeek();
      if (o < 0) {
        return o + 7;
      } else {
        return o;
      }
    }
    function g(e, t) {
      const i = (0, s.get_day_of_year)(t) - 1;
      let o = m(e, t) - i % 7;
      if (o === 0) {
        return (0, n.toInt)(i / 7);
      } else {
        if (o >= 0) {
          o -= 7;
        }
        return (0, n.toInt)((o + i) / 7);
      }
    }
    class f {
      indexOfPeriod(e) {
        return (0, s.get_day_of_year)(e) - 1;
      }
      startOfPeriod(e, t) {
        const i = (0, s.days_per_year)(t);
        return (0, s.get_cal)(d, t, s.JANUARY, 1 + Math.min(e, i));
      }
    }
    class y extends f {
      constructor(e) {
        super();
        this._sessionsSpec = e;
      }
      indexOfPeriod(e) {
        return super.indexOfPeriod(e) - function (e, t) {
          const i = g(e, t);
          const o = (0, s.get_cal)(d, (0, s.get_year)(t), s.JANUARY, 1);
          (0, s.add_date)(o, i * 7);
          const n = i * e.weekEndsCountForSingleSession() + e.holidaysFromYearStart(o);
          const r = (0, s.get_day_of_year)(t) - (0, s.get_day_of_year)(o);
          return n + r - e.calendarDaysToBusinessDays(o, r);
        }(this._sessionsSpec, e);
      }
      startOfPeriod(e, t) {
        const i = 7 - this._sessionsSpec.weekEndsCountForSingleSession();
        const o = Math.max(0, Math.trunc(e / i) - 1);
        const n = (0, s.get_cal)(d, t, s.JANUARY, 1);
        const r = (0, s.days_per_year)(t);
        (0, s.add_date)(n, o * 7);
        if ((e -= i * o - this._sessionsSpec.holidaysFromYearStart(n)) > 0) {
          const t = this._sessionsSpec.businessDaysToCalendarDays(n, e);
          (0, s.add_date)(n, t);
        }
        let a = (0, s.get_day_of_year)(n) - 1;
        if (t < (0, s.get_year)(n)) {
          a += r;
        }
        return super.startOfPeriod(a, t);
      }
    }
    class v extends f {
      constructor(e) {
        super();
        this._sessionsSpec = e;
      }
      indexOfPeriod(e) {
        return super.indexOfPeriod(e) - this._sessionsSpec.daysOffFromYearStart(e);
      }
      startOfPeriod(e, t) {
        const i = (0, s.get_cal)(d, t, s.JANUARY, 1);
        (0, s.add_date)(i, e);
        const o = this._sessionsSpec.daysOffFromYearStart(i);
        (0, s.add_date)(i, o);
        const n = this._sessionsSpec.daysOffFromYearStart(i) - o;
        if (n > 0) {
          const e = this._sessionsSpec.businessDaysToCalendarDays(i, n);
          (0, s.add_date)(i, e);
        }
        let r = (0, s.get_day_of_year)(i) - 1;
        if (t < (0, s.get_year)(i)) {
          r += (0, s.days_per_year)(t);
        }
        return super.startOfPeriod(r, t);
      }
    }
    class S {
      constructor(e) {
        this._builder = null;
        this._initialized = false;
        this._session = e;
      }
      indexOfPeriod(e) {
        return this._getBuilder().indexOfPeriod(e);
      }
      startOfPeriod(e, t) {
        return this._getBuilder().startOfPeriod(e, t);
      }
      _getBuilder() {
        if (this._builder === null || !this._initialized) {
          if (this._session.spec.hasWeekEnds()) {
            this._builder = this._session.spec.hasHistoryCorrections() ? new v(this._session.spec) : new y(this._session.spec);
          } else {
            this._builder = this._session.spec.hasHistoryCorrections() ? new v(this._session.spec) : new f();
          }
          this._initialized = true;
        }
        return this._builder;
      }
    }
    class b {
      constructor(e) {
        this._spec = e;
      }
      indexOfPeriod(e) {
        let t = g(this._spec, e);
        if (t === 0 && e.getTime() < this.startOfPeriod(0, (0, s.get_year)(e)).getTime()) {
          t = -1;
        }
        return t;
      }
      startOfPeriod(e, t) {
        if (e < 0) {
          t--;
          const i = (0, s.get_cal)(d, t, s.DECEMBER, 31, 23, 59, 59);
          const o = this.indexOfPeriod(i);
          const n = e * -1;
          const r = Math.trunc(o / n) * n;
          return this.startOfPeriod(r, t);
        }
        const i = (0, s.get_cal)(d, t, s.JANUARY, 1);
        const o = m(this._spec, i);
        const n = o === 0 ? e * 7 : (e + 1) * 7 - o;
        if (n > (0, s.days_per_year)((0, s.get_year)(i))) {
          return this.startOfPeriod(0, t + 1);
        } else {
          (0, s.add_date)(i, n);
          return i;
        }
      }
    }
    class w {
      constructor(e) {
        this._yearStartDataHash = new Map();
        this._spec = e;
      }
      startOfPeriod(e, t) {
        if (e < 0) {
          t--;
          const i = (0, s.get_cal)(d, t, s.DECEMBER, 31, 23, 59, 59);
          const o = this.indexOfPeriod(i);
          const n = e * -1;
          const r = Math.trunc(o / n) * n;
          return this.startOfPeriod(r, t);
        }
        const i = this._spec.getWeekIndicesWithAdditionalWeekBars(t);
        const o = this._getStartOfYearData(t, i);
        const n = this._moveToWeekIndexAccountingAdditional(o.firstWeekIndex, i, e);
        const r = (n - o.firstWeekIndex) * 7;
        let a = (0, s.clone)((0, c.ensureNotNull)(o.startOfFirstBarInYear));
        (0, s.add_date)(a, r);
        if ((0, s.get_year)(a) > t) {
          const e = t + 1;
          const i = this._spec.getWeekIndicesWithAdditionalWeekBars(e);
          const s = this._getStartOfYearData(e, i);
          if (a.getTime() >= (0, c.ensureNotNull)(s.startOfFirstBarInYear).getTime()) {
            return this.startOfPeriod(0, e);
          }
        }
        a = this._calculateBarWeekStart(a, i, n, e);
        return a;
      }
      indexOfPeriod(e) {
        const t = this._spec.getWeekIndex(e);
        const i = this._spec.getWeekIndicesWithAdditionalWeekBars((0, s.get_year)(e));
        const o = this._getStartOfYearData((0, s.get_year)(e), i);
        if (e.getTime() < (0, c.ensureNotNull)(o.startOfFirstBarInYear).getTime()) {
          return -1;
        }
        if (t === 0 && w.isOnFirstCalendarWeekOfYear(e) || t !== 0 && t === o.firstWeekIndex) {
          return this._calculateLastWeek(e, t, i, o.firstWeekbarsCount) - 1;
        }
        let n = this._numberOfCalendarWeeks(e);
        n += o.firstWeekbarsCount - o.fullWeeksAdjustment;
        n += this._calculateWeeksWithExtraBar(t, i, o.firstWeekIndex);
        n += this._calculateLastWeek(e, t, i, w.fullWeekOfAdditionalBarsCount) - 1;
        return n;
      }
      static isOnFirstCalendarWeekOfYear(e) {
        if ((0, s.get_day_of_year)(e) > s.LAST_DAY_OF_WEEK) {
          return false;
        }
        const t = (0, s.get_cal)(d, (0, s.get_year)(e), s.JANUARY, 1, 0, 0);
        const i = (0, s.clone)(t);
        (0, s.add_date)(i, s.LAST_DAY_OF_WEEK - (0, s.get_day_of_week)(t));
        return e.getTime() < i.getTime();
      }
      _moveToWeekIndexAccountingAdditional(e, t, i) {
        let s = e + i;
        for (const i of t) {
          if (!(i.weekIndex < e)) {
            if (i.weekIndex >= s) {
              break;
            }
            s--;
          }
        }
        return s;
      }
      _calculateBarWeekStart(e, t, i, o) {
        const n = this._getIndexOfWeekWithExtraBarIfExists(t, i);
        if (n === null) {
          const t = this._spec.getEntriesForWeek(i).firstDayOfWeek() - (0, s.get_day_of_week)(e);
          const o = (0, s.clone)(e);
          (0, s.add_date)(o, t);
          return o;
        }
        const r = this._spec.getHistoryByIndex(n.entryIndex);
        if (this.indexOfPeriod((0, c.ensureNotNull)(r.getStartDay())) === o) {
          return (0, s.clone)((0, c.ensureNotNull)(r.getStartDay()));
        }
        const a = this._spec.getHistoryByIndex(n.entryIndex - 1).getEntries().firstDayOfWeek() - (0, s.get_day_of_week)(e);
        const l = (0, s.clone)(e);
        (0, s.add_date)(l, a);
        return l;
      }
      _numberOfCalendarWeeks(e) {
        const t = (0, s.get_day_of_year)(e);
        const i = (0, s.get_day_of_week)(e);
        return Math.trunc((t - i) / 7);
      }
      _getStartOfYearData(e, t) {
        let i = this._yearStartDataHash.get(e);
        if (i !== undefined) {
          return i;
        }
        let o = (0, s.get_cal)(d, e, s.JANUARY, 1, 0, 0);
        let n = this._spec.getWeekIndex(o);
        let r = 0;
        if ((0, s.get_day_of_week)(o) === s.FIRST_DAY_OF_WEEK) {
          r = 1;
        }
        i = this._getYearStartDataFromWeek(t, n, o);
        while (i.startOfFirstBarInYear === null) {
          n++;
          r++;
          o = this._moveToNextCalendarWeekStart(o);
          i = this._getYearStartDataFromWeek(t, n, o);
        }
        i.fullWeeksAdjustment = r;
        this._yearStartDataHash.set(e, i);
        return i;
      }
      _moveToNextCalendarWeekStart(e) {
        const t = (0, s.get_day_of_week)(e);
        const i = (0, s.clone)(e);
        (0, s.add_date)(i, s.LAST_DAY_OF_WEEK - t + 1);
        return i;
      }
      _getYearStartDataFromWeek(e, t, i) {
        const o = (0, s.get_day_of_week)(i);
        let n = null;
        let r = 0;
        const a = this._getIndexOfWeekWithExtraBarIfExists(e, t);
        if (a !== null) {
          let e = this._spec.getHistoryByIndex(a.entryIndex - 1).getEntries().firstDayOfWeek() - o;
          if (e >= 0) {
            n = (0, s.clone)(i);
            (0, s.add_date)(n, e);
            r = 2;
          } else {
            const t = this._spec.getHistoryByIndex(a.entryIndex);
            e = t.getEntries().firstDayOfWeek() - o;
            if (e >= 0) {
              n = t.getStartDay();
              n &&= (0, s.clone)(n);
              r = 1;
            }
          }
        } else {
          const e = this._spec.getEntriesForWeek(t);
          const a = e.firstDayOfWeek() - o;
          if (a >= 0 && (this._hasWorkingDays(e) || this._hasWorkingDaysNextWeek(t + 1))) {
            n = (0, s.clone)(i);
            (0, s.add_date)(n, a);
            r = 1;
          }
        }
        return {
          startOfFirstBarInYear: n,
          firstWeekIndex: t,
          firstWeekbarsCount: r,
          fullWeeksAdjustment: 0
        };
      }
      _hasWorkingDays(e) {
        if (e.entriesByDay().size === 0) {
          return false;
        }
        for (let t = e.firstDayOfWeek(); t <= s.LAST_DAY_OF_WEEK; t++) {
          if (e.entriesByDay().get(t) !== undefined) {
            return true;
          }
        }
        return false;
      }
      _hasWorkingDaysNextWeek(e) {
        const t = this._spec.getEntriesForWeek(e);
        for (let e = 1; e < t.firstDayOfWeek(); e++) {
          if (t.entriesByDay().get(e) !== undefined) {
            return true;
          }
        }
        return false;
      }
      _calculateWeeksWithExtraBar(e, t, i) {
        let s = 0;
        for (const o of t) {
          if (o.weekIndex >= e) {
            break;
          }
          if (o.weekIndex > i) {
            s++;
          }
        }
        return s;
      }
      _calculateLastWeek(e, t, i, o) {
        const n = (0, s.get_day_of_week)(e);
        const r = this._getIndexOfWeekWithExtraBarIfExists(i, t);
        if (r === null) {
          if (n - this._spec.getEntriesForWeek(t).firstDayOfWeek() >= 0) {
            return 1;
          } else {
            return 0;
          }
        }
        const a = this._positionInsideWeekWithSeveralBars(r, n);
        if (a === w.IsInNewSession) {
          return o;
        } else if (a === w.IsInMidSession) {
          return o - 1;
        } else {
          return 0;
        }
      }
      _getIndexOfWeekWithExtraBarIfExists(e, t) {
        for (const i of e) {
          if (i.weekIndex === t) {
            return i;
          }
          if (i.weekIndex > t) {
            break;
          }
        }
        return null;
      }
      _positionInsideWeekWithSeveralBars(e, t) {
        let i = this._spec.getHistoryByIndex(e.entryIndex).getEntries().firstDayOfWeek() - t;
        if (i <= 0) {
          return w.IsInNewSession;
        }
        i = this._spec.getHistoryByIndex(e.entryIndex - 1).getEntries().firstDayOfWeek() - t;
        if (i <= 0) {
          return w.IsInMidSession;
        } else {
          return w.IsBeforeAnySession;
        }
      }
    }
    w.IsBeforeAnySession = -1;
    w.IsInMidSession = 0;
    w.IsInNewSession = 1;
    w.fullWeekOfAdditionalBarsCount = 2;
    class C {
      constructor(e) {
        this._builder = null;
        this._session = e;
      }
      indexOfPeriod(e) {
        return this._getBuilder().indexOfPeriod(e);
      }
      startOfPeriod(e, t) {
        return this._getBuilder().startOfPeriod(e, t);
      }
      _getBuilder() {
        if (this._builder == null) {
          this._builder = this._session.spec.hasHistoryCorrections() ? new w(this._session.spec) : new b(this._session.spec);
        }
        return this._builder;
      }
    }
    class P {
      constructor(e) {
        this._session = e;
      }
      indexOfPeriod(e) {
        return (0, s.get_month)(e);
      }
      startOfPeriod(e, t) {
        if (e < 0) {
          const i = (0, n.toInt)((11 - e) / 12);
          t -= i;
          e += i * 12;
        } else if (e > s.DECEMBER) {
          t++;
          e = s.JANUARY;
        }
        return (0, s.get_cal)(d, t, e, 1);
      }
    }
    var T;
    var x;
    function I(e, t, i, s = false) {
      const n = o.Interval.parse(e);
      const r = n.multiplier();
      if (n.isMinutes()) {
        return l.minutes(r, t);
      } else if (n.isSeconds()) {
        return l.seconds(r, t);
      } else if (n.isTicks()) {
        return new l(1, t);
      } else if (n.isRange()) {
        return new l(r * 60, t);
      } else {
        return new p(t, i ?? null, r, function (e, t) {
          switch (e) {
            case o.ResolutionKind.Days:
              return new S(t);
            case o.ResolutionKind.Weeks:
              return new C(t);
            case o.ResolutionKind.Months:
              return new P(t);
          }
          throw new Error(`Unknown dwm resolution: ${e}`);
        }(n.kind(), t), s);
      }
    }
    function M(e, t, i, s, o, n, r) {
      return L(e, t, i, s, o, n, r, 0);
    }
    function A(e, t, i, s, o, n, r) {
      return L(e, t, i, s, o, n, r, 1);
    }
    function L(e, t, i, n, a, l, c, h) {
      const d = o.Interval.parse(a + n);
      if (d.isMonths()) {
        const e = new Date(c);
        if (h === 0) {
          e.setUTCDate(1);
        }
        (function (e, t) {
          B(e, Math.floor(t / 12));
          let i = e.getUTCMonth() - t % 12;
          if (i < 0) {
            B(e, 1);
            i += 12;
          }
          e.setUTCMonth(i);
          while (e.getUTCMonth() !== i) {
            V(e, 1);
          }
        })(e, l * d.multiplier());
        return e.getTime();
      }
      const u = new r.SessionInfo("Etc/UTC", e, t, i);
      const _ = d.inMilliseconds();
      const p = d.isDWM();
      let m;
      if (p) {
        m = 86400000;
      } else {
        const e = u.spec.getWeekIndex((0, s.get_cal_from_unix_timestamp_ms)(u.timezone, c));
        m = u.spec.getEntriesForWeek(e).maxTradingDayLength() * 60 * 1000;
      }
      let g = 0;
      if (d.isWeeks()) {
        g = 7;
      } else {
        const e = u.spec.getWeekIndex((0, s.get_cal_from_unix_timestamp_ms)(u.timezone, c));
        g = 7 - u.spec.getEntriesForWeek(e).weekEndsCount();
      }
      const f = m / _;
      const y = g * f;
      let v;
      if (l < y) {
        v = l / f;
      } else {
        v = l / y * 7;
      }
      if (p) {
        v = Math.floor(v);
      }
      return c - v * 86400000;
    }
    function k(e, t, i, n, a, l, c) {
      const h = o.Interval.parse(a + n);
      if (h.isMonths()) {
        const e = new Date(l);
        const t = new Date(c);
        let i = (t.getUTCFullYear() - e.getUTCFullYear()) * 12;
        i += t.getUTCMonth() - e.getUTCMonth();
        return Math.ceil(i / h.multiplier());
      }
      const d = new r.SessionInfo("Etc/UTC", e, t, i);
      const u = h.inMilliseconds();
      let _;
      if (h.isDWM()) {
        _ = 86400000;
      } else {
        const e = d.spec.getWeekIndex((0, s.get_cal_from_unix_timestamp_ms)(d.timezone, c));
        _ = d.spec.getEntriesForWeek(e).maxTradingDayLength() * 60 * 1000;
      }
      let p = 0;
      if (h.isWeeks()) {
        p = 7;
      } else {
        const e = d.spec.getWeekIndex((0, s.get_cal_from_unix_timestamp_ms)(d.timezone, c));
        p = 7 - d.spec.getEntriesForWeek(e).weekEndsCount();
      }
      const m = c - l;
      const g = _ / u;
      const f = p * g;
      let y = m / 86400000 * g;
      if (y >= f) {
        y = m / 604800000 * f;
      }
      if (y % 1 <= Number.EPSILON * Math.ceil(y)) {
        return Math.round(y);
      } else {
        return Math.ceil(y);
      }
    }
    function D(e, t) {
      const i = (0, s.clone)(t);
      e.alignToSessionStart(i);
      return (0, s.cal_to_utc)((0, s.get_timezone)(e.timezone()), i);
    }
    function E(e, t) {
      const i = (0, s.utc_to_cal)(t.timezone, +e);
      let o = (0, s.get_day_of_week)(i);
      let n = (0, s.get_minutes_from_midnight)(i);
      const r = t.spec.findSession(t.spec.getWeekIndex(i), o, n).getEntry();
      if (r.isOvernight() && n > r.startOffset() + r.length() && o === r.dayOfWeek() - 1) {
        o++;
        n -= 1440;
      }
      return o === r.dayOfWeek() && n >= r.startOffset() && n < r.startOffset() + r.length();
    }
    function B(e, t) {
      const i = e.getUTCMonth();
      e.setUTCFullYear(e.getUTCFullYear() - t);
      if (e.getUTCMonth() !== i) {
        V(e, 1);
      }
    }
    function V(e, t) {
      e.setTime(e.getTime() - t * 86400000);
    }
    (function (e) {
      e[e.AlignToFirstDay = 0] = "AlignToFirstDay";
      e[e.AlignToClosestDay = 1] = "AlignToClosestDay";
    })(T ||= {});
    (function (e) {
      e[e.D = 86400000] = "D";
      e[e.W = 604800000] = "W";
    })(x ||= {});
  },
  79324: (e, t, i) => {
    "use strict";

    i.d(t, {
      BusinessDay: () => n
    });
    var s = i(2740);
    var o = i(32956);
    class n {
      constructor(e, t, i) {
        this.year = e;
        this.month = t;
        this.day = i;
      }
      toString() {
        return `${(0, o.addLeadingZeros)(this.year, 4)}-${(0, o.addLeadingZero)(this.month)}-${(0, o.addLeadingZero)(this.day)}`;
      }
      toyyyymmdd() {
        return `${(0, o.addLeadingZeros)(this.year, 4)}${(0, o.addLeadingZero)(this.month)}${(0, o.addLeadingZero)(this.day)}`;
      }
      compareTo(e) {
        if (this.year > e.year || this.year === e.year && this.month > e.month || this.year === e.year && this.month === e.month && this.day > e.day) {
          return 1;
        } else if (this.year === e.year && this.month === e.month && this.day === e.day) {
          return 0;
        } else {
          return -1;
        }
      }
      before(e) {
        return this.compareTo(e) === -1;
      }
      toCalendar(e) {
        return (0, s.get_cal)(e ?? (0, s.get_timezone)("Etc/UTC"), this.year, this.month - 1, this.day);
      }
      addDays(e) {
        const t = this.toCalendar((0, s.get_timezone)("Etc/UTC"));
        (0, s.add_date)(t, e);
        return n.fromCalendar(t);
      }
      firstDayOfYear() {
        return new n(this.year, 1, 1);
      }
      getDayOfWeek() {
        const e = this.toCalendar();
        return (0, s.get_day_of_week)(e);
      }
      static fromCalendar(e) {
        return new n((0, s.get_year)(e), (0, s.get_month)(e) + 1, (0, s.get_day_of_month)(e));
      }
    }
  },
  83910: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      SessionStage: () => s
    });
    (function (e) {
      e[e.PRE_SESSION = -1] = "PRE_SESSION";
      e[e.POST_SESSION = -2] = "POST_SESSION";
      e[e.LASTBAR_SESSION = -3] = "LASTBAR_SESSION";
      e[e.LAST_SESSION_END = -4] = "LAST_SESSION_END";
      e[e.FIRST_SESSION_START = -5] = "FIRST_SESSION_START";
    })(s ||= {});
  },
  40644: (e, t, i) => {
    "use strict";

    i.d(t, {
      extrapolateBarsFrontByCount: () => n,
      extrapolateBarsFrontToTime: () => o
    });
    var s = i(83910);
    function o(e, t, i, s, n = false) {
      if (t > i) {
        const r = o(e, i, t, s, n);
        r.count = -r.count;
        return r;
      }
      return r(e, t, 1, (e, t) => t > i || s !== 0 && e > s, n);
    }
    function n(e, t, i, s = false) {
      const o = i < 0 ? -1 : 1;
      return r(e, t, o, (e, t) => e >= i * o, s);
    }
    function r(e, t, i, o, n) {
      let r = 0;
      let a = t;
      e.moveTo(a);
      let l = 0;
      let c = Number.MAX_VALUE;
      let h = false;
      let d = t;
      const u = [];
      while (!o(r, a)) {
        if (l > 15) {
          throw new Error("Internal error 0x10 while extrapolating.");
        }
        const o = e.indexOfBar(a);
        if (o === s.SessionStage.PRE_SESSION && i === 1) {
          a = e.startOfBar(0);
          e.moveTo(a);
        } else if (o === s.SessionStage.PRE_SESSION && i === -1) {
          a = e.startOfBar(s.SessionStage.PRE_SESSION);
          e.moveTo(a);
        } else if (o === s.SessionStage.POST_SESSION && i === 1) {
          a = e.startOfBar(s.SessionStage.POST_SESSION);
          e.moveTo(a);
        } else {
          if (o === s.SessionStage.POST_SESSION && i === -1) {
            throw new Error("Internal error 0x12 while extrapolating.");
          }
          {
            const _ = e.startOfBar(o);
            if (_ > t && i > 0 || t > _ && i < 0) {
              if (h && c === _) {
                throw new Error("Internal error 0x11 while extrapolating.");
              }
              h = true;
              c = _;
              l = 0;
              r++;
              d = _;
              if (n) {
                u.push(d);
              }
            }
            if (o === 0 && i === -1) {
              a = _ - 1;
            } else {
              a = e.startOfBar(o + i);
              const t = e.startOfBar(s.SessionStage.POST_SESSION);
              if (a > t) {
                e.moveTo(t);
                a = e.startOfBar(0);
              }
            }
          }
        }
        l++;
      }
      return {
        time: d,
        times: u,
        count: r
      };
    }
  },
  17326: (e, t, i) => {
    "use strict";

    i.d(t, {
      SessionsSpec: () => P
    });
    var s;
    var o = i(50151);
    var n = i(2740);
    var r = i(29981);
    var a = i(79324);
    function l(e, t) {
      return e.compareTo(t);
    }
    (function (e) {
      e[e.LeftFirst = -1] = "LeftFirst";
      e[e.Unchanged = 0] = "Unchanged";
      e[e.RightFirst = 1] = "RightFirst";
    })(s ||= {});
    class c {
      constructor(e, t, i) {
        (0, o.assert)(Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(i), "Invalid arguments");
        this._dayOfWeek = e;
        this._start = t;
        this._length = i;
      }
      start() {
        return this._start + n.minutesPerDay * this.sessionStartDaysOffset();
      }
      startOffset() {
        return this._start;
      }
      sessionStartDaysOffset() {
        if (this._start >= 0) {
          return 0;
        } else if (this._start % n.minutesPerDay == 0) {
          return -Math.ceil(this._start / n.minutesPerDay);
        } else {
          return -Math.floor(this._start / n.minutesPerDay);
        }
      }
      isOvernight() {
        return this._start < 0;
      }
      dayOfWeek() {
        return this._dayOfWeek;
      }
      sessionStartDayOfWeek() {
        let e = this._dayOfWeek - this.sessionStartDaysOffset();
        if (e < n.SUNDAY) {
          e += 7;
        }
        return e;
      }
      length() {
        return this._length;
      }
      compareTo(e) {
        const t = this._weight();
        const i = t + this._length;
        const s = e._weight();
        const o = s + e._length;
        if (t <= s && s < i || s <= t && t < o) {
          return 0;
        } else if (t > s) {
          return 1;
        } else {
          return -1;
        }
      }
      contains(e) {
        return this._contains((0, n.get_minutes_with_hours)(e), (0, n.get_day_of_week)(e));
      }
      _weight() {
        return this._dayOfWeek * n.minutesPerDay + this._start;
      }
      _contains(e, t) {
        let i = t - this._dayOfWeek;
        if (i > 0) {
          i -= 7;
        }
        const s = i * n.minutesPerDay + e;
        return s >= this._start && s < this._start + this._length;
      }
    }
    class h {
      constructor(e, t, i) {
        this.weekIndex = e;
        this.entryIndex = t;
        this.entries = i;
      }
      getEntry() {
        return this.entries[this.entryIndex];
      }
    }
    class d {
      constructor(e, t, i, s) {
        this._maxTradingDayLength = null;
        this._list = e;
        this._entriesByDay = t;
        this._firstDayOfWeek = i;
        this._weekEndsCount = s;
      }
      firstDayOfWeek() {
        return this._firstDayOfWeek;
      }
      entriesByDay() {
        return this._entriesByDay;
      }
      list() {
        return this._list;
      }
      isWeekEnd(e) {
        return !this._entriesByDay.has(e);
      }
      weekEndsCount() {
        return this._weekEndsCount;
      }
      longestSessionLength() {
        if (this._list.length === 0) {
          return 0;
        } else {
          return Math.max(...this._list.map(e => e.length()));
        }
      }
      maxTradingDayLength() {
        if (this._maxTradingDayLength == null) {
          const e = new Map();
          for (const t of this._list) {
            const i = t.dayOfWeek();
            e.set(i, t.length() + (e.get(i) ?? 0));
          }
          let t = 0;
          e.forEach(e => {
            t = Math.max(t, e);
          });
          this._maxTradingDayLength = t;
        }
        return this._maxTradingDayLength;
      }
    }
    class u {
      constructor(e, t, i) {
        this._startDay = e;
        this._entries = i;
        this._specEndDay = t;
      }
      getEntries() {
        return this._entries;
      }
      getStartDay() {
        return this._startDay;
      }
      getSpecEndDay() {
        return this._specEndDay;
      }
      isOpenEnded() {
        return this._specEndDay == null;
      }
    }
    const _ = [n.MONDAY, n.TUESDAY, n.WEDNESDAY, n.THURSDAY, n.FRIDAY];
    const p = [n.SUNDAY, n.MONDAY, n.TUESDAY, n.WEDNESDAY, n.THURSDAY, n.FRIDAY, n.SATURDAY];
    function m(e) {
      return e >= 48 && e <= 57;
    }
    const g = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    class f extends Map {
      constructor() {
        super(...arguments);
        this._keyStringsToKey = new Map();
      }
      get(e) {
        const t = this._keyStringsToKey.get(e.toString());
        return t && super.get(t);
      }
      set(e, t) {
        const i = e.toString();
        const s = this._keyStringsToKey.get(i);
        if (s !== undefined) {
          super.delete(s);
        }
        this._keyStringsToKey.set(i, e);
        return super.set(e, t);
      }
      has(e) {
        return this._keyStringsToKey.has(e.toString());
      }
    }
    function y(e) {
      return e.length > 0;
    }
    class v {
      constructor() {
        this.historyEntries = [];
        this.timezone = "";
        this.adjustSessionsIndexes = null;
      }
      parseSessions(e, t) {
        this._parseHistoryEntries(e, t, false);
      }
      parseSessionsAndValidateDateTime(e, t) {
        this._parseHistoryEntries(e, t, true);
      }
      static parseHolidaysAndCorrections(e, t, i, s) {
        return this._parseHolidaysAndCorrectionsImpl(e, t, i, s);
      }
      static parseHolidaysAndCorrectionsAndValidateDateTime(e, t, i) {
        return this._parseHolidaysAndCorrectionsImpl(e, t, i, true);
      }
      _clearAll() {
        this.timezone = "";
        this.historyEntries = [];
        this.adjustSessionsIndexes = [];
      }
      _parseHistoryEntries(e, t, i) {
        this._clearAll();
        const s = t.split("/");
        let o = null;
        let n = null;
        this.hasHistoryCorrections = s.length > 1;
        for (let t = 0; t < s.length; t++) {
          const r = s[t].split("#");
          let a = null;
          if (t !== s.length - 1) {
            if (r.length !== 2) {
              throw new Error(`bad session history entry definition: ${s[t]}`);
            }
            a = v._parseDay(r[1], "session history entry end", i).toCalendar();
          } else {
            if (r.length !== 1) {
              throw new Error(`bad session history entry definition: ${s[t]}`);
            }
            a = null;
          }
          if (n !== null && a !== null && a.getTime() < n.getTime()) {
            throw new Error(`history sessions are not listed in ascending order (${n} -> ${a}`);
          }
          const l = this._parseSessionsImpl(e, r[0], i);
          o = this._adjustStartToPreviousSession(l.firstDayOfWeek());
          const c = new u(o, a, l);
          this.historyEntries.push(c);
          n = a;
        }
      }
      _parseSessionsImpl(e, t, i) {
        this.timezone = e;
        t = this._parseFirstDayOfWeek(t);
        const s = new Map();
        const o = [];
        if (t.toLowerCase() === "24x7") {
          for (const e of p) {
            const t = v._createSessionEntry(e, 0, 0, 0, 0);
            o.push(t);
            const i = [];
            i.push(t);
            s.set(e, i);
          }
        } else {
          let e = false;
          const n = new Map();
          for (const i of t.split("|")) {
            const t = i.split(":").filter(y);
            if (t.length !== 1 && t.length !== 2) {
              throw new Error(`bad session section: ${i}`);
            }
            const s = t.length === 1;
            if (s) {
              if (e) {
                throw new Error(`duplicated default section: ${i}`);
              }
              e = true;
            }
            const o = s ? _ : v._parseWorkingDays(t[1]);
            for (const e of o) {
              if (!s || !n.has(e)) {
                n.set(e, t[0]);
              }
            }
          }
          for (const e of p) {
            const t = n.get(e);
            if (t !== undefined) {
              for (const n of t.split(",").filter(y)) {
                const t = v._parseSessionEntry(e, n, i);
                let r = s.get(e);
                if (r === undefined) {
                  r = [];
                }
                r.push(t);
                o.push(t);
                s.set(e, r);
              }
            }
          }
        }
        o.sort(l);
        const n = new Set();
        for (const e of o) {
          n.add(e.dayOfWeek());
        }
        const r = 7 - n.size;
        return new d(o, s, this._firstDayOfWeek, r);
      }
      _parseFirstDayOfWeek(e) {
        const t = e.split(";");
        this._firstDayOfWeek = n.MONDAY;
        if (t.length > 2) {
          throw new Error(`bad sessions spec: ${e}`);
        }
        if (t.length === 1) {
          return e;
        }
        let i = 1;
        let s = t[0].indexOf("-") >= 0 ? NaN : parseInt(t[0]);
        if (isNaN(s)) {
          i = 0;
          s = parseInt(t[1]);
        }
        if (s < n.SUNDAY || s > n.SATURDAY) {
          throw new Error(`bad sessions spec: ${e}`);
        }
        this._firstDayOfWeek = s;
        return t[i];
      }
      _adjustStartToPreviousSession(e) {
        if (this.historyEntries.length === 0) {
          return null;
        }
        const t = (0, o.ensureNotNull)(this.historyEntries[this.historyEntries.length - 1].getSpecEndDay());
        const i = e - (0, n.get_day_of_week)(t);
        if (i === 0) {
          return t;
        }
        const s = (0, n.clone)(t);
        (0, n.add_date)(s, i);
        if (!(t.getTime() < s.getTime())) {
          (0, n.add_date)(s, 7);
        }
        return s;
      }
      static _parseSessionEntry(e, t, i) {
        const s = t.split("-");
        if (s.length !== 2) {
          throw new Error(`bad session entry: ${t}`);
        }
        let o = 0;
        let n = s[0];
        if (n.includes("F")) {
          const e = n.split("F");
          n = e[0];
          o = e[1] !== "" ? parseInt(e[1]) : 1;
        }
        let r = 0;
        let a = s[1];
        if (a.includes("F")) {
          const e = a.split("F");
          a = e[0];
          r = e[1] !== "" ? parseInt(e[1]) : 1;
        }
        const l = this._minutesFromHHMM(n, t, i);
        const c = this._minutesFromHHMM(a, t, i);
        return this._createSessionEntry(e, l, c, o, r);
      }
      static _minutesFromHHMM(e, t, i) {
        if (e.length === 4 && m(e.charCodeAt(0)) && m(e.charCodeAt(1)) && m(e.charCodeAt(2)) && m(e.charCodeAt(3))) {
          const t = parseInt(e);
          const s = Math.trunc(t / 100);
          const o = t % 100;
          if (!i || s < 24 && o < 60) {
            return o + s * 60;
          }
        }
        throw new Error(`incorrect entry syntax: ${t}`);
      }
      static _parseDay(e, t, i) {
        if (e.length === 8 && m(e.charCodeAt(0)) && m(e.charCodeAt(1)) && m(e.charCodeAt(2)) && m(e.charCodeAt(3)) && m(e.charCodeAt(4)) && m(e.charCodeAt(5)) && m(e.charCodeAt(6)) && m(e.charCodeAt(7))) {
          const t = parseInt(e.substring(0, 4));
          const s = parseInt(e.substring(4, 6));
          const o = parseInt(e.substring(6, 8));
          if (!i || this._isValidDayOfMonth(o, s, t)) {
            return new a.BusinessDay(t, s, o);
          }
        }
        throw new Error(`bad ${t} date: ${e}`);
      }
      static _isValidDayOfMonth(e, t, i) {
        return !(t < 1) && !(t > 12) && (!(e < 1) && !(e > g[t]) || t === 2 && e === 29 && !!(0, n.is_leap_year)(i));
      }
      static _parseWorkingDays(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
          const s = e.charCodeAt(i) - 48;
          if (s < 1 || s > 7) {
            throw new Error(`Invalid days specification: ${e}`);
          }
          if (!t.includes(s)) {
            t.push(s);
          }
        }
        return t;
      }
      static _createSessionEntry(e, t, i, s, r) {
        (0, o.assert)(s >= 0 && s < 7);
        (0, o.assert)(r >= 0 && r < 7);
        if (i === 0) {
          i = n.minutesPerDay;
        }
        if (s === r && i <= t) {
          s += 1;
        }
        (0, o.assert)(s >= r);
        if (s > 0) {
          t -= s * n.minutesPerDay;
        }
        if (r > 0) {
          i -= r * n.minutesPerDay;
        }
        const a = i - t;
        (0, o.assert)(e >= n.SUNDAY && e <= n.SATURDAY);
        (0, o.assert)(t < n.minutesPerDay);
        (0, o.assert)(a > 0);
        return new c(e, t, a);
      }
      static _parseHolidaysAndCorrectionsImpl(e, t, i, s) {
        const o = new f();
        if (t !== "") {
          const e = [];
          for (const i of t.split(",")) {
            const t = this._parseDay(i, "holiday", s);
            o.set(t, e);
          }
        }
        if (i === "") {
          return o;
        }
        for (const e of i.split(";")) {
          const t = e.split(":");
          if (t.length !== 2) {
            throw new Error(`bad correction section: ${e}`);
          }
          const i = [];
          if (t[0] !== "dayoff") {
            for (const e of t[0].split(",")) {
              i.push(this._parseSessionEntry(1, e, s));
            }
          }
          for (const e of t[1].split(",")) {
            const t = this._parseDay(e, "correction", s);
            const r = (0, n.get_day_of_week)(t.toCalendar());
            const a = [];
            for (let e = 0; e < i.length; e++) {
              const t = i[e];
              a.push(new c(r, t.startOffset(), t.length()));
            }
            o.set(t, a);
          }
        }
        return o;
      }
    }
    function S(e, t) {
      return e.compareTo(t) < 0;
    }
    const b = (0, n.get_timezone)("Etc/UTC");
    var w;
    (function (e) {
      e[e.Closest = 0] = "Closest";
      e[e.FirstInDay = -1] = "FirstInDay";
      e[e.LastInDay = 1] = "LastInDay";
    })(w ||= {});
    class C {
      constructor(e) {
        this._value = e;
      }
      get() {
        return this._value;
      }
      set(e) {
        this._value = e;
      }
    }
    class P {
      constructor(e = "Etc/UTC", t = "0000-0000", i = "", s = "", o = false) {
        const r = new v();
        if (o) {
          r.parseSessionsAndValidateDateTime(e, t);
        } else {
          r.parseSessions(e, t);
        }
        this._entries = r.historyEntries;
        this._hasHistoryCorrections = r.hasHistoryCorrections;
        this._presentHistoryEntry = r.historyEntries[r.historyEntries.length - 1];
        this._timezone = r.timezone;
        this._timezoneObj = (0, n.get_timezone)(r.timezone);
        this._holidayAndCorrectionMap = o ? v.parseHolidaysAndCorrectionsAndValidateDateTime(e, i, s) : v.parseHolidaysAndCorrections(e, i, s, o);
        const a = this._holidayAndCorrectionMap.keys();
        this._entriesHash = new Map();
        const l = this._prepareSessionsBorderParams();
        this._borderWeeksIndicesHash = l.borderWeeksIndicesHash;
        this._yearToWeeksIndicesHash = l.yearToWeeksIndicesHash;
        this._weekIndicesOfLastHistoryWeek = l.weekIndicesOfLastHistoryWeek;
        this._presentStartWeekIndex = l.startPresentSessionWeekIndex;
        this._yearToCalculatedAddedWeekIndicesHash = new Map();
        if (i === "" && s === "" && this._weekIndicesOfLastHistoryWeek === null) {
          this._isThereCorrections = false;
        } else {
          this._isThereCorrections = true;
        }
        for (const e of a) {
          const t = this.getWeekIndex(e.toCalendar());
          this._entriesHash.set(t, new C(null));
        }
      }
      hasHistoryCorrections() {
        return this._hasHistoryCorrections;
      }
      firstDayOfWeek() {
        return this._presentHistoryEntry.getEntries().firstDayOfWeek();
      }
      includesDay(e) {
        return this._getEntriesForDay(e).length > 0;
      }
      getEntriesForWeek(e) {
        if (!this._isThereCorrections) {
          return this._presentHistoryEntry.getEntries();
        }
        (0, o.assert)(e >= 0);
        const t = e;
        const i = this._entriesHash.get(t);
        if (i === undefined) {
          return this._getHistoryAndIndexForWeek(t).getEntries();
        }
        let s = i.get();
        if (s !== null) {
          return s;
        }
        let r = null;
        const c = this._borderWeeksIndicesHash.get(t);
        r = c === undefined ? this._getHistoryAndIndexForWeek(t).getEntries() : this._prepareBorderWeekHistory(c);
        const h = new Map(r.entriesByDay());
        let u = [...r.list()];
        const _ = this._weekIndexToLocalDateTime(e);
        const m = this._weekIndexToLocalDateTime(e + 1);
        const g = a.BusinessDay.fromCalendar(_);
        const f = a.BusinessDay.fromCalendar(m);
        for (const [e, t] of this._selectHolidays(g, f)) {
          const i = (0, n.get_day_of_week)(e.toCalendar());
          u = u.filter(e => e.dayOfWeek() !== i);
          u.push(...t);
          if (t.length === 0) {
            h.delete(i);
          } else {
            h.set(i, t);
          }
        }
        u.sort(l);
        const y = p.length - h.size;
        s = new d(u, h, r.firstDayOfWeek(), y);
        i.set(s);
        return s;
      }
      getHistoryByIndex(e) {
        return this._entries[e];
      }
      timezone() {
        return this._timezone;
      }
      timezoneObj() {
        return this._timezoneObj;
      }
      longestSessionLength() {
        let e = this._presentHistoryEntry.getEntries().longestSessionLength();
        for (let t = 0; t < this._entries.length - 1; t++) {
          const i = this._entries[t].getEntries().longestSessionLength();
          e = Math.max(e, i);
        }
        let t = -Infinity;
        for (const e of this._holidayAndCorrectionMap.values()) {
          t = Math.max(t, ...e.map(e => e.length()));
        }
        return Math.max(t, e);
      }
      isWeekEnd(e) {
        const t = this.getWeekIndex(e);
        let i;
        i = this._borderWeeksIndicesHash.get(t) === undefined ? this._getHistoryAndIndexForWeek(t).getEntries() : this.getEntriesForWeek(t);
        return i.isWeekEnd((0, n.get_day_of_week)(e));
      }
      isCalWeekEnd(e) {
        const t = (0, n.get_day_of_week)(e);
        if (!this._isThereCorrections) {
          return this._presentHistoryEntry.getEntries().isWeekEnd(t);
        }
        const i = this.getWeekIndex(e);
        const s = this.getEntriesForWeek(i);
        const o = a.BusinessDay.fromCalendar(e);
        const r = this._holidayAndCorrectionMap.get(o);
        if (r === undefined) {
          return s.isWeekEnd(t);
        } else {
          return r.length === 0;
        }
      }
      holidaysFromYearStart(e) {
        const t = e instanceof a.BusinessDay ? e : a.BusinessDay.fromCalendar(e);
        return this._holidaysFromYearStart(t);
      }
      daysOffFromYearStart(e) {
        const t = (0, n.get_cal)(b, (0, n.get_year)(e), n.JANUARY, 1);
        const i = this.getWeekIndex(t);
        const s = (0, n.get_day_of_week)(t);
        const o = (0, n.get_day_of_week)(e) - 1;
        if ((0, n.get_day_of_year)(e) + s <= n.LAST_DAY_OF_WEEK + n.FIRST_DAY_OF_WEEK) {
          return this._getDaysOffForWeekInBorders(i, s, o);
        }
        const r = this.getWeekIndex(e);
        let a = this._getDaysOffForWeekInBorders(i, s, n.LAST_DAY_OF_WEEK);
        for (let e = i + 1; e < r; e++) {
          a += this.getEntriesForWeek(e).weekEndsCount();
        }
        a += this._getDaysOffForWeekInBorders(r, n.FIRST_DAY_OF_WEEK, o);
        return a;
      }
      weekEndsCountForSingleSession() {
        (0, o.assert)(!this.hasHistoryCorrections());
        return this._presentHistoryEntry.getEntries().weekEndsCount();
      }
      intradayCanBeBuiltFrom24x7(e) {
        for (const t of this._entries) {
          if (!t.getEntries().list().every(t => t.start() % e == 0 && t.length() % e == 0)) {
            return false;
          }
        }
        return true;
      }
      intradayCanBeBuiltFrom24x7Seconds(e) {
        for (const t of this._entries) {
          if (!t.getEntries().list().every(t => t.start() * 60 % e == 0 && t.length() * 60 % e == 0)) {
            return false;
          }
        }
        return true;
      }
      indexOfSession(e, t, i) {
        (0, o.assert)(t >= n.SUNDAY && t <= n.SATURDAY);
        (0, o.assert)(i >= 0 && i < n.minutesPerDay);
        const s = this.getEntriesForWeek(e);
        const a = s.list();
        let l = (0, r.lowerbound)(a, new c(t, i, 0), S);
        if (l < a.length) {
          return new h(e, l, [...a]);
        }
        let d = e + 1;
        let u = this.getEntriesForWeek(d);
        if (u.list().length !== 0) {
          const e = 7 - t + u.firstDayOfWeek() - 1;
          i = -(n.minutesPerDay - i + e * n.minutesPerDay);
          l = (0, r.lowerbound)(u.list(), new c(u.firstDayOfWeek(), i, 0), S);
          if (l < u.list().length) {
            return new h(d, l, [...u.list()]);
          }
        }
        while (true) {
          d++;
          i -= n.minutesPerWeek;
          u = this.getEntriesForWeek(d);
          if (u.list().length !== 0 && (l = (0, r.lowerbound)(u.list(), new c(s.firstDayOfWeek(), i, 0), S), !(l >= u.list().length))) {
            return new h(d, l, [...u.list()]);
          }
        }
      }
      findSession(e, t, i, s = 0) {
        const o = this.indexOfSession(e, t, i);
        const n = o.entries;
        let r = o.entryIndex;
        if (s !== 0) {
          const e = n[r].dayOfWeek();
          const t = s > 0 ? 1 : -1;
          while (true) {
            const i = r + t;
            if (i < 0 || i >= n.length || n[i].dayOfWeek() !== e) {
              break;
            }
            r = i;
          }
        }
        return new h(o.weekIndex, r, n);
      }
      getWeekIndex(e) {
        if (this._isThereCorrections) {
          return P._getWeekIndexImpl(e);
        } else {
          return 0;
        }
      }
      correctTradingDay(e) {
        const t = this._correctTradingDay(this.getWeekIndex(e), (0, n.get_day_of_week)(e), (0, n.get_minutes_with_hours)(e));
        const i = (0, n.clone)(e);
        (0, n.add_date)(i, t);
        return i;
      }
      alignToSessionStart(e, t = 0) {
        const i = (0, n.get_day_of_week)(e);
        const s = (0, n.get_minutes_from_midnight)(e);
        const o = this.getWeekIndex(e);
        const r = this.findSession(o, i, s, t);
        const a = r.getEntry();
        const l = a.dayOfWeek() - i + Math.trunc(r.weekIndex - o) * 7;
        if (l !== 0) {
          (0, n.add_date)(e, l);
        }
        const c = a.startOffset();
        (0, n.set_hms)(e, Math.trunc(c / 60), c % 60, 0, 0);
        return a.length();
      }
      businessDaysToCalendarDays(e, t) {
        return this._businessDaysToCalendarDays(this.getWeekIndex(e), (0, n.get_day_of_week)(e), t);
      }
      calendarDaysToBusinessDays(e, t) {
        return this._calendarDaysToBusinessDays(this.getWeekIndex(e), (0, n.get_day_of_week)(e), t);
      }
      alignToNearestSessionStart(e, t) {
        return this._alignToNearestSessionValue(e, t, this._entrySessionStart.bind(this));
      }
      alignToNearestSessionEnd(e, t) {
        return this._alignToNearestSessionValue(e, t, this._entrySessionEnd.bind(this));
      }
      bordersOfDailyBar(e) {
        const t = this._getEntriesForDay(e);
        if (t.length === 0) {
          return null;
        }
        const i = t.slice();
        i.sort(l);
        const s = this._getLeftEntryBorder(e, i[0]);
        const o = i[i.length - 1];
        const r = (o.startOffset() + o.length()) * 60 - 1;
        const a = (0, n.clone)(e);
        (0, n.set_seconds)(a, r);
        return {
          from: s,
          to: a
        };
      }
      leftBorderOfDailyBar(e) {
        const t = this._getEntriesForDay(e);
        if (t.length === 0) {
          return null;
        }
        const i = t.slice();
        i.sort(l);
        return this._getLeftEntryBorder(e, i[0]);
      }
      checkSession() {
        return this._checkEachHistorySession() && this._checkSpecialEntries() && this._checkTooManyCorrectionsOnWeek();
      }
      inSession(e) {
        e = new Date(Math.floor(e.getTime() / 1000) * 1000);
        const t = this.alignToNearestSessionStart(e, -1);
        const i = this.alignToNearestSessionEnd(t, 1);
        return !(e.getTime() > i.getTime());
      }
      hasWeekEnds() {
        for (const e of this._entries) {
          if (e.getEntries().weekEndsCount() !== 0) {
            return true;
          }
        }
        return false;
      }
      getWeekIndicesWithAdditionalWeekBars(e) {
        let t = this._yearToCalculatedAddedWeekIndicesHash.get(e);
        if (t === undefined) {
          t = this._calculateAddedIndices(e);
          this._yearToCalculatedAddedWeekIndicesHash.set(e, t);
        }
        return t;
      }
      _prepareSessionsBorderParams() {
        const e = new Map();
        const t = new Map();
        let i = null;
        if (this._entries.length > 1) {
          i = Array.from({
            length: this._entries.length - 1
          }, () => 0);
        }
        let s = 0;
        for (let n = 0; n < this._entries.length - 1; n++) {
          const r = this._entries[n + 1];
          const a = (0, o.ensureNotNull)(r.getStartDay());
          s = P._getWeekIndexImpl(a);
          e.set(s, n + 1);
          this._addToYearHash(t, a, s);
          this._entriesHash.set(s, new C(null));
          (0, o.ensureNotNull)(i)[n] = s;
        }
        return {
          borderWeeksIndicesHash: e,
          yearToWeeksIndicesHash: t,
          startPresentSessionWeekIndex: s,
          weekIndicesOfLastHistoryWeek: i
        };
      }
      _addToYearHash(e, t, i) {
        const s = (0, n.get_year)(t);
        let o = e.get(s);
        if (o === undefined) {
          o = [];
          e.set(s, o);
        }
        o.push(i);
      }
      _getHistoryAndIndexForWeek(e) {
        if (this._presentStartWeekIndex <= e) {
          return this._presentHistoryEntry;
        }
        const t = this._getIndexOfHistoryEntry(e);
        return this._entries[t];
      }
      _getIndexOfHistoryEntry(e) {
        let t = 0;
        let i = this._entries.length - 1;
        let s = Math.floor((t + i) / 2);
        for ((0, o.assert)(this._weekIndicesOfLastHistoryWeek !== null); ;) {
          if (this._weekIndicesOfLastHistoryWeek[s] >= e) {
            i = s - 1;
            if (i < t) {
              return s;
            }
          } else {
            t = s + 1;
            if (i < t) {
              return s + 1;
            }
          }
          s = Math.floor((t + i) / 2);
        }
      }
      _selectHolidays(e, t) {
        const i = new Set();
        for (const [s, o] of this._holidayAndCorrectionMap) {
          if (s.compareTo(e) >= 0 && s.compareTo(t) < 0) {
            i.add([s, o]);
          }
        }
        return i;
      }
      _prepareBorderWeekHistory(e) {
        const t = this._entries[e - 1];
        const i = this._entries[e];
        const s = new Map();
        const r = [];
        const a = (0, n.get_day_of_week)((0, o.ensureNotNull)(i.getStartDay()));
        for (let e = 0; e < p.length; e++) {
          const o = p[e];
          if (o < a) {
            const e = t.getEntries().entriesByDay().get(o);
            if (e !== undefined) {
              r.push(...e);
              s.set(o, e);
            }
          } else {
            const e = i.getEntries().entriesByDay().get(o);
            if (e !== undefined) {
              r.push(...e);
              s.set(o, e);
            }
          }
        }
        return new d(r, s, i.getEntries().firstDayOfWeek(), 0);
      }
      _holidaysFromYearStart(e) {
        if (!this._isThereCorrections) {
          return 0;
        }
        (0, o.assert)(!this.hasHistoryCorrections());
        const t = e.firstDayOfYear();
        let i = 0;
        for (const [s, o] of this._selectHolidays(t, e)) {
          const e = s.getDayOfWeek();
          const t = o.length === 0;
          if (this._presentHistoryEntry.getEntries().isWeekEnd(e)) {
            i += t ? 0 : -1;
          } else {
            i += t ? 1 : 0;
          }
        }
        return i;
      }
      _getDaysOffForWeekInBorders(e, t, i) {
        let s = 0;
        const o = this.getEntriesForWeek(e);
        for (let e = t; e <= i; e++) {
          if (!o.entriesByDay().has(e)) {
            s++;
          }
        }
        return s;
      }
      _weekIndexToLocalDateTime(e) {
        const t = Math.floor(e * 86400 * 7 + 86400 - 62167219200);
        const i = (0, n.get_cal_from_unix_timestamp_ms)(b, t * 1000);
        (0, n.set_hms)(i, 0, 0, 0, 0);
        return i;
      }
      _correctTradingDay(e, t, i) {
        const s = this.findSession(e, t, i, 0);
        return s.getEntry().dayOfWeek() - t + Math.trunc(s.weekIndex - e) * 7;
      }
      _entrySessionValue(e, t, i, s) {
        t = (0, n.clone)(t);
        let o = (0, n.get_day_of_week)(t);
        const r = e.getEntry();
        let a = r.dayOfWeek() - r.sessionStartDaysOffset();
        const l = this.getWeekIndex(t);
        let c = Math.trunc(e.weekIndex - l);
        let h = false;
        if (a < n.SUNDAY) {
          if (c <= 0) {
            h = true;
          } else {
            c--;
          }
          a += 7;
        }
        if (c > 0 && i >= 0 || c < 0 && i < 0) {
          (0, n.add_date)(t, c * 7);
        }
        if (!r.contains(t)) {
          let e = a - o;
          if (h && i < 0) {
            e = -(7 - a + o);
          }
          (0, n.add_date)(t, e);
          o = (0, n.get_day_of_week)(t);
        }
        if (r.isOvernight()) {
          const e = r.sessionStartDaysOffset();
          const i = (o - (r.dayOfWeek() - e) + 7) % 7;
          if (i !== 0) {
            (0, n.add_date)(t, -i);
          }
        }
        const d = s(r);
        (0, n.set_seconds)(t, d);
        return t;
      }
      _businessDaysToCalendarDays(e, t, i) {
        let s = 0;
        let o = 0;
        while (o < i) {
          const r = this.getEntriesForWeek(e);
          for (let e = t; e <= n.SATURDAY; e++) {
            s++;
            if (r.entriesByDay().get(e) !== undefined) {
              o++;
            }
            if (o >= i) {
              return s;
            }
          }
          e++;
          t = n.SUNDAY;
        }
        return s;
      }
      _calendarDaysToBusinessDays(e, t, i) {
        let s = 0;
        let o = 0;
        while (s < i) {
          const r = this.getEntriesForWeek(e);
          for (let e = t; e <= n.SATURDAY; e++) {
            s++;
            if (r.entriesByDay().get(e) !== undefined) {
              o++;
            }
            if (s >= i) {
              return o;
            }
          }
          e++;
          t = n.SUNDAY;
        }
        return o;
      }
      _entrySessionStart(e, t, i) {
        return this._entrySessionValue(e, t, i, e => e.start() * 60);
      }
      _entrySessionEnd(e, t, i) {
        return this._entrySessionValue(e, t, i, e => (e.start() + e.length()) * 60 - 1);
      }
      _alignToNearestSessionValue(e, t, i) {
        const s = (0, n.get_day_of_week)(e);
        const o = (0, n.get_minutes_with_hours)(e);
        const r = this.getWeekIndex(e);
        let a = this.findSession(r, s, o);
        if (t === 1) {
          return i(a, e, t);
        }
        const l = a.getEntry();
        const c = l.contains(e);
        const d = r === a.weekIndex;
        const u = l.sessionStartDaysOffset() - l.dayOfWeek() >= 0;
        if (c && (d || u)) {
          return i(a, e, t);
        }
        let _ = a.entryIndex - 1;
        if (_ < 0) {
          let e = a.weekIndex;
          let t = a.entries;
          if (e === 0) {
            e--;
            _ += t.length;
          } else {
            while (_ < 0) {
              e--;
              t = this.getEntriesForWeek(e).list();
              _ += t.length;
            }
          }
          a = new h(e, _, t);
        } else {
          a = new h(a.weekIndex, _, a.entries);
        }
        return i(a, e, t);
      }
      _getEntriesForDay(e) {
        const t = (0, n.get_day_of_week)(e);
        const i = this.getEntriesForWeek(this.getWeekIndex(e)).entriesByDay().get(t);
        if (i !== undefined) {
          return i;
        } else {
          return [];
        }
      }
      _getLeftEntryBorder(e, t) {
        let i = t.startOffset();
        const s = -Math.trunc((i - 1439) / 1440);
        i += s * 1440;
        const o = (0, n.get_cal)(b, (0, n.get_year)(e), (0, n.get_month)(e), (0, n.get_day_of_month)(e), Math.trunc(i / 60), i % 60, 0);
        (0, n.add_date)(o, -s);
        return o;
      }
      _checkEachHistorySession() {
        for (const e of this._entries) {
          const t = e.getEntries().list();
          if (!this._checkEntriesForIntersections(t, t, t)) {
            return false;
          }
        }
        return true;
      }
      _checkEntriesForIntersections(e, t, i) {
        const s = this._buildTestEntries(e, t, i);
        for (let e = 0; e < s.length - 1; e++) {
          for (let t = e + 1; t < s.length; t++) {
            if (s[e].compareTo(s[t]) === 0) {
              return false;
            }
          }
        }
        return true;
      }
      _buildTestEntries(e, t, i) {
        const s = [];
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          const o = new c(i.dayOfWeek(), i.startOffset(), i.length());
          s.push(o);
        }
        for (let e = 0; e < t.length; e++) {
          const i = t[e];
          const o = new c(i.dayOfWeek() + 7, i.startOffset(), i.length());
          s.push(o);
        }
        for (let e = 0; e < i.length; e++) {
          const t = i[e];
          const o = new c(t.dayOfWeek() + 14, t.startOffset(), t.length());
          s.push(o);
        }
        return s;
      }
      _checkSpecialEntries() {
        for (const [e] of this._entriesHash) {
          const t = this.getEntriesForWeek(e).list();
          const i = this.getEntriesForWeek(e - 1).list();
          const s = this.getEntriesForWeek(e + 1).list();
          if (!this._checkEntriesForIntersections(i, t, s)) {
            return false;
          }
        }
        return true;
      }
      _checkTooManyCorrectionsOnWeek() {
        if (this._entries.length < 2) {
          return true;
        }
        for (let e = 0; e < this._entries.length - 2; e++) {
          const t = this._entries[e];
          const i = this._entries[e + 1];
          if (this.getWeekIndex((0, o.ensureNotNull)(t.getSpecEndDay())) === this.getWeekIndex((0, o.ensureNotNull)(i.getSpecEndDay()))) {
            return false;
          }
        }
        return true;
      }
      _calculateAddedIndices(e) {
        const t = [];
        const i = this._yearToWeeksIndicesHash.get(e);
        if (i === undefined) {
          return t;
        }
        for (const e of i) {
          const i = (0, o.ensureDefined)(this._borderWeeksIndicesHash.get(e));
          const s = this._entries[i];
          const r = this._entries[i - 1];
          let a = s.getEntries().firstDayOfWeek() - r.getEntries().firstDayOfWeek();
          while (a > 0) {
            const r = (0, n.clone)((0, o.ensureNotNull)(s.getStartDay()));
            (0, n.add_date)(r, -a);
            if (!this.isCalWeekEnd(r)) {
              const s = {
                entryIndex: i,
                weekIndex: e
              };
              t.push(s);
              break;
            }
            a--;
          }
        }
        return t;
      }
      static _getWeekIndexImpl(e) {
        const t = (0, n.get_cal_utc)((0, n.get_year)(e), (0, n.get_month)(e), 1);
        (0, n.add_date)(t, (0, n.get_day_of_month)(e) - (0, n.get_day_of_week)(e));
        const i = t.getTime() / 1000;
        (0, o.assert)((i + 62167219200) % 86400 == 0);
        return Math.trunc((i + 62167219200) / 86400 / 7);
      }
    }
  },
  15716: (e, t, i) => {
    "use strict";

    i.d(t, {
      barFunctionByStyle: () => o
    });
    var s = i(3070);
    function o(e, t) {
      switch (e) {
        case 12:
          return (0, s.barFunction)("low", "low", "close");
        case 2:
        case 18:
        case 20:
        case 14:
        case 15:
        case 3:
        case 10:
        case 13:
          return (0, s.barFunction)(t ?? "close");
        default:
          return (0, s.barFunction)("close", "open");
      }
    }
  },
  91988: (e, t, i) => {
    "use strict";

    i.d(t, {
      BarsRange: () => o
    });
    var s = i(50151);
    class o {
      constructor(e, t) {
        (0, s.assert)(e <= t, "The last bar in the bars range should be greater than or equal to the first bar");
        this._firstBar = e;
        this._lastBar = t;
      }
      firstBar() {
        return this._firstBar;
      }
      lastBar() {
        return this._lastBar;
      }
      count() {
        return this._lastBar - this._firstBar + 1;
      }
      contains(e) {
        return this._firstBar <= e && e <= this._lastBar;
      }
      unite(e) {
        if (e === null) {
          return this;
        } else {
          return new o(Math.min(this._firstBar, e.firstBar()), Math.max(this._lastBar, e.lastBar()));
        }
      }
      equals(e) {
        return this._firstBar === e.firstBar() && this._lastBar === e.lastBar();
      }
      static compare(e, t) {
        if (e === null || t === null) {
          return e === t;
        } else {
          return e.equals(t);
        }
      }
    }
  },
  42989: (e, t, i) => {
    "use strict";

    i.d(t, {
      allChartStyles: () => o
    });
    var s = i(56570);
    function o() {
      return function () {
        const e = [0, 1, 9, 13, 2, 14, 15, 3, 16, 10];
        if (s.enabled("chart_style_hilo")) {
          e.push(12);
        }
        e.push(21);
        return e;
      }().concat((s.enabled("japanese_chart_styles"), [8]));
    }
  },
  91920: (e, t, i) => {
    "use strict";

    var s = i(68979).makeFont;
    var o = i(68979).parseFont;
    var n = i(9343).getLogger;
    const {
      drawPoly: r
    } = i(37743);
    var a = n("Model.ChartTradingUtils");
    var l = {
      _fontHeightCache: {},
      _parsedColorCache: {},
      _parseColor: function (e) {
        if (this._parsedColorCache[e]) {
          return this._parsedColorCache[e];
        }
        var t = document.createElement("div");
        t.style.color = e;
        var i = t.style.color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i) || t.style.color.match(/^rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d*\.?\d+)\s*\)$/i);
        var s = {
          r: i[1],
          g: i[2],
          b: i[3],
          a: i[4] || "1"
        };
        this._parsedColorCache[e] = s;
        return s;
      },
      getColorFromProperties: function (e, t) {
        var i = 1 - t.value() / 100;
        var s = this._parseColor(e.value());
        return "rgba(" + s.r + "," + s.g + "," + s.b + "," + i + ")";
      },
      setColorToProperties: function (e, t, i) {
        var s = this._parseColor(e);
        t.setValue("rgb(" + s.r + "," + s.g + "," + s.b + ")");
        var o = (1 - s.a) * 100;
        i.setValue(Math.max(0, Math.min(o, 100)));
      },
      getFontFromProperties: function (e, t, i, o) {
        return s(t.value(), e.value(), o.value() ? "italic" : "", i.value() ? "bold" : "");
      },
      setFontToProperties: function (e, t, i, s, n) {
        var r = o(e);
        if (r !== null) {
          if (r.family.length > 0) {
            t.setValue(r.family);
          }
          i.setValue(r.size);
          s.setValue(r.bold);
          n.setValue(r.italic);
        } else {
          a.logError("Invalid font: " + e);
        }
      },
      fontHeight: function (e) {
        if (!this._fontHeightCache[e]) {
          var t = document.createElement("span");
          t.appendChild(document.createTextNode("height"));
          document.body.appendChild(t);
          t.style.cssText = "font: " + e + "; white-space: nowrap; display: inline;";
          var i = t.offsetHeight;
          document.body.removeChild(t);
          this._fontHeightCache[e] = Math.ceil(i);
        }
        return this._fontHeightCache[e];
      },
      drawPolyHoverOrPress: function (e, t, i, s) {
        if (s) {
          e.save();
          e.fillStyle = "rgba(0, 0, 0, 0.15)";
          r(e, t, true);
          e.restore();
        } else if (i) {
          e.save();
          e.fillStyle = "rgba(0, 0, 0, 0.1)";
          r(e, t, true);
          e.restore();
        }
      },
      repaint: function (e) {
        e.lightUpdate();
      },
      roundToMinTick: function (e, t) {
        var i = 1 / e.mainSource().base();
        return i * Math.round(t / i);
      }
    };
    e.exports = l;
  },
  46088: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      ColorType: () => s
    });
    (function (e) {
      e.Solid = "solid";
      e.Gradient = "gradient";
    })(s ||= {});
  },
  85856: (e, t, i) => {
    "use strict";

    i.d(t, {
      ConflatedChunksBuilder: () => r
    });
    var s = i(50151);
    var o = i(29981);
    const n = [{
      barsToMerge: 10,
      forBarspacingLargerThen: 0.03
    }, {
      barsToMerge: 30,
      forBarspacingLargerThen: 0.01
    }, {
      barsToMerge: 100,
      forBarspacingLargerThen: 0.003
    }, {
      barsToMerge: 500,
      forBarspacingLargerThen: 0
    }];
    class r {
      constructor(e, t) {
        this._plots = e;
        this._conflatedChunks = {
          chunks: new Map(),
          priceSource: null,
          priceSourcesProvider: t
        };
        this._clearConflatedChunks();
      }
      conflatedChunks(e, t) {
        if (t !== this._conflatedChunks.priceSource) {
          this._conflatedChunks.priceSource = t;
          const e = this._plots.first();
          if (e) {
            this._clearConflatedChunks();
            this._rebuildConflatedChunks(e);
          }
        }
        const i = (0, s.ensureDefined)(n.find(t => t.forBarspacingLargerThen <= e));
        return (0, s.ensureDefined)(this._conflatedChunks.chunks.get(i.barsToMerge));
      }
      mergeData(e) {
        const t = this._plots.size();
        const i = this._plots.merge(e);
        if (i && this._conflatedChunks.priceSource !== null) {
          if (t === this._plots.size() && i.index === this._plots.lastIndex()) {
            this._updateLatestChunks();
          } else {
            this._rebuildConflatedChunks(i);
          }
        }
        return i;
      }
      moveData(e) {
        this._plots.move(e);
        if (this._plots.size() > 0) {
          this._clearConflatedChunks();
        }
      }
      clearData() {
        this._plots.clear();
        this._clearConflatedChunks();
      }
      _rebuildConflatedChunks(e) {
        const t = this._conflatedChunks.priceSource;
        if (t === null) {
          return;
        }
        const i = e.index;
        const r = this._conflatedChunks.priceSourcesProvider(t);
        const a = (e, t, i) => {
          let s = null;
          for (const o of e) {
            const e = r(o.value);
            if (s && o.index - s.startTime >= i.barsToMerge) {
              t.push(s);
              s = null;
            }
            if (s) {
              s.endTime = o.index;
              s.high = Math.max(s.high, e);
              s.low = Math.min(s.low, e);
              s.close = e;
            } else {
              s = {
                startTime: o.index,
                endTime: o.index,
                open: e,
                high: e,
                low: e,
                close: e
              };
            }
          }
          if (s) {
            t.push(s);
          }
        };
        n.forEach(e => {
          const t = (0, s.ensureDefined)(this._conflatedChunks.chunks.get(e.barsToMerge));
          const n = (0, o.lowerbound)(t, i, (e, t) => e.endTime < t);
          if (n === 0 && t.length > 0) {
            const i = t[0].startTime - 1;
            const o = (0, s.ensureNotNull)(this._plots.firstIndex());
            const n = this._plots.rangeIterator(o, i);
            const r = [];
            a(n, r, e);
            const l = r.concat(t);
            this._conflatedChunks.chunks.set(e.barsToMerge, l);
          } else {
            const i = (0, s.ensureNotNull)(this._plots.lastIndex());
            t.splice(n);
            let o = (0, s.ensureNotNull)(this._plots.firstIndex());
            if (t.length) {
              o = t[t.length - 1].endTime + 1;
            }
            const r = this._plots.rangeIterator(o, i);
            a(r, t, e);
          }
        });
      }
      _updateLatestChunks() {
        const e = (0, s.ensureNotNull)(this._plots.last());
        const t = this._conflatedChunks.priceSourcesProvider("close");
        n.forEach(i => {
          const o = (0, s.ensureDefined)(this._conflatedChunks.chunks.get(i.barsToMerge));
          const n = t(e.value);
          const r = o[o.length - 1];
          r.high = Math.max(r.high, n);
          r.low = Math.min(r.low, n);
          r.close = n;
          r.endTime = e.index;
        });
      }
      _clearConflatedChunks() {
        n.forEach(e => this._conflatedChunks.chunks.set(e.barsToMerge, []));
      }
    }
  },
  50788: (e, t, i) => {
    "use strict";

    i.d(t, {
      actualCurrencyUnitVisibility: () => h,
      currencyUnitVisibilityOptions: () => l,
      currencyUnitVisibilityProperty: () => a,
      migrateShowCurrencyAndShowUnitProperties: () => u,
      restoreCurrencyUnitVisibilitySettingsValue: () => c
    });
    var s;
    var o = i(17656);
    var n = i(56840);
    var r = i.n(n);
    (function (e) {
      e.SettingsKey = "PriceAxisCurrencyAndUnit.visibility";
    })(s ||= {});
    const {
      property: a,
      availableValues: l,
      restoreDefaultValue: c,
      actualBehavior: h
    } = (0, o.createVisibilityController)("PriceAxisCurrencyAndUnit.visibility");
    let d = false;
    function u(e, t) {
      if (!d) {
        d = true;
        if (r().getValue("PriceAxisCurrencyAndUnit.visibility") === undefined) {
          a().setValue(e || t ? "alwaysOn" : "alwaysOff");
        }
      }
    }
  },
  28120: (e, t, i) => {
    "use strict";

    i.d(t, {
      CustomSourceBase: () => s
    });
    class s {
      constructor(e, t) {
        this._id = e;
        this._model = t;
      }
      id() {
        return this._id;
      }
      isHoveredEnabled() {
        return true;
      }
      isSelectionEnabled() {
        return false;
      }
      priceScale() {
        return null;
      }
      paneViews(e) {
        return [];
      }
      labelPaneViews(e) {
        return [];
      }
      priceAxisViews(e, t) {
        return [];
      }
      updateViewsForPane(e, t) {
        if (e.containsMainSeries()) {
          this.updateAllViews(t);
        }
      }
    }
  },
  36915: (e, t, i) => {
    "use strict";

    i.d(t, {
      isLineToolState: () => r,
      isMainSeriesState: () => o,
      isStudyLineToolState: () => a,
      isStudyState: () => n
    });
    var s = i(15764);
    function o(e) {
      return e.type === "MainSeries";
    }
    function n(e) {
      return Boolean(e.type) && e.type.toLowerCase().startsWith("study");
    }
    function r(e) {
      return Boolean(e.type) && (0, s.isLineToolName)(e.type);
    }
    function a(e) {
      return Boolean(e.type) && (0, s.isStudyLineToolName)(e.type);
    }
  },
  29137: (e, t, i) => {
    "use strict";

    i.d(t, {
      DataSource: () => d,
      getTranslatedStringForSource: () => c,
      toInputDisplayFlags: () => h
    });
    var s = i(45126);
    var o = i(19466);
    var n = i(92184);
    var r = i(52033);
    var a = i(64147);
    var l = i(65383);
    function c(e, t) {
      return new s.TranslatedString(t.name(), t.title(e));
    }
    function h(e) {
      switch (e) {
        case o.TitleDisplayTarget.DataWindow:
          return l.InputDisplayFlags.DataWindow;
        case o.TitleDisplayTarget.StatusLine:
        case o.TitleDisplayTarget.Alerts:
          return l.InputDisplayFlags.StatusLine;
      }
    }
    class d {
      constructor(e) {
        this.isSeries = false;
        this._isDestroyed = false;
        this._hasAlert = new a.WatchedValue(false);
        this._alertStatus = new a.WatchedValue(0);
        this._alertCreationAvailable = new a.WatchedValue(false);
        this._zorder = 0;
        this._priceScale = null;
        this._ownerSource = null;
        this._userEditEnabled = true;
        this._priceScaleChanged = new r.Delegate();
        this._isSelectionEnabled = true;
        this._instanceId = (0, n.randomHashN)(6);
        this._ownerSourceChanged = new r.Delegate();
        this._zOrderChanged = new r.Delegate();
        this._id = new a.WatchedValue(e ?? (0, n.randomHashN)(6));
      }
      destroy() {
        this._isDestroyed = true;
      }
      id() {
        return this._id.value();
      }
      idWV() {
        return this._id.readonly();
      }
      instanceId() {
        return this._instanceId;
      }
      preferNoScale() {
        return false;
      }
      setId(e) {
        this._id.setValue(e);
      }
      zorder() {
        return this._zorder;
      }
      setZorder(e) {
        if (typeof e == "number" && this._zorder !== e) {
          this._zorder = e;
          this._zOrderChanged.fire(e);
        }
      }
      preferredZOrder() {
        return null;
      }
      isSpeciallyZOrderedSource() {
        return false;
      }
      title(e) {
        return this.name();
      }
      priceScale() {
        return this._priceScale;
      }
      hasPriceScale() {
        return this._priceScale !== null;
      }
      setPriceScale(e) {
        if (this._priceScale !== e) {
          this._priceScale = e;
          this._priceScaleChanged.fire(e);
        }
      }
      priceScaleChanged() {
        return this._priceScaleChanged;
      }
      ownerSource() {
        return this._ownerSource;
      }
      setOwnerSource(e) {
        const t = this._ownerSource;
        this._ownerSource = e;
        this._ownerSourceChanged.fire(t, e);
      }
      ownerSourceChanged() {
        return this._ownerSourceChanged;
      }
      zOrderChanged() {
        return this._zOrderChanged;
      }
      isSavedInChart(e) {
        return true;
      }
      isSavedInStudyTemplates() {
        return true;
      }
      isRemovedByStudyTemplates() {
        return true;
      }
      hasContextMenu() {
        return true;
      }
      showInObjectTree() {
        return true;
      }
      setUserEditEnabled(e) {
        this._userEditEnabled = e;
      }
      userEditEnabled() {
        return this._userEditEnabled;
      }
      canBeHidden() {
        return this.userEditEnabled();
      }
      isUserDeletable() {
        return this.userEditEnabled();
      }
      properties() {
        return null;
      }
      propertyByPath(e) {
        const t = e.split(".");
        if (t.length < 1) {
          throw new Error("Invalid path");
        }
        const i = t[0];
        if (i === "properties") {
          const e = this.properties();
          if (t.length === 1) {
            return e;
          } else {
            return e.childByPath(t.slice(1).join("."));
          }
        }
        throw new Error(`Unknown property root: ${i}`);
      }
      isVisible() {
        return this.properties().visible.value();
      }
      dataWindowView() {
        return null;
      }
      priceAxisViews(e, t) {
        return null;
      }
      timeAxisViews() {
        return null;
      }
      updateAllViews(e) { }
      paneViews(e) {
        return null;
      }
      labelPaneViews(e) {
        return null;
      }
      isFailed() {
        return false;
      }
      isLoading() {
        return false;
      }
      isPhantom() {
        return false;
      }
      isChildStudy() {
        return false;
      }
      hasChildren() {
        return false;
      }
      canHaveChildren() {
        return false;
      }
      onClickOutside(e, t) { }
      getSourceIcon() {
        return null;
      }
      state(e) {
        return null;
      }
      doesMovingAffectsUndo() {
        return true;
      }
      isMultiPaneAvailable() {
        return false;
      }
      isMultiPaneEnabled() {
        return false;
      }
      copiable() {
        return false;
      }
      cloneable() {
        return false;
      }
      movable() {
        return false;
      }
      allowsMovingBetweenPanes() {
        return true;
      }
      isIncludedInAutoScale() {
        return false;
      }
      isHoveredEnabled() {
        return this.isSelectionEnabled();
      }
      showOnTopOnHovering() {
        return true;
      }
      isSelectionEnabled() {
        return this._isSelectionEnabled;
      }
      setSelectionEnabled(e) {
        this._isSelectionEnabled = e;
      }
      firstValue() {
        return null;
      }
      priceRange(e, t, i) {
        return null;
      }
      autoScaleInfo(e, t, i) {
        return {
          range: this.priceRange(e, t, i)
        };
      }
      stateForAlert() {
        return null;
      }
      canHasAlert() {
        return false;
      }
      canHasAlertOnLineTools() {
        return false;
      }
      hasAlert() {
        return this._hasAlert.readonly();
      }
      alertCreationAvailable() {
        return this._alertCreationAvailable.readonly();
      }
      hasStateForAlert() {
        return false;
      }
      idForAlert() {
        return this._id.value();
      }
      alertStatus() {
        return this._alertStatus.readonly();
      }
      _getAlertCreationAvailable() {
        return false;
      }
      _updateAlertCreationAvailable() {
        0;
      }
    }
  },
  7576: (e, t, i) => {
    "use strict";

    i.d(t, {
      DataWindowItem: () => s,
      DataWindowView: () => o
    });
    class s {
      constructor(e, t, i, s = false) {
        this._visible = true;
        this._id = e;
        this._title = t;
        this._value = i;
        this._unimportant = s;
      }
      id() {
        return this._id;
      }
      title() {
        return this._title;
      }
      setTitle(e) {
        this._title = e;
      }
      text() {
        return this._value;
      }
      value() {
        return this._value;
      }
      setValue(e) {
        this._value = e;
      }
      visible() {
        return this._visible;
      }
      setVisible(e) {
        this._visible = e;
      }
      color() {
        return this._color;
      }
      setColor(e) {
        this._color = e;
      }
      unimportant() {
        return this._unimportant;
      }
    }
    class o {
      constructor() {
        this._items = [];
        this._header = "";
        this._title = "";
      }
      header() {
        return this._header;
      }
      title() {
        return this._title;
      }
      items() {
        return this._items;
      }
      canShowItems() {
        return true;
      }
      update(e) { }
    }
  },
  63829: (e, t, i) => {
    "use strict";

    i.d(t, {
      dateFormatProperty: () => l,
      restoreDateFormatSettingsValue: () => c
    });
    var s = i(56840);
    var o = i(17625);
    var n = i(47462);
    const r = "date_format";
    function a() {
      return s.getValue(r, (0, n.defaultDateFormat)());
    }
    const l = (0, o.createPrimitiveProperty)(a());
    function c() {
      l.setValue((0, n.defaultDateFormat)());
      s.remove(r);
    }
    s.onSync.subscribe(null, () => l.setValue(a()));
    l.subscribe(null, () => s.setValue(r, l.value()));
  },
  32679: (e, t, i) => {
    "use strict";

    i.d(t, {
      DefaultProperty: () => q,
      allowSavingDefaults: () => R,
      createDefaultsState: () => B,
      extractAllPropertiesKeys: () => N,
      extractState: () => F,
      extractThemedColors: () => W
    });
    var s;
    var o = i(90054);
    var n = i(16738);
    var r = i(81960);
    var a = i(54029);
    var l = i(47339);
    var c = i(39852);
    var h = i(50279);
    var d = i(15943);
    var u = i(82433);
    var _ = i(83873);
    var p = i(50151);
    var m = i(24377);
    var g = i(9343);
    function f(e) {
      if (e < 0) {
        e += Math.PI * 2;
      }
      return e;
    }
    (function (e) {
      e[e.Pow25In7 = 6103515625] = "Pow25In7";
      e[e.LWeight = 1] = "LWeight";
      e[e.CWeight = 1] = "CWeight";
      e[e.HWeight = 1] = "HWeight";
    })(s ||= {});
    const y = [127, 127, 127];
    function v(e) {
      const t = e[3];
      const i = e.slice(0, 3);
      for (let e = 0; e < 3; e++) {
        i[e] = Math.round(i[e] * t + y[e] * (1 - t));
      }
      return i;
    }
    function S(e, t) {
      const i = function (e, t) {
        const [i, s, o] = e;
        const [n, r, a] = t;
        const l = (Math.sqrt(s ** 2 + o ** 2) + Math.sqrt(r ** 2 + a ** 2)) / 2;
        const c = (1 - Math.sqrt(Math.pow(l, 7) / (Math.pow(l, 7) + 6103515625))) * 0.5;
        const h = (1 + c) * s;
        const d = (1 + c) * r;
        const u = Math.sqrt(h * h + o * o);
        const _ = Math.sqrt(d * d + a * a);
        const p = o === 0 && h === 0 ? 0 : f(Math.atan2(o, h));
        const m = a === 0 && d === 0 ? 0 : f(Math.atan2(a, d));
        const g = n - i;
        const y = _ - u;
        let v;
        const S = u * _;
        if (S === 0) {
          v = 0;
        } else {
          v = m - p;
          if (v < -Math.PI) {
            v += Math.PI * 2;
          } else if (v > Math.PI) {
            v -= Math.PI * 2;
          }
        }
        const b = Math.sqrt(S) * 2 * Math.sin(v / 2);
        const w = (i + n) / 2;
        const C = (u + _) / 2;
        let P;
        const T = p + m;
        P = u * _ == 0 ? T : Math.abs(p - m) <= Math.PI ? T / 2 : T < Math.PI * 2 ? (T + Math.PI * 2) / 2 : (T - Math.PI * 2) / 2;
        const x = 1 - Math.cos(P - Math.PI / 6) * 0.17 + Math.cos(P * 2) * 0.24 + Math.cos(P * 3 + Math.PI / 30) * 0.32 - Math.cos(P * 4 - Math.PI / 180 * 63) * 0.2;
        const I = Math.PI / 6 * Math.exp(-Math.pow((P - Math.PI / 180 * 275) / (Math.PI / 180 * 25), 2));
        const M = Math.sqrt(Math.pow(C, 7) / (Math.pow(C, 7) + 6103515625)) * 2;
        const A = 1 + Math.pow(w - 50, 2) * 0.015 / Math.sqrt(20 + Math.pow(w - 50, 2));
        const L = 1 + C * 0.045;
        const k = 1 + C * 0.015 * x;
        const D = -Math.sin(I * 2) * M;
        return Math.sqrt(Math.pow(g / (A * 1), 2) + Math.pow(y / (L * 1), 2) + Math.pow(b / (k * 1), 2) + D * (y / (L * 1)) * (b / (k * 1)));
      }(C(b(v((0, m.parseRgba)(e)))), C(b(v((0, m.parseRgba)(t)))));
      return i < 3;
    }
    function b(e) {
      const [t, i, s] = e;
      const o = t / 255;
      const n = i / 255;
      const r = s / 255;
      const a = (o > 0.04045 ? Math.pow((o + 0.055) / 1.055, 2.4) : o / 12.92) * 100;
      const l = (n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92) * 100;
      const c = (r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92) * 100;
      return [a * 0.4124 + l * 0.3576 + c * 0.1805, a * 0.2126 + l * 0.7152 + c * 0.0722, a * 0.0193 + l * 0.1192 + c * 0.9505];
    }
    var w;
    function C(e) {
      const [t, i, s] = e;
      const o = t / 95.047;
      const n = i / 100;
      const r = s / 108.883;
      const a = o > 0.008856 ? Math.pow(o, 1 / 3) : o * 7.787 + 16 / 116;
      const l = n > 0.008856 ? Math.pow(n, 1 / 3) : n * 7.787 + 16 / 116;
      return [l * 116 - 16, (a - l) * 500, (l - (r > 0.008856 ? Math.pow(r, 1 / 3) : r * 7.787 + 16 / 116)) * 200];
    }
    (function (e) {
      e[e.X = 95.047] = "X";
      e[e.Y = 100] = "Y";
      e[e.Z = 108.883] = "Z";
    })(w ||= {});
    var P = i(24633);
    var T = i(45345);
    var x = i(85662);
    var I = i(52033);
    var M = i(72595);
    var A = i(35039);
    var L = i(12988);
    const k = (0, g.getLogger)("ThemedDefaults");
    function D(e) {
      if (e.value() === P.StdTheme.Dark) {
        return P.StdTheme.Dark;
      } else {
        return P.StdTheme.Light;
      }
    }
    function E(e, t, i) {
      for (const s of t) {
        (0, r.default)(e, s);
        if (i) {
          const t = s.split(".");
          for (t.pop(); t.length;) {
            const i = (0, a.default)(e, t);
            if (!(0, u.default)(i) || Object.keys(i).length !== 0) {
              break;
            }
            (0, r.default)(e, t);
            t.pop();
          }
        }
      }
    }
    function B(e, t, i, s) {
      const r = e ? A.defaults : A.factoryDefaults;
      const a = t.startsWith("study_") ? (0, o.default)(r("study")) : {};
      let l = (0, o.default)(r(t, s));
      if (t.startsWith("study_") && l.inputs) {
        delete l.inputs.symbol;
      }
      if (t === "linetoolicon" && e) {
        l.icon = (0, A.defaults)(t).icon;
      }
      if (t === "linetooemoji" && e) {
        l.emoji = (0, A.defaults)(t).emoji;
      }
      if (t === "linetoolsticker" && e) {
        l.sticker = (0, A.defaults)(t).sticker;
      }
      l = (0, o.default)(l);
      E(l, i);
      (0, n.default)(a, l);
      return a;
    }
    let V = false;
    function R(e) {
      V = e;
    }
    function N(e) {
      const t = Object.keys(e);
      const i = [];
      t.forEach(t => {
        const s = e[t];
        if ((0, u.default)(s)) {
          N(s).forEach(e => i.push(`${t}.${e}`));
        } else {
          i.push(t);
        }
      });
      return i;
    }
    function O(e, t, i = "") {
      if (t.length === 1 && t[0] === "*") {
        return e;
      }
      const s = {};
      for (const o of t) {
        const n = o.split(".");
        const r = n[0];
        const a = e[r];
        const l = i === "" ? r : `${i}.${r}`;
        if (e.hasOwnProperty(r)) {
          if (n.length > 1) {
            if (!(0, u.default)(a)) {
              k.logError(`path ${l} must be an object, but it is a primitive`);
              continue;
            }
            {
              const e = t.filter(e => e.startsWith(`${r}.`)).map(e => e.split(".").slice(1).join("."));
              s[r] = O(a, e, l);
            }
          } else {
            if ((0, u.default)(a)) {
              k.logError(`path ${l} must be a primitive, but it is an object`);
              continue;
            }
            s[r] = a;
          }
        }
      }
      return s;
    }
    function F(e, t, i) {
      if (!e) {
        return {};
      }
      let s = e;
      if (t) {
        s = O(e, t);
      }
      if (i) {
        E(s, i, true);
      }
      return s;
    }
    function W(e, t) {
      const i = N(e);
      const s = [];
      for (const o of i) {
        const i = (0, a.default)(e, o);
        const n = (0, a.default)(t, o);
        (0, p.assert)(i !== undefined, `Light theme value for ${o} is undefined`);
        (0, p.assert)(n !== undefined, `Dark theme value for ${o} is undefined`);
        s.push({
          path: o,
          colors: [i, n]
        });
      }
      return s;
    }
    function H(e, t) {
      if (!e.includes(t)) {
        e.push(t);
      }
    }
    function z(e, t) {
      const i = e.indexOf(t);
      if (i !== -1) {
        e.splice(i, 1);
      }
    }
    function U(e, t) {
      const i = (0, c.default)(e, (e, i, s) => {
        if (t[s] === undefined) {
          return e;
        }
        if (!(0, h.default)(i, t[s])) {
          if ((0, u.default)(i) && (0, u.default)(t[s])) {
            const o = U(i, t[s]);
            if (o !== undefined) {
              e[s] = o;
            }
          } else {
            e[s] = i;
          }
        }
        return e;
      }, {});
      if ((0, d.default)(i)) {
        return undefined;
      } else {
        return i;
      }
    }
    function j(e) {
      if (e === P.StdTheme.Dark) {
        return 1;
      } else {
        return 0;
      }
    }
    function G(e, t) {
      if (e === t) {
        return true;
      }
      if (typeof e != typeof t) {
        return false;
      }
      if (!(0, _.default)(e) || !(0, _.default)(t)) {
        return false;
      }
      const i = (0, m.tryParseRgba)(e);
      const s = (0, m.tryParseRgba)(t);
      return !!i && !!s && !!S(e, t);
    }
    class q extends L.Property {
      constructor(e) {
        const {
          defaultName: t,
          nonThemedDefaultsKeys: i,
          themedDefaultsKeys: s,
          excludedDefaultsKeys: o = [],
          themedColors: r,
          replaceThemedColorsOnThemeChange: a = false,
          allStateKeys: l,
          excludedStateKeys: c = [],
          excludedTemplateKeys: h = [],
          state: d,
          useUserPreferences: u = true,
          saveNonDefaultUserPreferencesOnly: _ = false,
          ignoreAllowSavingDefaults: m = false,
          alwaysSaveDefaultKeys: g = ["version"],
          saveDefaultsConsumer: f = A.saveDefaults,
          factoryDefaultsSupplier: y = () => B(false, t, [], null),
          schema: v = (0, M.createPropertySchema)(y()),
          theme: S = T.watchedTheme.spawnOwnership()
        } = e;
        super(undefined, v);
        this._themedColors = [];
        this._restoreFactoryDefaultsEvent = new I.Delegate();
        this._replaceThemedColorsOnThemeChange = false;
        this._forbidSavingDefaults = false;
        this._defaultName = t;
        this._useUserPreferences = u;
        this._saveNonDefaultUserPreferencesOnly = _;
        this._ignoreAllowSavingDefaults = m;
        this._saveDefaultsConsumer = f;
        this._factoryDefaultsSupplier = y;
        this._allStateKeys = l;
        this._excludedStateKeys = c;
        this._nonThemedDefaultsKeys = i;
        this._themedDefaultsKeys = s;
        this._allDefaultsKeys = i || s ? [...(i ?? []), ...(s ?? [])] : undefined;
        this._excludedDefaultsKeys = o;
        this._excludedTemplateKeys = h;
        this._themedColors = r;
        this._alwaysSaveDefaultKeys = g;
        (0, p.assert)(this._allDefaultsKeys === undefined || this._excludedDefaultsKeys.length === 0, "Defaults keys and excluded defaults keys cannot be used at the same time");
        (0, p.assert)(this._allStateKeys === undefined || this._excludedStateKeys.length === 0, "State keys and excluded state keys cannot be used at the same time");
        this._theme = S;
        const b = D(this._theme);
        this.merge((0, n.default)(this._factoryDefaultsForTheme((0, x.isStdThemeName)(b) ? b : P.StdTheme.Light), this._userSettings(), F(d, l, c)));
        if (r && a) {
          this.setThemedColors(r);
        }
        this._restoreFactoryDefaultsEvent = new I.Delegate();
      }
      destroy() {
        this._theme?.release();
        this._unsubscribeWatchedTheme?.();
        super.destroy();
      }
      applyTemplate(e, t) {
        this.mergeAndFire(F((0, n.default)((0, o.default)(t), e), this._allStateKeys, this._excludedTemplateKeys));
      }
      preferences() {
        return F(this.state(this._excludedDefaultsKeys), this._allDefaultsKeys);
      }
      template() {
        return F(this.state(), undefined, this._excludedTemplateKeys);
      }
      mergePreferences(e) {
        this.mergeAndFire(F(e, this._allDefaultsKeys, this._excludedDefaultsKeys));
      }
      addExcludedKey(e, t) {
        if (t & 1) {
          H(this._excludedDefaultsKeys, e);
        }
        if (t & 2) {
          H(this._excludedStateKeys, e);
        }
        if (t & 4) {
          H(this._excludedTemplateKeys, e);
        }
      }
      removeExcludedKey(e, t) {
        if (t & 1) {
          z(this._excludedDefaultsKeys, e);
        }
        if (t & 2) {
          z(this._excludedStateKeys, e);
        }
      }
      restoreFactoryDefaults() {
        const e = this.factoryDefaults();
        E(e, this._excludedDefaultsKeys);
        this.mergeAndFire(e);
        if (!this._defaultName.startsWith("study_") || !!this._defaultName.startsWith("study_VbPFixed")) {
          this.saveDefaults();
        }
        this._restoreFactoryDefaultsEvent.fire();
      }
      onRestoreFactoryDefaults() {
        return this._restoreFactoryDefaultsEvent;
      }
      saveDefaults() {
        if (!this._useUserPreferences || this._forbidSavingDefaults) {
          return;
        }
        let e;
        if (this._saveNonDefaultUserPreferencesOnly) {
          const t = this.state(this._excludedDefaultsKeys);
          const i = this.factoryDefaults();
          e = U(F(t, this._nonThemedDefaultsKeys), F(i, this._nonThemedDefaultsKeys, this._excludedDefaultsKeys));
          if (this._alwaysSaveDefaultKeys.length) {
            const i = F(t, this._alwaysSaveDefaultKeys);
            e = e ?? {};
            (0, n.default)(e, i);
          }
          const s = this.themeDefaults(D(this._theme));
          const o = this.themeState();
          const r = U(o, s);
          if (!(0, d.default)(r)) {
            e = e ?? {};
            (0, n.default)(e, o);
          }
        } else {
          e = this.preferences();
        }
        this._saveDefaultsConsumer(this._defaultName, e);
      }
      themeDefaults(e) {
        if (this._themedColors) {
          return function (e, t) {
            const i = {};
            for (const {
              path: s,
              colors: o
            } of e) {
              (0, l.default)(i, s, o[j(t)]);
            }
            return i;
          }(this._themedColors, e === P.StdTheme.Dark ? P.StdTheme.Dark : P.StdTheme.Light);
        }
        return F(this._factoryDefaultsSupplier(), this._themedDefaultsKeys, this._excludedDefaultsKeys);
      }
      factoryDefaults() {
        return this._factoryDefaultsForTheme(D(this._theme));
      }
      themeState() {
        const e = super.state(this._excludedDefaultsKeys);
        const t = this._themedColors;
        return F(e, t ? t.map(e => e.path) : this._themedDefaultsKeys);
      }
      allThemePropertiesAreDefault(e) {
        (0, p.assert)(!!this._themedColors, "This method should not be called if themed colors are not set");
        return function (e, t, i = []) {
          for (const s of i) {
            const i = s.path;
            if (!G((0, a.default)(e, i), (0, a.default)(t, i))) {
              return false;
            }
          }
          return true;
        }(this.themeState(), this.themeDefaults(e), this._themedColors);
      }
      clone(e) {
        return new q(this._options());
      }
      setThemedColors(e) {
        this._themedColors = e;
        if (this._unsubscribeWatchedTheme === undefined) {
          const e = () => {
            this._updateThemedColors(false);
          };
          this._theme.subscribe(e);
          this._unsubscribeWatchedTheme = () => this._theme.unsubscribe(e);
        }
        this._updateThemedColors(true);
      }
      applyDefaultThemedProperties(e) {
        if (this._themedColors) {
          this.mergeAndFire(this.themeDefaults(e));
        }
      }
      state(e, t) {
        return F(super.state([...this._excludedStateKeys, ...(e ?? [])], t), this._allStateKeys);
      }
      _updateThemedColors(e) {
        if (!this._themedColors) {
          return;
        }
        const t = D(this._theme);
        const i = t === P.StdTheme.Light ? P.StdTheme.Dark : P.StdTheme.Light;
        for (const s of this._themedColors) {
          const o = (0, p.ensureDefined)(this.childByPath(s.path));
          const n = s.colors[j(i)];
          if (o.value() === "" || !e && G(o.value(), n)) {
            o.setValue(s.colors[j(t)]);
          }
        }
      }
      _userSettings() {
        if (!this._useUserPreferences) {
          return;
        }
        const e = B(true, this._defaultName, [], null);
        if (e) {
          return F((0, o.default)(e), this._allDefaultsKeys, this._excludedDefaultsKeys);
        } else {
          return undefined;
        }
      }
      _options() {
        return {
          defaultName: this._defaultName,
          factoryDefaultsSupplier: this._factoryDefaultsSupplier,
          state: this.state(),
          nonThemedDefaultsKeys: this._nonThemedDefaultsKeys,
          themedDefaultsKeys: this._themedDefaultsKeys,
          excludedDefaultsKeys: this._excludedDefaultsKeys,
          themedColors: this._themedColors,
          replaceThemedColorsOnThemeChange: this._replaceThemedColorsOnThemeChange,
          allStateKeys: this._allStateKeys,
          excludedStateKeys: this._excludedDefaultsKeys,
          excludedTemplateKeys: this._excludedTemplateKeys,
          useUserPreferences: this._useUserPreferences,
          saveNonDefaultUserPreferencesOnly: this._saveNonDefaultUserPreferencesOnly,
          ignoreAllowSavingDefaults: this._ignoreAllowSavingDefaults,
          saveDefaultsConsumer: this._saveDefaultsConsumer,
          alwaysSaveDefaultKeys: this._alwaysSaveDefaultKeys,
          theme: this._theme.spawnOwnership()
        };
      }
      _childChanged(e, t) {
        super._childChanged(e, t);
        if (this._propertyAffectsDefaults(t)) {
          this.saveDefaults();
        }
      }
      _fireMergeAndFireChangedProps(e) {
        this._forbidSavingDefaults = true;
        super._fireMergeAndFireChangedProps(e);
        this._forbidSavingDefaults = false;
        if (e.some(e => this._propertyAffectsDefaults(e.pathToRootProperty()))) {
          this.saveDefaults();
        }
      }
      _factoryDefaultsForTheme(e) {
        return (0, n.default)(this._factoryDefaultsSupplier(), this.themeDefaults(e));
      }
      _propertyAffectsDefaults(e) {
        return (this._ignoreAllowSavingDefaults || V) && !this._defaultName.startsWith("replayStudyStrategy") && (!this._defaultName.startsWith("study_") || this._defaultName.startsWith("study_VbPFixed")) && (this._allDefaultsKeys && this._allDefaultsKeys.includes(e) || !this._allDefaultsKeys && !this._excludedDefaultsKeys?.includes(e)) && (0, L.isPrimitiveType)(this.childByPath(e)?.value());
      }
    }
  },
  35039: (e, t, i) => {
    "use strict";

    var s = i(80720).PlDisplay;
    const {
      merge: o
    } = i(97085);
    const {
      generateColor: n
    } = i(19063);
    const {
      getStdChartTheme: r
    } = i(24317);
    const {
      DEFAULT_THEME: a
    } = i(85662);
    const l = i(49156).colors;
    var c = i(80720).TradedGroupHorizontalAlignment;
    var h = i(5171);
    var d = i(96333).LineToolPitchforkStyle;
    var u = i(67467).LineToolBarsPatternMode;
    var _ = i(94113);
    var p = _.LineStudyPlotStyle;
    var m = _.STUDYPLOTDISPLAYTARGET;
    var g = i(55158);
    var f = i(94164).PriceAxisLastValueMode;
    var y = i(92693).MagnetMode;
    var v = i(49857).LineEnd;
    var S = i(46088).ColorType;
    const b = i(35578).DEFAULT_LINE_TOOL_LINE_WIDTH;
    var w = i(39429).StatsPosition;
    var C = i(6290).sessionsPreferencesDefault;
    var P = i(57596).axisLabelBackgroundColor;
    var T = i(9624).mainSeriesProperties;
    const {
      LINESTYLE_SOLID: x,
      LINESTYLE_DASHED: I
    } = i(51056);
    var M = i(9343).getLogger("Chart.Defaults");
    const {
      colorWhite: A,
      colorWhiteAlpha25: L,
      colorTvBlue50: k,
      colorTvBlue500: D,
      colorTvBlue500Alpha30: E,
      colorTvBlue500Alpha25: B,
      colorTvBlue500Alpha20: V,
      colorTvBlue600: R,
      colorDeepBlue200: N,
      colorDeepBlue300: O,
      colorDeepBlue500: F,
      colorDeepBlue500Alpha20: W,
      colorSkyBlue500: H,
      colorSkyBlue500Alpha20: z,
      colorSkyBlue700: U,
      colorSkyBlue700Alpha70: j,
      colorDefaultRed: G,
      colorRipeRed200: q,
      colorRipeRed300: $,
      colorRipeRed400: K,
      colorRipeRed400Alpha5: Y,
      colorRipeRed500: Z,
      colorRipeRed500Alpha30: X,
      colorRipeRed500Alpha20: J,
      colorRipeRed600: Q,
      colorGrapesPurple500: ee,
      colorGrapesPurple500Alpha0: te,
      colorGrapesPurple500Alpha20: ie,
      colorGrapesPurple500Alpha70: se,
      colorBerryPink400: oe,
      colorBerryPink500: ne,
      colorBerryPink500Alpha20: re,
      colorMintyGreen100: ae,
      colorMintyGreen400: le,
      colorMintyGreen500: ce,
      colorMintyGreen500Alpha20: he,
      colorIguanaGreen300: de,
      colorIguanaGreen500: ue,
      colorIguanaGreen500Alpha20: _e,
      colorTanOrange300: pe,
      colorTanOrange500: me,
      colorTanOrange500Alpha20: ge,
      colorTanOrange600: fe,
      colorTanOrange700: ye,
      colorColdGray150: ve,
      colorColdGray400: Se,
      colorColdGray450: be,
      colorColdGray500: we,
      colorColdGray900: Ce,
      colorColdGray750: Pe,
      colorForestGreen300: Te,
      colorForestGreen300Alpha5: xe
    } = l;
    function Ie(e) {
      function t(e, t) {
        return {
          color: e,
          visible: t
        };
      }
      function i(e, t, i, s) {
        const o = {
          coeff: e,
          color: t,
          visible: i
        };
        if (s) {
          o.text = "";
        }
        return o;
      }
      function _(e, t, i, s, o) {
        return {
          coeff: e,
          color: t,
          visible: i,
          linestyle: s === undefined ? x : s,
          linewidth: o === undefined ? b : o
        };
      }
      function M(e, t, i) {
        return {
          color: e,
          width: i === undefined ? b : i,
          visible: t
        };
      }
      function Ie(e, t, i, s, o) {
        return {
          color: e,
          visible: t,
          width: i,
          x: s,
          y: o
        };
      }
      function Me(e, t, i, s, o, n) {
        return {
          coeff1: e,
          coeff2: t,
          color: i,
          visible: s,
          linestyle: o === undefined ? x : o,
          linewidth: n === undefined ? b : n
        };
      }
      if (TradingView.defaultProperties === undefined) {
        var Le;
        switch (window.locale) {
          case "ar_AE":
            Le = "Asia/Dubai";
            break;
          case "au":
            Le = "Australia/Sydney";
            break;
          case "br":
            Le = "America/Sao_Paulo";
            break;
          case "ca":
            Le = "America/Toronto";
            break;
          case "de_DE":
          case "it":
            Le = "Europe/Berlin";
            break;
          case "es":
            Le = "Europe/Madrid";
            break;
          case "he_IL":
          case "tr":
            Le = "Europe/Athens";
            break;
          case "hu_HU":
          case "pl":
            Le = "Europe/Warsaw";
            break;
          case "id":
          case "th_TH":
          case "vi_VN":
            Le = "Asia/Bangkok";
            break;
          case "in":
            Le = "Asia/Kolkata";
            break;
          case "ja":
          case "kr":
            Le = "Asia/Tokyo";
            break;
          case "ms_MY":
            Le = "Asia/Singapore";
            break;
          case "ru":
            Le = "Europe/Moscow";
            break;
          case "uk":
            Le = "Europe/London";
            break;
          case "zh_CN":
          case "zh_TW":
            Le = "Asia/Shanghai";
            break;
          default:
            Le = "Etc/UTC";
        }
        const e = r(a);
        TradingView.defaultProperties = {
          chartproperties: o({
            timezone: Le,
            priceScaleSelectionStrategyName: "auto",
            paneProperties: {
              backgroundType: S.Solid,
              gridLinesMode: "both",
              vertGridProperties: {
                style: x
              },
              horzGridProperties: {
                style: x
              },
              crossHairProperties: {
                style: I,
                transparency: 0,
                width: 1
              },
              topMargin: 10,
              bottomMargin: 8,
              axisProperties: {
                autoScale: true,
                autoScaleDisabled: false,
                lockScale: false,
                percentage: false,
                percentageDisabled: false,
                indexedTo100: false,
                log: false,
                logDisabled: false,
                alignLabels: true,
                isInverted: false
              },
              legendProperties: {
                showStudyArguments: true,
                showStudyTitles: true,
                showStudyValues: true,
                showSeriesTitle: true,
                showSeriesOHLC: true,
                showLegend: true,
                showLastDayChange: false,
                showBarChange: true,
                showVolume: false,
                showBackground: true,
                showPriceSource: true,
                backgroundTransparency: 50,
                showLogo: true,
                showTradingButtons: true,
                showTradingButtonsMobile: true
              },
              separatorColor: ve
            },
            scalesProperties: {
              fontSize: 12,
              scaleSeriesOnly: false,
              showSeriesLastValue: true,
              seriesLastValueMode: f.LastValueAccordingToScale,
              showSeriesPrevCloseValue: false,
              showStudyLastValue: true,
              showSymbolLabels: false,
              showStudyPlotLabels: false,
              showBidAskLabels: false,
              showPrePostMarketPriceLabel: true,
              showFundamentalNameLabel: false,
              showFundamentalLastValue: true,
              barSpacing: g.DEFAULT_BAR_SPACING,
              axisHighlightColor: B,
              axisLineToolLabelBackgroundColorCommon: P.common,
              axisLineToolLabelBackgroundColorActive: P.active,
              showPriceScaleCrosshairLabel: true,
              showTimeScaleCrosshairLabel: true,
              crosshairLabelBgColorLight: Ce,
              crosshairLabelBgColorDark: Pe,
              saveLeftEdge: false
            },
            mainSeriesProperties: o(T, e.content.mainSourceProperties),
            chartEventsSourceProperties: {
              visible: true,
              futureOnly: true,
              breaks: {
                color: "#555555",
                visible: false,
                style: I,
                width: 1
              }
            },
            tradingProperties: {
              showPositions: true,
              positionPL: {
                visibility: true,
                display: s.Money
              },
              bracketsPL: {
                visibility: true,
                display: s.Money
              },
              showOrders: true,
              showExecutions: true,
              showExecutionsLabels: false,
              showReverse: true,
              horizontalAlignment: c.Right,
              extendLeft: true,
              lineLength: 5,
              lineWidth: 1,
              lineStyle: x
            },
            volumePaneSize: "large"
          }, e.content.chartProperties),
          sessions: o(C, e.content.sessions),
          drawings: {
            magnet: false,
            magnetMode: y.WeakMagnet,
            stayInDrawingMode: false,
            drawOnAllCharts: true,
            drawOnAllChartsMode: 1
          },
          linetoolorder: {
            extendLeft: "inherit",
            lineLength: "inherit",
            lineLengthUnit: "percentage",
            lineColor: G,
            lineActiveBuyColor: "#4094e8",
            lineInactiveBuyColor: "rgba(64, 148, 232, 0.5)",
            lineActiveSellColor: "#e75656",
            lineInactiveSellColor: "rgba(231, 86, 86, 0.5)",
            lineStyle: "inherit",
            lineWidth: "inherit",
            bodyBorderActiveBuyColor: "#4094e8",
            bodyBorderInactiveBuyColor: "rgba(64, 148, 232, 0.5)",
            bodyBorderActiveSellColor: "#e75656",
            bodyBorderInactiveSellColor: "rgba(231, 86, 86, 0.5)",
            bodyBackgroundColor: L,
            bodyBackgroundTransparency: 25,
            bodyTextInactiveLimitColor: "rgba(38, 140, 2, 0.5)",
            bodyTextActiveLimitColor: "#268c02",
            bodyTextInactiveStopColor: "rgba(231, 86, 86, 0.5)",
            bodyTextActiveStopColor: "#e75656",
            bodyTextInactiveBuyColor: "rgba(64, 148, 232, 0.5)",
            bodyTextActiveBuyColor: "#4094e8",
            bodyTextInactiveSellColor: "rgba(231, 86, 86, 0.5)",
            bodyTextActiveSellColor: "#e75656",
            bodyFontFamily: "Verdana",
            bodyFontSize: 9,
            bodyFontBold: true,
            bodyFontItalic: false,
            quantityBorderActiveBuyColor: "#4094e8",
            quantityBorderInactiveBuyColor: "rgba(64, 148, 232, 0.5)",
            quantityBorderActiveSellColor: "#e75656",
            quantityBorderInactiveSellColor: "rgba(231, 86, 86, 0.5)",
            quantityBackgroundInactiveBuyColor: "rgba(64, 148, 232, 0.5)",
            quantityBackgroundActiveBuyColor: "#4094e8",
            quantityBackgroundInactiveSellColor: "rgba(231, 86, 86, 0.5)",
            quantityBackgroundActiveSellColor: "#e75656",
            quantityTextColor: A,
            quantityTextTransparency: 0,
            quantityFontFamily: "Verdana",
            quantityFontSize: 9,
            quantityFontBold: true,
            quantityFontItalic: false,
            cancelButtonBorderActiveBuyColor: "#4094e8",
            cancelButtonBorderInactiveBuyColor: "rgba(64, 148, 232, 0.5)",
            cancelButtonBorderActiveSellColor: "#e75656",
            cancelButtonBorderInactiveSellColor: "rgba(231, 86, 86, 0.5)",
            cancelButtonBackgroundColor: L,
            cancelButtonBackgroundTransparency: 25,
            cancelButtonIconActiveBuyColor: "#4094e8",
            cancelButtonIconInactiveBuyColor: "rgba(64, 148, 232, 0.5)",
            cancelButtonIconActiveSellColor: "#e75656",
            cancelButtonIconInactiveSellColor: "rgba(231, 86, 86, 0.5)",
            tooltip: "",
            modifyTooltip: "",
            cancelTooltip: ""
          },
          linetoolposition: {
            extendLeft: "inherit",
            lineLength: "inherit",
            lineLengthUnit: "percentage",
            lineBuyColor: "#4094e8",
            lineSellColor: "#e75656",
            lineStyle: "inherit",
            lineWidth: "inherit",
            bodyBorderBuyColor: "#4094e8",
            bodyBorderSellColor: "#e75656",
            bodyBackgroundColor: L,
            bodyBackgroundTransparency: 25,
            bodyTextPositiveColor: "#268c02",
            bodyTextNeutralColor: "#646464",
            bodyTextNegativeColor: "#e75656",
            bodyFontFamily: "Verdana",
            bodyFontSize: 9,
            bodyFontBold: true,
            bodyFontItalic: false,
            quantityBorderBuyColor: "#4094e8",
            quantityBorderSellColor: "#e75656",
            quantityBackgroundBuyColor: "#4094e8",
            quantityBackgroundSellColor: "#e75656",
            quantityTextColor: A,
            quantityTextTransparency: 0,
            quantityFontFamily: "Verdana",
            quantityFontSize: 9,
            quantityFontBold: true,
            quantityFontItalic: false,
            reverseButtonBorderBuyColor: "#4094e8",
            reverseButtonBorderSellColor: "#e75656",
            reverseButtonBackgroundColor: L,
            reverseButtonBackgroundTransparency: 25,
            reverseButtonIconBuyColor: "#4094e8",
            reverseButtonIconSellColor: "#e75656",
            closeButtonBorderBuyColor: "#4094e8",
            closeButtonBorderSellColor: "#e75656",
            closeButtonBackgroundColor: L,
            closeButtonBackgroundTransparency: 25,
            closeButtonIconBuyColor: "#4094e8",
            closeButtonIconSellColor: "#e75656",
            tooltip: "",
            protectTooltip: "",
            closeTooltip: "",
            reverseTooltip: ""
          },
          linetoolexecution: {
            direction: "buy",
            arrowHeight: 8,
            arrowSpacing: 1,
            arrowBuyColor: "#4094e8",
            arrowSellColor: "#e75656",
            text: "",
            textColor: l.colorBlack,
            textTransparency: 0,
            fontFamily: "Verdana",
            fontSize: 10,
            fontBold: false,
            fontItalic: false,
            tooltip: ""
          },
          linetoolicon: {
            color: D,
            size: 40,
            icon: 61720,
            angle: Math.PI * 0.5
          },
          linetoolemoji: {
            size: 40,
            emoji: "😀",
            angle: Math.PI * 0.5
          },
          linetoolsticker: {
            size: 110,
            sticker: "bitcoin",
            angle: Math.PI * 0.5
          },
          linetoolimage: {
            transparency: 0,
            cssWidth: 0,
            cssHeight: 0,
            angle: 0
          },
          linetoolbezierquadro: {
            linecolor: D,
            linewidth: b,
            fillBackground: false,
            backgroundColor: V,
            transparency: 50,
            linestyle: x,
            extendLeft: false,
            extendRight: false,
            leftEnd: v.Normal,
            rightEnd: v.Normal
          },
          linetoolbeziercubic: {
            linecolor: F,
            linewidth: b,
            fillBackground: false,
            backgroundColor: W,
            transparency: 80,
            linestyle: x,
            extendLeft: false,
            extendRight: false,
            leftEnd: v.Normal,
            rightEnd: v.Normal
          },
          linetooltrendline: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            extendLeft: false,
            extendRight: false,
            leftEnd: v.Normal,
            rightEnd: v.Normal,
            showLabel: false,
            horzLabelsAlign: "center",
            vertLabelsAlign: "bottom",
            textcolor: D,
            fontsize: 14,
            bold: false,
            italic: false,
            alwaysShowStats: false,
            showMiddlePoint: false,
            showPriceLabels: false,
            showPriceRange: false,
            showPercentPriceRange: false,
            showPipsPriceRange: false,
            showBarsRange: false,
            showDateTimeRange: false,
            showDistance: false,
            showAngle: false,
            statsPosition: w.Right
          },
          linetoolinfoline: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            extendLeft: false,
            extendRight: false,
            leftEnd: v.Normal,
            rightEnd: v.Normal,
            showLabel: false,
            horzLabelsAlign: "center",
            vertLabelsAlign: "bottom",
            textcolor: D,
            fontsize: 14,
            bold: false,
            italic: false,
            alwaysShowStats: true,
            showMiddlePoint: false,
            showPriceLabels: false,
            showPriceRange: true,
            showPercentPriceRange: true,
            showPipsPriceRange: true,
            showBarsRange: true,
            showDateTimeRange: true,
            showDistance: true,
            showAngle: true,
            statsPosition: w.Center
          },
          linetooltimecycles: {
            linecolor: "#159980",
            linewidth: b,
            fillBackground: true,
            backgroundColor: "rgba(106, 168, 79, 0.5)",
            transparency: 50,
            linestyle: x
          },
          linetoolsineline: {
            linecolor: "#159980",
            linewidth: b,
            linestyle: x
          },
          linetooltrendangle: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            fontsize: 12,
            bold: false,
            italic: false,
            alwaysShowStats: false,
            showMiddlePoint: false,
            showPriceLabels: false,
            showPriceRange: false,
            showPercentPriceRange: false,
            showPipsPriceRange: false,
            showBarsRange: false,
            extendRight: false,
            extendLeft: false,
            statsPosition: w.Right
          },
          linetooldisjointangle: {
            linecolor: ce,
            linewidth: b,
            linestyle: x,
            fillBackground: true,
            backgroundColor: he,
            transparency: 20,
            extendLeft: false,
            extendRight: false,
            leftEnd: v.Normal,
            rightEnd: v.Normal,
            textcolor: ce,
            fontsize: 12,
            bold: false,
            italic: false,
            showPrices: false,
            showPriceRange: false,
            showDateTimeRange: false,
            showBarsRange: false,
            labelVisible: false,
            labelHorzAlign: "left",
            labelVertAlign: "bottom",
            labelTextColor: ce,
            labelFontSize: 14,
            labelBold: false,
            labelItalic: false
          },
          linetoolflatbottom: {
            linecolor: me,
            linewidth: b,
            linestyle: x,
            fillBackground: true,
            backgroundColor: ge,
            transparency: 20,
            extendLeft: false,
            extendRight: false,
            leftEnd: v.Normal,
            rightEnd: v.Normal,
            textcolor: me,
            fontsize: 12,
            bold: false,
            italic: false,
            showPrices: false,
            showPriceRange: false,
            showDateTimeRange: false,
            showBarsRange: false,
            labelVisible: false,
            labelHorzAlign: "left",
            labelVertAlign: "bottom",
            labelTextColor: me,
            labelFontSize: 14,
            labelBold: false,
            labelItalic: false
          },
          linetoolriskrewardshort: {
            linecolor: we,
            linewidth: 1,
            textcolor: A,
            fontsize: 12,
            fillLabelBackground: true,
            labelBackgroundColor: "#585858",
            fillBackground: true,
            stopBackground: J,
            profitBackground: he,
            stopBackgroundTransparency: 80,
            profitBackgroundTransparency: 80,
            drawBorder: false,
            borderColor: "#667b8b",
            compact: false,
            riskDisplayMode: "percents",
            accountSize: 1000,
            lotSize: 1,
            risk: 25,
            alwaysShowStats: false,
            showPriceLabels: true,
            currency: "NONE"
          },
          linetoolriskrewardlong: {
            linecolor: we,
            linewidth: 1,
            textcolor: A,
            fontsize: 12,
            fillLabelBackground: true,
            labelBackgroundColor: "#585858",
            fillBackground: true,
            stopBackground: J,
            profitBackground: he,
            stopBackgroundTransparency: 80,
            profitBackgroundTransparency: 80,
            drawBorder: false,
            borderColor: "#667b8b",
            compact: false,
            riskDisplayMode: "percents",
            accountSize: 1000,
            lotSize: 1,
            risk: 25,
            alwaysShowStats: false,
            showPriceLabels: true,
            currency: "NONE"
          },
          linetoolarrow: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            extendLeft: false,
            extendRight: false,
            leftEnd: v.Normal,
            rightEnd: v.Arrow,
            showLabel: false,
            horzLabelsAlign: "center",
            vertLabelsAlign: "bottom",
            textcolor: D,
            fontsize: 14,
            bold: false,
            italic: false,
            alwaysShowStats: false,
            showMiddlePoint: false,
            showPriceLabels: false,
            showPriceRange: false,
            showPercentPriceRange: false,
            showPipsPriceRange: false,
            showBarsRange: false,
            showDateTimeRange: false,
            showDistance: false,
            showAngle: false,
            statsPosition: w.Right
          },
          linetoolray: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            extendLeft: false,
            extendRight: true,
            leftEnd: v.Normal,
            rightEnd: v.Normal,
            showLabel: false,
            horzLabelsAlign: "center",
            vertLabelsAlign: "bottom",
            textcolor: D,
            fontsize: 14,
            bold: false,
            italic: false,
            alwaysShowStats: false,
            showMiddlePoint: false,
            showPriceLabels: false,
            showPriceRange: false,
            showPercentPriceRange: false,
            showPipsPriceRange: false,
            showBarsRange: false,
            showDateTimeRange: false,
            showDistance: false,
            showAngle: false,
            statsPosition: w.Right
          },
          linetoolextended: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            extendLeft: true,
            extendRight: true,
            leftEnd: v.Normal,
            rightEnd: v.Normal,
            showLabel: false,
            horzLabelsAlign: "center",
            vertLabelsAlign: "bottom",
            textcolor: D,
            fontsize: 14,
            bold: false,
            italic: false,
            alwaysShowStats: false,
            showMiddlePoint: false,
            showPriceLabels: false,
            showPriceRange: false,
            showPercentPriceRange: false,
            showPipsPriceRange: false,
            showBarsRange: false,
            showDateTimeRange: false,
            showDistance: false,
            showAngle: false,
            statsPosition: w.Right
          },
          linetoolhorzline: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            showPrice: true,
            showLabel: false,
            textcolor: D,
            fontsize: 12,
            bold: false,
            italic: false,
            horzLabelsAlign: "center",
            vertLabelsAlign: "middle"
          },
          linetoolhorzray: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            showPrice: true,
            showLabel: false,
            textcolor: D,
            fontsize: 12,
            bold: false,
            italic: false,
            horzLabelsAlign: "center",
            vertLabelsAlign: "top"
          },
          linetoolvertline: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            extendLine: true,
            showTime: true,
            showLabel: false,
            horzLabelsAlign: "center",
            vertLabelsAlign: "middle",
            textcolor: D,
            textOrientation: "vertical",
            fontsize: 14,
            bold: false,
            italic: false
          },
          linetoolcrossline: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            showPrice: true,
            showTime: true
          },
          linetoolfibtimezone: {
            horzLabelsAlign: "right",
            vertLabelsAlign: "bottom",
            showLabels: true,
            fillBackground: false,
            transparency: 80,
            trendline: {
              visible: true,
              color: "#808080",
              linewidth: 1,
              linestyle: I
            },
            level1: _(0, we, true),
            level2: _(1, D, true),
            level3: _(2, D, true),
            level4: _(3, D, true),
            level5: _(5, D, true),
            level6: _(8, D, true),
            level7: _(13, D, true),
            level8: _(21, D, true),
            level9: _(34, D, true),
            level10: _(55, D, true),
            level11: _(89, D, true)
          },
          linetooltext: {
            color: D,
            fontsize: 14,
            fillBackground: false,
            backgroundColor: "rgba(91, 133, 191, 0.3)",
            backgroundTransparency: 70,
            drawBorder: false,
            borderColor: "#667b8b",
            bold: false,
            italic: false,
            fixedSize: true,
            wordWrap: false,
            wordWrapWidth: 200
          },
          linetooltextabsolute: {
            color: D,
            fontsize: 14,
            fillBackground: false,
            backgroundColor: "rgba(155, 190, 213, 0.3)",
            backgroundTransparency: 70,
            drawBorder: false,
            borderColor: "#667b8b",
            bold: false,
            italic: false,
            fixedSize: false,
            wordWrap: false,
            wordWrapWidth: 200
          },
          linetoolballoon: {
            color: A,
            backgroundColor: se,
            borderColor: te,
            fontsize: 14,
            transparency: 30
          },
          linetoolcomment: {
            color: A,
            backgroundColor: D,
            borderColor: D,
            fontsize: 16,
            transparency: 0
          },
          linetoolbrush: {
            linecolor: H,
            linewidth: b,
            smooth: 5,
            fillBackground: false,
            backgroundColor: H,
            transparency: 50,
            leftEnd: v.Normal,
            rightEnd: v.Normal
          },
          linetoolhighlighter: {
            linecolor: J,
            smooth: 5,
            transparency: 80,
            width: 20
          },
          linetoolpolyline: {
            linecolor: H,
            linewidth: b,
            linestyle: x,
            fillBackground: true,
            backgroundColor: z,
            transparency: 80,
            filled: false
          },
          linetoolsignpost: {
            emoji: "🙂",
            showImage: false,
            plateColor: D,
            fontSize: 12,
            bold: false,
            italic: false
          },
          linetoolpath: {
            lineColor: D,
            lineWidth: b,
            lineStyle: x,
            leftEnd: v.Normal,
            rightEnd: v.Arrow
          },
          linetoolarrowmarkleft: {
            color: D,
            arrowColor: D,
            fontsize: 14,
            bold: false,
            italic: false,
            showLabel: true
          },
          linetoolarrowmarkup: {
            color: ce,
            arrowColor: ce,
            fontsize: 14,
            bold: false,
            italic: false,
            showLabel: true
          },
          linetoolarrowmarkright: {
            color: D,
            arrowColor: D,
            fontsize: 14,
            bold: false,
            italic: false,
            showLabel: true
          },
          linetoolarrowmarkdown: {
            color: Q,
            arrowColor: Q,
            fontsize: 14,
            bold: false,
            italic: false,
            showLabel: true
          },
          linetoolflagmark: {
            flagColor: D
          },
          linetoolpricelabel: {
            color: A,
            backgroundColor: D,
            borderColor: D,
            fontWeight: "bold",
            fontsize: 14,
            transparency: 0
          },
          linetoolarrowmarker: {
            backgroundColor: R,
            textColor: R,
            bold: true,
            italic: false,
            fontsize: 16,
            showLabel: true
          },
          linetoolrotatedrectangle: {
            color: ue,
            fillBackground: true,
            backgroundColor: _e,
            transparency: 50,
            linewidth: b
          },
          linetoolcircle: {
            color: me,
            backgroundColor: ge,
            fillBackground: true,
            linewidth: b,
            showLabel: false,
            textColor: me,
            fontSize: 14,
            bold: false,
            italic: false
          },
          linetoolellipse: {
            color: Z,
            fillBackground: true,
            backgroundColor: J,
            transparency: 50,
            linewidth: b,
            showLabel: false,
            textColor: Z,
            fontSize: 14,
            bold: false,
            italic: false
          },
          linetoolarc: {
            color: ne,
            fillBackground: true,
            backgroundColor: re,
            transparency: 80,
            linewidth: b
          },
          linetoolprediction: {
            linecolor: D,
            linewidth: b,
            sourceBackColor: D,
            sourceTextColor: A,
            sourceStrokeColor: D,
            targetStrokeColor: D,
            targetBackColor: D,
            targetTextColor: A,
            successBackground: ue,
            successTextColor: A,
            failureBackground: Z,
            failureTextColor: A,
            intermediateBackColor: "#ead289",
            intermediateTextColor: "#6d4d22",
            transparency: 10,
            centersColor: "#202020"
          },
          linetooltriangle: {
            color: ce,
            fillBackground: true,
            backgroundColor: he,
            transparency: 80,
            linewidth: b
          },
          linetoolcallout: {
            color: A,
            backgroundColor: j,
            transparency: 50,
            linewidth: b,
            fontsize: 14,
            bordercolor: U,
            bold: false,
            italic: false,
            wordWrap: false,
            wordWrapWidth: 200
          },
          linetoolparallelchannel: {
            linecolor: D,
            linewidth: b,
            linestyle: x,
            extendLeft: false,
            extendRight: false,
            fillBackground: true,
            backgroundColor: V,
            transparency: 20,
            showMidline: true,
            midlinecolor: D,
            midlinewidth: 1,
            midlinestyle: I,
            labelVisible: false,
            labelHorzAlign: "left",
            labelVertAlign: "bottom",
            labelTextColor: D,
            labelFontSize: 14,
            labelBold: false,
            labelItalic: false
          },
          linetoolelliottimpulse: {
            degree: 7,
            showWave: true,
            color: "#3d85c6",
            linewidth: b
          },
          linetoolelliotttriangle: {
            degree: 7,
            showWave: true,
            color: me,
            linewidth: b
          },
          linetoolelliotttriplecombo: {
            degree: 7,
            showWave: true,
            color: "#6aa84f",
            linewidth: b
          },
          linetoolelliottcorrection: {
            degree: 7,
            showWave: true,
            color: "#3d85c6",
            linewidth: b
          },
          linetoolelliottdoublecombo: {
            degree: 7,
            showWave: true,
            color: "#6aa84f",
            linewidth: b
          },
          linetoolbarspattern: {
            color: D,
            mode: u.Bars,
            mirrored: false,
            flipped: false
          },
          linetoolghostfeed: {
            averageHL: 20,
            variance: 50,
            candleStyle: {
              upColor: ae,
              downColor: q,
              drawWick: true,
              drawBorder: true,
              borderColor: "#378658",
              borderUpColor: ce,
              borderDownColor: Z,
              wickColor: we
            },
            transparency: 50
          },
          study: {
            inputs: {},
            styles: {},
            bands: {},
            graphics: {},
            ohlcPlots: {},
            palettes: {},
            filledAreasStyle: {},
            filledAreas: {},
            visible: true,
            showLegendValues: true,
            showLabelsOnPriceScale: true,
            precision: "default"
          },
          linetoolpitchfork: {
            fillBackground: true,
            transparency: 80,
            style: d.Original,
            median: {
              visible: true,
              color: Z,
              linewidth: b,
              linestyle: x
            },
            extendLines: false,
            level0: _(0.25, pe, false),
            level1: _(0.382, de, false),
            level2: _(0.5, ce, true),
            level3: _(0.618, ce, false),
            level4: _(0.75, H, false),
            level5: _(1, D, true),
            level6: _(1.5, ee, false),
            level7: _(1.75, ne, false),
            level8: _(2, $, false)
          },
          linetoolpitchfan: {
            fillBackground: true,
            transparency: 80,
            median: {
              visible: true,
              color: Z,
              linewidth: b,
              linestyle: x
            },
            level0: _(0.25, pe, false),
            level1: _(0.382, de, false),
            level2: _(0.5, H, true),
            level3: _(0.618, ce, false),
            level4: _(0.75, H, false),
            level5: _(1, D, true),
            level6: _(1.5, ee, false),
            level7: _(1.75, ne, false),
            level8: _(2, $, false)
          },
          linetoolgannfan: {
            linewidth: b,
            showLabels: true,
            fillBackground: true,
            transparency: 80,
            level1: Me(1, 8, me, true),
            level2: Me(1, 4, ce, true),
            level3: Me(1, 3, ue, true),
            level4: Me(1, 2, ce, true),
            level5: Me(1, 1, H, true),
            level6: Me(2, 1, D, true),
            level7: Me(3, 1, ee, true),
            level8: Me(4, 1, ne, true),
            level9: Me(8, 1, Z, true)
          },
          linetoolganncomplex: {
            fillBackground: false,
            arcsBackground: {
              fillBackground: true,
              transparency: 80
            },
            reverse: false,
            scaleRatio: "",
            showLabels: true,
            labelsStyle: {
              fontSize: 12,
              bold: false,
              italic: false
            },
            levels: [M(we, true), M(me, true), M(H, true), M(ue, true), M(ce, true), M(we, true)],
            fanlines: [Ie(N, false, b, 8, 1), Ie(Z, false, b, 5, 1), Ie(we, false, b, 4, 1), Ie(me, false, b, 3, 1), Ie(H, true, b, 2, 1), Ie(ue, true, b, 1, 1), Ie(ce, true, b, 1, 2), Ie(ce, false, b, 1, 3), Ie(D, false, b, 1, 4), Ie(O, false, b, 1, 5), Ie(N, false, b, 1, 8)],
            arcs: [Ie(me, true, b, 1, 0), Ie(me, true, b, 1, 1), Ie(me, true, b, 1.5, 0), Ie(H, true, b, 2, 0), Ie(H, true, b, 2, 1), Ie(ue, true, b, 3, 0), Ie(ue, true, b, 3, 1), Ie(ce, true, b, 4, 0), Ie(ce, true, b, 4, 1), Ie(D, true, b, 5, 0), Ie(D, true, b, 5, 1)]
          },
          linetoolgannfixed: {
            fillBackground: false,
            arcsBackground: {
              fillBackground: true,
              transparency: 80
            },
            reverse: false,
            levels: [M(we, true), M(me, true), M(H, true), M(ue, true), M(ce, true), M(we, true)],
            fanlines: [Ie(N, false, b, 8, 1), Ie(Z, false, b, 5, 1), Ie(we, false, b, 4, 1), Ie(me, false, b, 3, 1), Ie(H, true, b, 2, 1), Ie(ue, true, b, 1, 1), Ie(ce, true, b, 1, 2), Ie(ce, false, b, 1, 3), Ie(D, false, b, 1, 4), Ie(O, false, b, 1, 5), Ie(N, false, b, 1, 8)],
            arcs: [Ie(me, true, b, 1, 0), Ie(me, true, b, 1, 1), Ie(me, true, b, 1.5, 0), Ie(H, true, b, 2, 0), Ie(H, true, b, 2, 1), Ie(ue, true, b, 3, 0), Ie(ue, true, b, 3, 1), Ie(ce, true, b, 4, 0), Ie(ce, true, b, 4, 1), Ie(D, true, b, 5, 0), Ie(D, true, b, 5, 1)]
          },
          linetoolgannsquare: {
            color: "rgba(21, 56, 153, 0.8)",
            linewidth: b,
            linestyle: x,
            showTopLabels: true,
            showBottomLabels: true,
            showLeftLabels: true,
            showRightLabels: true,
            fillHorzBackground: true,
            horzTransparency: 80,
            fillVertBackground: true,
            vertTransparency: 80,
            reverse: false,
            fans: t(Se, false),
            hlevel1: i(0, we, true),
            hlevel2: i(0.25, me, true),
            hlevel3: i(0.382, H, true),
            hlevel4: i(0.5, ue, true),
            hlevel5: i(0.618, ce, true),
            hlevel6: i(0.75, D, true),
            hlevel7: i(1, we, true),
            vlevel1: i(0, we, true),
            vlevel2: i(0.25, me, true),
            vlevel3: i(0.382, H, true),
            vlevel4: i(0.5, ue, true),
            vlevel5: i(0.618, ce, true),
            vlevel6: i(0.75, D, true),
            vlevel7: i(1, we, true)
          },
          linetoolfibspeedresistancefan: {
            fillBackground: true,
            transparency: 80,
            grid: {
              color: "rgba(21, 56, 153, 0.8)",
              linewidth: 1,
              linestyle: x,
              visible: true
            },
            linewidth: b,
            linestyle: x,
            showTopLabels: true,
            showBottomLabels: true,
            showLeftLabels: true,
            showRightLabels: true,
            reverse: false,
            hlevel1: i(0, we, true),
            hlevel2: i(0.25, me, true),
            hlevel3: i(0.382, H, true),
            hlevel4: i(0.5, ue, true),
            hlevel5: i(0.618, ce, true),
            hlevel6: i(0.75, D, true),
            hlevel7: i(1, we, true),
            vlevel1: i(0, we, true),
            vlevel2: i(0.25, me, true),
            vlevel3: i(0.382, H, true),
            vlevel4: i(0.5, ue, true),
            vlevel5: i(0.618, ce, true),
            vlevel6: i(0.75, D, true),
            vlevel7: i(1, we, true)
          },
          linetoolfibretracement: {
            showCoeffs: true,
            showPrices: true,
            fillBackground: true,
            transparency: 80,
            extendLines: false,
            extendLinesLeft: false,
            horzLabelsAlign: "left",
            vertLabelsAlign: "middle",
            showText: true,
            horzTextAlign: "center",
            vertTextAlign: "middle",
            reverse: false,
            coeffsAsPercents: false,
            fibLevelsBasedOnLogScale: false,
            labelFontSize: 12,
            trendline: {
              visible: true,
              color: we,
              linewidth: b,
              linestyle: I
            },
            levelsStyle: {
              linewidth: b,
              linestyle: x
            },
            level1: i(0, we, true, true),
            level2: i(0.236, Z, true, true),
            level3: i(0.382, me, true, true),
            level4: i(0.5, ue, true, true),
            level5: i(0.618, ce, true, true),
            level6: i(0.786, H, true, true),
            level7: i(1, we, true, true),
            level8: i(1.618, D, true, true),
            level9: i(2.618, Z, true, true),
            level10: i(3.618, ee, true, true),
            level11: i(4.236, ne, true, true),
            level12: i(1.272, me, false, true),
            level13: i(1.414, Z, false, true),
            level16: i(2, ce, false, true),
            level14: i(2.272, me, false, true),
            level15: i(2.414, ue, false, true),
            level17: i(3, H, false, true),
            level18: i(3.272, we, false, true),
            level19: i(3.414, D, false, true),
            level20: i(4, Z, false, true),
            level21: i(4.272, ee, false, true),
            level22: i(4.414, ne, false, true),
            level23: i(4.618, me, false, true),
            level24: i(4.764, ce, false, true)
          },
          linetoolfibchannel: {
            showCoeffs: true,
            showPrices: true,
            fillBackground: true,
            transparency: 80,
            extendLeft: false,
            extendRight: false,
            horzLabelsAlign: "left",
            vertLabelsAlign: "middle",
            coeffsAsPercents: false,
            labelFontSize: 12,
            levelsStyle: {
              linewidth: b,
              linestyle: x
            },
            level1: i(0, we, true),
            level2: i(0.236, Z, true),
            level3: i(0.382, me, true),
            level4: i(0.5, ue, true),
            level5: i(0.618, ce, true),
            level6: i(0.786, H, true),
            level7: i(1, we, true),
            level8: i(1.618, D, true),
            level9: i(2.618, Z, true),
            level10: i(3.618, ee, true),
            level11: i(4.236, ne, true),
            level12: i(1.272, me, false),
            level13: i(1.414, Z, false),
            level16: i(2, ce, false),
            level14: i(2.272, me, false),
            level15: i(2.414, ue, false),
            level17: i(3, H, false),
            level18: i(3.272, we, false),
            level19: i(3.414, D, false),
            level20: i(4, Z, false),
            level21: i(4.272, ee, false),
            level22: i(4.414, ne, false),
            level23: i(4.618, me, false),
            level24: i(4.764, ce, false)
          },
          linetoolprojection: {
            showCoeffs: true,
            fillBackground: true,
            transparency: 80,
            color1: V,
            color2: ie,
            linewidth: b,
            trendline: {
              visible: true,
              color: Se,
              linestyle: x
            },
            level1: _(1, "#808080", true)
          },
          linetool5pointspattern: {
            color: D,
            textcolor: A,
            fillBackground: true,
            backgroundColor: D,
            fontsize: 12,
            bold: false,
            italic: false,
            transparency: 85,
            linewidth: b
          },
          linetoolcypherpattern: {
            color: D,
            textcolor: A,
            fillBackground: true,
            backgroundColor: D,
            fontsize: 12,
            bold: false,
            italic: false,
            transparency: 85,
            linewidth: b
          },
          linetooltrianglepattern: {
            color: F,
            textcolor: A,
            fillBackground: true,
            backgroundColor: F,
            fontsize: 12,
            bold: false,
            italic: false,
            transparency: 85,
            linewidth: b
          },
          linetoolabcd: {
            color: ce,
            textcolor: A,
            fontsize: 12,
            bold: false,
            italic: false,
            linewidth: b
          },
          linetoolthreedrivers: {
            color: F,
            textcolor: A,
            fillBackground: true,
            backgroundColor: "rgba(149, 40, 204, 0.5)",
            fontsize: 12,
            bold: false,
            italic: false,
            transparency: 50,
            linewidth: b
          },
          linetoolheadandshoulders: {
            color: ce,
            textcolor: A,
            fillBackground: true,
            backgroundColor: ce,
            fontsize: 12,
            bold: false,
            italic: false,
            transparency: 85,
            linewidth: b
          },
          linetoolfibwedge: {
            showCoeffs: true,
            fillBackground: true,
            transparency: 80,
            trendline: {
              visible: true,
              color: "#808080",
              linewidth: b,
              linestyle: x
            },
            level1: _(0.236, Z, true),
            level2: _(0.382, me, true),
            level3: _(0.5, ue, true),
            level4: _(0.618, ce, true),
            level5: _(0.786, H, true),
            level6: _(1, we, true),
            level7: _(1.618, D, false),
            level8: _(2.618, Z, false),
            level9: _(3.618, F, false),
            level10: _(4.236, ne, false),
            level11: _(4.618, ne, false)
          },
          linetoolfibcircles: {
            showCoeffs: true,
            fillBackground: true,
            transparency: 80,
            coeffsAsPercents: false,
            trendline: {
              visible: true,
              color: we,
              linewidth: b,
              linestyle: I
            },
            level1: _(0.236, Z, true),
            level2: _(0.382, me, true),
            level3: _(0.5, ce, true),
            level4: _(0.618, ue, true),
            level5: _(0.786, H, true),
            level6: _(1, we, true),
            level7: _(1.618, D, true),
            level8: _(2.618, ne, true),
            level9: _(3.618, D, true),
            level10: _(4.236, ne, true),
            level11: _(4.618, Z, true)
          },
          linetoolfibspeedresistancearcs: {
            showCoeffs: true,
            fillBackground: true,
            transparency: 80,
            fullCircles: false,
            trendline: {
              visible: true,
              color: we,
              linewidth: b,
              linestyle: I
            },
            level1: _(0.236, Z, true),
            level2: _(0.382, me, true),
            level3: _(0.5, ce, true),
            level4: _(0.618, ue, true),
            level5: _(0.786, H, true),
            level6: _(1, we, true),
            level7: _(1.618, D, true),
            level8: _(2.618, ne, true),
            level9: _(3.618, D, true),
            level10: _(4.236, ne, true),
            level11: _(4.618, Z, true)
          },
          linetooltrendbasedfibextension: {
            showCoeffs: true,
            showPrices: true,
            fillBackground: true,
            transparency: 80,
            extendLines: false,
            extendLinesLeft: false,
            horzLabelsAlign: "left",
            vertLabelsAlign: "middle",
            showText: true,
            horzTextAlign: "center",
            vertTextAlign: "middle",
            reverse: false,
            coeffsAsPercents: false,
            fibLevelsBasedOnLogScale: false,
            labelFontSize: 12,
            trendline: {
              visible: true,
              color: we,
              linewidth: b,
              linestyle: I
            },
            levelsStyle: {
              linewidth: b,
              linestyle: x
            },
            level1: i(0, we, true, true),
            level2: i(0.236, Z, true, true),
            level3: i(0.382, me, true, true),
            level4: i(0.5, ue, true, true),
            level5: i(0.618, ce, true, true),
            level6: i(0.786, H, true, true),
            level7: i(1, we, true, true),
            level8: i(1.618, D, true, true),
            level9: i(2.618, Z, true, true),
            level10: i(3.618, ee, true, true),
            level11: i(4.236, ne, true, true),
            level12: i(1.272, me, false, true),
            level13: i(1.414, Z, false, true),
            level16: i(2, ce, false, true),
            level14: i(2.272, me, false, true),
            level15: i(2.414, ue, false, true),
            level17: i(3, H, false, true),
            level18: i(3.272, we, false, true),
            level19: i(3.414, D, false, true),
            level20: i(4, Z, false, true),
            level21: i(4.272, ee, false, true),
            level22: i(4.414, ne, false, true),
            level23: i(4.618, me, false, true),
            level24: i(4.764, ce, false, true)
          },
          linetooltrendbasedfibtime: {
            showCoeffs: true,
            fillBackground: true,
            transparency: 80,
            horzLabelsAlign: "right",
            vertLabelsAlign: "bottom",
            trendline: {
              visible: true,
              color: we,
              linewidth: b,
              linestyle: I
            },
            level1: _(0, we, true),
            level2: _(0.382, Z, true),
            level3: _(0.5, de, false),
            level4: _(0.618, ue, true),
            level5: _(1, ce, true),
            level6: _(1.382, H, true),
            level7: _(1.618, we, true),
            level8: _(2, D, true),
            level9: _(2.382, ne, true),
            level10: _(2.618, ee, true),
            level11: _(3, F, true)
          },
          linetoolschiffpitchfork: {
            fillBackground: true,
            transparency: 80,
            style: d.Schiff,
            median: {
              visible: true,
              color: Z,
              linewidth: b,
              linestyle: x
            },
            extendLines: false,
            level0: _(0.25, pe, false),
            level1: _(0.382, de, false),
            level2: _(0.5, ce, true),
            level3: _(0.618, ce, false),
            level4: _(0.75, H, false),
            level5: _(1, D, true),
            level6: _(1.5, ee, false),
            level7: _(1.75, ne, false),
            level8: _(2, $, false)
          },
          linetoolschiffpitchfork2: {
            fillBackground: true,
            transparency: 80,
            style: d.Schiff2,
            median: {
              visible: true,
              color: Z,
              linewidth: b,
              linestyle: x
            },
            extendLines: false,
            level0: _(0.25, pe, false),
            level1: _(0.382, de, false),
            level2: _(0.5, ce, true),
            level3: _(0.618, ce, false),
            level4: _(0.75, H, false),
            level5: _(1, D, true),
            level6: _(1.5, ee, false),
            level7: _(1.75, ne, false),
            level8: _(2, $, false)
          },
          linetoolinsidepitchfork: {
            fillBackground: true,
            transparency: 80,
            style: d.Inside,
            median: {
              visible: true,
              color: Z,
              linewidth: b,
              linestyle: x
            },
            extendLines: false,
            level0: _(0.25, pe, false),
            level1: _(0.382, de, false),
            level2: _(0.5, ce, true),
            level3: _(0.618, ce, false),
            level4: _(0.75, H, false),
            level5: _(1, D, true),
            level6: _(1.5, ee, false),
            level7: _(1.75, ne, false),
            level8: _(2, $, false)
          },
          linetoolregressiontrend: {
            linewidth: 1,
            linestyle: x,
            styles: {
              upLine: {
                display: m.All,
                color: E,
                linestyle: x,
                linewidth: b
              },
              downLine: {
                display: m.All,
                color: E,
                linestyle: x,
                linewidth: b
              },
              baseLine: {
                display: m.All,
                color: X,
                linestyle: I,
                linewidth: 1
              },
              extendLines: false,
              showPearsons: true,
              transparency: 70
            }
          }
        };
        Ae(TradingView.defaultProperties.chartproperties);
        ke();
      }
      if (TradingView.defaultProperties["study_MA@tv-basicstudies"] === undefined) {
        TradingView.defaultProperties["study_MA@tv-basicstudies"] = {
          description: "Moving Average",
          shortDescription: "MA",
          inputs: {
            length: 9,
            source: "close"
          },
          styles: {
            MovAvg: {
              display: m.All,
              color: D,
              linestyle: x,
              linewidth: 1,
              plottype: p.Line,
              histogramBase: 0,
              title: "MA"
            }
          }
        };
      }
      if (TradingView.defaultProperties["study_PivotPointsHighLow@tv-basicstudies"] === undefined) {
        TradingView.defaultProperties["study_PivotPointsHighLow@tv-basicstudies"] = {
          fontsize: 10,
          borderColor: D,
          backColor: k,
          textColor: Ce
        };
      }
      if (TradingView.defaultProperties["study_PivotPointsStandard@tv-basicstudies"] === undefined) {
        var De = true;
        TradingView.defaultProperties["study_PivotPointsStandard@tv-basicstudies"] = {
          _hardCodedDefaultsVersion: 1,
          fontsize: 11,
          levelsStyle: {
            showLabels: true,
            visibility: {
              P: De,
              "S1/R1": De,
              "S2/R2": De,
              "S3/R3": De,
              "S4/R4": De,
              "S5/R5": De
            },
            colors: {
              P: fe,
              "S1/R1": fe,
              "S2/R2": fe,
              "S3/R3": fe,
              "S4/R4": fe,
              "S5/R5": fe
            },
            widths: {
              P: 1,
              "S1/R1": 1,
              "S2/R2": 1,
              "S3/R3": 1,
              "S4/R4": 1,
              "S5/R5": 1
            }
          }
        };
      }
      if (TradingView.defaultProperties["study_ZigZag@tv-basicstudies"] === undefined) {
        TradingView.defaultProperties["study_ZigZag@tv-basicstudies"] = {
          color: D,
          linewidth: 2
        };
      }
      const Ee = {
        styles: {
          splitByBlocks: false
        },
        graphics: {
          tpoLevels: {
            tpo: {
              tpoPoc: {
                color: ""
              },
              tpoPoorHigh: {
                color: ""
              },
              tpoPoorLow: {
                color: ""
              },
              tpoSingleprints: {
                color: ""
              },
              tpoVah: {
                color: ""
              },
              tpoVal: {
                color: ""
              },
              volumePoc: {
                color: ""
              },
              volumeVah: {
                color: ""
              },
              volumeVal: {
                color: ""
              }
            }
          },
          tpoVolumeRows: {
            tpo: {
              valuesColor: "",
              colors: {
                nonVa: "",
                va: ""
              }
            }
          }
        }
      };
      function Be(e) {
        const t = {
          styles: {
            developingPoc: {
              color: ""
            },
            developingVAHigh: {
              color: ""
            },
            developingVALow: {
              color: ""
            }
          },
          graphics: {
            horizlines: {
              pocLines: {
                color: ""
              },
              vahLines: {
                color: ""
              },
              valLines: {
                color: ""
              }
            },
            hhists: {
              histBars2: {
                colors: ["", ""],
                valuesColor: ""
              },
              histBarsVA: {
                colors: ["", ""],
                valuesColor: ""
              }
            }
          }
        };
        if (e) {
          t.graphics.polygons = {
            histBoxBg: {
              color: ""
            }
          };
        }
        return t;
      }
      if (TradingView.defaultProperties["study_TPOPeriodic@tv-volumebyprice"] === undefined) {
        TradingView.defaultProperties["study_TPOPeriodic@tv-volumebyprice"] = Ee;
      }
      if (TradingView.defaultProperties["study_TPOSessions@tv-volumebyprice"] === undefined) {
        TradingView.defaultProperties["study_TPOSessions@tv-volumebyprice"] = Ee;
      }
      if (TradingView.defaultProperties["study_VbPSessions@tv-volumebyprice"] === undefined) {
        TradingView.defaultProperties["study_VbPSessions@tv-volumebyprice"] = Be(true);
      }
      if (TradingView.defaultProperties["study_VbPSessionsRoughDetailed@tv-volumebyprice"] === undefined) {
        TradingView.defaultProperties["study_VbPSessionsRoughDetailed@tv-volumebyprice"] = Be(true);
      }
      if (TradingView.defaultProperties["study_VbPPeriodic@tv-volumebyprice"] === undefined) {
        TradingView.defaultProperties["study_VbPPeriodic@tv-volumebyprice"] = Be(true);
      }
      if (TradingView.defaultProperties["study_VbPVisible@tv-volumebyprice"] === undefined) {
        TradingView.defaultProperties["study_VbPVisible@tv-volumebyprice"] = Be(false);
      }
      const Ve = {
        styles: {
          developingPoc: {
            color: ""
          },
          developingVAHigh: {
            color: ""
          },
          developingVALow: {
            color: ""
          }
        },
        graphics: {
          hhists: {
            histBars2: {
              colors: ["", ""],
              valuesColor: ""
            },
            histBarsVA: {
              colors: ["", ""],
              valuesColor: ""
            }
          },
          horizlines: {
            pocLines: {
              color: ""
            },
            vahLines: {
              color: ""
            },
            valLines: {
              color: ""
            }
          },
          polygons: {
            histBoxBg: {
              color: ""
            }
          }
        }
      };
      if (TradingView.defaultProperties["study_VbPFixed@tv-volumebyprice"] === undefined) {
        TradingView.defaultProperties["study_VbPFixed@tv-volumebyprice"] = Ve;
      }
      if (TradingView.defaultProperties["study_VbPFixed@tv-basicstudies"] === undefined) {
        TradingView.defaultProperties["study_VbPFixed@tv-basicstudies"] = Ve;
      }
      if (TradingView.defaultProperties.linetoolanchoredvp === undefined) {
        TradingView.defaultProperties.linetoolanchoredvp = Be(true);
      }
      if (TradingView.defaultProperties["study_VbPAutoAnchored@tv-volumebyprice"] === undefined) {
        TradingView.defaultProperties["study_VbPAutoAnchored@tv-volumebyprice"] = Be(true);
      }
      if (TradingView.defaultProperties["study_ElliottWave@tv-basicstudies"] === undefined) {
        TradingView.defaultProperties["study_ElliottWave@tv-basicstudies"] = {
          inputs: {},
          level0: t(G, false),
          level1: t("#008000", false),
          level2: t("#0000ff", false),
          level3: t("#ff00ff", false),
          level4: t("#0080ff", true),
          level5: t(G, true),
          level6: t("#008000", true),
          level7: t("#0000ff", true),
          level8: t("#ff00ff", true)
        };
      }
      if (TradingView.defaultProperties["study_LinearRegression@tv-basicstudies"] === undefined) {
        TradingView.defaultProperties["study_LinearRegression@tv-basicstudies"] = {
          styles: {
            upLine: {
              display: m.All,
              color: E,
              linestyle: x,
              linewidth: 1
            },
            downLine: {
              display: m.All,
              color: E,
              linestyle: x,
              linewidth: 1
            },
            baseLine: {
              display: m.All,
              color: X,
              linestyle: x,
              linewidth: 1
            },
            extendLines: true,
            showPearsons: true,
            backgroundColor: "rgba(153, 21, 21, 0.3)",
            transparency: 70
          }
        };
      }
      if (TradingView.defaultProperties["study_Compare@tv-basicstudies"] === undefined) {
        TradingView.defaultProperties["study_Compare@tv-basicstudies"] = {
          minTick: "default"
        };
      }
      if (TradingView.defaultProperties["study_Overlay@tv-basicstudies"] === undefined) {
        TradingView.defaultProperties["study_Overlay@tv-basicstudies"] = {
          style: h.STYLE_LINE,
          allowExtendTimeScale: false,
          showPriceLine: false,
          minTick: "default",
          candleStyle: {
            upColor: le,
            downColor: oe,
            drawWick: true,
            drawBorder: true,
            drawBody: true,
            borderColor: "#378658",
            borderUpColor: le,
            borderDownColor: oe,
            wickColor: "#737375",
            wickUpColor: le,
            wickDownColor: oe,
            barColorsOnPrevClose: false
          },
          hollowCandleStyle: {
            upColor: le,
            downColor: oe,
            drawWick: true,
            drawBorder: true,
            drawBody: true,
            borderColor: "#378658",
            borderUpColor: le,
            borderDownColor: oe,
            wickColor: "#737375",
            wickUpColor: le,
            wickDownColor: oe,
            barColorsOnPrevClose: false
          },
          barStyle: {
            upColor: le,
            downColor: oe,
            barColorsOnPrevClose: false,
            dontDrawOpen: false,
            thinBars: true
          },
          lineStyle: {
            color: ye,
            linestyle: x,
            linewidth: 2,
            priceSource: "close"
          },
          lineWithMarkersStyle: {
            color: ye,
            linestyle: x,
            linewidth: 2,
            priceSource: "close"
          },
          steplineStyle: {
            color: ye,
            linestyle: x,
            linewidth: 2,
            priceSource: "close"
          },
          areaStyle: {
            color1: D,
            color2: D,
            linecolor: D,
            linestyle: x,
            linewidth: 2,
            priceSource: "close",
            transparency: 95
          },
          baselineStyle: {
            baselineColor: be,
            topFillColor1: xe,
            topFillColor2: xe,
            bottomFillColor1: Y,
            bottomFillColor2: Y,
            topLineColor: Te,
            bottomLineColor: K,
            topLineWidth: 2,
            bottomLineWidth: 2,
            priceSource: "close",
            transparency: 50,
            baseLevelPercentage: 50
          },
          hiloStyle: {
            color: D,
            showBorders: true,
            borderColor: D,
            showLabels: true,
            labelColor: D,
            drawBody: true
          },
          columnStyle: {
            upColor: n(ce, 50),
            downColor: n(Z, 50),
            barColorsOnPrevClose: true,
            priceSource: "close",
            baselinePosition: "bottom"
          },
          hlcAreaStyle: {
            highLineColor: ce,
            highLineStyle: x,
            highLineWidth: 2,
            lowLineColor: Z,
            lowLineStyle: x,
            lowLineWidth: 2,
            closeLineColor: be,
            closeLineStyle: x,
            closeLineWidth: 2,
            highCloseFillColor: he,
            closeLowFillColor: J
          },
          hlcBarsStyle: {
            color: D,
            barColorsOnPrevClose: false,
            thinBars: true
          },
          styles: {
            open: {
              display: m.All,
              color: G,
              linestyle: x,
              linewidth: 1,
              plottype: p.Line,
              histogramBase: 0
            },
            high: {
              display: m.All,
              color: G,
              linestyle: x,
              linewidth: 1,
              plottype: p.Line,
              histogramBase: 0
            },
            low: {
              display: m.All,
              color: G,
              linestyle: x,
              linewidth: 1,
              plottype: p.Line,
              histogramBase: 0
            },
            close: {
              display: m.All,
              color: G,
              linestyle: x,
              linewidth: 1,
              plottype: p.Line,
              histogramBase: 0
            }
          }
        };
      }
      for (var Re = e.split("."), Ne = TradingView.defaultProperties, Oe = 0; Oe < Re.length; Oe++) {
        Ne &&= Ne[Re[Oe]];
      }
      if (Ne != null) {
        return TradingView.clone(Ne);
      } else {
        return {};
      }
    }
    function Me(e, t, i, s, o) {
      if (s) {
        for (var n in s) {
          var r = n.split(".");
          var a = c(r[0]);
          var l = o !== undefined && o === r[0];
          if (r.length !== 0 && l) {
            a = c((r = r.slice(1))[0]);
          }
          if (r.length !== 0 && e.hasOwnProperty(a)) {
            if (!h(e, r, s[n])) {
              d(n);
            }
          } else if (l) {
            d(n);
          }
        }
      }
      function c(e) {
        if (t && t[e]) {
          return t[e];
        } else {
          return e;
        }
      }
      function h(e, t, i, s) {
        var o = c(t[0]);
        return !!e.hasOwnProperty(o) && (t.length > 1 ? h(e[o], t.slice(1), i) : (e[o] && e[o].setValue ? e[o].setValue(i) : e[o] = i, true));
      }
      function d(e) {
        if (!i) {
          M.logWarn("Path `" + e + "` does not exist.");
        }
      }
    }
    function Ae(e, t, i, s) {
      if (window.__defaultsOverrides) {
        Me(e, t, i, window.__defaultsOverrides, s);
      }
    }
    function Le(e, t) {
      if (window.__settingsOverrides) {
        Me(e, null, false, window.__settingsOverrides, t);
      }
    }
    function ke() {
      var e = /^linetool.+/;
      Object.keys(TradingView.defaultProperties).forEach(function (t) {
        if (e.test(t)) {
          Ae(TradingView.defaultProperties[t], null, false, t);
        }
      });
    }
    function De(e, t) {
      if (t) {
        return function (e, t) {
          var i = Ie(e);
          if (!window._UNIT_TESTS) {
            var s = TradingView.clone(TVSettings.getJSON(e, null));
            if (function (e) {
              var t = new Set(["linetoolregressiontrend"]);
              return e.startsWith("study_") || t.has(e);
            }(e) && s && function (e) {
              if (!e) {
                return false;
              }
              e = e.toString();
              var t = new RegExp("\\d+").exec(e);
              var i = t !== null && t[0] === e;
              return i;
            }(s.version)) {
              var o = s.inputs;
              var n = t.updateStudyInputs(s.id, s.version, "last", o, null);
              s.inputs = n;
              s = t.updateStudyState(s, s);
            }
            TradingView.merge(i, s);
            Le(i, e);
          }
          return i;
        }(e, t);
      } else {
        return function (e) {
          var t = Ie(e);
          if (!window._UNIT_TESTS) {
            var i = TradingView.clone(TVSettings.getJSON(e, null));
            if (i) {
              TradingView.merge(t, i);
              const s = e.split(".");
              Le(t, s[1] === undefined ? e : s[1]);
            }
          }
          return t;
        }(e);
      }
    }
    De.create = function (e, t) {
      if (t) {
        var i = Ie(e);
        TradingView.defaultProperties[e] = TradingView.merge(t, i);
      }
    };
    De.remove = function (e) {
      TradingView.defaultProperties[e] = undefined;
    };
    TradingView.saveDefaults = function (e, t) {
      if (t === undefined) {
        TVSettings.remove(e);
      } else {
        TVSettings.setJSON(e, t);
      }
    };
    TradingView.factoryDefaults = Ie;
    window.applyDefaultOverridesToLinetools = ke;
    window.applyDefaultsOverrides = Ae;
    window.applyPropertiesOverrides = Me;
    window.defaults = De;
    t.applyDefaultOverridesToLinetools = ke;
    t.applyDefaultsOverrides = Ae;
    t.applyPropertiesOverrides = Me;
    t.defaults = De;
    t.factoryDefaults = Ie;
    t.saveDefaults = TradingView.saveDefaults;
    t.createDefaults = De.create;
    t.removeDefaults = De.remove;
  },
  928: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      DrawingSyncMode: () => s,
      SelectPointMode: () => o,
      activePointSelectionMode: () => Z,
      alignTo45Degrees: () => xe,
      barTimesUnderCursor: () => J,
      beenSetLineToolLastPoint: () => N,
      cancelLineTool: () => se,
      cancelledLineTool: () => R,
      changeLineStyle: () => _e,
      changeLineTool: () => ce,
      changedLineStyle: () => q,
      changedLineTool: () => z,
      continueLineTool: () => ie,
      continuedLineTool: () => V,
      copiedLineTool: () => $,
      copyLineTool: () => pe,
      createLineTool: () => te,
      createdLineTool: () => B,
      crosshairLock: () => P,
      cursorTool: () => A,
      drawOnAllCharts: () => Ie,
      drawOnAllChartsMode: () => Me,
      emojiTool: () => I,
      finishChangingLineTool: () => he,
      finishLineTool: () => ue,
      finishMovingLineTool: () => ae,
      finishedChangingLineTool: () => U,
      finishedLineTool: () => G,
      finishedMovingLineTool: () => W,
      hideAllDrawings: () => we,
      hideAllIndicators: () => Ce,
      hideMarksOnBars: () => Te,
      iconTool: () => x,
      init: () => ve,
      isDirectionalMovementActive: () => E,
      isStudyEditingNow: () => X,
      isToolCreatingNow: () => L,
      isToolEditingNow: () => k,
      isToolMovingNow: () => D,
      lockDrawings: () => Pe,
      moveLineTool: () => re,
      movedLineTool: () => F,
      properties: () => be,
      removeLineTool: () => de,
      removedLineTool: () => j,
      resetToCursor: () => f,
      restoreLineTool: () => me,
      restoreLineToolState: () => ge,
      restoredLineTool: () => K,
      restoredLineToolState: () => Y,
      runOnDrawingStateReady: () => Se,
      setLineToolLastPoint: () => oe,
      startChangingLineTool: () => le,
      startMovingLineTool: () => ne,
      startedChangingLineTool: () => H,
      startedMovingLineTool: () => O,
      stickerTool: () => M,
      tool: () => T,
      toolIsCursor: () => p,
      toolIsDemonstration: () => m,
      toolIsMeasure: () => g
    });
    var s;
    var o;
    var n = i(50151);
    var r = i(17625);
    var a = i(32679);
    var l = i(64147);
    var c = i(91676);
    var h = i(52033);
    var d = i(56840);
    var u = i(76422);
    (function (e) {
      e[e.Layout = 1] = "Layout";
      e[e.Global = 2] = "Global";
    })(s ||= {});
    (function (e) {
      e[e.None = 0] = "None";
      e[e.Replay = 1] = "Replay";
      e[e.Study = 2] = "Study";
    })(o ||= {});
    const _ = new Set(["cursor", "arrow", "dot", "performance", "demonstration"]);
    function p(e) {
      return _.has(e);
    }
    function m(e) {
      return e === "demonstration";
    }
    function g(e) {
      return e === "measure";
    }
    function f(e = false) {
      if (!e && y) {
        if (y.childs().stayInDrawingMode.value()) {
          return;
        }
      }
      T.setValue(A.value());
    }
    let y = null;
    let v = null;
    let S = null;
    let b = null;
    let w = null;
    let C = null;
    const P = new c.WatchedObject(null);
    const T = new l.WatchedValue();
    const x = new l.WatchedValue();
    const I = new l.WatchedValue();
    const M = new l.WatchedValue();
    const A = new l.WatchedValue();
    const L = new l.WatchedValue(false);
    const k = new l.WatchedValue(false);
    const D = new l.WatchedValue(false);
    const E = new l.WatchedValue(false);
    const B = new h.Delegate();
    const V = new h.Delegate();
    const R = new h.Delegate();
    const N = new h.Delegate();
    const O = new h.Delegate();
    const F = new h.Delegate();
    const W = new h.Delegate();
    const H = new h.Delegate();
    const z = new h.Delegate();
    const U = new h.Delegate();
    const j = new h.Delegate();
    const G = new h.Delegate();
    const q = new h.Delegate();
    const $ = new h.Delegate();
    const K = new h.Delegate();
    const Y = new h.Delegate();
    const Z = new l.WatchedValue(o.None);
    const X = new l.WatchedValue(false);
    const J = new Map();
    function Q(e, t) {
      const i = t || {
        value: false
      };
      return t => {
        if (!i.value) {
          i.value = true;
          e.fire(t);
          i.value = false;
        }
      };
    }
    const ee = {
      value: false
    };
    const te = Q(B, ee);
    const ie = Q(V, ee);
    const se = Q(R, ee);
    const oe = Q(N, ee);
    const ne = Q(O);
    const re = Q(F);
    const ae = Q(W);
    const le = Q(H);
    const ce = Q(z);
    const he = Q(U);
    const de = Q(j);
    const ue = Q(G);
    const _e = Q(q, ee);
    const pe = Q($, ee);
    const me = Q(K);
    const ge = Q(Y);
    let fe = false;
    let ye = [];
    function ve() {
      if (fe) {
        return;
      }
      const e = d.getValue("chart.cursorPreference", "cursor");
      T.setValue(p(e) ? e : "cursor");
      T.subscribe(e => p(e) && A.setValue(e), {
        callWithLast: true
      });
      A.subscribe(e => {
        if (e && e !== "performance" && !m(e)) {
          d.setValue("chart.cursorPreference", e);
        }
      });
      y = new a.DefaultProperty({
        defaultName: "drawings"
      });
      v = (0, r.createPrimitiveProperty)(false);
      S = (0, r.createPrimitiveProperty)(false);
      b = (0, r.createPrimitiveProperty)(false);
      w = (0, r.createPrimitiveProperty)(!d.getBool("BarsMarksContainer.visibile", true));
      C = (0, r.createPrimitiveProperty)(false);
      T.subscribe(e => {
        (0, u.emit)("onSelectedLineToolChanged");
      });
      fe = true;
      ye.forEach(e => e());
      ye = [];
    }
    function Se(e) {
      if (fe) {
        e();
      } else {
        ye.push(e);
      }
    }
    function be() {
      return (0, n.ensureNotNull)(y);
    }
    function we() {
      return (0, n.ensureNotNull)(v);
    }
    function Ce() {
      return (0, n.ensureNotNull)(S);
    }
    function Pe() {
      return (0, n.ensureNotNull)(b);
    }
    function Te() {
      return (0, n.ensureNotNull)(w);
    }
    function xe() {
      return (0, n.ensureNotNull)(C);
    }
    function Ie() {
      return be().childs().drawOnAllCharts;
    }
    function Me() {
      return be().childs().drawOnAllChartsMode;
    }
  },
  28331: (e, t, i) => {
    "use strict";

    i.d(t, {
      EnvironmentState: () => o
    });
    var s = i(49483);
    class o {
      constructor(e, t = false) {
        this._shift = false;
        this._mod = false;
        this._alt = false;
        if (e !== undefined) {
          this._shift = Boolean(e.shiftKey);
          this._mod = Boolean((0, s.isMac)() ? e.metaKey : e.ctrlKey);
          this._alt = Boolean(e.altKey);
        }
        this._isApiEvent = t;
      }
      shift() {
        return this._shift;
      }
      mod() {
        return this._mod;
      }
      alt() {
        return this._alt;
      }
      shiftOnly() {
        return this._shift && !this._mod && !this._alt;
      }
      modOnly() {
        return this._mod && !this._shift && !this._alt;
      }
      altOnly() {
        return this._alt && !this._shift && !this._mod;
      }
      modShift() {
        return this._shift && this._mod && !this._alt;
      }
      isApiEvent() {
        return this._isApiEvent;
      }
      static create(e = false, t = false, i = false) {
        return new o({
          shiftKey: e,
          ctrlKey: t,
          metaKey: t,
          altKey: i
        });
      }
    }
  },
  73698: (e, t, i) => {
    "use strict";

    i.d(t, {
      decodeExtendedSymbol: () => l,
      encodeExtendedSymbolOrGetSimpleSymbolString: () => r,
      isEncodedExtendedSymbol: () => a,
      isStudySymbol: () => n
    });
    function s(e) {
      return "=" + JSON.stringify(o(e));
    }
    function o(e) {
      return Object.keys(e).sort().reduce((t, i) => {
        if (Object.prototype.toString.call(e[i]) === "[object Object]") {
          t[i] = o(e[i]);
        } else {
          t[i] = e[i];
        }
        return t;
      }, {});
    }
    function n(e) {
      return Boolean(e.inputs);
    }
    function r(e) {
      return s(e);
    }
    function a(e) {
      return e[0] === "=";
    }
    function l(e) {
      if (!a(e)) {
        return {
          symbol: e
        };
      }
      try {
        return JSON.parse(e.slice(1));
      } catch (t) {
        return {
          symbol: e
        };
      }
    }
  },
  32956: (e, t, i) => {
    "use strict";

    function s(e) {
      return o(e, 2);
    }
    function o(e, t = 2) {
      const i = e.toString();
      return "0".repeat(Math.max(0, t - i.length)) + i;
    }
    i.d(t, {
      addLeadingZero: () => s,
      addLeadingZeros: () => o
    });
  },
  24526: (e, t, i) => {
    "use strict";

    i.d(t, {
      customFormatters: () => s
    });
    const s = {
      dateFormatter: null,
      timeFormatter: null,
      tickMarkFormatter: null,
      priceFormatterFactory: null,
      studyFormatterFactory: null
    };
  },
  47462: (e, t, i) => {
    "use strict";

    i.d(t, {
      availableDateFormats: () => v,
      dateFormatFunctions: () => f,
      defaultDateFormat: () => S,
      getDateFormatWithWeekday: () => y
    });
    var s = i(11542);
    var o = i(28865);
    var n = i(58683);
    const r = {
      1: () => s.t(null, undefined, i(62310)),
      2: () => s.t(null, undefined, i(2507)),
      3: () => s.t(null, undefined, i(92767)),
      4: () => s.t(null, undefined, i(27072)),
      5: () => s.t(null, {
        context: "short"
      }, i(13132)),
      6: () => s.t(null, undefined, i(429)),
      7: () => s.t(null, undefined, i(53786)),
      8: () => s.t(null, undefined, i(46450)),
      9: () => s.t(null, undefined, i(6816)),
      10: () => s.t(null, undefined, i(12179)),
      11: () => s.t(null, undefined, i(26899)),
      12: () => s.t(null, undefined, i(32084))
    };
    const a = {
      1: () => s.t(null, undefined, i(14568)),
      2: () => s.t(null, undefined, i(13534)),
      3: () => s.t(null, undefined, i(14530)),
      4: () => s.t(null, undefined, i(3762))
    };
    const l = (e, t) => (t ? e.getMonth() : e.getUTCMonth()) + 1;
    const c = (e, t) => t ? e.getFullYear() : e.getUTCFullYear();
    const h = e => e.toLocaleDateString(window.language ? (0, o.getIsoLanguageCodeFromLanguage)(window.language) : undefined, {
      weekday: "short",
      timeZone: "UTC"
    });
    const d = (e, t) => a[((e, t) => Math.floor((l(e, t) - 1) / 3) + 1)(e, t)]();
    const u = (e, t) => (0, n.numberToStringWithLeadingZero)(((e, t) => t ? e.getDate() : e.getUTCDate())(e, t), 2);
    const _ = (e, t) => r[l(e, t)]();
    const p = (e, t) => (0, n.numberToStringWithLeadingZero)(l(e, t), 2);
    const m = (e, t) => (0, n.numberToStringWithLeadingZero)(c(e, t) % 100, 2);
    const g = (e, t) => (0, n.numberToStringWithLeadingZero)(c(e, t), 4);
    const f = {
      "qq 'yy": (e, t) => `${d(e, t)} '${m(e, t)}`,
      "qq yyyy": (e, t) => `${d(e, t)} ${g(e, t)}`,
      "dd MMM 'yy": (e, t) => `${u(e, t)} ${_(e, t)} '${m(e, t)}`,
      "MMM 'yy": (e, t) => `${_(e, t)} '${m(e, t)}`,
      "MMM dd, yyyy": (e, t) => `${_(e, t)} ${u(e, t)}, ${g(e, t)}`,
      "MMM yyyy": (e, t) => `${_(e, t)} ${g(e, t)}`,
      "MMM dd": (e, t) => `${_(e, t)} ${u(e, t)}`,
      "dd MMM": (e, t) => `${u(e, t)} ${_(e, t)}`,
      "yyyy-MM-dd": (e, t) => `${g(e, t)}-${p(e, t)}-${u(e, t)}`,
      "yy-MM-dd": (e, t) => `${m(e, t)}-${p(e, t)}-${u(e, t)}`,
      "yy/MM/dd": (e, t) => `${m(e, t)}/${p(e, t)}/${u(e, t)}`,
      "yyyy/MM/dd": (e, t) => `${g(e, t)}/${p(e, t)}/${u(e, t)}`,
      "dd-MM-yyyy": (e, t) => `${u(e, t)}-${p(e, t)}-${g(e, t)}`,
      "dd-MM-yy": (e, t) => `${u(e, t)}-${p(e, t)}-${m(e, t)}`,
      "dd/MM/yy": (e, t) => `${u(e, t)}/${p(e, t)}/${m(e, t)}`,
      "dd/MM/yyyy": (e, t) => `${u(e, t)}/${p(e, t)}/${g(e, t)}`,
      "MM/dd/yy": (e, t) => `${p(e, t)}/${u(e, t)}/${m(e, t)}`,
      "MM/dd/yyyy": (e, t) => `${p(e, t)}/${u(e, t)}/${g(e, t)}`
    };
    function y(e) {
      if (window.language === "ja") {
        return (t, i) => `${f[e](t, i)} (${h(t)})`;
      } else {
        return (t, i) => `${h(t)} ${f[e](t, i)}`;
      }
    }
    const v = Object.keys(f);
    const S = () => ["ja", "ko", "zh", "zh_TW"].indexOf(window.language || "") !== -1 ? "yyyy-MM-dd" : "dd MMM 'yy";
  },
  82826: (e, t, i) => {
    "use strict";

    i.d(t, {
      DateFormatter: () => n
    });
    var s = i(24526);
    var o = i(47462);
    class n {
      constructor(e = "yyyy-MM-dd", t = false) {
        this._dateFormatFunc = t ? (0, o.getDateFormatWithWeekday)(e) : o.dateFormatFunctions[e];
      }
      format(e) {
        if (s.customFormatters && s.customFormatters.dateFormatter) {
          return s.customFormatters.dateFormatter.format(e);
        } else {
          return this._dateFormatFunc(e, false);
        }
      }
      formatLocal(e) {
        if (s.customFormatters.dateFormatter) {
          if (s.customFormatters.dateFormatter.formatLocal) {
            return s.customFormatters.dateFormatter.formatLocal(e);
          } else {
            return s.customFormatters.dateFormatter.format(e);
          }
        } else {
          return this._dateFormatFunc(e, true);
        }
      }
      parse(e) {
        if (e === "") {
          return {
            res: false
          };
        }
        let t = e;
        if (s.customFormatters && s.customFormatters.dateFormatter && !s.customFormatters.dateFormatter.parse) {
          console.warn("You need to provide a `parse` function as part of `dateFormatter`");
        }
        if (s.customFormatters && s.customFormatters.dateFormatter && s.customFormatters.dateFormatter.parse) {
          t = String(s.customFormatters.dateFormatter.parse(e));
        }
        return {
          res: true,
          value: t
        };
      }
    }
  },
  52388: (e, t, i) => {
    "use strict";

    i.d(t, {
      DateTimeFormatter: () => r
    });
    var s = i(15344);
    var o = i(82826);
    const n = {
      dateFormat: "yyyy-MM-dd",
      withWeekday: false,
      timeFormat: s.hourMinuteSecondFormat,
      dateTimeSeparator: " "
    };
    class r {
      constructor(e = {}) {
        const t = Object.assign({}, n, e);
        this._dateFormatter = new o.DateFormatter(t.dateFormat, t.withWeekday);
        this._timeFormatter = new s.TimeFormatter(t.timeFormat);
        this._separator = t.dateTimeSeparator;
      }
      format(e, t) {
        const i = t?.dateTimeSeparator ?? this._separator;
        return `${this._dateFormatter.format(e)}${i}${this._timeFormatter.format(e)}`;
      }
      formatLocal(e, t) {
        const i = t?.dateTimeSeparator ?? this._separator;
        return `${this._dateFormatter.formatLocal(e)}${i}${this._timeFormatter.formatLocal(e)}`;
      }
    }
  },
  58683: (e, t, i) => {
    "use strict";

    i.d(t, {
      numDependencyFormatter: () => n,
      numberToStringWithLeadingZero: () => o
    });
    var s = i(37265);
    function o(e, t) {
      if (!(0, s.isNumber)(e)) {
        return "n/a";
      }
      if (!(0, s.isInteger)(t)) {
        throw new TypeError("invalid length");
      }
      if (t < 0 || t > 24) {
        throw new TypeError("invalid length");
      }
      if (t === 0) {
        return e.toString();
      }
      return ("0000000000000000" + e.toString()).slice(-t);
    }
    function n(e) {
      const t = new Map();
      return i => {
        const s = i ?? -1;
        let o = t.get(s);
        if (!o) {
          o = e(i);
          t.set(s, o);
        }
        return o;
      };
    }
  },
  73866: (e, t, i) => {
    "use strict";

    i.d(t, {
      LimitedPrecisionNumericFormatter: () => n
    });
    var s;
    var o = i(59623);
    (function (e) {
      e[e.DefaultPrecision = 1] = "DefaultPrecision";
    })(s ||= {});
    class n {
      constructor(e, t) {
        this._precision = e ?? 1;
        this._numericFormatter = new o.NumericFormatter({
          precision: this._precision,
          ignoreLocaleNumberFormat: t
        });
      }
      format(e, t) {
        const i = e.toFixed(this._precision);
        const s = Math.pow(10, -this._precision);
        return this._numericFormatter.format(Math.max(parseFloat(i), s), t);
      }
      parse(e, t) {
        const i = this._numericFormatter.parse(e, t);
        if (i.res) {
          return {
            res: true,
            value: i.value,
            suggest: this.format(i.value)
          };
        } else {
          return i;
        }
      }
    }
  },
  53085: (e, t, i) => {
    "use strict";

    i.d(t, {
      formatNumber: () => r,
      parseNumber: () => l
    });
    var s = i(60521);
    var o = i(59332);
    var n = i(63273);
    function r(e, t, i, o, n) {
      if (!Number.isFinite(e)) {
        return `${e}`;
      }
      const r = Math.sign(e) === -1 ? "-" : "";
      e = Math.abs(e);
      let a = i === undefined ? e.toString() : e.toFixed(i);
      if (a.includes("e")) {
        if (!o) {
          return `${r}${a.replace(".", t.decimalSign)}`;
        }
        {
          const t = new s.Big(e);
          a = t.lt(1) ? t.toFixed() : t.toString();
        }
      }
      const l = a.split(".");
      const c = l[0];
      let h = l[1];
      const d = function (e, t) {
        let i = e.length;
        const s = [];
        while (i > 0) {
          s.unshift(e.slice(Math.max(i - 3, 0), i));
          i -= 3;
        }
        return s.join(t);
      }(c, t.groupingSeparator);
      if (i !== undefined) {
        h = i === 0 ? undefined : e.toFixed(i).slice(-i);
      }
      if (n !== undefined && h !== undefined) {
        h = function (e, t) {
          let i = e.length - 1;
          for (let s = i; s >= t && e[s] === "0"; s -= 1) {
            i -= 1;
          }
          return e.slice(0, i + 1);
        }(h, n);
      }
      if (h) {
        return `${r}${d}${t.decimalSign}${h}`;
      } else {
        return `${r}${d}`;
      }
    }
    const a = (0, o.default)(e => {
      const t = e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      return new RegExp(t, "gm");
    });
    function l(e, t) {
      if (/^(NaN|[+|-]?Infinity)$/.test(e)) {
        return parseFloat(e);
      }
      e = (0, n.stripLTRMarks)(e);
      const i = a(t.groupingSeparator);
      if (i) {
        e = e.replace(i, "");
      }
      e = e.replace(t.decimalSign, ".");
      if (/^(\+|-)?\d+(\.\d+|\.)?(e(\+|-)?\d+)?$/.test(e)) {
        return parseFloat(e);
      } else {
        return NaN;
      }
    }
  },
  11345: (e, t, i) => {
    "use strict";

    let s;
    i.d(t, {
      formatterOptions: () => o,
      formatterOptionsLibraryOverrides: () => n,
      getNumberFormat: () => d
    });
    const o = {
      decimalSign: ".",
      decimalSignFractional: "'"
    };
    const n = {};
    const r = {
      groupingSeparator: ",",
      decimalSign: "."
    };
    const a = {
      groupingSeparator: ".",
      decimalSign: ","
    };
    const l = {
      groupingSeparator: "\u202F",
      decimalSign: ","
    };
    const c = {
      groupingSeparator: "",
      decimalSign: "."
    };
    const h = new Map([["en", r], ["th", r], ["ja", r], ["ko", r], ["zh", r], ["zh_TW", r], ["ar", r], ["he_IL", r], ["ms_MY", r], ["vi", r], ["de", a], ["es", a], ["it", a], ["tr", a], ["pt", a], ["id_ID", a], ["fr", l], ["pl", l], ["ru", l]]);
    function d(e) {
      if (e) {
        return {
          decimalSign: o.decimalSign,
          groupingSeparator: ""
        };
      }
      return {
        ...(h.get(s || window.language || "") ?? c),
        ...n
      };
    }
  },
  59623: (e, t, i) => {
    "use strict";

    i.d(t, {
      NumericFormatter: () => n
    });
    var s = i(53085);
    var o = i(11345);
    class n {
      constructor(e = {}) {
        this._options = e;
      }
      format(e, t) {
        if (!Number.isFinite(e)) {
          return String(e);
        }
        const {
          ignoreLocaleNumberFormat: i,
          precision: r,
          minPrecision: a
        } = this._options;
        const l = (0, o.getNumberFormat)(i || t?.ignoreLocaleNumberFormat);
        if (r === undefined) {
          return n._formatNoEImpl(e, l, r, a);
        } else {
          return (0, s.formatNumber)(e, l, r, undefined, a);
        }
      }
      parse(e, t) {
        const {
          ignoreLocaleNumberFormat: i,
          precision: n
        } = this._options;
        const r = (0, o.getNumberFormat)(i || t?.ignoreLocaleNumberFormat);
        let a = (0, s.parseNumber)(e, r);
        if (Number.isFinite(a)) {
          if (n) {
            a = +a.toFixed(n);
          }
          return {
            res: true,
            value: a
          };
        } else {
          return {
            res: false
          };
        }
      }
      static formatNoE(e, t) {
        return this._formatNoEImpl(e, t);
      }
      static _formatNoEImpl(e, t, i, o) {
        if (Number.isFinite(e)) {
          t = t ?? {
            groupingSeparator: "",
            decimalSign: "."
          };
          return (0, s.formatNumber)(e, t, i, true, o);
        } else {
          return String(e);
        }
      }
    }
  },
  719: (e, t, i) => {
    "use strict";

    i.d(t, {
      PercentageFormatter: () => n
    });
    var s = i(725);
    var o = i(63273);
    class n extends s.PriceFormatter {
      constructor(e = {}) {
        if (e.decimalPlaces !== undefined) {
          e.priceScale = Math.pow(10, e.decimalPlaces);
        }
        super(e);
        this.type = "percentage";
      }
      state() {
        return {
          ...super.state(),
          percent: true
        };
      }
      parse(e, t) {
        e = e.replace("%", "");
        return super.parse(e, t);
      }
      format(e, t = {}) {
        const {
          useRtlFormat: i = true
        } = t;
        const s = super.format(e, {
          ...t,
          useRtlFormat: false
        }) + "%";
        if (i) {
          return (0, o.forceLTRStr)(s);
        } else {
          return s;
        }
      }
      static serialize(e) {
        return e.state();
      }
      static deserialize(e) {
        return new n(e);
      }
    }
  },
  725: (e, t, i) => {
    "use strict";

    i.d(t, {
      PriceFormatter: () => T
    });
    var s = i(60521);
    var o = i(9343);
    var n = i(50151);
    var r = i(11542);
    var a = i(50335);
    var l = i(37265);
    function c(e) {
      if (e) {
        return (0, s.Big)(e.minMove).div(e.priceScale).toNumber();
      } else {
        return NaN;
      }
    }
    function h(e) {
      const {
        minTick: t,
        price: i,
        variableMinTickData: s,
        shouldCheckForEquality: o
      } = e;
      const n = (0, a.isNumber)(t) ? d(t) : t;
      if (s === undefined) {
        return n;
      } else {
        return function (e, t, i = false) {
          for (let s = 0; s < t.length; s++) {
            if (e < t[s].price) {
              return t[s].minTick;
            }
            if (i && e === t[s].price) {
              return t[s].minTick;
            }
          }
          return t[t.length - 1].minTick;
        }(i, s, o);
      }
    }
    function d(e) {
      const t = function (e) {
        return (new s.Big(e).toFixed().split(".")[1] || "").length;
      }(e);
      const i = Math.pow(10, t);
      return {
        priceScale: i,
        minMove: (0, s.Big)(e).mul(i).toNumber()
      };
    }
    function u(e, t) {
      const i = [{
        minTick: (0, a.isNumber)(e) ? d(e) : e,
        price: Infinity,
        maxIndex: Infinity
      }];
      try {
        const e = t.split(" ").map((e, t) => (0, l.isEven)(t) ? function (e) {
          const t = Number(e);
          if (Number.isFinite(t)) {
            return d(t);
          }
          {
            const t = e.split("/");
            if (t.length < 2 || t.length > 3) {
              throw new Error(`Unexpected mintick: ${e}`);
            }
            const i = Number(t[1]);
            const s = Number(t[0]);
            if (!Number.isFinite(i) || !Number.isFinite(s)) {
              throw new Error(`Unexpected mintick: ${e}`);
            }
            const o = t.length === 3 ? Number(t[2]) : undefined;
            if (o !== undefined && !Number.isFinite(o)) {
              throw new Error(`Unexpected mintick: ${e}`);
            }
            const n = {
              priceScale: i,
              minMove: s
            };
            if (o !== undefined) {
              n.minMove2 = o;
            }
            return n;
          }
        }(e) : function (e) {
          const t = Number(e);
          if (Number.isNaN(t)) {
            throw new Error(`Unexpected price limit: ${e}`);
          }
          return t;
        }(e));
        if ((0, l.isEven)(e.length)) {
          throw new Error("Theme must not be event number of elements");
        }
        const i = [];
        for (let t = 0; t < e.length; t += 2) {
          const o = e[t + 1] ?? Infinity;
          const n = i[i.length - 1]?.price ?? 0;
          const r = i[i.length - 1]?.maxIndex ?? 0;
          const a = o === Infinity ? Infinity : new s.Big(o).minus(n).div(c(e[t])).plus(r).toNumber();
          i.push({
            minTick: e[t],
            price: o,
            maxIndex: a
          });
        }
        return i;
      } catch {
        return i;
      }
    }
    var _ = i(63273);
    const p = new RegExp(/^(-?)[0-9]+$/);
    function m(e, t, i, s) {
      let o = 0;
      if (e > 0 && t > 0) {
        let t = e;
        for (i && s && (t /= s); t > 1;) {
          t /= 10;
          o++;
        }
      }
      return o;
    }
    function g(e, t, i) {
      const s = (0, n.ensureNotNull)(h({
        price: i,
        minTick: null,
        variableMinTickData: t,
        shouldCheckForEquality: true
      }));
      const {
        priceScale: o,
        minMove: r,
        minMove2: a
      } = s;
      return {
        priceScale: o,
        minMove: r,
        fractionalLength: m(o, r, e, a)
      };
    }
    class f {
      constructor(e) {
        this._formatterErrors = {
          custom: r.t(null, undefined, i(66123)),
          fraction: r.t(null, undefined, i(39643)),
          secondFraction: r.t(null, undefined, i(70784))
        };
        const {
          priceScale: t,
          minMove: s,
          minMove2: o,
          ignoreMinMove: n,
          variableMinTick: a,
          fractionalLength: l
        } = e;
        this._priceScale = t;
        this._minMove = s;
        this._minMove2 = o;
        this._ignoreMinMove = n;
        this._variableMinTickData = a === undefined ? undefined : u({
          priceScale: t,
          minMove: s,
          minMove2: o
        }, a);
        this._fractionalLength = l;
      }
      formatImpl(e, t = {}) {
        const {
          signPositive: i,
          signNegative: s = true,
          tailSize: o,
          cutFractionalByPrecision: n = false,
          useRtlFormat: r = true,
          variableMinTickDataPrice: a,
          ignoreLocaleNumberFormat: l,
          removeAllEndingZeros: c
        } = t;
        let h = "";
        if (e < 0) {
          h = s === false ? "" : "−";
        } else if (e && i === true) {
          h = "+";
        }
        const d = h + this._formatUnsigned(Math.abs(e), o, n, a, l, c);
        if (r) {
          return (0, _.forceLTRStr)(d);
        } else {
          return d;
        }
      }
      parse(e, t) {
        if ((e = (e = (0, _.stripLTRMarks)(e)).replace("−", "-"))[0] === "+") {
          e = e.substring(1);
        }
        return this._parseUnsigned(e, t);
      }
      _removeEndingZeros(e, t) {
        for (let i = 0; i < t && e[e.length - 1] === "0"; i++) {
          e = e.substring(0, e.length - 1);
        }
        return e;
      }
    }
    var y = i(53085);
    var v = i(58683);
    var S = i(11345);
    const b = (0, o.getLogger)("Chart.DecimalPriceFormatter");
    class w extends f {
      constructor(e) {
        super(e);
        const {
          minMove2: t,
          ignoreLocaleNumberFormat: i
        } = e;
        if (t !== undefined && t !== 10 && t !== 0 && t !== 1) {
          b.logDebug("invalid minmove2");
        }
        this._ignoreLocaleNumberFormat = i;
      }
      hasForexAdditionalPrecision() {
        return this._minMove2 === 10;
      }
      _parseUnsigned(e, t) {
        return this._parseAsDecimal(e, t);
      }
      _formatUnsigned(e, t, i, s, o, n) {
        const r = {
          price: Math.abs(e),
          priceScale: this._priceScale,
          minMove: this._minMove,
          fractionalLength: this._fractionalLength,
          tailSize: t,
          cutFractionalByPrecision: i,
          ignoreLocaleNumberFormat: o,
          removeAllEndingZeros: n
        };
        if (this._variableMinTickData !== undefined) {
          Object.assign(r, g(false, this._variableMinTickData, s ?? r.price));
          if (this._ignoreMinMove) {
            r.minMove = 1;
          }
        }
        return this._formatAsDecimal(r);
      }
      _formatAsExponential(e, t) {
        const i = Math.floor(Math.log10(this._priceScale) * 0.75);
        const s = e * Math.pow(10, i);
        const o = `e-${i}`;
        const n = Math.log10(this._priceScale) - i;
        return `${s.toFixed(n).replace(".", t.decimalSign)}${o}`;
      }
      _formatAsDecimal(e) {
        const {
          price: t,
          priceScale: i,
          minMove: o,
          fractionalLength: n = 0,
          tailSize: r = 0,
          cutFractionalByPrecision: a,
          ignoreLocaleNumberFormat: l,
          removeAllEndingZeros: c
        } = e;
        const h = (0, S.getNumberFormat)(this._ignoreLocaleNumberFormat || l);
        if (t >= 1e+21) {
          return t.toString().replace(".", h.decimalSign);
        }
        if (i > 1000000000000000) {
          return this._formatAsExponential(t, h);
        }
        const d = Math.pow(10, r) * i / (a ? 1 : o);
        const u = 1 / d;
        let _;
        if (d > 1) {
          _ = Math.floor(t);
        } else {
          const e = Math.floor(Math.round(t / u) * u);
          _ = Math.round((t - e) / u) === 0 ? e : e + u;
        }
        let p = "";
        if (d > 1) {
          let e = a ? new s.Big(t).mul(d).round(undefined, 0).minus(new s.Big(_).mul(d)).toNumber() : parseFloat((Math.round(t * d) - _ * d).toFixed(n));
          if (e >= d) {
            e -= d;
            _ += 1;
          }
          e = a ? new s.Big(e).round(n, 0).toNumber() : parseFloat(e.toFixed(n)) * o;
          const i = (0, v.numberToStringWithLeadingZero)(e, n + r);
          const l = this._removeEndingZeros(i, c ? i.length : r);
          p = l ? h.decimalSign + l : l;
        }
        return (0, y.formatNumber)(_, h) + p;
      }
      _parseAsDecimal(e, t = {}) {
        const {
          ignoreLocaleNumberFormat: i
        } = t;
        const s = (0, S.getNumberFormat)(this._ignoreLocaleNumberFormat || i);
        const o = (0, y.parseNumber)(e, s);
        if (Number.isFinite(o)) {
          return {
            value: o,
            res: true,
            suggest: this.formatImpl(o)
          };
        } else {
          return {
            error: this._formatterErrors.custom,
            res: false
          };
        }
      }
    }
    const C = (0, o.getLogger)("Chart.FractionalPriceFormatter");
    class P extends f {
      constructor(e) {
        super(e);
        const {
          minMove2: t
        } = e;
        if (t != null && t > 0 && t !== 2 && t !== 4 && t !== 8) {
          C.logDebug("invalid minmove2");
        }
      }
      hasForexAdditionalPrecision() {
        return false;
      }
      _parseUnsigned(e) {
        if (this._minMove2) {
          return this._parseAsDoubleFractional(e);
        } else {
          return this._parseAsSingleFractional(e);
        }
      }
      _formatUnsigned(e, t, i, s) {
        const o = {
          price: Math.abs(e),
          priceScale: this._priceScale,
          minMove: this._minMove,
          minMove2: this._minMove2,
          fractionalLength: (0, n.ensureDefined)(this._fractionalLength),
          tailSize: t
        };
        if (this._variableMinTickData !== undefined) {
          Object.assign(o, g(true, this._variableMinTickData, s ?? o.price));
        }
        return this._formatAsFractional(o);
      }
      _parseAsSingleFractional(e) {
        let t = p.exec(e);
        if (t) {
          const t = parseFloat(e);
          return {
            value: t,
            res: true,
            suggest: this.formatImpl(t)
          };
        }
        t = new RegExp("^(-?)([0-9]+)\\" + S.formatterOptions.decimalSignFractional + "([0-9]+)$").exec(e);
        if (t) {
          const e = !!t[1];
          const i = parseInt(t[2]);
          const s = this._priceScale;
          const o = this._patchFractPart(parseInt(t[3]), 1, s);
          if (o >= s || o < 0) {
            return {
              error: this._formatterErrors.fraction,
              res: false
            };
          }
          let n = i + o / s;
          if (e) {
            n = -n;
          }
          return {
            value: n,
            res: true,
            suggest: this.formatImpl(n)
          };
        }
        return {
          error: this._formatterErrors.custom,
          res: false
        };
      }
      _parseAsDoubleFractional(e) {
        let t = p.exec(e);
        if (t) {
          const t = parseFloat(e);
          return {
            value: t,
            res: true,
            suggest: this.formatImpl(t)
          };
        }
        t = new RegExp("^(-?)([0-9]+)\\" + S.formatterOptions.decimalSignFractional + "([0-9]+)\\" + S.formatterOptions.decimalSignFractional + "([0-9]+)$").exec(e);
        if (t) {
          const e = !!t[1];
          const i = parseInt(t[2]);
          const s = this._minMove2 !== undefined && this._minMove2 !== null ? this._minMove2 : NaN;
          const o = this._priceScale / s;
          const n = this._minMove2;
          const r = this._patchFractPart(parseInt(t[3]), 1, o);
          const a = this._patchFractPart(parseInt(t[4]), 2, n);
          if (r >= o || r < 0) {
            return {
              error: this._formatterErrors.fraction,
              res: false
            };
          }
          if (n != null && a >= n || a < 0) {
            return {
              error: this._formatterErrors.secondFraction,
              res: false
            };
          }
          let l = n != null ? i + r / o + a / (o * n) : NaN;
          if (e) {
            l = -l;
          }
          return {
            value: l,
            res: true,
            suggest: this.formatImpl(l)
          };
        }
        return {
          error: this._formatterErrors.custom,
          res: false
        };
      }
      _patchFractPart(e, t, i) {
        const s = {
          0: 0,
          5: 1
        };
        const o = {
          0: 0,
          2: 1,
          5: 2,
          7: 3
        };
        const n = {
          0: 0,
          1: 1,
          2: 2,
          3: 3,
          5: 4,
          6: 5,
          7: 6,
          8: 7
        };
        if (i === 2) {
          if (s[e] === undefined) {
            return -1;
          } else {
            return s[e];
          }
        } else if (i === 4) {
          if (o[e] === undefined) {
            return -1;
          } else {
            return o[e];
          }
        } else if (i === 8 && t === 2) {
          if (n[e] === undefined) {
            return -1;
          } else {
            return n[e];
          }
        } else {
          return e;
        }
      }
      _formatAsFractional(e) {
        const {
          price: t,
          tailSize: i,
          priceScale: s,
          minMove: o,
          minMove2: n,
          fractionalLength: r
        } = e;
        const a = s / o;
        let l = Math.floor(t);
        let c = i ? Math.floor(t * a) - l * a : Math.round(t * a) - l * a;
        if (c === a) {
          c = 0;
          l += 1;
        }
        let h = "";
        if (i) {
          let e = (t - l - c / a) * a;
          e = Math.round(e * Math.pow(10, i));
          h = (0, v.numberToStringWithLeadingZero)(e, i);
          h = this._removeEndingZeros(h, i);
        }
        if (!r) {
          throw new Error("_fractionalLength is not calculated");
        }
        let d = "";
        if (n) {
          const e = c % n;
          c = (c - e) / n;
          const t = (0, v.numberToStringWithLeadingZero)(c, r);
          const i = this._getFractPart(e, 2, n);
          d = t + S.formatterOptions.decimalSignFractional + i;
        } else {
          c = this._getFractPart(c, 1, s);
          d = (0, v.numberToStringWithLeadingZero)(c * o, r);
        }
        return l.toString() + S.formatterOptions.decimalSignFractional + d + h;
      }
      _getFractPart(e, t, i) {
        const s = [0, 5];
        const o = [0, 2, 5, 7];
        const n = [0, 1, 2, 3, 5, 6, 7, 8];
        if (i === 2) {
          if (s[e] === undefined) {
            return -1;
          } else {
            return s[e];
          }
        } else if (i === 4) {
          if (o[e] === undefined) {
            return -1;
          } else {
            return o[e];
          }
        } else if (i === 8 && t === 2) {
          if (n[e] === undefined) {
            return -1;
          } else {
            return n[e];
          }
        } else {
          return e;
        }
      }
    }
    class T {
      constructor(e = {}) {
        this.type = "price";
        const {
          minMove2: t,
          fractional: i,
          variableMinTick: s,
          ignoreMinMove: o,
          ignoreLocaleNumberFormat: n
        } = e;
        const r = !e.minMove || o ? 1 : e.minMove;
        const a = (0, l.isNumber)(e.priceScale) && (0, l.isInteger)(e.priceScale) ? e.priceScale : 100;
        const c = m(a, r, i, t);
        const h = {
          ...e,
          minMove: r,
          priceScale: a,
          fractionalLength: c
        };
        if (a < 0) {
          throw new TypeError("invalid base");
        }
        this._priceScale = a;
        this._minMove = r;
        this._minMove2 = t;
        this._fractional = i;
        this._variableMinTick = s;
        this._ignoreMinMove = o;
        this._fractionalLength = c;
        this._ignoreLocaleNumberFormat = n;
        this._implementation = i ? new P(h) : new w(h);
      }
      isFractional() {
        return !!this._fractional;
      }
      state() {
        return {
          minMove: this._minMove,
          minMove2: this._minMove2,
          priceScale: this._priceScale,
          variableMinTick: this._variableMinTick,
          ignoreMinMove: this._ignoreMinMove,
          fractional: this._fractional
        };
      }
      formatChange(e, t, i) {
        return this._implementation.formatImpl(e - t, {
          ...i,
          variableMinTickDataPrice: Math.min(Math.abs(e), Math.abs(t))
        });
      }
      format(e, t) {
        return this._implementation.formatImpl(e, t);
      }
      parse(e, t) {
        return this._implementation.parse(e, t);
      }
      hasForexAdditionalPrecision() {
        return this._implementation.hasForexAdditionalPrecision();
      }
      static serialize(e) {
        return e.state();
      }
      static deserialize(e) {
        return new T(e);
      }
    }
  },
  15344: (e, t, i) => {
    "use strict";

    i.d(t, {
      TimeFormatter: () => _,
      hourMinuteFormat: () => l,
      hourMinuteNonZeroSecondFormat: () => r,
      hourMinuteSecondFormat: () => n,
      hourMinuteSecondMillisecFormat: () => a,
      twelveHourMinuteFormat: () => d,
      twelveHourMinuteNonZeroSecondFormat: () => h,
      twelveHourMinuteSecondFormat: () => c
    });
    var s = i(24526);
    var o = i(58683);
    const n = "%h:%m:%s";
    const r = "%h:%m:%s+";
    const a = "%h:%m:%s.%ss+";
    const l = "%h:%m";
    const c = "%h:%m:%s %ampm";
    const h = "%h:%m:%s+ %ampm";
    const d = "%h:%m %ampm";
    var u;
    (function (e) {
      e.TwentyFourHours = "24-hours";
      e.TwelveHours = "12-hours";
    })(u ||= {});
    class _ {
      constructor(e) {
        this._isTwelveHoursFormat = false;
        this._valuesAndDelimeters = [];
        const t = e || n;
        const i = new RegExp("%h|%m|%s\\+|%ss\\+|%ss|%ampm|%s", "g");
        let s = i.exec(t);
        let o = 0;
        while (s !== null) {
          const e = s[0];
          if (e === "%ampm") {
            this._isTwelveHoursFormat = true;
          }
          const n = t.substring(o, s.index);
          if (n !== "") {
            this._valuesAndDelimeters.push(n);
          }
          this._valuesAndDelimeters.push(e);
          o = s.index + e.length;
          s = i.exec(t);
        }
      }
      format(e) {
        if (s.customFormatters.timeFormatter) {
          return s.customFormatters.timeFormatter.format(e);
        } else {
          return this._formatTime(e, false);
        }
      }
      formatLocal(e) {
        if (s.customFormatters.timeFormatter) {
          if (s.customFormatters.timeFormatter.formatLocal) {
            return s.customFormatters.timeFormatter.formatLocal(e);
          } else {
            return s.customFormatters.timeFormatter.format(e);
          }
        } else {
          return this._formatTime(e, true);
        }
      }
      _formatTime(e, t) {
        let i = t ? e.getHours() : e.getUTCHours();
        const s = t ? e.getMinutes() : e.getUTCMinutes();
        const n = t ? e.getSeconds() : e.getUTCSeconds();
        const r = t ? e.getMilliseconds() : e.getUTCMilliseconds();
        let a = "";
        if (this._isTwelveHoursFormat) {
          a = i >= 12 ? "PM" : "AM";
          i %= 12;
          i = i || 12;
        }
        let l = "";
        let c = false;
        for (let e = this._valuesAndDelimeters.length - 1; e >= 0; e--) {
          const t = this._valuesAndDelimeters[e];
          let h;
          switch (t) {
            case "%h":
              h = (0, o.numberToStringWithLeadingZero)(i, 2);
              break;
            case "%m":
              h = (0, o.numberToStringWithLeadingZero)(s, 2);
              break;
            case "%s+":
              if (n !== 0) {
                h = (0, o.numberToStringWithLeadingZero)(n, 2);
              } else {
                h = "";
                c = true;
              }
              break;
            case "%s":
              h = (0, o.numberToStringWithLeadingZero)(n, 2);
              break;
            case "%ss":
              h = (0, o.numberToStringWithLeadingZero)(r, 3);
              break;
            case "%ss+":
              if (r !== 0) {
                h = (0, o.numberToStringWithLeadingZero)(r, 3);
              } else {
                h = "";
                c = true;
              }
              break;
            case "%ampm":
              h = a;
              break;
            default:
              if (c) {
                c = false;
                continue;
              }
              h = t;
          }
          l = h + l;
        }
        return l;
      }
    }
  },
  92953: (e, t, i) => {
    "use strict";

    i.d(t, {
      TimeSpanFormatter: () => r
    });
    var s = i(11542);
    var o = i(53085);
    var n = i(11345);
    class r {
      format(e, t) {
        const r = e < 0;
        e = Math.abs(e);
        const a = Math.floor(e / 86400);
        e -= a * 86400;
        const l = Math.floor(e / 3600);
        e -= l * 3600;
        const c = Math.floor(e / 60);
        e -= c * 60;
        let h = "";
        if (a) {
          const e = (0, n.getNumberFormat)(t?.ignoreLocaleNumberFormat);
          h += (0, o.formatNumber)(a, e) + s.t(null, {
            context: "dates"
          }, i(85886)) + " ";
        }
        if (l) {
          h += l + s.t(null, {
            context: "dates"
          }, i(44634)) + " ";
        }
        if (c) {
          h += c + s.t(null, {
            context: "dates"
          }, i(5977)) + " ";
        }
        if (e) {
          h += e + s.t(null, {
            context: "dates"
          }, i(21492)) + " ";
        }
        if (r) {
          h = "-" + h;
        }
        return h.trim();
      }
    }
  },
  46084: (e, t, i) => {
    "use strict";

    i.d(t, {
      VolumeFormatter: () => l
    });
    var s = i(11542);
    var o = i(59623);
    var n = i(37265);
    const r = [{
      value: 3,
      letter: "K"
    }, {
      value: 6,
      letter: "M"
    }, {
      value: 9,
      letter: "B"
    }, {
      value: 12,
      letter: "T"
    }];
    function a(e, t) {
      const i = e - t;
      return r.find(e => e.value >= i) ?? r[r.length - 1];
    }
    class l {
      constructor(e = {}) {
        this.type = "volume";
        const {
          precision: t = 0,
          minPrecision: i = 0,
          dimensionPrecision: s = 2,
          dimensionMinPrecision: n = 0,
          significantDigits: r = 3,
          ignoreLocaleNumberFormat: a,
          removeSpaceBeforeDimension: l
        } = e;
        this._precision = t;
        this._formatter = new o.NumericFormatter({
          ignoreLocaleNumberFormat: a,
          precision: this._precision,
          minPrecision: i
        });
        this._dimensionPrecision = s;
        this._dimensionFormatter = new o.NumericFormatter({
          ignoreLocaleNumberFormat: a,
          precision: this._dimensionPrecision,
          minPrecision: n
        });
        this._significantDigits = r;
        this._fractionalValues = t !== undefined && t > 0;
        this._spaceBeforeDimension = l ? "" : "\u202F";
        this._options = e;
      }
      state() {
        const {
          ignoreLocaleNumberFormat: e,
          ...t
        } = this._options;
        return t;
      }
      format(e, t) {
        if (!(0, n.isNumber)(e)) {
          return "---";
        }
        if (Math.abs(e) >= 1e+100) {
          return s.t(null, undefined, i(96935));
        }
        let o = "";
        if (Math.abs(e) < 1) {
          e = +e.toFixed(this._precision);
        }
        if (e < 0) {
          o = "−";
        } else if (e > 0 && t?.signPositive) {
          o = "+";
        }
        e = Math.abs(e);
        const r = !!(t?.ignoreLocaleNumberFormat ?? this._options.ignoreLocaleNumberFormat);
        let l;
        let c;
        let h = Math.floor(Math.log10(e)) + 1;
        if (h <= this._significantDigits) {
          e = +e.toFixed(this._precision);
          h = Math.floor(Math.log10(e)) + 1;
        }
        if (h <= this._significantDigits) {
          l = this._formatNumber(e, r, this._formatter);
        } else {
          let t = a(h, this._significantDigits);
          const i = Math.pow(10, t.value);
          e = +(e / i).toFixed(this._dimensionPrecision) * i;
          t = a(Math.floor(Math.log10(e)) + 1, this._significantDigits);
          l = this._formatNumber(e / Math.pow(10, t.value), r, this._dimensionFormatter);
          c = t.letter;
        }
        if (c) {
          return `${o}${l}${this._spaceBeforeDimension}${c}`;
        } else {
          return `${o}${l}`;
        }
      }
      parse(e, t) {
        if (e === "---") {
          return {
            error: "not a number",
            res: false,
            value: NaN
          };
        }
        const i = {
          K: 1000,
          M: 1000000,
          B: 1000000000,
          T: 1000000000000
        };
        const s = (e = e.replace("−", "-")).slice(-1);
        if (i.hasOwnProperty(s)) {
          const o = this._formatter.parse(e.slice(0, -1).trim(), t);
          const r = o.res ? o.value : NaN;
          if ((0, n.isNumber)(r)) {
            return {
              res: true,
              value: r * i[s]
            };
          } else {
            return {
              error: "not a number",
              res: false,
              value: NaN
            };
          }
        }
        {
          const i = this._formatter.parse(e.trim(), t);
          const s = i.res ? i.value : NaN;
          if ((0, n.isNumber)(s)) {
            return {
              res: true,
              value: s
            };
          } else {
            return {
              error: "not a number",
              res: false,
              value: NaN
            };
          }
        }
      }
      static serialize(e) {
        return e.state();
      }
      static deserialize(e) {
        return new l(e);
      }
      _formatNumber(e, t, i) {
        if (this._fractionalValues && e !== 0) {
          const t = 14 - Math.ceil(Math.log10(e));
          const i = Math.pow(10, t);
          e = Math.round(e * i) / i;
        }
        return i.format(e, {
          ignoreLocaleNumberFormat: t
        });
      }
    }
  },
  41991: (e, t, i) => {
    "use strict";

    i.d(t, {
      getPriceValueFormatterForSource: () => l,
      getPriceValueFormatterForStudy: () => c,
      shouldBeFormattedAsIndexedTo100: () => r,
      shouldBeFormattedAsPercent: () => n
    });
    var s = i(68805);
    var o = i(60074);
    function n(e) {
      const t = e.priceScale();
      return t !== null && !!t.isPercentage() && (!(0, o.isActingAsSymbolSource)(e) || (0, s.isPriceSourceStyle)(e.style()));
    }
    function r(e) {
      const t = e.priceScale();
      return t !== null && !!t.isIndexedTo100() && (!(0, o.isActingAsSymbolSource)(e) || (0, s.isPriceSourceStyle)(e.style()));
    }
    function a(e) {
      const t = e.priceScale();
      if (r(e) && t !== null) {
        return (i, s) => t.formatPriceIndexedTo100(i, e.firstValue() ?? 100, s);
      } else if (n(e) && t !== null) {
        return (i, s) => t.formatPricePercentage(i, e.firstValue() ?? 100, s);
      } else {
        return null;
      }
    }
    function l(e) {
      const t = a(e);
      if (t) {
        return t;
      }
      const i = e.formatter();
      return i.format.bind(i);
    }
    function c(e, t) {
      const i = a(e);
      if (i) {
        return i;
      }
      const s = e.plotFormatter(t);
      return s.format.bind(s);
    }
  },
  56468: (e, t, i) => {
    "use strict";

    i.d(t, {
      AreaName: () => s,
      HitTarget: () => n,
      HitTestResult: () => d,
      hitTestResultDataAreEqual: () => h,
      shouldDefaultActionBeExecuted: () => c,
      tryCallHandler: () => l
    });
    var s;
    var o;
    var n;
    var r = i(50279);
    var a = i(50151);
    function l(e, t, i, s) {
      if (e.isTouch) {
        if (s !== undefined) {
          s(e, t);
          return true;
        }
      } else if (i !== undefined) {
        i(e, t);
        return true;
      }
      return false;
    }
    function c(e, t, i, s) {
      return t.executeDefaultAction !== undefined && (e.isTouch ? Boolean(t.executeDefaultAction[s]) : Boolean(t.executeDefaultAction[i]));
    }
    function h(e, t) {
      if (e && t && e.equals && t.equals) {
        return e.equals(t);
      } else {
        return (0, r.default)(e, t);
      }
    }
    (function (e) {
      e.Style = "Style";
      e.Text = "Text";
      e.Line = "Line";
      e.Tooltip = "Tooltip";
      e.Button = "Button";
      e.SourceItemMove = "SourceItemMove";
      e.AnchorPoint = "AnchorPoint";
    })(s ||= {});
    (function (e) {
      e[e.Both = 0] = "Both";
      e[e.Horz = 1] = "Horz";
      e[e.Vert = 2] = "Vert";
    })(o ||= {});
    (function (e) {
      e[e.MovePointBackground = 1] = "MovePointBackground";
      e[e.Regular = 2] = "Regular";
      e[e.MovePoint = 3] = "MovePoint";
      e[e.ChangePoint = 4] = "ChangePoint";
      e[e.Custom = 5] = "Custom";
    })(n ||= {});
    class d {
      constructor(e, t, i) {
        this._target = e;
        this._data = t || null;
        this._eraseMarker = i;
      }
      target() {
        return this._target;
      }
      data() {
        return this._data;
      }
      mergeData(e) {
        this._data = {
          ...(0, a.ensureNotNull)(this._data),
          ...e
        };
      }
      hasPressedMoveHandler(e) {
        return this._data !== null && function (e, t, i) {
          if (e.isTouch) {
            if (i !== undefined) {
              return true;
            }
          } else if (t !== undefined) {
            return true;
          }
          return false;
        }(e, this._data.pressedMouseMoveHandler, this._data.touchMoveHandler);
      }
      tryCallMouseDownOrTouchStartHandler(e, t) {
        return this._data !== null && l(e, t, this._data.mouseDownHandler, this._data.touchStartHandler);
      }
      tryCallMouseUpOrTouchEndHandler(e, t) {
        return this._data !== null && l(e, t, this._data.mouseUpHandler, this._data.touchEndHandler);
      }
      tryCallMouseEnterHandler(e, t) {
        return this._data !== null && l(e, t, this._data.mouseEnterHandler);
      }
      tryCallMouseLeaveHandler(e, t) {
        return this._data !== null && l(e, t, this._data.mouseLeaveHandler);
      }
      tryCallMouseMoveHandler(e, t) {
        return this._data !== null && l(e, t, this._data.mouseMoveHandler);
      }
      tryCallClickOrTapHandler(e, t) {
        return this._data !== null && l(e, t, this._data.clickHandler, this._data.tapHandler);
      }
      tryCallDblClickOrDblTapHandler(e, t) {
        return this._data !== null && l(e, t, this._data.doubleClickHandler, this._data.doubleTapHandler);
      }
      tryCallContextMenuHandler(e, t) {
        return this._data !== null && l(e, t, this._data.contextMenuHandler, this._data.touchContextMenuHandler);
      }
      eraseMarker() {
        return this._eraseMarker;
      }
    }
  },
  52397: (e, t, i) => {
    "use strict";

    i.d(t, {
      HorizontalLinePaneView: () => n
    });
    var s = i(50600);
    var o = i(51056);
    class n {
      constructor() {
        this._lineRendererData = {
          y: 0,
          color: "rgba(0, 0, 0, 0)",
          linewidth: 1,
          linestyle: o.LINESTYLE_SOLID,
          visible: false
        };
        this._lineRenderer = new s.HorizontalLineRenderer();
        this._invalidated = true;
        this._lineRenderer.setData(this._lineRendererData);
      }
      update(e) {
        this._invalidated = true;
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        return this._lineRenderer;
      }
    }
  },
  80720: (e, t, i) => {
    "use strict";

    var s;
    var o;
    var n;
    i.d(t, {
      CustomSourceLayer: () => a,
      PlDisplay: () => o,
      RecalcVisibleRangeStudiesReason: () => c,
      TradedGroupHorizontalAlignment: () => n,
      tradingPreferencesDefault: () => r
    });
    (function (e) {
      e[e.Initial = 2] = "Initial";
      e[e.SeriesZOrderIsAlwaysZero = 3] = "SeriesZOrderIsAlwaysZero";
      e[e.Current = 3] = "Current";
    })(s ||= {});
    (function (e) {
      e[e.Money = 0] = "Money";
      e[e.Pips = 1] = "Pips";
      e[e.Percentage = 2] = "Percentage";
    })(o ||= {});
    (function (e) {
      e[e.Left = 0] = "Left";
      e[e.Center = 1] = "Center";
      e[e.Right = 2] = "Right";
    })(n ||= {});
    const r = {
      showPositions: false,
      positionPL: {
        visibility: false,
        display: o.Money
      },
      bracketsPL: {
        visibility: false,
        display: o.Money
      },
      showOrders: false,
      showExecutions: false,
      showExecutionsLabels: false,
      showReverse: false,
      extendLeft: false,
      lineLength: 0,
      horizontalAlignment: n.Right,
      lineWidth: 0,
      lineStyle: 0
    };
    var a;
    var l;
    var c;
    var h;
    (function (e) {
      e[e.Background = 0] = "Background";
      e[e.Foreground = 1] = "Foreground";
      e[e.Topmost = 2] = "Topmost";
    })(a ||= {});
    (function (e) {
      e[e.Unavailable = 0] = "Unavailable";
      e[e.AvailableReadonlyAlwaysDisabled = 1] = "AvailableReadonlyAlwaysDisabled";
      e[e.AvailableReadonlyAlwaysEnabled = 2] = "AvailableReadonlyAlwaysEnabled";
      e[e.Available = 3] = "Available";
    })(l ||= {});
    (function (e) {
      e[e.ViewportChangeUserAction = 0] = "ViewportChangeUserAction";
      e[e.DataUpdate = 1] = "DataUpdate";
      e[e.SeriesRestart = 2] = "SeriesRestart";
      e[e.SeriesCompleted = 3] = "SeriesCompleted";
      e[e.StudyCreation = 4] = "StudyCreation";
    })(c ||= {});
    (function (e) {
      e[e.Chart = 0] = "Chart";
    })(h ||= {});
  },
  77148: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      CreateLineToolSyncMode: () => s
    });
    (function (e) {
      e[e.Default = 0] = "Default";
      e[e.ForceOn = 1] = "ForceOn";
      e[e.ForceOff = 2] = "ForceOff";
    })(s ||= {});
  },
  19466: (e, t, i) => {
    "use strict";

    var s;
    var o;
    var n;
    i.d(t, {
      TitleDisplayTarget: () => n
    });
    (function (e) {
      e[e.AfterMainSeries = 0] = "AfterMainSeries";
    })(s ||= {});
    (function (e) {
      e[e.Idle = 0] = "Idle";
      e[e.Processing = 1] = "Processing";
      e[e.Active = 2] = "Active";
      e[e.Stopped = 3] = "Stopped";
    })(o ||= {});
    (function (e) {
      e[e.DataWindow = 1] = "DataWindow";
      e[e.StatusLine = 2] = "StatusLine";
      e[e.Alerts = 3] = "Alerts";
    })(n ||= {});
  },
  85049: (e, t, i) => {
    "use strict";

    i.d(t, {
      Interval: () => h,
      ResolutionKind: () => n,
      SpecialResolutionKind: () => r,
      isHour: () => u
    });
    const s = /^(\d*)([TSHDWMR])$/;
    const o = /^(\d+)$/;
    var n;
    var r;
    (function (e) {
      e.Ticks = "ticks";
      e.Seconds = "seconds";
      e.Minutes = "minutes";
      e.Days = "days";
      e.Weeks = "weeks";
      e.Months = "months";
      e.Range = "range";
      e.Invalid = "invalid";
    })(n ||= {});
    (function (e) {
      e.Hours = "hours";
    })(r ||= {});
    const a = {
      [n.Ticks]: 1000,
      [n.Seconds]: 1000
    };
    a[n.Minutes] = a[n.Seconds] * 60;
    a[n.Days] = a[n.Minutes] * 1440;
    a[n.Weeks] = a[n.Days] * 7;
    const l = {
      T: n.Ticks,
      S: n.Seconds,
      D: n.Days,
      W: n.Weeks,
      M: n.Months,
      R: n.Range
    };
    const c = new Set([n.Ticks, n.Seconds, n.Minutes]);
    class h {
      constructor(e, t) {
        this._kind = n.Invalid;
        this._multiplier = 0;
        if (e !== n.Invalid && t > 0) {
          this._kind = e;
          this._multiplier = t;
        }
      }
      kind() {
        return this._kind;
      }
      guiKind() {
        if (this.isMinuteHours()) {
          return r.Hours;
        } else {
          return this._kind;
        }
      }
      multiplier() {
        return this._multiplier;
      }
      isValid() {
        return this.kind() !== n.Invalid && this.multiplier() > 0;
      }
      isDWM() {
        return this.isValid() && !this.isRange() && !this.isIntraday() && !this.isTicks();
      }
      isIntraday() {
        const e = c.has(this.kind());
        return this.isValid() && e;
      }
      isSeconds() {
        return this.kind() === n.Seconds;
      }
      isMinutes() {
        return this.kind() === n.Minutes;
      }
      isMinuteHours() {
        return this.kind() === n.Minutes && u(this.multiplier());
      }
      isDays() {
        return this.kind() === n.Days;
      }
      isWeeks() {
        return this.kind() === n.Weeks;
      }
      isMonths() {
        return this.kind() === n.Months;
      }
      isRange() {
        return this.kind() === n.Range;
      }
      isTicks() {
        return this.kind() === n.Ticks;
      }
      is1Tick() {
        return this.isTicks() && this.multiplier() === 1;
      }
      isTimeBased() {
        return !this.isRange();
      }
      letter() {
        if (this.isValid() && this.kind() !== n.Minutes) {
          return this.kind()[0].toUpperCase();
        } else {
          return "";
        }
      }
      value() {
        if (this.isValid()) {
          if (this.kind() === n.Minutes) {
            return this.multiplier() + "";
          } else {
            return this.multiplier() + this.letter();
          }
        } else {
          return "";
        }
      }
      isEqualTo(e) {
        if (!(e instanceof h)) {
          throw new Error("Argument is not an Interval");
        }
        return !!this.isValid() && !!e.isValid() && this.kind() === e.kind() && this.multiplier() === e.multiplier();
      }
      inMilliseconds(e = Date.now()) {
        if (!this.isValid() || this.isRange()) {
          return NaN;
        }
        if (this.isMonths()) {
          const t = new Date(e);
          t.setUTCMonth(t.getUTCMonth() + (this.multiplier() || 1));
          return +t - e;
        }
        const t = this.multiplier();
        return a[this.kind()] * t;
      }
      static isEqual(e, t) {
        return e === t || h.parse(e).isEqualTo(h.parse(t));
      }
      static parseExt(e) {
        e = (e + "").toUpperCase().split(",")[0];
        let t = s.exec(e);
        if (t !== null) {
          if (t[2] === "H") {
            return {
              interval: new h(n.Minutes, d(t[1]) * 60),
              guiResolutionKind: r.Hours
            };
          } else {
            return {
              interval: new h(l[t[2]], d(t[1])),
              guiResolutionKind: l[t[2]]
            };
          }
        } else {
          t = o.exec(e);
          if (t !== null) {
            return {
              interval: new h(n.Minutes, d(t[1])),
              guiResolutionKind: n.Minutes
            };
          } else {
            return {
              interval: new h(n.Invalid, 0),
              guiResolutionKind: n.Invalid
            };
          }
        }
      }
      static parse(e) {
        return h.parseExt(e).interval;
      }
      static kind(e) {
        return h.parse(e).kind();
      }
      static isValid(e) {
        return h.parse(e).isValid();
      }
      static isDWM(e) {
        return h.parse(e).isDWM();
      }
      static isIntraday(e) {
        return h.parse(e).isIntraday();
      }
      static isSeconds(e) {
        return h.parse(e).isSeconds();
      }
      static isMinutes(e) {
        return h.parse(e).isMinutes();
      }
      static isMinuteHours(e) {
        return h.parse(e).isMinuteHours();
      }
      static isDays(e) {
        return h.parse(e).isDays();
      }
      static isWeeks(e) {
        return h.parse(e).isWeeks();
      }
      static isMonths(e) {
        return h.parse(e).isMonths();
      }
      static isRange(e) {
        return h.parse(e).isRange();
      }
      static isTicks(e) {
        return h.parse(e).isTicks();
      }
      static isTimeBased(e) {
        return h.parse(e).isTimeBased();
      }
      static normalize(e) {
        const t = h.parse(e);
        if (t.isValid()) {
          return t.value();
        } else {
          return null;
        }
      }
    }
    function d(e) {
      if (e.length === 0) {
        return 1;
      } else {
        return parseInt(e, 10);
      }
    }
    function u(e) {
      return e >= 60 && !(e % 60);
    }
  },
  31229: (e, t, i) => {
    "use strict";

    i.d(t, {
      intervalsVisibilitiesDefaults: () => s
    });
    const s = {
      ticks: true,
      seconds: true,
      secondsFrom: 1,
      secondsTo: 59,
      minutes: true,
      minutesFrom: 1,
      minutesTo: 59,
      hours: true,
      hoursFrom: 1,
      hoursTo: 24,
      days: true,
      daysFrom: 1,
      daysTo: 366,
      weeks: true,
      weeksFrom: 1,
      weeksTo: 52,
      months: true,
      monthsFrom: 1,
      monthsTo: 12,
      ranges: true
    };
  },
  94260: (e, t, i) => {
    "use strict";

    i.d(t, {
      IntervalsVisibilitiesProperty: () => o
    });
    var s = i(12988);
    i(10892);
    class o extends s.Property {
      state(e, t) {
        return super.state(e, t);
      }
      storeStateIfUndefined() {
        return false;
      }
    }
  },
  10892: (e, t, i) => {
    "use strict";

    i.d(t, {
      getIntervalsVisibilitiesForMode: () => _,
      isActualInterval: () => d,
      makeIntervalsVisibilitiesVisibleAtInterval: () => c,
      mergeIntervalVisibilitiesDefaults: () => u
    });
    var s;
    var o = i(16738);
    var n = i(90054);
    var r = i(50151);
    var a = i(85049);
    var l = i(31229);
    function c(e, t) {
      let i = t.multiplier();
      if (t.isTicks()) {
        e.ticks = true;
      }
      if (t.isSeconds()) {
        if (i < 60) {
          e.seconds = true;
          e.secondsFrom = Math.min(e.secondsFrom, i);
          e.secondsTo = Math.max(e.secondsTo, i);
        } else {
          i = Math.floor(i / 60);
          t = new a.Interval(a.ResolutionKind.Minutes, i);
        }
      }
      if (t.isMinutes()) {
        if (i < 60) {
          e.minutes = true;
          e.minutesFrom = Math.min(e.minutesFrom, i);
          e.minutesTo = Math.max(e.minutesTo, i);
        } else {
          const t = Math.floor(i / 60);
          e.hours = true;
          e.hoursFrom = Math.min(e.hoursFrom, t);
          e.hoursTo = Math.max(e.hoursTo, t);
        }
      }
      if (t.isDays()) {
        e.days = true;
        e.daysFrom = Math.min(e.daysFrom, i);
        e.daysTo = Math.max(e.daysTo, i);
      }
      if (t.isWeeks()) {
        e.weeks = true;
        e.weeksFrom = Math.min(e.weeksFrom, i);
        e.weeksTo = Math.max(e.weeksTo, i);
      }
      if (t.isMonths()) {
        e.months = true;
        e.monthsFrom = Math.min(e.monthsFrom, i);
        e.monthsTo = Math.max(e.monthsTo, i);
      }
      if (t.isRange()) {
        e.ranges = true;
      }
    }
    function h(e, t, i, s) {
      return e && s >= t && s <= i;
    }
    function d(e, t) {
      const i = t.childs();
      switch (e.kind()) {
        case a.ResolutionKind.Ticks:
          return i.ticks.value();
        case a.ResolutionKind.Seconds:
          if (e.multiplier() < 60) {
            return h(i.seconds.value(), i.secondsFrom.value(), i.secondsTo.value(), e.multiplier());
          }
          {
            const t = Math.floor(e.multiplier() / 60);
            return h(i.minutes.value(), i.minutesFrom.value(), i.minutesTo.value(), t);
          }
        case a.ResolutionKind.Minutes:
          if (e.multiplier() < 60) {
            return h(i.minutes.value(), i.minutesFrom.value(), i.minutesTo.value(), e.multiplier());
          }
          {
            const t = Math.floor(e.multiplier() / 60);
            return h(i.hours.value(), i.hoursFrom.value(), i.hoursTo.value(), t);
          }
        case a.ResolutionKind.Days:
          return h(i.days.value(), i.daysFrom.value(), i.daysTo.value(), e.multiplier());
        case a.ResolutionKind.Weeks:
          return h(i.weeks.value(), i.weeksFrom.value(), i.weeksTo.value(), e.multiplier());
        case a.ResolutionKind.Months:
          return h(i.months.value(), i.monthsFrom.value(), i.monthsTo.value(), e.multiplier());
        case a.ResolutionKind.Range:
          return i.ranges.value();
      }
      (0, r.assert)(false, `Unsupported resolution: ${e.value()}`);
      return false;
    }
    function u(e) {
      return (0, o.default)((0, n.default)(l.intervalsVisibilitiesDefaults), e ?? {});
    }
    function _(e, t) {
      if (t === 0 || e.isTicks() && t === 3 || e.isRange() && t === 2) {
        return u();
      }
      let i = false;
      const s = {
        ticks: false,
        seconds: false,
        minutes: false,
        hours: false,
        days: false,
        weeks: false,
        months: false,
        ranges: false
      };
      const o = e => e.multiplier();
      [{
        checker: e => e.isTicks(),
        getIntervalMultiplier: o,
        markIntervalAsVisible: (e, t) => {
          s.ticks = true;
        }
      }, {
        checker: e => e.isSeconds() && e.multiplier() < 60,
        getIntervalMultiplier: o,
        markIntervalAsVisible: (e, t) => {
          s.seconds = true;
          s.secondsFrom = e;
          s.secondsTo = t;
        }
      }, {
        checker: e => e.isSeconds() && e.multiplier() >= 60,
        getIntervalMultiplier: e => Math.floor(e.multiplier() / 60),
        markIntervalAsVisible: (e, t) => {
          s.minutes = true;
          s.minutesFrom = e;
          s.minutesTo = t;
        }
      }, {
        checker: e => e.isMinutes() && e.multiplier() < 60,
        getIntervalMultiplier: o,
        markIntervalAsVisible: (e, t) => {
          s.minutes = true;
          s.minutesFrom = e;
          s.minutesTo = t;
        }
      }, {
        checker: e => e.isMinutes() && e.multiplier() >= 60,
        getIntervalMultiplier: e => Math.floor(e.multiplier() / 60),
        markIntervalAsVisible: (e, t) => {
          s.hours = true;
          s.hoursFrom = e;
          s.hoursTo = t;
        }
      }, {
        checker: e => e.isDays(),
        getIntervalMultiplier: o,
        markIntervalAsVisible: (e, t) => {
          s.days = true;
          s.daysFrom = e;
          s.daysTo = t;
        }
      }, {
        checker: e => e.isWeeks(),
        getIntervalMultiplier: o,
        markIntervalAsVisible: (e, t) => {
          s.weeks = true;
          s.weeksFrom = e;
          s.weeksTo = t;
        }
      }, {
        checker: e => e.isMonths(),
        getIntervalMultiplier: o,
        markIntervalAsVisible: (e, t) => {
          s.months = true;
          s.monthsFrom = e;
          s.monthsTo = t;
        }
      }, {
        checker: e => e.isRange(),
        getIntervalMultiplier: o,
        markIntervalAsVisible: (e, t) => {
          s.ranges = true;
        }
      }].forEach(s => {
        if (s.checker(e)) {
          i = true;
          const o = s.getIntervalMultiplier(e);
          if (t === 1) {
            s.markIntervalAsVisible(o, o);
          } else if (t === 3) {
            s.markIntervalAsVisible(o, undefined);
          } else {
            s.markIntervalAsVisible(undefined, o);
          }
        } else if (!i && t === 2 || i && t === 3) {
          s.markIntervalAsVisible(undefined, undefined);
        }
      });
      return u(s);
    }
    (function (e) {
      e[e.All = 0] = "All";
      e[e.OnlyCurrent = 1] = "OnlyCurrent";
      e[e.CurrentAndBelow = 2] = "CurrentAndBelow";
      e[e.CurrentAndAbove = 3] = "CurrentAndAbove";
    })(s ||= {});
  },
  22820: (e, t, i) => {
    "use strict";

    var s;
    var o;
    var n;
    i.d(t, {
      PaneMode: () => n
    });
    (function (e) {
      e.Left = "left";
      e.Right = "right";
    })(s ||= {});
    (function (e) {
      e.Tiny = "tiny";
      e.Small = "small";
      e.Medium = "medium";
      e.Large = "large";
    })(o ||= {});
    (function (e) {
      e[e.Regular = 0] = "Regular";
      e[e.Widget = 1] = "Widget";
    })(n ||= {});
  },
  8025: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      PlotRowSearchMode: () => s
    });
    (function (e) {
      e[e.NearestLeft = -1] = "NearestLeft";
      e[e.Exact = 0] = "Exact";
      e[e.NearestRight = 1] = "NearestRight";
    })(s ||= {});
  },
  66666: (e, t, i) => {
    "use strict";

    function s(e) {
      return Boolean(e.showInObjectTree);
    }
    i.d(t, {
      isDataSource: () => s
    });
  },
  1819: (e, t, i) => {
    "use strict";

    i.d(t, {
      isTicksEnabled: () => o
    });
    var s = i(56570);
    function o() {
      return s.enabled("tick_resolution");
    }
  },
  4340: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      SymbolErrorPermissionDeniedReason: () => s,
      invalidSymbol: () => n,
      permissionDenied: () => o
    });
    (function (e) {
      e.Symbol = "symbol";
      e.GroupPermission = "group";
    })(s ||= {});
    const o = "permission denied";
    const n = "invalid symbol";
  },
  60074: (e, t, i) => {
    "use strict";

    function s(e) {
      return e?.symbolSource && e.symbolSource() === e || e?.isActingAsSymbolSource !== undefined;
    }
    function o(e) {
      return s(e) && "quotesProvider" in e;
    }
    function n(e) {
      return s(e) && e.isActingAsSymbolSource().value();
    }
    i.d(t, {
      isActingAsSymbolSource: () => n,
      isSymbolSource: () => s,
      isSymbolSourceWithQuotesProvider: () => o
    });
  },
  23486: (e, t, i) => {
    "use strict";

    i.d(t, {
      alwaysShowLastPriceAndLastDayChange: () => s,
      lastDayChangeAvailable: () => o
    });
    i(56570);
    const s = false;
    const o = false;
  },
  85719: (e, t, i) => {
    "use strict";

    i.d(t, {
      lineToolsDoNotAffectChartInvalidation: () => s
    });
    const s = false;
  },
  67467: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      LineToolBarsPatternMode: () => s
    });
    (function (e) {
      e[e.Bars = 0] = "Bars";
      e[e.Line = 1] = "Line";
      e[e.OpenClose = 2] = "OpenClose";
      e[e.LineOpen = 3] = "LineOpen";
      e[e.LineHigh = 4] = "LineHigh";
      e[e.LineLow = 5] = "LineLow";
      e[e.LineHL2 = 6] = "LineHL2";
    })(s ||= {});
  },
  64195: (e, t, i) => {
    "use strict";

    i.d(t, {
      LineToolBrushBase: () => r
    });
    var s = i(50151);
    var o = i(29875);
    var n = i(64147);
    class r extends o.LineDataSource {
      constructor() {
        super(...arguments);
        this._hasEditableCoordinates = new n.WatchedValue(false);
        this._finished = false;
      }
      pointsCount() {
        return -1;
      }
      finished() {
        return this._finished;
      }
      finish() {
        this._finished = true;
        this._lastPoint = null;
        this._normalizePoints();
        this.createServerPoints();
      }
      hasOnlyOnePoint() {
        return this._points.length === 1;
      }
      addPoint(e, t, i) {
        if (this._finished) {
          return true;
        }
        this._lastPoint = null;
        if (this._points.length > 0) {
          const t = this._points[this._points.length - 1];
          const i = (0, s.ensureNotNull)(this.pointToScreenPoint(t));
          if ((0, s.ensureNotNull)(this.pointToScreenPoint(e)).subtract(i).length() < 2) {
            return this._finished;
          }
        }
        super.addPoint(e);
        return this._finished;
      }
      restorePoints(e, t, i) {
        super.restorePoints(e, t, i);
        this._finished = true;
      }
    }
  },
  97435: (e, t, i) => {
    "use strict";

    i.d(t, {
      CircleRenderer: () => r
    });
    var s = i(34026);
    var o = i(56468);
    var n = i(61993);
    class r {
      constructor(e) {
        this._data = e ?? null;
      }
      setData(e) {
        this._data = e;
      }
      draw(e, t) {
        if (this._data === null) {
          return;
        }
        const {
          center: i,
          radius: s,
          lineWidth: o,
          color: n,
          backColor: r
        } = this._data;
        e.save();
        const {
          horizontalPixelRatio: a,
          verticalPixelRatio: l
        } = t;
        const c = Math.max(1, Math.floor(a));
        const h = c % 2 / 2;
        const d = Math.round(i.x * a) + h;
        const u = Math.round(i.y * l) + h;
        const _ = Math.round(d + s * a);
        const p = Math.max(1, Math.floor(o * a));
        const m = _ - d - p;
        if (m > 0) {
          e.fillStyle = r;
          e.beginPath();
          e.moveTo(d + m, u);
          e.arc(d, u, m, 0, Math.PI * 2, false);
          e.fill();
        }
        const g = Math.max(c / 2, _ - d - p / 2);
        e.strokeStyle = n;
        e.lineWidth = p;
        e.beginPath();
        e.moveTo(d + g, u);
        e.arc(d, u, g, 0, Math.PI * 2, false);
        e.stroke();
        e.restore();
      }
      hitTest(e) {
        if (this._data === null || this._data.disableInteractions) {
          return null;
        }
        const {
          center: t,
          radius: i,
          backgroundHitTarget: r
        } = this._data;
        const a = (0, n.interactionTolerance)().curve;
        if (!(0, s.pointInCircle)(e, t, i + a)) {
          return null;
        }
        const l = i > a && (0, s.pointInCircle)(e, t, i - a) ? r ?? o.HitTarget.MovePointBackground : o.HitTarget.MovePoint;
        return new o.HitTestResult(l);
      }
    }
  },
  35578: (e, t, i) => {
    "use strict";

    i.d(t, {
      DEFAULT_LINE_TOOL_LINE_WIDTH: () => s
    });
    const s = 2;
  },
  65365: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      LineToolElliott: () => m,
      LineToolElliottCorrection: () => T,
      LineToolElliottDegree: () => s,
      LineToolElliottDoubleCombo: () => I,
      LineToolElliottImpulse: () => y,
      LineToolElliottTriangle: () => S,
      LineToolElliottTripleCombo: () => w
    });
    var s;
    var o;
    var n = i(11542);
    var r = i(45126);
    var a = i(29875);
    var l = i(29023);
    var c = i(32679);
    var h = i(73305);
    var d = i(85719);
    (function (e) {
      e[e.Supermillennium = 0] = "Supermillennium";
      e[e.Millennium = 1] = "Millennium";
      e[e.Submillennium = 2] = "Submillennium";
      e[e.GrandSupercycle = 3] = "GrandSupercycle";
      e[e.Supercycle = 4] = "Supercycle";
      e[e.Cycle = 5] = "Cycle";
      e[e.Primary = 6] = "Primary";
      e[e.Intermediate = 7] = "Intermediate";
      e[e.Minor = 8] = "Minor";
      e[e.Minute = 9] = "Minute";
      e[e.Minuette = 10] = "Minuette";
      e[e.Subminuette = 11] = "Subminuette";
      e[e.Micro = 12] = "Micro";
      e[e.Submicro = 13] = "Submicro";
      e[e.Minuscule = 14] = "Minuscule";
    })(s ||= {});
    (function (e) {
      e[e.Current = 4] = "Current";
    })(o ||= {});
    const u = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
    const _ = new r.TranslatedString("change Elliott degree", n.t(null, undefined, i(47977)));
    const p = [{
      value: 0,
      title: n.t(null, undefined, i(3348))
    }, {
      value: 1,
      title: n.t(null, undefined, i(87957))
    }, {
      value: 2,
      title: n.t(null, undefined, i(63375))
    }, {
      value: 3,
      title: n.t(null, undefined, i(57726))
    }, {
      value: 4,
      title: n.t(null, undefined, i(67948))
    }, {
      value: 5,
      title: n.t(null, undefined, i(87380))
    }, {
      value: 6,
      title: n.t(null, undefined, i(59189))
    }, {
      value: 7,
      title: n.t(null, undefined, i(10268))
    }, {
      value: 8,
      title: n.t(null, {
        context: "wave"
      }, i(67736))
    }, {
      value: 9,
      title: n.t(null, {
        context: "wave"
      }, i(922))
    }, {
      value: 10,
      title: n.t(null, undefined, i(14724))
    }, {
      value: 11,
      title: n.t(null, undefined, i(30585))
    }, {
      value: 12,
      title: n.t(null, undefined, i(24866))
    }, {
      value: 13,
      title: n.t(null, undefined, i(1145))
    }, {
      value: 14,
      title: n.t(null, undefined, i(78273))
    }];
    class m extends a.LineDataSource {
      constructor(e, t, s, o) {
        super(e, t ?? m.createProperties(e.backgroundTheme().spawnOwnership()), s, o);
        this.version = 4;
        Promise.all([i.e(6290), i.e(9116), i.e(1200), i.e(1583)]).then(i.bind(i, 98424)).then(e => {
          this._setPaneViews([new e.ElliottLabelsPaneView(this, this._model)]);
        });
      }
      migrateVersion(e, t, i) {
        if (i.properties.hasChild("background")) {
          i.properties.removeProperty("background");
        }
        if (i.properties.hasChild("backgroundColor")) {
          i.properties.removeProperty("backgroundColor");
        }
        if (i.properties.hasChild("showBackground")) {
          i.properties.removeProperty("showBackground");
        }
        if (e === 1) {
          const e = Object.assign({}, this._timePoint[0]);
          this._timePoint.unshift(e);
          if (this._points.length > 0) {
            const e = Object.assign({}, this._points[0]);
            this._points.unshift(e);
          }
        }
      }
      applyTemplate(e) {
        const t = e;
        delete t.background;
        delete t.backgroundColor;
        delete t.showBackground;
        super.applyTemplate(e);
      }
      name() {
        return "Elliott Labels";
      }
      async additionalActions(e) {
        return {
          actions: [new l.Action({
            actionId: "Chart.LineTool.Elliot.ChangeDegreeProperty",
            options: {
              label: n.t(null, undefined, i(23403)),
              subItems: u.map(t => {
                const i = p.filter(e => e.value === t)[0];
                return new l.Action({
                  actionId: "Chart.LineTool.Elliot.ChangeDegreeProperty",
                  options: {
                    label: i.title,
                    checkable: true,
                    checked: this.properties().childs().degree.value() === t,
                    onExecute: () => {
                      e.setProperty(this.properties().childs().degree, t, _, d.lineToolsDoNotAffectChartInvalidation);
                    }
                  }
                });
              })
            }
          })],
          placement: "CustomAction"
        };
      }
      label(e) {
        const t = u.length - this.properties().childs().degree.value() - 1;
        const i = Math.floor(t / 3);
        return {
          group: i,
          bold: !!(i % 2),
          decoration: ["", "brackets", "circle"][t % 3],
          label: this.labelsGroup()[i][e]
        };
      }
      availableDegreesValues() {
        return p;
      }
      static createProperties(e, t) {
        const i = new c.DefaultProperty({
          defaultName: "linetoolelliott",
          state: t,
          theme: e
        });
        this._configureProperties(i);
        return i;
      }
      static migrateState(e) {
        const t = {
          0: 11,
          1: 10,
          2: 9,
          3: 8,
          4: 7,
          5: 6,
          6: 5,
          7: 4,
          8: 3
        };
        const i = {
          0: 11,
          1: 8
        };
        if (e.type === "LineToolElliottSubminuette") {
          e.type = "LineToolElliottImpulse";
          e.state.degree = t[e.state.wavesize];
        }
        if (e.type === "LineToolElliottMinor") {
          e.type = "LineToolElliottImpulse";
          e.state.degree = t[e.state.wavesize];
        }
        if (e.type === "LineToolElliottCircle") {
          e.type = "LineToolElliottImpulse";
          e.state.degree = t[e.state.wavesize];
        }
        if (e.type === "LineToolElliottMinorRetr") {
          e.type = "LineToolElliottCorrection";
          e.state.degree = i[e.state.wavesize];
        }
        if (e.type === "LineToolElliottMajorRetr") {
          e.type = "LineToolElliottCorrection";
          e.state.degree = i[e.state.wavesize];
        }
      }
      async _getPropertyDefinitionsViewModelClass() {
        return (await Promise.all([i.e(6406), i.e(3889), i.e(8009), i.e(8056), i.e(8537)]).then(i.bind(i, 70491))).ElliottPatternDefinitionsViewModel;
      }
      static _configureProperties(e) {
        super._configureProperties(e);
        e.addChild("linesColors", new h.LineToolColorsProperty([e.childs().color]));
        e.addExcludedKey("linesColors", 3);
      }
    }
    class g extends m {
      pointsCount() {
        return 6;
      }
    }
    const f = [["0", "1", "2", "3", "4", "5"], ["0", "i", "ii", "iii", "iv", "v"], ["0", "1", "2", "3", "4", "5"], ["0", "I", "II", "III", "IV", "V"], ["0", "1", "2", "3", "4", "5"]];
    class y extends g {
      constructor(e, t, i, s) {
        super(e, t ?? y.createProperties(e.backgroundTheme().spawnOwnership()), i, s);
      }
      name() {
        return "Elliott Impulse Wave (12345)";
      }
      labelsGroup() {
        return f;
      }
      static createProperties(e, t) {
        const i = new c.DefaultProperty({
          defaultName: "linetoolelliottimpulse",
          state: t,
          theme: e
        });
        this._configureProperties(i);
        return i;
      }
    }
    const v = [["0", "A", "B", "C", "D", "E"], ["0", "a", "b", "c", "d", "e"], ["0", "A", "B", "C", "D", "E"], ["0", "a", "b", "c", "d", "e"], ["0", "A", "B", "C", "D", "E"]];
    class S extends g {
      constructor(e, t, i, s) {
        super(e, t ?? S.createProperties(e.backgroundTheme().spawnOwnership()), i, s);
      }
      name() {
        return "Elliott Triangle Wave (ABCDE)";
      }
      labelsGroup() {
        return v;
      }
      static createProperties(e, t) {
        const i = new c.DefaultProperty({
          defaultName: "linetoolelliotttriangle",
          state: t,
          theme: e
        });
        this._configureProperties(i);
        return i;
      }
    }
    const b = [["0", "W", "X", "Y", "X", "Z"], ["0", "w", "x", "y", "x", "z"], ["0", "W", "X", "Y", "X", "Z"], ["0", "w", "x", "y", "x", "z"], ["0", "W", "X", "Y", "X", "Z"]];
    class w extends g {
      constructor(e, t, i, s) {
        super(e, t ?? w.createProperties(e.backgroundTheme().spawnOwnership()), i, s);
      }
      name() {
        return "Elliott Triple Combo Wave (WXYXZ)";
      }
      labelsGroup() {
        return b;
      }
      static createProperties(e, t) {
        const i = new c.DefaultProperty({
          defaultName: "linetoolelliotttriplecombo",
          state: t,
          theme: e
        });
        this._configureProperties(i);
        return i;
      }
    }
    class C extends m {
      pointsCount() {
        return 4;
      }
    }
    const P = [["0", "A", "B", "C"], ["0", "a", "b", "c"], ["0", "A", "B", "C"], ["0", "a", "b", "c"], ["0", "A", "B", "C"]];
    class T extends C {
      constructor(e, t, i, s) {
        super(e, t ?? T.createProperties(e.backgroundTheme().spawnOwnership()), i, s);
      }
      name() {
        return "Elliott Correction Wave (ABC)";
      }
      labelsGroup() {
        return P;
      }
      static createProperties(e, t) {
        const i = new c.DefaultProperty({
          defaultName: "linetoolelliottcorrection",
          state: t,
          theme: e
        });
        this._configureProperties(i);
        return i;
      }
    }
    const x = [["0", "W", "X", "Y"], ["0", "w", "x", "y"], ["0", "W", "X", "Y"], ["0", "w", "x", "y"], ["0", "W", "X", "Y"]];
    class I extends C {
      constructor(e, t, i, s) {
        super(e, t ?? I.createProperties(e.backgroundTheme().spawnOwnership()), i, s);
      }
      name() {
        return "Elliott Double Combo Wave (WXY)";
      }
      labelsGroup() {
        return x;
      }
      static createProperties(e, t) {
        const i = new c.DefaultProperty({
          defaultName: "linetoolelliottdoublecombo",
          state: t,
          theme: e
        });
        this._configureProperties(i);
        return i;
      }
    }
  },
  56991: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      ExecutionLineAdapter: () => _,
      ExecutionsPositionController: () => u,
      LineToolExecution: () => p
    });
    var s = i(50151);
    var o = i(29875);
    var n = i(91920);
    var r = i(32679);
    var a = i(8025);
    var l = i(56570);
    var c = i(2718);
    var h = i(44672);
    const d = c.sortSourcesPreOrdered.LineToolExecution;
    class u {
      constructor(e) {
        this._pane = e;
      }
      getXYCoordinate(e, t, i) {
        let o = 0;
        const n = e.getDirection();
        const r = n === "buy";
        const l = this._pane.model().mainSeries();
        if (l.bars) {
          const e = r ? 10 : -10;
          const t = l.bars().search(i, a.PlotRowSearchMode.NearestLeft);
          if (t !== null) {
            i = t.index;
            const n = r ? t.value[3] : t.value[2];
            const a = l.priceScale();
            const c = (0, s.ensureNotNull)(l.firstValue());
            o = a.priceToCoordinate(n, c) + e;
          }
        }
        e.setAlignedTimePointIndex(i);
        const c = t.visibleBarsStrictRange();
        if (!isFinite(i) || c === null || i > c.lastBar() || i < c.firstBar()) {
          return {
            x: -1,
            y: -1
          };
        }
        const h = u._cachedByBarIndexOrderedExecutions[i] || this._pane.sourcesByGroup().all();
        for (let t = h.length - 1; t >= 0; --t) {
          const s = h[t];
          if (!(s instanceof p) || s.adapter().alignedTimePointIndex() !== i || s.adapter().getDirection() !== n) {
            continue;
          }
          if (s === e.line()) {
            break;
          }
          const a = s.adapter().height();
          o = r ? o + a : o - a;
        }
        return {
          x: t.indexToCoordinate(i),
          y: o
        };
      }
      static recreateOrderedByBarsSourcesCache(e) {
        this.clearOrderedByBarsSourcesCache();
        const t = e.sourcesByGroup().all();
        for (const e of t) {
          if (!(e instanceof p)) {
            continue;
          }
          const t = e.adapter().alignedTimePointIndex();
          if (t === undefined) {
            continue;
          }
          const i = u._cachedByBarIndexOrderedExecutions[t] || [];
          u._cachedByBarIndexOrderedExecutions[t] = i;
          i.push(e);
        }
      }
      static clearOrderedByBarsSourcesCache() {
        u._cachedByBarIndexOrderedExecutions = {};
      }
    }
    u._cachedByBarIndexOrderedExecutions = {};
    class _ {
      constructor(e, t) {
        this._unixtime = NaN;
        this._line = e;
        this._model = t;
      }
      alignedTimePointIndex() {
        return this._alignedTimePointIndex;
      }
      setAlignedTimePointIndex(e) {
        this._alignedTimePointIndex = e;
      }
      line() {
        return this._line;
      }
      getIndex() {
        return this._model.timeScale().baseIndex() - this._line.points()[0].index;
      }
      setIndex(e) {
        const t = this._model.timeScale().baseIndex() - Math.abs(e);
        this._line.startMoving({
          logical: this._line.points()[0]
        });
        const i = {
          ...this._line.points()[0]
        };
        i.index = t;
        this._line.move({
          logical: i
        });
        this._line.endMoving(false);
        return this;
      }
      getTime() {
        return this._unixtime;
      }
      setTime(e) {
        this._unixtime = e;
        this._line.restorePoints([{
          offset: 0,
          price: this.getPrice(),
          time_t: this._unixtime
        }], []);
        this._line.createServerPoints();
        return this;
      }
      getPrice() {
        if (this._line.points().length > 0) {
          return this._line.points()[0].price;
        } else if (this._line.normalizedPoints().length > 0) {
          return this._line.normalizedPoints()[0].price;
        } else {
          return NaN;
        }
      }
      setPrice(e) {
        if (this._line.points().length > 0) {
          this._line.points()[0].price = e;
        }
        if (this._line.normalizedPoints().length > 0) {
          this._line.normalizedPoints()[0].price = e;
        }
        return this;
      }
      getText() {
        return this._line.properties().childs().text.value();
      }
      setText(e) {
        this._line.properties().childs().text.setValue(e || "");
        this._line.updateAllViewsAndRedraw((0, h.sourceChangeEvent)(this._line.id()));
        return this;
      }
      getArrowHeight() {
        return this._line.properties().childs().arrowHeight.value();
      }
      setArrowHeight(e) {
        this._line.properties().childs().arrowHeight.setValue(e || 5);
        return this;
      }
      getArrowSpacing() {
        return this._line.properties().childs().arrowSpacing.value();
      }
      setArrowSpacing(e) {
        this._line.properties().childs().arrowSpacing.setValue(e || 1);
        return this;
      }
      getDirection() {
        return this._line.properties().childs().direction.value();
      }
      setDirection(e) {
        this._line.properties().childs().direction.setValue(e || "buy");
        return this;
      }
      getArrowColor() {
        const e = this._line.properties().childs();
        if (this.getDirection() === "buy") {
          return e.arrowBuyColor.value();
        } else {
          return e.arrowSellColor.value();
        }
      }
      setArrowColor(e) {
        if (this.getDirection() === "buy") {
          this.setArrowBuyColor(e);
        } else {
          this.setArrowSellColor(e);
        }
        return this;
      }
      setArrowBuyColor(e) {
        this._line.properties().childs().arrowBuyColor.setValue(e);
        return this;
      }
      setArrowSellColor(e) {
        this._line.properties().childs().arrowSellColor.setValue(e);
        return this;
      }
      getTextColor() {
        const e = this._line.properties().childs();
        return n.getColorFromProperties(e.textColor, e.textTransparency);
      }
      setTextColor(e) {
        const t = this._line.properties().childs();
        n.setColorToProperties(e, t.textColor, t.textTransparency);
        return this;
      }
      getFont() {
        const e = this._line.properties().childs();
        return n.getFontFromProperties(e.fontFamily, e.fontSize, e.fontBold, e.fontItalic);
      }
      setFont(e) {
        const t = this._line.properties().childs();
        n.setFontToProperties(e, t.fontFamily, t.fontSize, t.fontBold, t.fontItalic);
        return this;
      }
      setTooltip(e) {
        if (e == null) {
          e = "";
        } else {
          e += "";
        }
        this._line.properties().childs().tooltip.setValue(e);
        return this;
      }
      getTooltip() {
        return this._line.properties().childs().tooltip.value();
      }
      remove() {
        this._model.removeSource(this._line);
      }
      getPoints() {
        return this._line.points();
      }
      height() {
        const e = this.getArrowHeight();
        const t = this.getArrowSpacing();
        let i = 0;
        if (this.getText()) {
          i = n.fontHeight(this.getFont());
        }
        return e + t + i + 10;
      }
    }
    class p extends o.LineDataSource {
      constructor(e, t, s, o) {
        super(e, t ?? p.createProperties(e.backgroundTheme().spawnOwnership()), s, o);
        this._adapter = new _(this, e);
        this.customization.forcePriceAxisLabel = false;
        this.customization.disableErasing = true;
        this.setSelectionEnabled(false);
        Promise.all([i.e(6290), i.e(9116), i.e(1200), i.e(1583)]).then(i.bind(i, 256)).then(e => {
          this._setPaneViews([new e.ExecutionPaneView(this, this._model)]);
        });
      }
      adapter() {
        return this._adapter;
      }
      zorder() {
        return d;
      }
      isSpeciallyZOrderedSource() {
        return true;
      }
      pointsCount() {
        return 1;
      }
      name() {
        return "Execution";
      }
      hasContextMenu() {
        return false;
      }
      state() {
        return {};
      }
      updateAllViews(e) {
        if (this._isVisible()) {
          return super.updateAllViews(e);
        }
      }
      priceAxisViews(e, t) {
        if (this._isVisible()) {
          return super.priceAxisViews(e, t);
        } else {
          return null;
        }
      }
      paneViews() {
        if (window.TradingView.printing && !l.enabled("snapshot_trading_drawings")) {
          return null;
        } else if (this._isVisible()) {
          return super.paneViews();
        } else {
          return null;
        }
      }
      userEditEnabled() {
        return false;
      }
      showInObjectTree() {
        return false;
      }
      cloneable() {
        return false;
      }
      copiable() {
        return false;
      }
      isSynchronizable() {
        return false;
      }
      static createProperties(e, t) {
        const i = new r.DefaultProperty({
          defaultName: "linetoolexecution",
          state: t,
          useUserPreferences: false,
          theme: e
        });
        p._configureProperties(i);
        return i;
      }
      _isVisible() {
        return this._model.properties().childs().tradingProperties.childs().showExecutions.value();
      }
    }
  },
  25931: (e, t, i) => {
    "use strict";

    i.d(t, {
      checkImageSize: () => c,
      generateLink: () => a,
      getMaxImageSizeInBytes: () => d,
      getMaxImageSizeLabel: () => u,
      imageIsOversized: () => l,
      setImageStorageAdapter: () => r,
      uploadImage: () => h
    });
    var s = i(11542);
    const o = /data:(.+?);base64,(.+)/;
    let n = 2000000;
    function r(e) {
      n = e.getMaxImageSizeInBytes();
    }
    async function a(e) {
      return new Promise((t, i) => {
        const s = new FileReader();
        s.addEventListener("load", () => t(s.result));
        s.addEventListener("error", i);
        s.addEventListener("abort", i);
        s.readAsDataURL(e);
      });
    }
    function l(e) {
      return function (e) {
        const t = e.match(o);
        if (t === null) {
          return Infinity;
        }
        const [i, s, n] = t;
        const r = atob(n);
        const a = new Array(r.length);
        for (let e = 0; e < r.length; e++) {
          a[e] = r.charCodeAt(e);
        }
        const l = new Uint8Array(a);
        return new Blob([l], {
          type: s
        }).size;
      }(e.src) > n;
    }
    async function c(e) {
      return e.size <= n;
    }
    async function h(e) {
      if (!(await c(e))) {
        throw new Error(s.t(null, {
          replace: {
            value: u()
          }
        }, i(93738)));
      }
      return a(e);
    }
    function d() {
      return n;
    }
    function u() {
      const e = Math.floor(Math.log(n) / Math.log(1000));
      return `${(n / Math.pow(1000, e)).toFixed(2)}${["Bytes", "KB", "MB", "GB", "TB", "PB"][e]}`;
    }
  },
  3503: (e, t, i) => {
    "use strict";

    i.d(t, {
      blobImageFilter: () => o,
      checkImageSize: () => a,
      generateLink: () => r,
      getMaxImageSizeInBytes: () => c,
      getMaxImageSizeLabel: () => h,
      imageIsOversized: () => n,
      uploadImage: () => l
    });
    var s = i(25931);
    function o(e) {
      return e.type === "image/png" || e.type === "image/jpeg" || e.type === "image/webp";
    }
    function n(e) {
      return s.imageIsOversized(e);
    }
    async function r(e) {
      return {
        status: "ok",
        data: {
          url: await s.generateLink(e),
          fields: {}
        },
        filename: "",
        filepath: ""
      };
    }
    async function a(e) {
      return s.checkImageSize(e);
    }
    async function l(e) {
      return s.uploadImage(e);
    }
    function c() {
      return s.getMaxImageSizeInBytes();
    }
    function h() {
      return s.getMaxImageSizeLabel();
    }
  },
  70262: (e, t, i) => {
    "use strict";

    i.d(t, {
      drawSelection: () => r,
      getSymbolCoordinatesInfo: () => n
    });
    var s = i(63273);
    var o = i(7114);
    function n(e) {
      const {
        symbolPosition: t,
        textWidth: i,
        textByLines: n,
        lineHeight: r,
        font: a,
        textAlign: l,
        lineSpacing: c = 0
      } = e;
      let h = 0;
      let d = 0;
      const u = (0, s.isRtl)();
      const _ = r + c;
      let p = 0;
      let m = 0;
      let g = "";
      for (let e = 0; e < n.length; e++) {
        let s = t - p;
        const {
          wrappedLinePart: r,
          wrappedLineEnd: c,
          hidden: f,
          text: y
        } = n[e];
        const v = e < n.length - 1 ? n[e + 1] : null;
        if (!f) {
          g = y;
        }
        if (v && s > y.length) {
          p += y.length + (r && !c ? 0 : 1);
          if (!f) {
            h += _;
          }
          continue;
        }
        if (f) {
          h -= _;
        }
        const S = r && !c && y.length === s && v && !v.hidden;
        if (f) {
          g += "\u202F";
          s = g.length;
        }
        if (l === "center") {
          if (S) {
            d = i / 2;
          } else {
            const e = (0, o.measureText)(g, a).width;
            const t = (0, o.measureText)(g.slice(0, s), a).width;
            const n = i / 2;
            d = u ? n + e / 2 - t : n - e / 2 + t;
          }
        } else if (l === "right" && !u || l === "left" && u || l === "end") {
          if (S) {
            d = i;
          } else {
            const e = (0, o.measureText)(g.slice(s), a).width;
            d = u ? e : i - e;
          }
        } else if (S) {
          d = 0;
        } else {
          const e = (0, o.measureText)(g.slice(0, s), a).width;
          d = u ? i - e : e;
        }
        if (S) {
          m = e + 1;
          h += _;
        } else {
          m = e;
        }
        break;
      }
      return {
        x: d,
        y: h,
        lineNumber: m
      };
    }
    function r(e, t, i) {
      const {
        lines: n,
        selectionStart: r,
        selectionEnd: l,
        left: c,
        right: h,
        color: d,
        font: u,
        lineHeight: _,
        lineSpacing: p = 0
      } = i;
      e.save();
      const m = (c + h) / 2;
      const g = _ + p;
      const f = (0, s.isRtl)();
      e.fillStyle = d;
      const {
        horizontalPixelRatio: y,
        verticalPixelRatio: v
      } = t;
      if (r.lineNumber === l.lineNumber) {
        const t = Math.round(r.x * y);
        const i = Math.round(r.y * v);
        const s = Math.round(l.x * y);
        e.fillRect(Math.min(t, s), i, Math.abs(t - s), Math.round(g * v));
      } else {
        const t = (0, o.measureText)(" ", u).width;
        let i = 0;
        for (let s = r.lineNumber; s <= l.lineNumber; s += 1) {
          const o = s === r.lineNumber;
          const d = s === l.lineNumber;
          const _ = n[s];
          if (_.hidden) {
            continue;
          }
          const p = a(_.text, u);
          let S;
          let b;
          let w = false;
          if (e.textAlign === "center") {
            S = o ? r.x : f ? m + p / 2 : m - p / 2;
            b = d ? l.x : f ? m - p / 2 : m + p / 2;
          } else if (e.textAlign === "right" || f && e.textAlign === "start" || !f && e.textAlign === "end") {
            S = o ? r.x : h - p;
            b = d ? l.x : h;
            w = true;
          } else {
            S = o ? r.x : c;
            b = d ? l.x : c + p;
          }
          let C = Math.min(S, b);
          let P = Math.max(S, b);
          if (!d && (!_.wrappedLinePart || !!_.wrappedLineEnd)) {
            if (w) {
              C -= t;
            } else {
              P += t;
            }
          }
          const T = Math.round(C * y);
          const x = Math.round(P * y);
          const I = Math.round((r.y + i * g) * v);
          const M = Math.round((r.y + (i + 1) * g) * v);
          e.fillRect(T, I, x - T, M - I);
          i += 1;
        }
      }
      e.restore();
    }
    function a(e, t) {
      return (0, o.measureText)(e, t).width;
    }
  },
  15764: (e, t, i) => {
    "use strict";

    i.d(t, {
      isLineDrawnWithPressedButton: () => l,
      isLineToolDrawWithoutPoints: () => h,
      isLineToolFinishRequiredWhenCreatedByApi: () => c,
      isLineToolName: () => a,
      isMtpPredictorToolName: () => n,
      isStudyLineToolName: () => r,
      isTextToolName: () => d,
      simpleLineToolNames: () => o
    });
    const s = new Set([]);
    const o = new Set(["LineToolFibRetracement", "LineToolFibChannel", "LineToolFibSpeedResistanceArcs", "LineToolProjection", "LineToolTrendBasedFibExtension", "LineToolElliott", "LineToolFibCircles", "LineToolVertLine", "LineToolCrossLine", "LineToolBarsPattern", "LineToolTrendBasedFibTime", "LineToolFibTimeZone", "LineToolCircleLines", "LineToolDateRange", "LineToolPriceRange", "LineToolDateAndPriceRange", "LineToolParallelChannel", "LineToolTrendAngle", "LineToolTrendLine", "LineToolInfoLine", "LineToolArrowMark", "LineToolPitchfan", "LineToolGannSquare", "LineToolFibSpeedResistanceFan", "LineToolGannComplex", "LineToolGannFixed", "LineToolGannFan", "LineToolFibWedge", "LineToolPitchfork", "LineToolDisjointAngle", "LineToolFlatBottom", "LineToolIcon", "LineToolEmoji", "LineToolSticker", "LineToolRotatedRectangle", "LineToolFibSpiral", "LineToolHeadAndShoulders", "LineToolTriangle", "LineToolTrianglePattern", "LineTool5PointsPattern", "LineToolThreeDrivers", "LineToolABCD", "LineToolPolyline", "LineToolPath", "LineToolPrediction", "LineToolPriceLabel", "LineToolPriceNote", "LineToolTextNote", "LineToolNote", "LineToolNoteAbsolute", "LineToolArrowMarker", "LineToolSignpost", "LineToolBrush", "LineToolArc", "LineToolCallout", "LineToolBalloon", "LineToolComment", "LineToolText", "LineToolHorzLine", "LineToolHorzRay", "LineToolRectangle", "LineToolCircle", "LineToolEllipse", "LineToolTimeCycles", "LineToolSineLine", "LineToolGhostFeed", "LineToolBezierQuadro", "LineToolBezierCubic", "LineToolArrow", "LineToolRay", "LineToolExtended", "LineToolSchiffPitchfork", "LineToolSchiffPitchfork2", "LineToolInsidePitchfork", "LineToolTextAbsolute", "LineToolArrowMarkLeft", "LineToolArrowMarkRight", "LineToolArrowMarkUp", "LineToolArrowMarkDown", "LineToolFlagMark", "LineToolCypherPattern", "LineToolElliottImpulse", "LineToolElliottTriangle", "LineToolElliottTripleCombo", "LineToolElliottCorrection", "LineToolElliottDoubleCombo", "LineToolRiskRewardLong", "LineToolRiskRewardShort", "LineToolPosition", "LineToolOrder", "LineToolHighlighter", "LineToolTable", "LineToolImage"]);
    function n(e) {
      return s.has(e);
    }
    function r(e) {
      return e === "LineToolRegressionTrend" || e === "LineToolVbPFixed" || e === "LineToolFixedRangeVolumeProfile" || e === "LineToolAnchoredVolumeProfile" || e === "LineToolAnchoredVWAP";
    }
    function a(e) {
      return o.has(e) || r(e);
    }
    function l(e) {
      return e === "LineToolBrush" || e === "LineToolHighlighter";
    }
    function c(e) {
      return l(e) || e === "LineToolPath" || e === "LineToolPolyline" || e === "LineToolGhostFeed";
    }
    function h(e) {
      return e === "LineToolTweet" || e === "LineToolIdea" || e === "LineToolImage";
    }
    function d(e) {
      switch (e) {
        case "LineToolBalloon":
        case "LineToolComment":
        case "LineToolText":
        case "LineToolTextAbsolute":
        case "LineToolCallout":
        case "LineToolNote":
        case "LineToolNoteAbsolute":
        case "LineToolSignpost":
          return true;
      }
      return false;
    }
    o.add("LineToolExecution");
  },
  78956: (e, t, i) => {
    "use strict";

    i.d(t, {
      isLineTool: () => o
    });
    var s = i(29875);
    function o(e) {
      return e instanceof s.LineDataSource;
    }
  },
  20834: (e, t, i) => {
    "use strict";

    i.d(t, {
      LineDataSourcePointIndexProperty: () => o
    });
    var s = i(12988);
    class o extends s.Property {
      constructor(e, t) {
        super();
        this._waitingPointsetUpdate = false;
        this._lineSource = e;
        this._pointIndex = t;
        this._cachedIndex = this.value();
      }
      value() {
        const e = this._lineSource.points();
        if (e.length === 0) {
          return this._cachedIndex;
        } else {
          return e[this._pointIndex].index;
        }
      }
      setValue(e) {
        this._cachedIndex = e;
        const t = this._lineSource.points();
        const i = e => {
          const t = this._lineSource.points()[this._pointIndex];
          if (t.index === e) {
            return;
          }
          t.index = e;
          this._lineSource.startChanging(this._pointIndex, t);
          this._setPointImpl(t);
          this._lineSource.model().updateSource(this._lineSource);
          this._listeners.fire(this, "");
          const i = this._lineSource.endChanging(true, false);
          this._lineSource.syncMultichartState(i);
        };
        if (t.length === 0) {
          const e = () => {
            i(this._cachedIndex);
            this._waitingPointsetUpdate = false;
          };
          if (this._waitingPointsetUpdate) {
            return;
          }
          this._lineSource.pointsetUpdated().subscribe(this, e, true);
          this._waitingPointsetUpdate = true;
        } else {
          i(e);
        }
      }
      _setPointImpl(e) {
        this._lineSource.setPoint(this._pointIndex, e);
      }
    }
  },
  90793: (e, t, i) => {
    "use strict";

    i.d(t, {
      LineToolPriceAxisView: () => r
    });
    var s = i(50151);
    var o = i(98558);
    var n = i(19063);
    class r extends o.PriceAxisView {
      constructor(e, t) {
        super();
        this._source = e;
        this._data = t;
        this._properties = e.model().properties().childs().scalesProperties;
      }
      _updateRendererData(e, t, i) {
        e.visible = false;
        const s = this._source.model();
        if (!s.timeScale() || s.timeScale().isEmpty()) {
          return;
        }
        const o = this._source.priceScale();
        if (o === null || o.isEmpty()) {
          return;
        }
        if (!s.selection().isSelected(this._source) && !this._source.isForcedDrawPriceAxisLabel()) {
          return;
        }
        if (s.timeScale().visibleBarsStrictRange() === null) {
          return;
        }
        const r = this._source.priceAxisPoints();
        const a = this._data.pointIndex;
        if (r.length <= a) {
          return;
        }
        const l = r[a];
        if (!isFinite(l.price)) {
          return;
        }
        const c = this._source.ownerSource();
        const h = c !== null ? c.firstValue() : null;
        if (h === null) {
          return;
        }
        let d = this._data.backgroundPropertyGetter ? this._data.backgroundPropertyGetter() : null;
        if (d === null) {
          d = this._getBgColor();
        }
        i.background = (0, n.resetTransparency)(d);
        i.borderColor = "#2E84A6";
        i.textColor = this.generateTextColor(i.background);
        i.coordinate = o.priceToCoordinate(l.price, h);
        e.text = this._formatPrice(l.price, h);
        e.visible = true;
      }
      _getBgColor() {
        if (this._active) {
          return this._properties.childs().axisLineToolLabelBackgroundColorActive.value();
        } else {
          return this._properties.childs().axisLineToolLabelBackgroundColorCommon.value();
        }
      }
      _formatPrice(e, t) {
        return (0, s.ensureNotNull)(this._source.priceScale()).formatPrice(e, t);
      }
    }
  },
  14169: (e, t, i) => {
    "use strict";

    i.d(t, {
      LineDataSourceTimeAxisView: () => o
    });
    var s = i(66156);
    class o extends s.TimeAxisView {
      constructor(e, t) {
        super(e.model());
        this._active = false;
        this._source = e;
        this._pointIndex = t;
        this._properties = e.model().properties().childs().scalesProperties;
      }
      setActive(e) {
        this._active = e;
      }
      _getBgColor() {
        if (this._active) {
          return this._properties.childs().axisLineToolLabelBackgroundColorActive.value();
        } else {
          return this._properties.childs().axisLineToolLabelBackgroundColorCommon.value();
        }
      }
      _getIndex() {
        if (!this._model.selection().isSelected(this._source)) {
          return null;
        }
        const e = this._source.timeAxisPoints();
        if (e.length <= this._pointIndex) {
          return null;
        } else {
          return e[this._pointIndex].index;
        }
      }
      _isVisible() {
        return true;
      }
    }
  },
  29875: (e, t, i) => {
    "use strict";

    i.d(t, {
      LineDataSource: () => z,
      changePointUndoText: () => H
    });
    var s = i(7029);
    var o = i(86441);
    var n = i(50151);
    var r = i(76422);
    var a = i(9343);
    var l = i(56570);
    var c = i(53388);
    var h = i(40644);
    var d = i(52033);
    var u = i(18832);
    var _ = i(64147);
    var p = i(62288);
    var m = i(45687);
    var g = i(10892);
    var f = i(31229);
    var y = i(68805);
    var v = i(76350);
    var S = i(85049);
    var b = i(12988);
    var w = i(928);
    var C = i(29137);
    var P = i(94260);
    var T = i(37265);
    var x = i(44672);
    var I = i(60074);
    var M = i(45126);
    var A = i(20834);
    class L extends b.Property {
      constructor(e, t) {
        super();
        this._lineSource = e;
        this._pointIndex = t;
        e.pointAdded().subscribe(this, e => {
          if (this._pointIndex === e) {
            this._listeners.fire(this, `${e}`);
          }
        });
        e.pointChanged().subscribe(this, e => {
          if (this._pointIndex === e) {
            this._listeners.fire(this, `${e}`);
          }
        });
      }
      value() {
        const e = this._lineSource.points()[this._pointIndex].price;
        const t = (0, n.ensureNotNull)(this._lineSource.ownerSource()).formatter();
        if (t.parse) {
          const i = t.format(e);
          const s = t.parse(i);
          if (s.res) {
            return s.value;
          } else {
            return e;
          }
        }
        return e;
      }
      setValue(e) {
        const t = this._lineSource.points()[this._pointIndex];
        t.price = parseFloat("" + e);
        this._lineSource.startChanging(this._pointIndex, t);
        this._lineSource.setPoint(this._pointIndex, t);
        this._lineSource.model().updateSource(this._lineSource);
        this._listeners.fire(this, "");
        const i = this._lineSource.endChanging(true, false);
        this._lineSource.syncMultichartState(i);
      }
    }
    var k = i(14169);
    var D = i(90793);
    var E = i(73305);
    var B = i(98523);
    var V = i(35039);
    var R = i(7927);
    const N = (0, a.getLogger)("Chart.LineDataSource");
    const O = l.enabled("datasource_copypaste");
    class F {
      constructor() {
        this._states = [];
      }
      start(e) {
        this._states.push(e);
      }
      finish(e) {
        const t = (0, n.ensureDefined)(this._states.pop());
        s = t;
        if ((i = e).length !== s.length) {
          return {
            indexesChanged: true,
            pricesChanged: true
          };
        } else {
          return i.reduce((e, t, i) => {
            const o = s[i];
            e.indexesChanged = e.indexesChanged || t.index !== o.index;
            e.pricesChanged = e.pricesChanged || t.price !== o.price;
            return e;
          }, {
            indexesChanged: false,
            pricesChanged: false
          });
        }
        var i;
        var s;
      }
      isEmpty() {
        return this._states.length === 0;
      }
    }
    let W = 0;
    const H = new M.TranslatedString("change point", s.t(null, undefined, i(76660)));
    class z extends C.DataSource {
      constructor(e, t, i, s) {
        super(s);
        this.version = 1;
        this.toolname = "";
        this.customization = {
          forcePriceAxisLabel: false,
          disableErasing: false,
          disableSave: false,
          showInObjectsTree: true
        };
        this._currentPointsetAndSymbolId = null;
        this._pointChanged = new d.Delegate();
        this._pointAdded = new d.Delegate();
        this._priceAxisViews = [];
        this._timeAxisViews = [];
        this._timePoint = [];
        this._points = [];
        this._lastPoint = null;
        this._paneViews = new Map();
        this._normalizedPointsChanged = new d.Delegate();
        this._fixedPointsChanged = new d.Delegate();
        this._changeStatesStack = new F();
        this._startMovingPoint = null;
        this._currentMovingPoint = null;
        this._isActualSymbol = false;
        this._isActualInterval = false;
        this._isActualCurrency = false;
        this._isActualUnit = false;
        this._sharingMode = new _.WatchedValue(0);
        this._onTemplateApplying = new d.Delegate();
        this._onTemplateApplied = new d.Delegate();
        this._syncStateExclusions = ["interval"];
        this._definitionsViewModel = null;
        this._hasEditableCoordinates = new _.WatchedValue(true);
        this._syncLineStyleMuted = false;
        this._onIsActualIntervalChange = new d.Delegate();
        this._onPointsetUpdatedDelegate = new d.Delegate();
        this._onServerUpdateTime = new d.Delegate();
        this._linkKey = new _.WatchedValue(null);
        this._serverUpdateTime = null;
        this._boundCalcIsActualSymbol = this.calcIsActualSymbol.bind(this);
        this._alignerCache = null;
        this._alertUndoMode = false;
        this._onAlertStatusChanged = () => {
          this.updateAllViewsAndRedraw((0, x.sourceChangeEvent)(this.id()));
        };
        this._model = e;
        this._properties = t;
        this._localAndServerAlertsMismatch = false;
        if (!this._properties.hasChild("interval")) {
          this._properties.addChild("interval", new b.Property(e.mainSeries().interval()));
        }
        this.calcIsActualSymbol();
        this._properties.childs().intervalsVisibilities.subscribe(this, this.calcIsActualSymbol);
        this._properties.subscribe(this, this.propertiesChanged.bind(this, false, undefined));
        this.zOrderChanged().subscribe(this, this.propertiesChanged.bind(this, true, undefined));
        this._createPointsProperties();
        if (this.pointsCount() > 0) {
          for (let e = 0; e < this.pointsCount(); e++) {
            this._priceAxisViews.push(this.createPriceAxisView(e));
            this._timeAxisViews.push(new k.LineDataSourceTimeAxisView(this, e));
          }
        }
        this._properties.childs().visible.subscribe(this, e => {
          const t = (0, w.hideAllDrawings)().value() === false;
          if (e.value()) {
            if (e.value() && t) {
              r.emit("drawing_event", this._id.value(), "show");
            }
          } else {
            if (this._model.selection().isSelected(this)) {
              this._model.selectionMacro(e => {
                e.removeSourceFromSelection(this);
              });
            }
            if (t) {
              r.emit("drawing_event", this._id.value(), "hide");
            }
          }
          this._onSourceHiddenMayChange();
        });
        (0, w.hideAllDrawings)().subscribe(this, this._onSourceHiddenMayChange);
        this._sessionConnected = this._model.chartApi().isConnected().spawn();
        this._sessionConnected.subscribe(e => {
          if (!e) {
            this._currentPointsetAndSymbolId = null;
          }
        });
        this._alertStatus.subscribe(this._onAlertStatusChanged);
        this._definitionsViewModel = null;
        this._properties.setNameInOwner((0, R.propertyPathForSource)(this));
      }
      destroy() {
        this._paneViews.forEach((e, t) => this._destroyPanePaneViews(t));
        this.stop();
        if (this._definitionsViewModel !== null) {
          this._definitionsViewModel.destroy();
          this._definitionsViewModel = null;
        }
        if (this._ownerSource !== null) {
          this._ownerSource.currencyChanged().unsubscribeAll(this);
          this._ownerSource.unitChanged().unsubscribeAll(this);
          if ((0, I.isSymbolSource)(this._ownerSource)) {
            this._ownerSource.symbolResolved().unsubscribeAll(this);
            this._ownerSource.isActingAsSymbolSource().unsubscribe(this._boundCalcIsActualSymbol);
          }
        }
        this.ownerSourceChanged().unsubscribeAll(this);
        (0, w.hideAllDrawings)().unsubscribeAll(this);
        this._sessionConnected.destroy();
        this._alertStatus.unsubscribe(this._onAlertStatusChanged);
        this._properties.destroy();
        super.destroy();
      }
      setId(e) {
        super.setId(e);
        this._properties.setNameInOwner((0, R.propertyPathForSource)(this));
      }
      priceScale() {
        if (this._ownerSource) {
          return this._ownerSource.priceScale();
        } else {
          return null;
        }
      }
      createPriceAxisView(e) {
        return new D.LineToolPriceAxisView(this, {
          pointIndex: e
        });
      }
      model() {
        return this._model;
      }
      symbol() {
        return this._properties.childs().symbol.value();
      }
      linkKey() {
        return this._linkKey;
      }
      serverUpdateTime() {
        return this._serverUpdateTime;
      }
      setServerUpdateTime(e) {
        this._serverUpdateTime = e;
        this._onServerUpdateTime.fire();
      }
      serverUpdateTimeChanged() {
        return this._onServerUpdateTime;
      }
      boundToSymbol() {
        return true;
      }
      isAvailableInFloatingWidget() {
        return true;
      }
      points() {
        const e = [];
        for (let t = 0; t < this._points.length; t++) {
          const i = this._points[t];
          e.push({
            index: i.index,
            price: i.price,
            time: i.time
          });
        }
        if (this._lastPoint) {
          e.push(this._correctLastPoint(this._lastPoint));
        }
        if (!this.isFixed() && this._currentMovingPoint && this._startMovingPoint) {
          this._correctPoints(e);
        }
        return e;
      }
      timeAxisPoints() {
        return this.points();
      }
      priceAxisPoints() {
        return this.points();
      }
      fixedPoint() {
        if (!this.isFixed()) {
          return;
        }
        let e;
        const t = this.priceScale();
        if (this._positionPercents && t !== null && !t.isEmpty()) {
          const i = this._positionPercents;
          const s = this._model.timeScale().width() * i.x;
          const n = t.height() * i.y;
          e = new o.Point(s, n);
        } else if (this._fixedPoint !== undefined) {
          e = this._fixedPoint?.clone();
        }
        if (this._currentMovingPoint && this._startMovingPoint && e !== undefined) {
          const t = this._correctFixedPoint(e);
          if (t.didCorrect) {
            e = t.point;
          }
        }
        return e;
      }
      positionPercents() {
        if (this.isFixed()) {
          return this._positionPercents;
        } else {
          return undefined;
        }
      }
      clearFixedPoint() {
        this._fixedPoint = undefined;
        this._positionPercents = undefined;
      }
      normalizedPoints() {
        return this._timePoint;
      }
      normalizedPointsForCreating() {
        return this.normalizedPoints();
      }
      normalizedPointsChanged() {
        return this._normalizedPointsChanged;
      }
      fixedPointChanged() {
        return this._fixedPointsChanged;
      }
      geometry() {
        const e = (0, n.ensureNotNull)(this.priceScale());
        return this.points().map(t => {
          const i = (0, n.ensureNotNull)(this.pointToScreenPoint(t));
          const s = i.x / this._model.timeScale().width();
          const r = i.y / e.height();
          return new o.Point(s, r);
        });
      }
      widthsProperty() {
        return this._properties.childs().linesWidths ?? null;
      }
      lineColorsProperty() {
        return this._properties.childs().linesColors ?? null;
      }
      backgroundColorsProperty() {
        return this._properties.childs().backgroundsColors ?? null;
      }
      textColorsProperty() {
        return this._properties.childs().textsColors ?? null;
      }
      pointsProperty() {
        return this._pointsProperty;
      }
      hasEditableCoordinates() {
        return this._hasEditableCoordinates;
      }
      startMoving(e, t, i, s) {
        if (this.isFixed()) {
          this.restoreFixedPoint();
        }
        this._startMovingPoint = e;
      }
      move(e, t, i, s) {
        if (i && (i.shiftOnly() || i.modShift())) {
          if (this.isFixed()) {
            const t = this._alignScreenPointHorizontallyOrVertically((0, n.ensureDefined)(e.screen));
            this._currentMovingPoint = {
              screen: t
            };
          } else {
            const t = this._alignPointHorizontallyOrVertically((0, n.ensureDefined)(e.logical));
            const i = (0, n.ensureNotNull)(this.pointToScreenPoint(t));
            this._currentMovingPoint = {
              logical: t,
              screen: i
            };
          }
        } else {
          this._currentMovingPoint = e;
        }
        this.updateAllViews((0, x.sourceChangeEvent)(this.id()));
      }
      endMoving(e, t, i) {
        let s = false;
        let o = false;
        if (this._currentMovingPoint && this._startMovingPoint) {
          if (this.isFixed()) {
            const e = this._correctFixedPoint((0, n.ensureDefined)(this._fixedPoint));
            if (e.didCorrect) {
              this._fixedPoint = e.point;
              this._fixedPointsChanged.fire();
            }
          } else {
            const e = (0, n.ensureDefined)(this._currentMovingPoint.logical);
            const t = (0, n.ensureDefined)(this._startMovingPoint.logical);
            s = e.index !== t.index;
            o = e.price !== t.price;
            if (this._correctPoints(this._points, i)) {
              const e = this._id.value();
              r.emit("drawing_event", e, "move");
              r.emit("drawing_event", e, "points_changed");
              for (let e = 0; e < this._points.length; e++) {
                this._pointChanged.fire(e);
              }
            }
          }
          this._startMovingPoint = null;
          this._currentMovingPoint = null;
        }
        const a = {
          indexesChanged: s,
          pricesChanged: o
        };
        if (this.isFixed()) {
          this.calcPositionPercents();
          this.updateAllViews((0, x.sourceChangeEvent)(this.id()));
          return a;
        } else {
          if (s) {
            this._points.forEach(e => e.interval = this._model.mainSeries().interval());
          }
          this.updateAllViews((0, x.sourceChangeEvent)(this.id()));
          if (s && !e) {
            this._properties.childs().interval.setValue(this._model.mainSeries().interval());
            this._normalizePoints();
            this.createServerPoints();
          } else {
            this._copyPricesWithoutNormalization();
            this._normalizedPointsChanged.fire();
          }
          return a;
        }
      }
      startMovingPoint() {
        if (this._startMovingPoint) {
          return {
            ...this._startMovingPoint
          };
        } else {
          return null;
        }
      }
      currentMovingPoint() {
        if (this._currentMovingPoint) {
          return {
            ...this._currentMovingPoint
          };
        } else {
          return null;
        }
      }
      changePointUndoText(e) {
        return H;
      }
      startChanging(e, t) {
        if (this.isFixed()) {
          this.restoreFixedPoint();
        }
        if (e !== undefined && t !== undefined) {
          if (e < this._priceAxisViews.length) {
            this._priceAxisViews[e].setActive(true);
          }
          if (e < this._timeAxisViews.length) {
            this._timeAxisViews[e].setActive(true);
          }
        }
        this._changeStatesStack.start(this.points());
      }
      endChanging(e, t, i) {
        const s = this._changeStatesStack.finish(this.points());
        if (s.indexesChanged && this._changeStatesStack.isEmpty()) {
          this._normalizePoints();
          if (!t) {
            this.createServerPoints();
          }
        } else {
          this._copyPricesWithoutNormalization();
          this._normalizedPointsChanged.fire();
        }
        r.emit("drawing_event", this._id.value(), "points_changed");
        for (let e = 0; e < this._priceAxisViews.length; e++) {
          this._priceAxisViews[e].setActive(false);
        }
        for (let e = 0; e < this._timeAxisViews.length; e++) {
          this._timeAxisViews[e].setActive(false);
        }
        return s;
      }
      setPoint(e, t, i, s) {
        if (this._snapTo45DegreesApplicable(i)) {
          const i = e === 0 ? 1 : e - 1;
          this.snapPoint45Degree(t, this.points()[i]);
        }
        this._setPoint(e, {
          ...t,
          interval: this._model.mainSeries().interval()
        });
      }
      getPoint(e) {
        return this.points()[e] || null;
      }
      alignCrossHairToAnchor(e) {
        return true;
      }
      alignCrossHairToMovePoint() {
        return false;
      }
      setLastPoint(e, t, i = true) {
        this._lastPoint = i ? this._preparePoint(e, t) : e;
        this.updateAllViews((0, x.sourceChangeEvent)(this.id()));
        return this._lastPoint;
      }
      lastPoint() {
        return this._lastPoint;
      }
      getChangePointForSync(e) {
        return this.getPoint(e);
      }
      setPoints(e) {
        const t = this._model.mainSeries().interval();
        this._points = e.map(e => ({
          ...e,
          interval: e.interval ?? t
        }));
      }
      isForcedDrawPriceAxisLabel() {
        return this.customization.forcePriceAxisLabel;
      }
      clearData() {
        this._points = [];
      }
      denormalizeTimePoints() {
        let e = [];
        const t = this._model.mainSeries().interval();
        for (let i = 0; i < this._timePoint.length; i++) {
          const s = this._model.timeScale().denormalizeTimePoint(this._timePoint[i]);
          if (s === undefined) {
            e = [];
            break;
          }
          e.push({
            index: s,
            price: this._timePoint[i].price,
            interval: this._timePoint[i].interval ?? t
          });
        }
        if (e.length > 0) {
          this._points = e;
        }
      }
      restorePoints(e, t, i) {
        const s = this._timePoint.length > 0 && !(0, T.deepEquals)(this._timePoint, e)[0];
        const o = this._properties.childs().interval.value();
        this._timePoint = e.map(e => ({
          ...e,
          interval: e.interval ?? o
        }));
        const n = this._model.mainSeries().interval();
        this._points = t.map(e => ({
          ...e,
          interval: n
        }));
        if (!i) {
          this.denormalizeTimePoints();
        }
        if (s) {
          this._normalizedPointsChanged.fire();
        }
      }
      restorePositionPercents(e) {
        this._positionPercents = e;
        this.restoreFixedPoint();
      }
      calcIsActualSymbol() {
        const e = this.ownerSource();
        if (e === null) {
          this._isActualSymbol = false;
        } else {
          const t = (0, n.ensureNotNull)(e.symbolSource());
          const i = t.symbolInfo();
          if (i) {
            this._migrateSymbolProperty(i);
            const e = this._properties.childs().symbol;
            const s = e.value();
            this._isActualSymbol = t.symbolSameAsCurrent(s);
            if (this._isActualSymbol) {
              const o = (0, y.extractLineToolSymbolFromSymbolInfo)(i, t.symbol());
              if (!(0, v.areEqualSymbols)(s, o)) {
                N.logWarn("Possible drawing \"migrating\" detected from \"" + s + "\" to \"" + o + "\"");
                N.logWarn("Series symbolInfo: " + JSON.stringify(t.symbolInfo()));
                N.logWarn(`${new Error().stack}`);
              }
              e.setValue(o);
            }
          }
        }
        this.calcIsActualInterval();
        this.calcIsActualCurrency();
        this.calcIsActualUnit();
        this._onSourceHiddenMayChange();
      }
      calcIsActualCurrency() {
        const e = this.ownerSource();
        if (e === null) {
          this._isActualCurrency = false;
          return;
        }
        let t = this._properties.childs().currencyId.value();
        if (t !== null) {
          const i = e.symbolSource();
          0;
          this._isActualCurrency = t === (0, y.symbolCurrency)(i.symbolInfo(), undefined, true);
        } else {
          const t = (0, n.ensureNotNull)(e.symbolSource());
          this._isActualCurrency = t.symbolInfo() !== null && !t.isConvertedToOtherCurrency();
        }
        this._onSourceHiddenMayChange();
      }
      calcIsActualUnit() {
        const e = this.ownerSource();
        if (e === null) {
          this._isActualUnit = false;
          return;
        }
        const t = this._properties.childs().unitId.value();
        if (t !== null) {
          this._isActualUnit = t === (0, n.ensureNotNull)(e.symbolSource()).unit();
        } else {
          const t = (0, n.ensureNotNull)(e.symbolSource());
          this._isActualUnit = t.symbolInfo() !== null && !t.isConvertedToOtherUnit();
        }
        this._onSourceHiddenMayChange();
      }
      calcIsActualInterval() {
        const e = this._isActualInterval;
        const t = this._properties;
        const i = this._model.mainSeries();
        this._isActualInterval = (0, g.isActualInterval)(S.Interval.parse(i.interval()), t.childs().intervalsVisibilities);
        if (!this._isActualInterval && this._model.selection().isSelected(this)) {
          this._model.selectionMacro(e => e.removeSourceFromSelection(this));
        }
        if (this._isActualInterval !== e) {
          this._onIsActualIntervalChange.fire();
        }
        this._onSourceHiddenMayChange();
      }
      paneViews(e) {
        if (this.isSourceHidden()) {
          return null;
        }
        const t = this._getPaneViews(this.isMultiPaneAvailable() ? e : undefined);
        if (t === null) {
          return null;
        }
        if (t.length === 1) {
          return [t[0]];
        }
        const i = [];
        for (let e = t.length - 1; e >= 0; --e) {
          i.push(t[e]);
        }
        return i;
      }
      priceAxisViews(e, t) {
        if (this.isFixed()) {
          return null;
        }
        if (t !== this.priceScale() || this.isSourceHidden()) {
          return null;
        }
        if (this._model.lineBeingEdited() === this) {
          const e = this._model.linePointBeingEdited();
          if (e !== null && e < this._priceAxisViews.length) {
            const t = this._priceAxisViews.slice();
            const i = t[e];
            t.splice(e, 1);
            t.push(i);
            return t;
          }
          return this._priceAxisViews;
        }
        return this._priceAxisViews;
      }
      timeAxisViews() {
        if (this.isSourceHidden() || this.isFixed()) {
          return null;
        }
        if (this._model.lineBeingEdited() === this) {
          const e = this._model.linePointBeingEdited();
          if (e !== null && e < this._timeAxisViews.length) {
            const t = this._timeAxisViews.slice();
            const i = t[e];
            t.splice(e, 1);
            t.push(i);
            return t;
          }
          return this._timeAxisViews;
        }
        return this._timeAxisViews;
      }
      isSavedInChart() {
        return !this.customization.disableSave;
      }
      isSavedInStudyTemplates() {
        return false;
      }
      setSavingInChartEnabled(e) {
        this.customization.disableSave = !e;
      }
      shouldBeRemovedOnDeselect() {
        return false;
      }
      getOrderTemplate() {
        return null;
      }
      getSourceIcon() {
        return {
          type: "loadSvg",
          svgId: "linetool." + this.toolname
        };
      }
      alertId() {
        return this._alertId;
      }
      async waitSettingAlertId() {
        if (this._pendingAlertIdPromise) {
          this._alertId = await this._pendingAlertIdPromise;
        }
      }
      async setAlert(e, t = {}) {
        throw new Error("not implemented");
      }
      async restoreAlert(e, t) {
        throw new Error("not implemented");
      }
      editAlert(e) { }
      async getAlert() {
        try {
          const e = await this._getChartAlert();
          if (!e) {
            N.logError("Failed to get alert, alert will not be saved with drawing in chart");
            throw new Error("got_no_alert");
          }
          return e;
        } catch (e) {
          if (e === "not_exists") {
            throw new Error(e);
          }
          N.logError(`Getting alert failed: ${e instanceof Error ? e.message : e}`);
          return null;
        }
      }
      getAlertSync() {
        return null;
      }
      async synchronizeAlert(e = false) { }
      syncAlert(e) {
        0;
      }
      stateForAlert() {
        return null;
      }
      getAlertIsActive() {
        return false;
      }
      detachAlert() { }
      removeAlert() { }
      deleteAlert() { }
      areLocalAndServerAlertsMismatch() {
        return false;
      }
      showInObjectTree() {
        return this.customization.showInObjectsTree;
      }
      setShowInObjectsTreeEnabled(e) {
        this.customization.showInObjectsTree = e;
      }
      start() {
        this.createServerPoints();
      }
      processHibernate() {
        if (this.canBeHibernated()) {
          if (this.isStarted()) {
            this.stop();
          }
        } else if (!this.isStarted()) {
          this.start();
        }
      }
      canBeHibernated() {
        return this.isSourceHidden();
      }
      onData(e) {
        if (e.method !== "pointset_error") {
          if (e.params.customId === this._currentPointsetIdWithPrefix()) {
            this._onPointsetUpdated(e.params.plots);
          }
        } else {
          N.logError(`Error getting pointset: ${e.params[0]} ${e.params[1]}`);
        }
      }
      isBeingEdited() {
        return this === this._model.lineBeingEdited();
      }
      isActualSymbol() {
        return this._isActualSymbol;
      }
      isActualCurrency() {
        return this._isActualCurrency;
      }
      isActualInterval() {
        return this._isActualInterval;
      }
      isActualUnit() {
        return this._isActualUnit;
      }
      onIsActualIntervalChange() {
        return this._onIsActualIntervalChange;
      }
      setOwnerSource(e) {
        if (this._ownerSource !== null) {
          this._ownerSource.currencyChanged().unsubscribeAll(this);
          this._ownerSource.unitChanged().unsubscribeAll(this);
        }
        if (this._ownerSource !== null && (0, I.isSymbolSource)(this._ownerSource)) {
          this._ownerSource.symbolResolved().unsubscribe(this, this._boundCalcIsActualSymbol);
          this._ownerSource.isActingAsSymbolSource().unsubscribe(this._boundCalcIsActualSymbol);
        }
        super.setOwnerSource(e);
        if (e) {
          this.setPriceScale(e.priceScale());
          e.currencyChanged().subscribe(this, this.calcIsActualCurrency);
          e.unitChanged().subscribe(this, this.calcIsActualUnit);
          this.calcIsActualSymbol();
          this._migrateZOrder();
          this._updateAlertCreationAvailable();
        }
        if ((0, I.isSymbolSource)(e)) {
          e.symbolResolved().subscribe(this, this._boundCalcIsActualSymbol);
          e.isActingAsSymbolSource().subscribe(this._boundCalcIsActualSymbol);
        }
      }
      dataAndViewsReady() {
        return this._paneViews.size > 0;
      }
      pointAdded() {
        return this._pointAdded;
      }
      pointChanged() {
        return this._pointChanged;
      }
      pointsetUpdated() {
        return this._onPointsetUpdatedDelegate;
      }
      pointToScreenPoint(e) {
        const t = this._model.timeScale();
        const i = this.priceScale();
        const s = this.ownerSource()?.firstValue();
        if (!i || i.isEmpty() || t.isEmpty() || s == null) {
          return null;
        }
        const n = t.indexToCoordinate(e.index);
        const r = i.priceToCoordinate(e.price, s);
        return new o.Point(n, r);
      }
      screenPointToPoint(e, t) {
        const i = this.priceScale();
        const s = this.ownerSource()?.firstValue();
        if (s == null || !isFinite(s) || i === null) {
          return null;
        }
        const o = this._model.timeScale();
        const n = t ? o.coordinateToFloatIndex(e.x) : o.coordinateToIndex(e.x);
        return {
          price: i.coordinateToPrice(e.y, s),
          index: n
        };
      }
      calcMiddlePoint(e, t) {
        return new o.Point((e.x + t.x) / 2, (e.y + t.y) / 2);
      }
      addPoint(e, t, i) {
        const s = this._preparePoint(e, t);
        return this._addPointIntenal(s, t, i);
      }
      addFixedPoint(e) {
        this._fixedPoint = e;
        this.calcPositionPercents();
        return true;
      }
      calcPositionPercents() {
        const e = this.priceScale();
        if (!e || e.isEmpty() || this._fixedPoint === undefined) {
          return;
        }
        const t = this._fixedPoint.x / this._model.timeScale().width();
        const i = this._fixedPoint.y / e.height();
        this._positionPercents = {
          x: t,
          y: i
        };
        return this._positionPercents;
      }
      restoreFixedPoint() {
        this._fixedPoint = this.fixedPoint();
      }
      propertiesChanged(e, t) {
        this.calcIsActualInterval();
        this.updateAllViewsAndRedraw((0, x.sourceChangeEvent)(this.id()));
        if (!t) {
          this._syncLineStyleIfNeeded(e);
        }
        if (!e && this._pendingPropertyChangedEvent === undefined) {
          this._pendingPropertyChangedEvent = setTimeout(() => {
            this._pendingPropertyChangedEvent = undefined;
            r.emit("drawing_event", this._id.value(), "properties_changed");
          }, 0);
        }
      }
      state(e) {
        const t = {
          type: this.toolname,
          id: this.id(),
          state: this.properties().state(this._propertiesStateExclusions()),
          points: (0, u.deepCopy)(this._timePoint),
          zorder: this.zorder(),
          ownerSource: this.ownerSource()?.id()
        };
        t.isSelectionEnabled = this.isSelectionEnabled();
        t.userEditEnabled = this.userEditEnabled();
        if (this.linkKey().value()) {
          t.linkKey = this.linkKey().value();
        }
        delete t.state.points;
        if (e) {
          t.indexes = this._points;
        }
        if (this.isFixed()) {
          t.positionPercents = this._positionPercents || this.calcPositionPercents();
        }
        if ("version" in this && this.version !== 1) {
          t.version = this.version;
        }
        return t;
      }
      updateAllViews(e) {
        if (!this.isSourceHidden() && (e.type !== "data-source-change" || !this._ignoreSourceEvent(e))) {
          this._updateAllPaneViews(e);
          this._priceAxisViews.forEach(t => t.update(e));
          this._timeAxisViews.forEach(t => t.update(e));
        }
      }
      updateAllViewsAndRedraw(e) {
        this.updateAllViews(e);
        this._model.updateSource(this);
      }
      tags() {
        return [this.toolname];
      }
      properties() {
        return this._properties;
      }
      restoreExternalPoints(e, t) {
        this._timePoint = (0, u.deepCopy)(e.points);
        if (t.indexesChanged) {
          this.properties().childs().interval.setValue(e.interval);
          if (!this.isActualSymbol()) {
            this._clearServerPoints();
            this._normalizedPointsChanged.fire();
            return;
          }
          this.createServerPoints();
        } else {
          const t = Math.min(this._points.length, e.points.length);
          for (let i = 0; i < t; i++) {
            this._points[i].price = e.points[i].price;
          }
        }
        this._normalizedPointsChanged.fire();
      }
      restoreExternalState(e) {
        this.properties().mergeAndFire(e);
      }
      applyTemplate(e) {
        this._onTemplateApplying.fire(e);
        this._applyTemplateImpl(e);
        this.calcIsActualSymbol();
        this.updateAllViews((0, x.sourceChangeEvent)(this.id()));
        this.model().lightUpdate();
        this._onTemplateApplied.fire();
      }
      template() {
        return this.properties().preferences();
      }
      isFixed() {
        return false;
      }
      anchorable() {
        return false;
      }
      isLocked() {
        const e = this.properties().child("frozen");
        return e !== undefined && e.value();
      }
      isSourceHidden() {
        return !this._properties.childs().visible.value() || (0, w.hideAllDrawings)().value() && this.canBeHidden() || !this._isActualInterval || !this._isActualSymbol || !this._isActualCurrency || !this._isActualUnit;
      }
      isSynchronizable() {
        return this.priceScale() === this._model.mainSeries().priceScale();
      }
      copiable() {
        return O;
      }
      cloneable() {
        return this._ownerSource !== null && this._ownerSource.firstValue() !== null;
      }
      movable() {
        return true;
      }
      allowsMovingBetweenPanes() {
        return false;
      }
      async getPropertyDefinitionsViewModel() {
        if (this._definitionsViewModel === null) {
          const e = await this._getPropertyDefinitionsViewModelClass();
          if (e === null || this._isDestroyed) {
            return null;
          } else {
            this._definitionsViewModel = new e(this._model.undoModel(), this);
            return this._definitionsViewModel;
          }
        }
        return this._definitionsViewModel;
      }
      title() {
        return this.translatedType();
      }
      translatedType() {
        return B.lineToolsLocalizedNames[this.toolname] ?? "Line Tool";
      }
      name() {
        return "Line Tool";
      }
      createServerPoints() {
        if (!this._isActualSymbol) {
          return;
        }
        if (!this._model.chartApi().isConnected().value()) {
          return;
        }
        this._clearServerPoints();
        if (this._model.timeScale().isEmpty()) {
          return;
        }
        if (this._timePoint.length === 0 && this._points.length > 0) {
          this._normalizePoints();
        }
        if (!this._readyToCreatePointset()) {
          return;
        }
        const e = this._pointsForPointset();
        if (e.length === 0) {
          return;
        }
        ++W;
        this._currentPointsetAndSymbolId = {
          pointsetId: W,
          symbolId: (0, n.ensureNotNull)(this._model.mainSeries().seriesSource().symbolInstanceId())
        };
        const t = (0, m.getServerInterval)(this.properties().childs().interval.value());
        this._model.chartApi().createPointset(this._currentPointsetIdWithPrefix(), "turnaround", this._currentPointsetAndSymbolId.symbolId, t, e, this.onData.bind(this));
      }
      finish() { }
      realign() {
        this.calcIsActualSymbol();
        if (!this.isFixed() && !this.isSourceHidden() && this._model.lineBeingCreated() !== this && this._model.lineBeingEdited() !== this && this._currentPointsetAndSymbolId?.symbolId !== this._model.mainSeries().seriesSource().symbolInstanceId()) {
          this._clearServerPoints();
        }
        if (this._model.mainSeries().symbolInfo() === null) {
          this._alignerCache = null;
        }
        this.updateAllViews((0, x.sourceChangeEvent)(this.id()));
      }
      stop() {
        this._clearServerPoints();
      }
      restart() {
        if (!this.isFixed()) {
          this._currentPointsetAndSymbolId = null;
          this.createServerPoints();
        }
      }
      isStarted() {
        return this._currentPointsetAndSymbolId !== null;
      }
      convertYCoordinateToPriceForMoving(e, t) {
        const i = (0, n.ensureNotNull)(this.priceScale());
        if (i.isEmpty()) {
          return null;
        }
        const s = this.ownerSource();
        const o = (0, n.ensure)((s || t)?.firstValue());
        return i.coordinateToPrice(e, o);
      }
      syncMultichartState(e) {
        const t = {
          points: this._timePoint,
          pointPositionPercents: this.positionPercents(),
          interval: this._model.mainSeries().interval()
        };
        const i = this.linkKey().value();
        if (i !== null && this.isSynchronizable()) {
          const s = {
            model: this._model,
            linkKey: i,
            symbol: this._model.mainSeries().symbol(),
            finalState: t,
            changes: e
          };
          (0, w.finishChangingLineTool)(s);
        }
      }
      enableCurrentIntervalVisibility() {
        let e = this.properties().childs().intervalsVisibilities.state();
        if (e !== undefined) {
          e = (0, g.mergeIntervalVisibilitiesDefaults)(e);
          (0, g.makeIntervalsVisibilitiesVisibleAtInterval)(e, this._model.mainSeries().intervalObj());
          this.properties().childs().intervalsVisibilities.mergeAndFire(e);
        }
      }
      clonePositionOffset() {
        if (this.isFixed()) {
          return {
            barOffset: 0,
            xCoordOffset: 20,
            yCoordOffset: 20
          };
        } else {
          return {
            barOffset: 0,
            xCoordOffset: 0,
            yCoordOffset: -40
          };
        }
      }
      sharingMode() {
        return this._sharingMode;
      }
      share(e) {
        if (this.isSynchronizable()) {
          this._sharingMode.setValue(e);
        }
      }
      syncLineStyleState(e) {
        if (e) {
          return {
            zOrder: this.zorder()
          };
        }
        const {
          intervalsVisibilities: t,
          ...i
        } = this.properties().state(this._syncStateExclusions);
        return {
          ...i,
          intervalsVisibilities: (0, g.mergeIntervalVisibilitiesDefaults)(t),
          zOrder: this.zorder()
        };
      }
      moveLineTool(e) {
        const t = this._model.mainSeries().interval();
        e.forEach((e, i) => this._setPoint(i, {
          ...e,
          interval: t
        }));
        this._normalizePoints();
      }
      snapTo45DegreesAvailable() {
        return false;
      }
      alignTo45DegreesPoints() {
        if (this.snapTo45DegreesAvailable()) {
          const [e, t] = this.points();
          if (e && t) {
            return [{
              ...e,
              pointIndex: 0
            }, {
              ...t,
              pointIndex: 1
            }];
          }
        }
        return null;
      }
      snapPoint45Degree(e, t, i) {
        const s = this._model.timeScale();
        const o = s.indexToCoordinate(t.index);
        const r = s.indexToCoordinate(e.index) - o;
        const a = (0, n.ensureNotNull)(this.priceScale());
        const l = t.price;
        const c = e.price;
        const h = (0, n.ensureNotNull)((0, n.ensureNotNull)(this.ownerSource()).firstValue());
        const d = a.priceToCoordinate(l, h);
        const u = a.priceToCoordinate(c, h) - d;
        const _ = Math.round(Math.atan2(r, u) / Math.PI * 4);
        if (Math.abs(_) === 2) {
          if (!i) {
            e.price = l;
          }
        } else if (Math.abs(_) === 0 || Math.abs(_) === 4) {
          if (!i) {
            e.index = t.index;
          }
        } else {
          const t = Math.sqrt(r * r + u * u);
          const i = r < 0 ? -1 : 1;
          const n = u < 0 ? -1 : 1;
          let l = Math.max(Math.abs(u), Math.abs(r));
          l /= l * Math.sqrt(2) / t;
          const c = Math.round(s.coordinateToIndex(o + l * i));
          const _ = Math.abs(s.indexToCoordinate(c) - o);
          const p = a.coordinateToPrice(d + _ * n, h);
          e.index = c;
          e.price = p;
        }
      }
      _ignoreSourceEvent(e) {
        return e.sourceId !== this.id();
      }
      _pointsForPointset() {
        return this._timePoint.map(e => e.interval ? [e.time_t, e.offset, (0, m.getServerInterval)(e.interval)] : [e.time_t, e.offset]);
      }
      _setPoint(e, t) {
        if (this._points[e]) {
          if (this._points[e].index === t.index) {
            this._points[e].price = t.price;
          } else {
            this._points[e] = t;
          }
          this._pointChanged.fire(e);
        }
      }
      _correctLastPoint(e) {
        return (0, T.clone)(e);
      }
      _snapTo45DegreesApplicable(e) {
        return this.snapTo45DegreesAvailable() && (e?.shift() || (0, w.alignTo45Degrees)().value());
      }
      _normalizePoint(e, t) {
        return {
          ...this._model.timeScale().normalizeBarIndex(e.index),
          price: e.price,
          interval: e.interval
        };
      }
      _normalizePointWithoutOffset(e) {
        const t = this._model.timeScale().indexToTimePoint(e.index) ?? this._utcTimeInCurrentResolution(e);
        if (t === null) {
          return null;
        } else {
          return {
            price: e.price,
            time_t: t,
            offset: 0,
            interval: e.interval
          };
        }
      }
      _normalizePoints() {
        let e = [];
        const t = this._model.mainSeries().interval();
        for (let i = 0; i < this._points.length; i++) {
          if (S.Interval.isEqual(this._points[i].interval, t)) {
            if (this._points[i].index !== undefined) {
              const t = this._normalizePoint(this._points[i], i);
              if (!t.time_t) {
                e = [];
                break;
              }
              e.push(t);
            }
          } else {
            e.push({
              ...this._timePoint[i],
              price: this._points[i].price
            });
          }
        }
        this._timePoint = e;
        this._normalizedPointsChanged.fire();
      }
      _getStartBarAligner() {
        const e = this._model.mainSeries().interval();
        if (this._alignerCache === null || this._alignerCache.resolution !== this._model.mainSeries().interval()) {
          const t = this._model.mainSeries().symbolInfo();
          if (!t) {
            return null;
          }
          this._alignerCache = {
            resolution: e,
            aligner: (0, c.createTimeToBarTimeAligner)(e, t)
          };
        }
        return this._alignerCache.aligner;
      }
      _utcTimeInCurrentResolution(e) {
        const t = this._model.timeScale().points();
        const i = t.firstPoint();
        const s = t.lastPoint();
        const o = this._model.mainSeries().syncModel();
        if (i === null || s === null || o === null) {
          return null;
        }
        const r = (0, n.ensureNotNull)(t.indexOf(i, false));
        const a = (0, n.ensureNotNull)(t.indexOf(s, false));
        if (e.index >= r && e.index <= a) {
          return null;
        }
        const l = e.index < r ? r : a;
        const c = (0, n.ensureNotNull)(t.valueAt(l));
        const d = e.index - l;
        return (0, h.extrapolateBarsFrontByCount)(o.barBuilder(), c * 1000, d).time / 1000;
      }
      _setPaneViews(e, t, i) {
        if (this._isDestroyed) {
          for (const t of e) {
            if (t.destroy) {
              t.destroy();
            }
          }
        } else {
          this._paneViews.set(t, e);
          if (t !== undefined && i) {
            t.onDestroyed().subscribe(this, () => this._destroyPanePaneViews(t));
          }
          this._model.lightUpdate();
        }
      }
      _getPaneViews(e) {
        return this._paneViews.get(e) || null;
      }
      _updateAllPaneViews(e) {
        this._paneViews.forEach(t => {
          for (const i of t) {
            i.update(e);
          }
        });
      }
      _alignPointHorizontallyOrVertically(e) {
        const t = (0, n.ensureNotNull)(this.pointToScreenPoint(e));
        const i = (0, n.ensureDefined)((0, n.ensureNotNull)(this._startMovingPoint).logical);
        const s = (0, n.ensureDefined)((0, n.ensureNotNull)(this._startMovingPoint).screen);
        const o = Math.abs(s.x - t.x);
        const r = Math.abs(s.y - t.y);
        if (o < 10 && r < 10) {
          return e;
        }
        return {
          index: o < r ? i.index : e.index,
          price: o < r ? e.price : i.price
        };
      }
      _alignScreenPointHorizontallyOrVertically(e) {
        const t = (0, n.ensureDefined)((0, n.ensureNotNull)(this._startMovingPoint).screen);
        const i = Math.abs(t.x - e.x);
        const s = Math.abs(t.y - e.y);
        if (i < 10 && s < 10) {
          return e;
        } else if (i < s) {
          return new o.Point(t.x, e.y);
        } else {
          return new o.Point(e.x, t.y);
        }
      }
      _correctPoints(e, t) {
        const i = (0, n.ensure)(this._currentMovingPoint?.screen);
        const s = (0, n.ensure)(this._startMovingPoint?.screen);
        const o = i.subtract(s);
        if (o.length() < 1 && !t) {
          return false;
        }
        const r = Math.round((0, n.ensure)(this._currentMovingPoint?.logical).index - (0, n.ensure)(this._startMovingPoint?.logical).index);
        for (const t of e) {
          const e = (0, n.ensureNotNull)(this.pointToScreenPoint(t)).add(o);
          t.index = t.index + r;
          t.price = (0, n.ensureNotNull)(this.screenPointToPoint(e)).price;
        }
        return true;
      }
      _correctFixedPoint(e) {
        if (this._fixedPoint === undefined) {
          return {
            didCorrect: false,
            point: e
          };
        }
        const t = (0, n.ensureDefined)((0, n.ensureNotNull)(this._currentMovingPoint).screen);
        const i = (0, n.ensureDefined)((0, n.ensureNotNull)(this._startMovingPoint).screen);
        const s = t.subtract(i);
        if (s.length() >= 1) {
          return {
            didCorrect: true,
            point: e.add(s)
          };
        } else {
          return {
            didCorrect: false,
            point: e
          };
        }
      }
      _currentPointsetIdWithPrefix() {
        return "pointset_" + (0, n.ensureNotNull)(this._currentPointsetAndSymbolId).pointsetId;
      }
      _clearServerPoints() {
        if (this._currentPointsetAndSymbolId !== null && this._model.chartApi().isConnected().value()) {
          this._model.chartApi().removePointset(this._currentPointsetIdWithPrefix());
        }
        this._currentPointsetAndSymbolId = null;
      }
      _createPointProperty(e) {
        const t = this._pointsProperty.childs().points;
        t.addChild("" + e, new b.Property({}));
        const i = t[e];
        i.addChild("price", new L(this, e));
        i.addChild("bar", new A.LineDataSourcePointIndexProperty(this, e));
      }
      _createPointsProperties() {
        this._pointsProperty = new b.Property();
        this._pointsProperty.addChild("points", new b.Property());
        for (let e = 0; e < this.pointsCount(); e++) {
          this._createPointProperty(e);
        }
      }
      _alignPointToRangeOfActualData(e) {
        const t = (0, n.ensureNotNull)(this._model.mainSeries().bars().firstIndex());
        const i = (0, n.ensureNotNull)(this._model.mainSeries().bars().lastIndex());
        let s = Math.max(e.index, t);
        s = Math.min(s, i);
        return {
          ...e,
          index: s
        };
      }
      _migrateSymbolProperty(e) {
        const t = this._properties.childs();
        if (t.symbolStateVersion.value() < 2) {
          const i = (0, n.ensureNotNull)(this.ownerSource());
          const s = (0, n.ensureNotNull)(i.symbolSource());
          const o = this._model.mainSeries();
          if (s === o) {
            t.symbolStateVersion.setValueSilently(2);
            return;
          }
          if (o.symbolInfo() === null) {
            return;
          }
          if (s.symbolInfo() === null) {
            return;
          }
          if (o.symbolSameAsCurrent(t.symbol.value())) {
            t.symbol.setValueSilently((0, y.extractLineToolSymbolFromSymbolInfo)(e, s.symbol()));
          }
          t.symbolStateVersion.setValueSilently(2);
        }
      }
      _migrateZOrder() {
        const e = this._properties.childs();
        if (e.zOrderVersion.value() < 2) {
          if (this.ownerSource() === this.model().mainSeries()) {
            this.setZorder(this.zorder() - this.model().mainSeries().obsoleteZOrder());
          }
          e.zOrderVersion.setValueSilently(2);
        }
      }
      _preparePoint(e, t) {
        const i = e;
        if (this._snapTo45DegreesApplicable(t) && this.points().length >= 2) {
          this.snapPoint45Degree(i, this.points()[this.points().length - 2]);
        }
        return i;
      }
      _addPointIntenal(e, t, i) {
        this._points.push({
          ...e,
          interval: this._model.mainSeries().interval()
        });
        const s = this._points.length === this.pointsCount();
        if (s) {
          this._lastPoint = null;
          if (!i) {
            this._normalizePoints();
            this.createServerPoints();
          }
        } else {
          this._lastPoint = e;
        }
        this._pointAdded.fire(this._points.length - 1);
        return s;
      }
      _onSourceHiddenMayChange() {
        if (this.isSourceHidden()) {
          this._model.selectionMacro(e => {
            e.removeSourceFromSelection(this);
          });
        }
        this._model.invalidate(p.InvalidationMask.validateAction(() => {
          if (this !== this._model.lineBeingCreated()) {
            if (!this._isDestroyed) {
              this.processHibernate();
            }
          }
        }));
      }
      _saveAlertIdInState() {
        return true;
      }
      _onPointsetUpdated(e) {
        if (e.length === 0) {
          return;
        }
        const t = this.properties().childs().interval.value();
        for (let i = 0; i < e.length; i++) {
          const s = e[i];
          const o = this._timePoint[s.index];
          const n = {
            index: s.value[0],
            time: s.value[1],
            price: o.price,
            interval: o.interval ?? t
          };
          if (this._points.length <= s.index) {
            this._points.push(n);
            this._pointAdded.fire(this._points.length - 1);
          } else {
            this._points[s.index] = n;
            this._pointChanged.fire(s.index);
          }
        }
        this._onPointsetUpdatedDelegate.fire();
        this.updateAllViewsAndRedraw((0, x.sourceChangeEvent)(this.id()));
      }
      _onMainSeriesSymbolResolved() {
        const e = this.ownerSource();
        if (e !== null && this._model.mainSeries() !== e.symbolSource() && !this.isSourceHidden()) {
          this.createServerPoints();
        }
      }
      _readyToCreatePointset() {
        return this._timePoint.length > 0;
      }
      _propertiesStateExclusions() {
        return [];
      }
      _syncLineStyleIfNeeded(e) {
        const t = this.linkKey().value();
        if (t && !this._syncLineStyleMuted) {
          this._syncLineStyleChanges(t, this.syncLineStyleState(e));
        }
      }
      _muteSyncLineStyle() {
        this._syncLineStyleMuted = true;
      }
      _unmuteSyncLineStyleWithoutApplyingChanges() {
        this.propertiesChanged();
        this._syncLineStyleMuted = false;
      }
      _applyTemplateImpl(e) {
        e.intervalsVisibilities = (0, g.mergeIntervalVisibilitiesDefaults)(e.intervalsVisibilities);
        const t = this.properties();
        t.applyTemplate(e, (0, V.factoryDefaults)(this.toolname.toLowerCase()));
        t.saveDefaults();
        this.propertiesChanged();
      }
      _getPropertyDefinitionsViewModelClass() {
        return Promise.resolve(null);
      }
      _getAlertPlots() {
        return [];
      }
      _getUndoHistory() {
        return this._model.undoModel().undoHistory();
      }
      _synchronizeAlert(e) { }
      _linePointsToAlertPlot(e, t, i, s) {
        return null;
      }
      _getAlertCreationAvailable() {
        return false;
      }
      _onAnchoredChange() {
        if (this.isFixed()) {
          const e = (0, n.ensureNotNull)(this.pointToScreenPoint(this.points()[0]));
          this.addFixedPoint(e);
        } else {
          if (!this._fixedPoint) {
            return;
          }
          const e = (0, n.ensureNotNull)(this.screenPointToPoint(this._fixedPoint));
          this._points[0] = {
            ...e,
            interval: this._model.mainSeries().interval()
          };
          this.startChanging();
          this.setPoint(0, e);
          this.endChanging(false, false);
          this._timePoint[0] = this._normalizePoint(this._points[0], 0);
          this.clearFixedPoint();
        }
        const e = this.linkKey().value();
        if (e !== null && this.isSynchronizable()) {
          (0, w.restoreLineToolState)({
            model: this._model,
            linkKey: e,
            state: this.state()
          });
        }
      }
      _syncLineStyleChanges(e, t, i) {
        if (this.anchorable() && this.isFixed() !== Boolean(this._positionPercents)) {
          this._onAnchoredChange();
        }
        (0, w.changeLineStyle)({
          linkKey: e,
          state: t,
          alertId: i,
          model: this._model
        });
      }
      static _configureProperties(e) {
        this._addCollectedProperties(e);
        if (!e.hasChild("symbolStateVersion")) {
          e.addChild("symbolStateVersion", new b.Property(1));
        }
        if (!e.hasChild("zOrderVersion")) {
          e.addChild("zOrderVersion", new b.Property(1));
        }
        if (!e.hasChild("visible")) {
          e.addChild("visible", new b.Property(true));
        }
        if (!e.hasChild("frozen")) {
          e.addChild("frozen", new b.Property(false));
        }
        if (!e.hasChild("symbol")) {
          e.addChild("symbol", new b.Property(""));
        }
        if (!e.hasChild("currencyId")) {
          e.addChild("currencyId", new b.Property(null));
        }
        if (!e.hasChild("unitId")) {
          e.addChild("unitId", new b.Property(null));
        }
        if (e.hasChild("intervalsVisibilities")) {
          const t = (0, T.merge)((0, T.clone)(f.intervalsVisibilitiesDefaults), e.childs().intervalsVisibilities.state());
          e.removeProperty("intervalsVisibilities");
          e.addChild("intervalsVisibilities", new P.IntervalsVisibilitiesProperty(t));
        } else {
          e.addChild("intervalsVisibilities", new P.IntervalsVisibilitiesProperty(f.intervalsVisibilitiesDefaults));
        }
        if (!e.hasChild("title")) {
          e.addChild("title", new b.Property(""));
        }
        ["symbolStateVersion", "zOrderVersion", "visible", "frozen", "symbol", "currencyId", "unitId", "symbolInfo", "points", "interval", "title"].forEach(t => e.addExcludedKey(t, 5));
        if (e.hasChild("singleChartOnly")) {
          e.removeProperty("singleChartOnly");
        }
        if (e.hasChild("font")) {
          e.removeProperty("font");
        }
      }
      static _addCollectedProperties(e) {
        if (e.hasChild("linewidth")) {
          e.addChild("linesWidths", new E.LineToolWidthsProperty([(0, n.ensureDefined)(e.child("linewidth"))]));
        }
        if (e.hasChild("linecolor")) {
          e.addChild("linesColors", new E.LineToolColorsProperty([(0, n.ensureDefined)(e.child("linecolor"))]));
        }
        if (e.hasChild("backgroundColor")) {
          e.addChild("backgroundsColors", new E.LineToolColorsProperty([(0, n.ensureDefined)(e.child("backgroundColor"))]));
        }
        if (e.hasChild("textColor")) {
          e.addChild("textsColors", new E.LineToolColorsProperty([(0, n.ensureDefined)(e.child("textColor"))]));
        }
        if (e.hasChild("linestyle")) {
          e.addChild("linesStyles", new E.LineToolCollectedProperty([(0, n.ensureDefined)(e.child("linestyle"))]));
        }
        ["linesWidths", "linesColors", "backgroundsColors", "textsColors", "linesStyles"].forEach(t => {
          e.addExcludedKey(t, 7);
        });
      }
      _areAlertsOnLineToolProhibited() {
        return this._ownerSource !== null && !this._ownerSource.canHasAlertOnLineTools();
      }
      _removeAlertSubscriptions() {
        this._unsubscribeAlertCallbacks?.();
        this._unsubscribeAlertCallbacks = undefined;
      }
      _addAlertSubscriptions(e, t = {}) { }
      _destroyPanePaneViews(e) {
        const t = this._paneViews.get(e);
        if (t !== undefined) {
          for (const e of t) {
            if (e.destroy) {
              e.destroy();
            }
          }
        }
        if (e !== undefined) {
          e.onDestroyed().unsubscribeAll(this);
        }
        this._paneViews.delete(e);
      }
      _copyPricesWithoutNormalization() {
        const e = Math.min(this._points.length, this._timePoint.length);
        for (let t = 0; t < e; t++) {
          this._timePoint[t].price = this._points[t].price;
        }
      }
      async _getChartAlert() {
        throw new Error("not implemented");
      }
      async _syncAlertWithAlertFacade(e = {}) {
        try {
          const t = await this.getAlert();
          if (!t) {
            return;
          }
          this._addAlertSubscriptions(t, e);
          if (e.syncAlertFocus) {
            const e = this._model.selection().isSelected(this);
            t.setSelected(e);
          }
        } catch (e) {
          if (e instanceof Error && e.message === "not_exists" && this.hasAlert().value()) {
            this._alertStatus.setValue(0);
            (await getChartAlertsFacade()).removeAlertFromAllChartsSilently(this.id(), (0, n.ensureDefined)(this._alertId));
            return;
          }
          N.logError("Failed to set alert, alert will not be saved with drawing in chart");
        }
      }
    }
  },
  73305: (e, t, i) => {
    "use strict";

    i.d(t, {
      LineToolCollectedProperty: () => c,
      LineToolColorsProperty: () => d,
      LineToolWidthsProperty: () => h,
      MultipleLineColorsProperty: () => p,
      MultipleLineWidthsProperty: () => _
    });
    var s = i(9343);
    var o = i(34776);
    var n = i(23073);
    const r = (0, s.getLogger)("Chart.LineToolCollectedProperty");
    class a {
      applyValue(e, t) {
        e.setValue(t);
      }
    }
    class l extends n.PropertyBase {
      constructor(e, t) {
        super();
        this._properties = e;
        e.forEach((e, t) => e.subscribe(this, (e, i) => {
          this._listeners.fire(this, `${t}.${i}`);
        }));
        this._showIfProperty = t;
      }
      visible() {
        return !this._showIfProperty || this._showIfProperty?.value();
      }
      value() {
        if (this._properties.length === 0) {
          r.logError("Incorrect call, should not request value of 0 properties");
          return "mixed";
        }
        const e = this._properties[0].value();
        if (this._properties.length === 1 || this._properties.every(t => t.value() === e)) {
          return e;
        } else {
          return "mixed";
        }
      }
      setValueSilently(e) {
        if (e !== "mixed") {
          this._properties.forEach(t => t.setValueSilently(e));
        }
      }
      hasChild(e) {
        const t = parseInt(e, 10);
        return !isNaN(t) && t >= 0 && t < this._properties.length;
      }
      childCount() {
        return this._properties.length;
      }
      childNames() {
        return this._properties.map((e, t) => t.toString());
      }
      child(e) {
        const t = parseInt(e, 10);
        if (!isNaN(t) && t >= 0 && t < this._properties.length) {
          return this._properties[t];
        } else {
          return undefined;
        }
      }
      destroy() {
        this._properties.forEach(e => e.unsubscribeAll(this));
        this._listeners.destroy();
      }
      storeStateIfUndefined() {
        return true;
      }
      weakReference() {
        return (0, o.weakReference)(this);
      }
      ownership() {
        return (0, o.ownership)(this);
      }
    }
    class c extends l {
      setValue(e, t, i) {
        if (e === "mixed") {
          return;
        }
        const s = i ?? new a();
        this._properties.forEach(t => s.applyValue(t, e));
      }
    }
    class h extends c { }
    class d extends c {
      firstColor() {
        return this._properties[0].value();
      }
    }
    class u extends l {
      setValue(e, t, i) {
        if (e === "mixed") {
          return;
        }
        const s = i ?? new a();
        this._properties.forEach(t => t.setValue(e, undefined, s));
      }
    }
    class _ extends u { }
    class p extends u { }
  },
  77336: (e, t, i) => {
    "use strict";

    i.d(t, {
      ensureLineToolLoaded: () => u,
      getLoadedLineTool: () => _,
      isAsyncGenericLineToolName: () => l,
      isAsyncStudyLineToolName: () => c,
      isLineToolLoaded: () => h,
      loadLineTool: () => d
    });
    var s = i(50151);
    const o = new Map();
    const n = new Map([["LineToolPriceNote", async () => (await Promise.all([i.e(8940), i.e(3889), i.e(8009), i.e(380)]).then(i.bind(i, 36875))).LineToolPriceNote], ["LineToolTextNote", async () => (await Promise.all([i.e(6645), i.e(3889), i.e(8009), i.e(9116), i.e(9123)]).then(i.bind(i, 46902))).LineToolTextNote], ["LineToolNote", async () => (await Promise.all([i.e(3355), i.e(3889), i.e(8009), i.e(9116), i.e(3248)]).then(i.bind(i, 40258))).LineToolNote], ["LineToolFibSpiral", async () => (await Promise.all([i.e(3181), i.e(3889), i.e(8009), i.e(8090)]).then(i.bind(i, 22717))).LineToolFibSpiral], ["LineToolCircleLines", async () => (await Promise.all([i.e(2787), i.e(3889), i.e(8009), i.e(9445)]).then(i.bind(i, 9093))).LineToolCyclicLines], ["LineToolNoteAbsolute", async () => (await Promise.all([i.e(3355), i.e(3889), i.e(8009), i.e(9116), i.e(3248)]).then(i.bind(i, 40258))).LineToolNoteAbsolute], ["LineToolTable", async () => (await Promise.all([i.e(9494), i.e(3889), i.e(8009), i.e(9116), i.e(319)]).then(i.bind(i, 56176))).LineToolTable], ["LineToolFibSpeedResistanceArcs", async () => (await Promise.all([i.e(1427), i.e(3889), i.e(8009), i.e(9116), i.e(3710)]).then(i.bind(i, 49145))).LineToolFibSpeedResistanceArcs], ["LineToolPitchfan", async () => (await Promise.all([i.e(7952), i.e(3889), i.e(8009), i.e(8056), i.e(1313)]).then(i.bind(i, 43176))).LineToolPitchfan], ["LineToolFibSpeedResistanceFan", async () => (await Promise.all([i.e(1308), i.e(3889), i.e(8009), i.e(906)]).then(i.bind(i, 2662))).LineToolFibSpeedResistanceFan], ["LineToolFibWedge", async () => (await Promise.all([i.e(6760), i.e(3889), i.e(8009), i.e(9116), i.e(3314)]).then(i.bind(i, 30051))).LineToolFibWedge], ["LineToolEmoji", async () => (await Promise.all([i.e(6155), i.e(3889), i.e(8009), i.e(1200), i.e(5529)]).then(i.bind(i, 39374))).LineToolEmoji], ["LineToolBalloon", async () => (await Promise.all([i.e(3367), i.e(3889), i.e(8009), i.e(3960), i.e(1277)]).then(i.bind(i, 69113))).LineToolBalloon], ["LineToolComment", async () => (await Promise.all([i.e(2303), i.e(3889), i.e(8009), i.e(9116), i.e(3960), i.e(3966)]).then(i.bind(i, 84738))).LineToolComment], ["LineToolBezierCubic", async () => (await Promise.all([i.e(1432), i.e(3889), i.e(8009), i.e(9014)]).then(i.bind(i, 54696))).LineToolBezierCubic], ["LineToolInsidePitchfork", async () => (await Promise.all([i.e(8763), i.e(8468)]).then(i.bind(i, 20690))).LineToolInsidePitchfork]]);
    n.set("LineToolFibRetracement", async () => (await Promise.all([i.e(7850), i.e(3723)]).then(i.bind(i, 33168))).LineToolFibRetracement);
    n.set("LineToolFibChannel", async () => (await Promise.all([i.e(7850), i.e(2283)]).then(i.bind(i, 42851))).LineToolFibChannel);
    n.set("LineToolProjection", async () => (await Promise.all([i.e(7122), i.e(3945)]).then(i.bind(i, 12120))).LineToolProjection);
    n.set("LineToolTrendBasedFibExtension", async () => (await Promise.all([i.e(7850), i.e(4731)]).then(i.bind(i, 68554))).LineToolTrendBasedFibExtension);
    n.set("LineToolElliott", async () => (await Promise.resolve().then(i.bind(i, 65365))).LineToolElliott);
    n.set("LineToolFibCircles", async () => (await Promise.all([i.e(7850), i.e(2816)]).then(i.bind(i, 57994))).LineToolFibCircles);
    n.set("LineToolVertLine", async () => (await Promise.all([i.e(7122), i.e(1282)]).then(i.bind(i, 56096))).LineToolVertLine);
    n.set("LineToolCrossLine", async () => (await i.e(7203).then(i.bind(i, 92007))).LineToolCrossLine);
    n.set("LineToolBarsPattern", async () => (await Promise.all([i.e(4543), i.e(5206)]).then(i.bind(i, 81756))).LineToolBarsPattern);
    n.set("LineToolTrendBasedFibTime", async () => (await Promise.all([i.e(5111), i.e(7127)]).then(i.bind(i, 27172))).LineToolTrendBasedFibTime);
    n.set("LineToolFibTimeZone", async () => (await Promise.all([i.e(5111), i.e(1506)]).then(i.bind(i, 8532))).LineToolFibTimeZone);
    n.set("LineToolDateRange", async () => (await i.e(4273).then(i.bind(i, 42214))).LineToolDateRange);
    n.set("LineToolPriceRange", async () => (await i.e(6477).then(i.bind(i, 23234))).LineToolPriceRange);
    n.set("LineToolDateAndPriceRange", async () => (await i.e(1455).then(i.bind(i, 70791))).LineToolDateAndPriceRange);
    n.set("LineToolParallelChannel", async () => (await i.e(2050).then(i.bind(i, 56621))).LineToolParallelChannel);
    n.set("LineToolTrendAngle", async () => (await Promise.all([i.e(7122), i.e(8372)]).then(i.bind(i, 83776))).LineToolTrendAngle);
    n.set("LineToolTrendLine", async () => (await Promise.all([i.e(7122), i.e(8673)]).then(i.bind(i, 99294))).LineToolTrendLine);
    n.set("LineToolInfoLine", async () => (await Promise.all([i.e(7122), i.e(7488)]).then(i.bind(i, 51065))).LineToolInfoLine);
    n.set("LineToolArrowMark", async () => (await i.e(569).then(i.bind(i, 27621))).LineToolArrowMark);
    n.set("LineToolGannSquare", async () => (await i.e(9478).then(i.bind(i, 9770))).LineToolGannSquare);
    n.set("LineToolGannComplex", async () => (await i.e(1963).then(i.bind(i, 99083))).LineToolGannComplex);
    n.set("LineToolGannFixed", async () => (await i.e(6336).then(i.bind(i, 8308))).LineToolGannFixed);
    n.set("LineToolGannFan", async () => (await Promise.all([i.e(5111), i.e(4981)]).then(i.bind(i, 85259))).LineToolGannFan);
    n.set("LineToolPitchfork", async () => (await Promise.all([i.e(8763), i.e(5055)]).then(i.bind(i, 64002))).LineToolPitchfork);
    n.set("LineToolDisjointAngle", async () => (await i.e(9581).then(i.bind(i, 57897))).LineToolDisjointChannel);
    n.set("LineToolFlatBottom", async () => (await i.e(9310).then(i.bind(i, 90921))).LineToolFlatBottom);
    n.set("LineToolIcon", async () => (await i.e(7806).then(i.bind(i, 15510))).LineToolIcon);
    n.set("LineToolSticker", async () => (await i.e(8949).then(i.bind(i, 86915))).LineToolSticker);
    n.set("LineToolRotatedRectangle", async () => (await i.e(4015).then(i.bind(i, 23550))).LineToolRotatedRectangle);
    n.set("LineToolHeadAndShoulders", async () => (await i.e(3378).then(i.bind(i, 47267))).LineToolHeadAndShoulders);
    n.set("LineToolTriangle", async () => (await i.e(6432).then(i.bind(i, 39737))).LineToolTriangle);
    n.set("LineToolTrianglePattern", async () => (await i.e(3383).then(i.bind(i, 33865))).LineToolTrianglePattern);
    n.set("LineTool5PointsPattern", async () => (await i.e(1155).then(i.bind(i, 17658))).LineTool5PointsPattern);
    n.set("LineToolThreeDrivers", async () => (await i.e(4602).then(i.bind(i, 46660))).LineToolThreeDrivers);
    n.set("LineToolABCD", async () => (await i.e(5283).then(i.bind(i, 30906))).LineToolABCD);
    n.set("LineToolPolyline", async () => (await i.e(3866).then(i.bind(i, 51691))).LineToolPolyline);
    n.set("LineToolPath", async () => (await i.e(961).then(i.bind(i, 14150))).LineToolPath);
    n.set("LineToolPrediction", async () => (await i.e(9534).then(i.bind(i, 29356))).LineToolPrediction);
    n.set("LineToolPriceLabel", async () => (await i.e(6484).then(i.bind(i, 83710))).LineToolPriceLabel);
    n.set("LineToolArrowMarker", async () => (await i.e(1470).then(i.bind(i, 66403))).LineToolArrowMarker);
    n.set("LineToolSignpost", async () => (await Promise.all([i.e(7122), i.e(4674)]).then(i.bind(i, 28820))).LineToolSignpost);
    n.set("LineToolBrush", async () => (await i.e(5122).then(i.bind(i, 28462))).LineToolBrush);
    n.set("LineToolArc", async () => (await i.e(5967).then(i.bind(i, 87654))).LineToolArc);
    n.set("LineToolCallout", async () => (await Promise.all([i.e(7122), i.e(688)]).then(i.bind(i, 62828))).LineToolCallout);
    n.set("LineToolText", async () => (await Promise.all([i.e(7122), i.e(2312)]).then(i.bind(i, 424))).LineToolText);
    n.set("LineToolHorzLine", async () => (await Promise.all([i.e(7122), i.e(4201)]).then(i.bind(i, 43636))).LineToolHorzLine);
    n.set("LineToolHorzRay", async () => (await i.e(574).then(i.bind(i, 47845))).LineToolHorzRay);
    n.set("LineToolRectangle", async () => (await Promise.all([i.e(7122), i.e(8422)]).then(i.bind(i, 63397))).LineToolRectangle);
    n.set("LineToolCircle", async () => (await Promise.all([i.e(7122), i.e(6748)]).then(i.bind(i, 17333))).LineToolCircle);
    n.set("LineToolEllipse", async () => (await Promise.all([i.e(7122), i.e(7660)]).then(i.bind(i, 59002))).LineToolEllipse);
    n.set("LineToolTimeCycles", async () => (await i.e(8334).then(i.bind(i, 4741))).LineToolTimeCycles);
    n.set("LineToolSineLine", async () => (await i.e(1713).then(i.bind(i, 8066))).LineToolSineLine);
    n.set("LineToolGhostFeed", async () => (await i.e(7563).then(i.bind(i, 37968))).LineToolGhostFeed);
    n.set("LineToolBezierQuadro", async () => (await i.e(8061).then(i.bind(i, 28904))).LineToolBezierQuadro);
    n.set("LineToolArrow", async () => (await Promise.all([i.e(7122), i.e(8607)]).then(i.bind(i, 96068))).LineToolArrow);
    n.set("LineToolRay", async () => (await Promise.all([i.e(7122), i.e(4934)]).then(i.bind(i, 36224))).LineToolRay);
    n.set("LineToolExtended", async () => (await Promise.all([i.e(7122), i.e(925)]).then(i.bind(i, 6921))).LineToolExtended);
    n.set("LineToolSchiffPitchfork", async () => (await Promise.all([i.e(8763), i.e(7175)]).then(i.bind(i, 63533))).LineToolSchiffPitchfork);
    n.set("LineToolSchiffPitchfork2", async () => (await Promise.all([i.e(8763), i.e(341)]).then(i.bind(i, 68802))).LineToolSchiffPitchfork2);
    n.set("LineToolTextAbsolute", async () => (await Promise.all([i.e(7122), i.e(2312)]).then(i.bind(i, 424))).LineToolTextAbsolute);
    n.set("LineToolArrowMarkLeft", async () => (await i.e(569).then(i.bind(i, 27621))).LineToolArrowMarkLeft);
    n.set("LineToolArrowMarkRight", async () => (await i.e(569).then(i.bind(i, 27621))).LineToolArrowMarkRight);
    n.set("LineToolArrowMarkUp", async () => (await i.e(569).then(i.bind(i, 27621))).LineToolArrowMarkUp);
    n.set("LineToolArrowMarkDown", async () => (await i.e(569).then(i.bind(i, 27621))).LineToolArrowMarkDown);
    n.set("LineToolFlagMark", async () => (await i.e(8820).then(i.bind(i, 41124))).LineToolFlagMark);
    n.set("LineToolCypherPattern", async () => (await i.e(6740).then(i.bind(i, 16628))).LineToolCypherPattern);
    n.set("LineToolElliottImpulse", async () => (await Promise.resolve().then(i.bind(i, 65365))).LineToolElliottImpulse);
    n.set("LineToolElliottTriangle", async () => (await Promise.resolve().then(i.bind(i, 65365))).LineToolElliottTriangle);
    n.set("LineToolElliottTripleCombo", async () => (await Promise.resolve().then(i.bind(i, 65365))).LineToolElliottTripleCombo);
    n.set("LineToolElliottCorrection", async () => (await Promise.resolve().then(i.bind(i, 65365))).LineToolElliottCorrection);
    n.set("LineToolElliottDoubleCombo", async () => (await Promise.resolve().then(i.bind(i, 65365))).LineToolElliottDoubleCombo);
    n.set("LineToolRiskRewardLong", async () => (await Promise.all([i.e(2342), i.e(1667), i.e(2277)]).then(i.bind(i, 21986))).LineToolRiskRewardLong);
    n.set("LineToolRiskRewardShort", async () => (await Promise.all([i.e(2342), i.e(1667), i.e(6768)]).then(i.bind(i, 65137))).LineToolRiskRewardShort);
    n.set("LineToolPosition", async () => (await i.e(1314).then(i.t.bind(i, 40265, 19))).LineToolPosition);
    n.set("LineToolOrder", async () => (await i.e(2232).then(i.t.bind(i, 64732, 19))).LineToolOrder);
    n.set("LineToolHighlighter", async () => (await i.e(2087).then(i.bind(i, 65539))).LineToolHighlighter);
    n.set("LineToolImage", async () => (await Promise.all([i.e(5402), i.e(5231)]).then(i.bind(i, 18181))).LineToolImage);
    n.set("LineToolExecution", async () => (await Promise.resolve().then(i.bind(i, 56991))).LineToolExecution);
    const r = new Map();
    const a = new Map([["LineToolAnchoredVWAP", async () => (await i.e(5500).then(i.bind(i, 13099))).LineToolAnchoredVWAP], ["LineToolRegressionTrend", async () => (await i.e(9748).then(i.bind(i, 10986))).LineToolRegressionTrend], ["LineToolVbPFixed", async () => (await i.e(5695).then(i.bind(i, 71131))).LineToolVbPFixed], ["LineToolFixedRangeVolumeProfile", async () => (await i.e(5695).then(i.bind(i, 25937))).LineToolFixedRangeVolumeProfile]]);
    function l(e) {
      return n.has(e) || a.has(e) || o.has(e);
    }
    function c(e) {
      return a.has(e);
    }
    function h(e) {
      return !l(e) || o.has(e) || r.has(e);
    }
    async function d(e) {
      if (h(e)) {
        return _(e);
      }
      const t = c(e);
      const i = (0, s.ensureDefined)((t ? a : n).get(e));
      const l = await i();
      if (t) {
        r.set(e, (0, s.ensureDefined)(l));
        return _(e);
      } else {
        o.set(e, (0, s.ensureDefined)(l));
        return _(e);
      }
    }
    async function u(e) {
      if (l(e) && !h(e)) {
        await d(e);
      }
    }
    function _(e) {
      if (c(e)) {
        return (0, s.ensureDefined)(r.get(e), `Study line tool ${e}`);
      } else {
        return (0, s.ensureDefined)(o.get(e), `Line tool ${e}`);
      }
    }
  },
  98523: (e, t, i) => {
    "use strict";

    i.d(t, {
      lineToolsLocalizedNames: () => o
    });
    var s = i(11542);
    const o = {
      LineTool5PointsPattern: s.t(null, undefined, i(42231)),
      LineToolABCD: s.t(null, undefined, i(46712)),
      LineToolArc: s.t(null, undefined, i(59324)),
      LineToolArrow: s.t(null, undefined, i(11858)),
      LineToolArrowMarkDown: s.t(null, undefined, i(73193)),
      LineToolArrowMarkLeft: s.t(null, undefined, i(1949)),
      LineToolArrowMarkRight: s.t(null, undefined, i(86275)),
      LineToolArrowMarkUp: s.t(null, undefined, i(62453)),
      LineToolBalloon: s.t(null, undefined, i(70540)),
      LineToolComment: s.t(null, undefined, i(9818)),
      LineToolBarsPattern: s.t(null, undefined, i(81994)),
      LineToolBezierCubic: s.t(null, undefined, i(77125)),
      LineToolBezierQuadro: s.t(null, undefined, i(78609)),
      LineToolBrush: s.t(null, undefined, i(43539)),
      LineToolCallout: s.t(null, undefined, i(25381)),
      LineToolCircleLines: s.t(null, undefined, i(84031)),
      LineToolCypherPattern: s.t(null, undefined, i(93191)),
      LineToolDateAndPriceRange: s.t(null, undefined, i(47017)),
      LineToolDateRange: s.t(null, undefined, i(85444)),
      LineToolDisjointAngle: s.t(null, undefined, i(91544)),
      LineToolElliottCorrection: s.t(null, undefined, i(80943)),
      LineToolElliottDoubleCombo: s.t(null, undefined, i(75112)),
      LineToolElliottImpulse: s.t(null, undefined, i(61114)),
      LineToolElliottTriangle: s.t(null, undefined, i(72359)),
      LineToolElliottTripleCombo: s.t(null, undefined, i(76129)),
      LineToolEllipse: s.t(null, undefined, i(78996)),
      LineToolExtended: s.t(null, undefined, i(52788)),
      LineToolFibChannel: s.t(null, undefined, i(59005)),
      LineToolFibCircles: s.t(null, undefined, i(82330)),
      LineToolFibRetracement: s.t(null, undefined, i(55986)),
      LineToolFibSpeedResistanceArcs: s.t(null, undefined, i(33880)),
      LineToolFibSpeedResistanceFan: s.t(null, undefined, i(2395)),
      LineToolFibSpiral: s.t(null, undefined, i(39014)),
      LineToolFibTimeZone: s.t(null, undefined, i(30622)),
      LineToolFibWedge: s.t(null, undefined, i(85042)),
      LineToolFlagMark: s.t(null, undefined, i(14600)),
      LineToolImage: s.t(null, undefined, i(68065)),
      LineToolFlatBottom: s.t(null, undefined, i(45051)),
      LineToolAnchoredVWAP: s.t(null, undefined, i(84541)),
      LineToolGannComplex: s.t(null, undefined, i(44763)),
      LineToolGannFixed: s.t(null, undefined, i(60707)),
      LineToolGannFan: s.t(null, undefined, i(48683)),
      LineToolGannSquare: s.t(null, undefined, i(47460)),
      LineToolHeadAndShoulders: s.t(null, undefined, i(21928)),
      LineToolHorzLine: s.t(null, undefined, i(21795)),
      LineToolHorzRay: s.t(null, undefined, i(25487)),
      LineToolIcon: s.t(null, undefined, i(37913)),
      LineToolEmoji: s.t(null, undefined, i(73456)),
      LineToolSticker: s.t(null, undefined, i(43114)),
      LineToolInsidePitchfork: s.t(null, undefined, i(41686)),
      LineToolNote: s.t(null, undefined, i(86631)),
      LineToolTextNote: s.t(null, undefined, i(94389)),
      LineToolSignpost: s.t(null, undefined, i(67751)),
      LineToolParallelChannel: s.t(null, undefined, i(59256)),
      LineToolPitchfan: s.t(null, undefined, i(34156)),
      LineToolPitchfork: s.t(null, undefined, i(19634)),
      LineToolPolyline: s.t(null, undefined, i(39949)),
      LineToolPath: s.t(null, undefined, i(371)),
      LineToolPrediction: s.t(null, undefined, i(20138)),
      LineToolPriceLabel: s.t(null, undefined, i(91282)),
      LineToolArrowMarker: s.t(null, undefined, i(36352)),
      LineToolPriceRange: s.t(null, undefined, i(68941)),
      LineToolProjection: s.t(null, undefined, i(75747)),
      LineToolRay: s.t(null, undefined, i(50318)),
      LineToolRectangle: s.t(null, undefined, i(26001)),
      LineToolCircle: s.t(null, undefined, i(91944)),
      LineToolRegressionTrend: s.t(null, undefined, i(2460)),
      LineToolRiskRewardLong: s.t(null, undefined, i(74832)),
      LineToolRiskRewardShort: s.t(null, undefined, i(8075)),
      LineToolFixedRangeVolumeProfile: s.t(null, {
        context: "study"
      }, i(25705)),
      LineToolAnchoredVolumeProfile: s.t(null, {
        context: "study"
      }, i(89633)),
      LineToolRotatedRectangle: s.t(null, undefined, i(56820)),
      LineToolSchiffPitchfork: s.t(null, undefined, i(57681)),
      LineToolSchiffPitchfork2: s.t(null, undefined, i(42608)),
      LineToolSineLine: s.t(null, undefined, i(39090)),
      LineToolText: s.t(null, {
        context: "tool"
      }, i(91405)),
      LineToolTextAbsolute: s.t(null, undefined, i(42669)),
      LineToolThreeDrivers: s.t(null, undefined, i(46982)),
      LineToolTimeCycles: s.t(null, undefined, i(46852)),
      LineToolTrendAngle: s.t(null, undefined, i(35757)),
      LineToolTrendBasedFibExtension: s.t(null, undefined, i(80583)),
      LineToolTrendBasedFibTime: s.t(null, undefined, i(72159)),
      LineToolTrendLine: s.t(null, undefined, i(97339)),
      LineToolInfoLine: s.t(null, undefined, i(15992)),
      LineToolTriangle: s.t(null, undefined, i(1671)),
      LineToolTrianglePattern: s.t(null, undefined, i(90148)),
      LineToolVertLine: s.t(null, undefined, i(29535)),
      LineToolCrossLine: s.t(null, undefined, i(74334)),
      LineToolHighlighter: s.t(null, undefined, i(69476)),
      LineToolPriceNote: s.t(null, undefined, i(97512)),
      LineToolVbPFixed: s.t(null, undefined, i(40693)),
      LineToolGhostFeed: s.t(null, undefined, i(46808)),
      LineToolTable: s.t(null, undefined, i(17981))
    };
  },
  15491: (e, t, i) => {
    "use strict";

    i.d(t, {
      lineToolsStudyIds: () => s
    });
    const s = {
      LineToolAnchoredVWAP: "AnchoredVWAP@tv-basicstudies",
      LineToolRegressionTrend: "RegressionTrend@tv-basicstudies",
      LineToolFixedRangeVolumeProfile: "VbPFixed@tv-basicstudies",
      LineToolVbPFixed: "VbPFixed@tv-volumebyprice"
    };
  },
  32755: (e, t, i) => {
    "use strict";

    i.d(t, {
      cloneLineTool: () => N,
      createLineTool: () => x,
      createLineToolProperties: () => M,
      createStudyLineToolProperties: () => A,
      ensureAllLineToolsLoadedForLayout: () => P,
      initAllLineToolsFromContent: () => T,
      initLineTool: () => S,
      isBrushBasedLineTool: () => k,
      isEditableTextLineTool: () => V,
      isLineTool: () => g.isLineTool,
      isStudyLineTool: () => D,
      isTrading: () => E,
      prepareLineToolPropertiesByOwnerSource: () => I,
      setNewToolProperties: () => y,
      supportsPhantomMode: () => L,
      tryFindStudyLineToolNameByStudyId: () => R,
      unsetNewToolProperties: () => v
    });
    var s = i(82433);
    var o = i(50151);
    var n = i(86441);
    var r = i(10892);
    var a = i(43156);
    var l = i(36009);
    var c = i(68805);
    var h = i(15764);
    var d = i(16638);
    var u = i(15491);
    var _ = i(64195);
    var p = i(77336);
    var m = i(9343);
    var g = i(78956);
    let f = null;
    function y(e, t, i) {
      if (f === null || f.tool !== e || f.toolData !== t) {
        v(true);
        f = {
          properties: M(i.backgroundTheme().spawnOwnership(), e, !i.readOnly()),
          tool: e,
          toolData: t
        };
      }
      return f.properties;
    }
    function v(e) {
      if (e) {
        f?.properties.destroy();
      }
      f = null;
    }
    async function S(e) {
      ["LineToolRiskRewardLong", "LineToolRiskRewardShort"].includes(e);
      const t = e;
      if (D(t) || (0, p.isAsyncStudyLineToolName)(t)) {
        await (0, d.studyMetaInfoRepository)().findAllJavaStudies();
      }
      if (!(0, p.isLineToolLoaded)(t)) {
        if ((0, h.isLineToolName)(t)) {
          await (0, p.loadLineTool)(t);
        }
      }
    }
    function b(e, t) {
      const i = "charts" in e ? e.charts : [e];
      for (const e of i) {
        for (const i of e.panes) {
          for (const e of i.sources) {
            t(e.type);
          }
        }
        e.lineToolsGroups?.groups.forEach(e => {
          e.tools.forEach(e => t(e));
        });
      }
    }
    class w extends Error {
      constructor(e, t) {
        super(`Failed to load line tool: ${e}`);
        this.name = "LineToolLoadError";
        this.toolName = e;
        this.originalError = t;
      }
    }
    const C = (0, m.getLogger)("LineToolsSynchronizer");
    async function P(e) {
      const t = new Set();
      const i = e => {
        if ((0, p.isAsyncGenericLineToolName)(e)) {
          t.add(e);
        }
      };
      for (const t of e) {
        b(t, i);
      }
      const s = [...t];
      const o = (await Promise.allSettled(s.map(e => (0, p.ensureLineToolLoaded)(e).catch(t => {
        throw new w(e, t);
      })))).filter(e => e.status === "rejected");
      if (o.length > 0) {
        o.forEach(e => {
          const t = e.reason;
          C.logError(`Failed to load line tool: ${t.toolName}`);
        });
      }
    }
    async function T(e) {
      if (!e) {
        return;
      }
      const t = new Set();
      b(e, e => {
        if ((0, h.isLineToolName)(e)) {
          t.add(e);
        }
      });
      await Promise.all(Array.from(t).map(e => S(e)));
    }
    function x(e, t, i, s, n, r) {
      (0, o.assert)((0, h.isLineToolName)(e), "Unknown line tool: " + e);
      const a = e;
      let l;
      (0, o.assert)((0, p.isLineToolLoaded)(a), `Line tool ${a} is not loaded`);
      if (!n && !i && f !== null && f.tool === e) {
        i = f.properties;
        v(false);
      }
      if ((0, p.isAsyncStudyLineToolName)(a)) {
        l = new ((0, p.getLoadedLineTool)(a))(t, i, (0, o.ensureDefined)(s), n, r);
      } else {
        l = new ((0, p.getLoadedLineTool)(a))(t, i, n, r);
      }
      l.toolname = e;
      v(true);
      return l;
    }
    function I(e, t) {
      const i = (0, o.ensureNotNull)(t.symbolSource());
      const s = i.symbolInfo();
      const n = s ? (0, c.extractLineToolSymbolFromSymbolInfo)(s, i.symbol()) : i.symbol();
      e.childs().symbol.setValue(n);
      if (i.model().currencyConversionEnabled() && i.isConvertedToOtherCurrency()) {
        e.childs().currencyId.setValue(i.currency());
      }
      if (i.model().unitConversionEnabled() && i.isConvertedToOtherUnit()) {
        e.childs().unitId.setValue(i.unit());
      }
      e.childs().symbolStateVersion.setValue(2);
      e.childs().zOrderVersion.setValue(2);
    }
    function M(e, t, i, s) {
      (0, o.assert)((0, h.isLineToolName)(t), `${t} should be name of the line tool`);
      const n = t;
      (0, o.assert)((0, p.isLineToolLoaded)(n), `Line tool ${n} is not loaded`);
      if ((0, p.isAsyncStudyLineToolName)(n)) {
        return (0, p.getLoadedLineTool)(n).createProperties(e, s);
      }
      return (0, p.getLoadedLineTool)(n).createProperties(e, s, i);
    }
    function A(e, t, i, s, n, r) {
      (0, o.assert)((0, h.isStudyLineToolName)(t), `${t} should be name of the study line tool`);
      const a = t;
      if ((0, p.isAsyncStudyLineToolName)(a)) {
        return (0, p.getLoadedLineTool)(a).createPropertiesFromStudyMetaInfoAndState(i, s, n, r, e);
      }
      throw new Error(`Property creation is not implemented for study line tool ${t}`);
    }
    function L(e) {
      (0, o.assert)((0, h.isLineToolName)(e), `${e} should be name of the line tool`);
      const t = e;
      (0, o.assert)((0, p.isLineToolLoaded)(t), `Line tool ${t} is not loaded`);
      const i = (0, p.getLoadedLineTool)(t);
      return i !== undefined && Boolean(i.supportPhantomMode);
    }
    function k(e) {
      return e instanceof _.LineToolBrushBase;
    }
    function D(e) {
      return e instanceof a.StudyLineDataSource;
    }
    function E(e) {
      return e instanceof l.LineToolTrading;
    }
    const B = ["editableTextStyle", "editableText", "editableTextProperties"];
    function V(e) {
      return (0, s.default)(e) && B.every(t => t in e);
    }
    function R(e) {
      let t = null;
      if (e === u.lineToolsStudyIds.LineToolRegressionTrend) {
        t = "LineToolRegressionTrend";
      } else if (e === u.lineToolsStudyIds.LineToolVbPFixed) {
        t = "LineToolVbPFixed";
      } else if (e === u.lineToolsStudyIds.LineToolFixedRangeVolumeProfile) {
        t = "LineToolFixedRangeVolumeProfile";
      }
      return t;
    }
    function N(e, t, i, s) {
      const a = t.toolname;
      const l = t.properties().state();
      l.intervalsVisibilities = (0, r.mergeIntervalVisibilitiesDefaults)(l?.intervalsVisibilities);
      const c = M(e.backgroundTheme().spawnOwnership(), t.toolname, !e.readOnly(), l);
      c.childs().visible.setValue(true);
      const h = (0, o.ensureNotNull)(t.ownerSource());
      const d = x(a, e, c);
      if (s !== undefined) {
        d.setId(s);
      }
      d.setOwnerSource(h);
      d.toolname = a;
      const u = d.clonePositionOffset();
      if (t.isFixed()) {
        const e = (0, o.ensureDefined)(t.fixedPoint());
        const s = i ? e.add(new n.Point(u.xCoordOffset, u.yCoordOffset)) : e;
        d.addFixedPoint(s);
      }
      const _ = t.normalizedPoints();
      const p = i ? function (e, t, i) {
        const s = (0, o.ensureNotNull)(t.priceScale());
        const n = (0, o.ensureNotNull)(t.firstValue());
        return e.map(e => {
          const t = e.price;
          const o = s.priceToCoordinate(t, n) + i.yCoordOffset;
          const r = s.coordinateToPrice(o, n);
          const a = e.interval;
          return {
            time_t: e.time_t,
            price: r,
            offset: e.offset + i.barOffset,
            interval: a
          };
        });
      }(_, h, u) : _;
      const m = t.points();
      d.restorePoints(p, m);
      if (d.cloneData) {
        d.cloneData(t);
      }
      if (d.recalculateStateByData) {
        d.recalculateStateByData();
      }
      return d;
    }
  },
  96333: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      LineToolPitchforkStyle: () => s
    });
    (function (e) {
      e[e.Original = 0] = "Original";
      e[e.Schiff = 1] = "Schiff";
      e[e.Inside = 2] = "Inside";
      e[e.Schiff2 = 3] = "Schiff2";
    })(s ||= {});
  },
  43156: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyLineDataSource: () => b
    });
    var s = i(64755);
    var o = i(29875);
    var n = i(32679);
    var r = i(68159);
    var a = i(14019);
    var l = i(65383);
    var c = i(71838);
    var h = i(678);
    class d extends c.StudyDataSource {
      constructor(e, t, i, s) {
        super(e, t.seriesSource(), i, s);
        this._series = t;
      }
      _createStudyError(e) {
        return (0, h.createStudyError)(this._getStudyErrorDescription(e), this._series.symbolInfo()?.exchange);
      }
    }
    var u = i(16685);
    var _ = i(82349);
    var p = i(17534);
    var m = i(44672);
    var g = i(27538);
    class f extends g.StatusProviderBase {
      constructor(e) {
        super();
        this._source = e;
      }
      errorStatus() {
        const e = this._source.status();
        if (e.type === h.StudyStatusType.Error) {
          return {
            error: this.sourceStatusText(),
            solutionId: (0, h.studyStatusSolutionId)(e),
            title: (0, h.studyStatusTitle)(e),
            studyFeature: (0, h.studyStatusFeature)(e)
          };
        } else {
          return null;
        }
      }
      getSplitTitle() {
        return this._source.titleInParts();
      }
      text() {
        return this._source.translatedType();
      }
      sourceStatusText() {
        return (0, h.convertStudyStatusToString)(this._source.status(), true);
      }
    }
    var y = i(62288);
    var v = i(27777);
    class S extends v.StatusView {
      constructor(e) {
        super(e.statusProvider({}));
      }
      getSplitTitle() {
        return this._statusProvider.getSplitTitle();
      }
    }
    class b extends o.LineDataSource {
      constructor(e, t, s, o, n, r) {
        super(e, o, n, r);
        this._indexes = null;
        this._inputs = null;
        this._definitionsViewModel = null;
        this._pointsetPoints = null;
        this._loadedPlots = null;
        this._loadedGraphics = null;
        this._beingCreatedPaneView = null;
        this._anchorsPaneView = null;
        this._isLegendDisplayed = false;
        Promise.all([Promise.all([i.e(6290), i.e(9116), i.e(1200), i.e(1583)]).then(i.bind(i, 8938)), Promise.all([i.e(6290), i.e(9116), i.e(1200), i.e(1583)]).then(i.bind(i, 19583))]).then(t => {
          const {
            LineToolBeingCreatedPaneView: i
          } = t[0];
          const {
            StudyLineDataSourceAnchorsPaneView: s
          } = t[1];
          this._beingCreatedPaneView = new i(this, e);
          this._anchorsPaneView = new s(this, this.model());
          this._model.lightUpdate();
        });
        this._metaInfo = t;
        this._dataSource = new d(e.chartApi(), e.mainSeries(), s, t);
        this._dataSource.dataCleared().subscribe(this, this._onDataCleared);
        this._dataSource.dataUpdated().subscribe(this, this._onDataUpdated);
        this._dataSource.studyStatusChanged().subscribe(this, this._onStudyStatusChanged);
        this._statusProvider = new f(this);
        this._statusView = new S(this);
        this._showStudyArgumentsProperty = e.properties().childs().paneProperties.childs().legendProperties.childs().showStudyArguments;
      }
      isDisplayedInLegend() {
        return this._isLegendDisplayed;
      }
      titleInParts() {
        const e = [];
        if (this._showStudyArgumentsProperty.value() && this._inputs) {
          for (const t of this._metaInfo.inputs) {
            if (t.isHidden === true || t.type === "bool") {
              continue;
            }
            const i = this._inputs[t.id];
            e.push(i.toString());
          }
        }
        return [this.name(), e];
      }
      destroy() {
        this._dataSource.dataUpdated().unsubscribeAll(this);
        this._dataSource.dataCleared().unsubscribeAll(this);
        this._dataSource.studyStatusChanged().unsubscribeAll(this);
        this._dataSource.destroy();
        if (this._definitionsViewModel !== null) {
          this._definitionsViewModel.destroy();
          this._definitionsViewModel = null;
        }
        this._unsubscribeApplyInputsOnSeriesCompleted();
        this._isDestroyed = true;
        super.destroy();
      }
      stop() {
        super.stop();
        if (!this._isDestroyed) {
          this._dataSource.stop();
          this.clearData();
        }
      }
      start() {
        super.start();
        if (!this._isDestroyed && this._inputs !== null) {
          this._dataSource.start();
        }
      }
      metaInfo() {
        return this._metaInfo;
      }
      graphicsInfo() {
        return this._metaInfo.graphics;
      }
      series() {
        return this._model.mainSeries();
      }
      translatedType() {
        return this._metaInfo.description;
      }
      name() {
        return this._metaInfo.description;
      }
      studyId() {
        return this._metaInfo.id;
      }
      setPoint(e, t, i) {
        super.setPoint(e, this._preparePoint(t, i));
      }
      move(e) { }
      clearData() {
        this._clearAllDataExceptPointsetPoints();
        this._pointsetPoints = null;
        this.updateAllViews((0, m.sourceChangeEvent)({
          sourceId: this.id(),
          clearData: true
        }));
        super.clearData();
      }
      data() {
        return this.plots();
      }
      plots() {
        return this._loadedPlots || this._dataSource.plots();
      }
      graphics() {
        return this._loadedGraphics || this._dataSource.graphics();
      }
      valueAt(e, t) {
        return this.ownerSource()?.symbolSource().valueAt(e, t) ?? null;
      }
      firstValue() {
        return this._model.mainSeries().firstValue();
      }
      state(e) {
        const t = {
          ...super.state(e),
          metaInfo: this.metaInfo().state()
        };
        if (e) {
          t.data = this.plots().state();
          t.nonseriesindexes = this._indexes;
          t.graphics = (0, a.saveStudyGraphics)(this.graphics(), null);
        }
        return t;
      }
      restoreData(e) {
        if (e.data !== undefined) {
          this._loadedPlots = new s.PlotList((0, _.studyPlotFunctionMap)(this._metaInfo), _.studyEmptyPlotValuePredicate);
          this._loadedPlots.restoreState(e.data);
        }
        this._indexes = e.nonseriesindexes ?? this._indexes;
        this._loadedGraphics = e.graphics ? (0, a.loadStudyGraphics)(e.graphics) : this._loadedGraphics;
      }
      getPropertyDefinitionsViewModel() {
        if (this._definitionsViewModel === null) {
          return this._getPropertyDefinitionsViewModelClass().then(e => e === null || this._isDestroyed ? null : (this._definitionsViewModel === null && (this._definitionsViewModel = new e(this._model.undoModel(), this)), this._definitionsViewModel));
        } else {
          return Promise.resolve(this._definitionsViewModel);
        }
      }
      paneViews(e) {
        let t = [];
        if (this.isSourceHidden()) {
          return t;
        }
        if (this._isReady() && this._changeStatesStack.isEmpty()) {
          const i = super.paneViews(e);
          if (i !== null) {
            t = t.concat(i);
          }
        } else if (this._beingCreatedPaneView !== null) {
          t.push(this._beingCreatedPaneView);
        }
        if (this._anchorsPaneView !== null) {
          t.push(this._anchorsPaneView);
        }
        return t;
      }
      propertiesChanged(e) {
        super.propertiesChanged(e);
        this._onStudyInputsMayChange();
      }
      dataAndViewsReady() {
        return super.dataAndViewsReady() && this._isReady();
      }
      endChanging(e, t) {
        const i = super.endChanging(e, t);
        if (i.indexesChanged) {
          this.clearData();
        } else {
          this._updateAnchorsPrice(true);
        }
        return i;
      }
      moveData(e) {
        this._dataSource.moveData(e);
      }
      restorePoints(e, t, i) {
        super.restorePoints(e, t, i);
        this._updateAnchorsPrice(true);
      }
      statusProvider(e) {
        return this._statusProvider;
      }
      statusView() {
        return this._statusView;
      }
      legendView() {
        return null;
      }
      dataProblemModel() {
        return null;
      }
      dataUpdatedModeModel() {
        return null;
      }
      marketStatusModel() {
        return null;
      }
      onStatusChanged() {
        return this._dataSource.studyStatusChanged();
      }
      status() {
        return this._dataSource.studyStatus();
      }
      recalcStudyIfNeeded() { }
      static createPropertiesFromStudyMetaInfoAndState(e, t, i, s, o) {
        const n = (0, p.prepareStudyPropertiesForLoadChart)(e, t, i, s, undefined, o);
        this._configureProperties(n);
        return n;
      }
      _getPointsetPoints() {
        return this._pointsetPoints;
      }
      _onStudyStatusChanged(e, t) {
        let i;
        switch (t.type) {
          case u.StudyStatusType.Error:
            i = true;
            break;
          case u.StudyStatusType.Completed:
            i = false;
            break;
          default:
            return;
        }
        if (i === this._isLegendDisplayed) {
          return;
        }
        this._isLegendDisplayed = i;
        const s = this._model.paneForSource(this);
        if (s) {
          const e = this._model.panes().indexOf(s);
          const t = y.InvalidationMask.invalidateLegendWidgetLayout(e);
          this.model().invalidate(t);
        }
      }
      _studyId() {
        return this._dataSource.studyId();
      }
      _isReady() {
        return true;
      }
      _updateAllPaneViews(e) {
        super._updateAllPaneViews(e);
        this._beingCreatedPaneView?.update();
        this._anchorsPaneView?.update(e);
      }
      _getPointTime(e, t) {
        const i = e.index;
        const s = this._model.timeScale().indexToTimePoint(i);
        if (s !== null) {
          return s;
        } else if (t || e.time === undefined) {
          return null;
        } else {
          return this._utcTimeInCurrentResolution(e);
        }
      }
      _updateAnchorsPrice(e) { }
      _onPointsetUpdated(e) {
        super._onPointsetUpdated(e);
        this._pointsetPoints = this._points.map(e => ({
          price: e.price,
          index: e.index,
          time: e.time
        }));
        this._onStudyInputsMayChange();
      }
      _onDataCleared() {
        this.updateAllViews((0, m.sourceChangeEvent)({
          sourceId: this.id(),
          clearData: true
        }));
        this._model.updateSource(this);
      }
      _onDataUpdated(e, t, i) {
        this._updateAnchorsPrice();
        this.updateAllViews((0, m.sourceChangeEvent)({
          sourceId: this.id(),
          firstUpdatedTimePointIndex: e[0]?.index
        }));
        this._model.updateSource(this);
      }
      _onStudyInputsMayChange() {
        let e = null;
        if (this._pointsetPoints !== null && this._pointsetPoints.length === this.pointsCount()) {
          e = this._studyInputs(this._pointsetPoints);
          if (e === null) {
            this._clearAllDataExceptPointsetPoints();
            this.updateAllViews((0, m.sourceChangeEvent)(this.id()));
          }
        }
        if (e !== null) {
          const t = this.metaInfo().inputs.map(e => e.id);
          const i = Object.keys(e);
          for (const s of i) {
            if (!t.includes(s)) {
              delete e[s];
            }
          }
        }
        if (!this._areInputsEqual(this._inputs, e)) {
          this._applyStudyInputs(e);
        }
      }
      _preparePoint(e, t) {
        return super._preparePoint(this._alignPointToRangeOfActualData(e), t);
      }
      _getPropertyDefinitionsViewModelClass() {
        return Promise.resolve(null);
      }
      _subscribeApplyInputsOnSeriesCompleted() {
        this._unsubscribeApplyInputsOnSeriesCompleted();
        this._model.mainSeries().dataEvents().completed().subscribe(this, () => this._onStudyInputsMayChange(), true);
      }
      _unsubscribeApplyInputsOnSeriesCompleted() {
        this._model.mainSeries().dataEvents().completed().unsubscribeAll(this);
      }
      _onInputsChanged() {
        0;
      }
      _clearAllDataExceptPointsetPoints() {
        this._inputs = null;
        this._dataSource.clearData();
        this._loadedPlots = null;
        this._indexes = null;
        this._loadedGraphics = null;
      }
      static _createPropertiesFromStudyIdAndState(e, t) {
        const i = r.StudyMetaInfo.getStudyPropertyRootNameById(e);
        const s = new n.DefaultProperty({
          defaultName: i,
          state: t
        });
        this._configureProperties(s);
        return s;
      }
      static _configureProperties(e) {
        super._configureProperties(e);
        e.removeExcludedKey("intervalsVisibilities", 1);
      }
      _areInputsEqual(e, t) {
        if (t === null) {
          return e === null;
        } else {
          return e !== null && (0, l.areStudyInputsEqual)(this._metaInfo.inputs, e, t);
        }
      }
      _applyStudyInputs(e) {
        const t = this._inputs;
        this._inputs = e;
        if (e !== null) {
          this._unsubscribeApplyInputsOnSeriesCompleted();
          this._dataSource.setInputs(e);
          if (t === null && this.isStarted() && !this._dataSource.isStarted()) {
            this._dataSource.start();
          }
        }
        this._onInputsChanged();
      }
    }
  },
  36009: (e, t, i) => {
    "use strict";

    const s = i(29875).LineDataSource;
    const o = i(92934).alignToStep;
    const n = i(24526).customFormatters;
    const r = i(68805).createSeriesFormatter;
    class a extends s {
      constructor(e, t) {
        super(e, t);
        this.customization.forcePriceAxisLabel = true;
        this.customization.disableErasing = true;
        this.customization.showInObjectsTree = false;
        this._createFormatter(e.mainSeries().symbolInfo());
        this.setSelectionEnabled(false);
      }
      isSynchronizable() {
        return false;
      }
      pointsCount() {
        return a.POINTS_COUNT;
      }
      hasContextMenu() {
        return false;
      }
      state() {
        return null;
      }
      startMoving() {
        super.startMoving.apply(this, arguments);
        this._cursorMoved = false;
      }
      endMoving() {
        super.endMoving.apply(this, arguments);
        this._cursorMoved = false;
      }
      userEditEnabled() {
        return true;
      }
      movable() {
        return false;
      }
      canBeHidden() {
        return false;
      }
      isUserDeletable() {
        return false;
      }
      showInObjectTree() {
        return false;
      }
      doesMovingAffectsUndo() {
        return false;
      }
      isAvailableInFloatingWidget() {
        return false;
      }
      timeAxisViews() {
        return null;
      }
      cloneable() {
        return false;
      }
      copiable() {
        return false;
      }
      _correctPoints(e, t) {
        if (this._currentMovingPoint && this._startMovingPoint) {
          if (this._currentMovingPoint.logical.price - this._startMovingPoint.logical.price) {
            this._cursorMoved = true;
          }
        } else {
          this._cursorMoved = false;
        }
        var i = 1 / this.priceScale().mainSource().base();
        for (var s = 0; s < e.length; s++) {
          var n = e[s];
          if (this._cursorMoved) {
            n.price = this._currentMovingPoint.logical.price;
          }
          n.price = o(n.price, i);
          e[s] = n;
        }
      }
      _createFormatter(e) {
        let t = null;
        t = n && n.priceFormatterFactory && n.priceFormatterFactory(e);
        if (t == null) {
          t = null;
        }
        this._formatter = t !== null ? t : r(e, "default", false, true);
      }
    }
    a.POINTS_COUNT = 1;
    e.exports.LineToolTrading = a;
  },
  58519: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      loadTheme: () => r
    });
    var s = i(85662);
    var o = i(76422);
    var n = i(35039);
    async function r(e, t) {
      const {
        themeName: i,
        standardTheme: r,
        syncState: a = true,
        noUndo: l = false,
        applyOverrides: c = false,
        onlyActiveChart: h = false
      } = t;
      const d = await (r ? Promise.resolve((0, s.getStdTheme)(i)) : (0, s.getTheme)(i));
      const u = !r;
      if (d.content !== undefined) {
        const t = !r || h;
        if (c) {
          if ((_ = d.content).chartProperties !== undefined) {
            (0, n.applyDefaultsOverrides)(_.chartProperties);
          }
          if (_.mainSourceProperties !== undefined) {
            (0, n.applyDefaultsOverrides)(_.mainSourceProperties, undefined, true, "mainSeriesProperties");
          }
        }
        await e.applyTheme({
          theme: d.content,
          onlyActiveChart: t,
          restoreNonThemeDefaults: u,
          themeName: i,
          standardTheme: r,
          syncState: a,
          noUndo: l
        });
        (0, o.emit)("chart_theme_changed", i, r, t);
      }
      var _;
      return d;
    }
  },
  92693: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      MagnetMode: () => s
    });
    (function (e) {
      e[e.WeakMagnet = 0] = "WeakMagnet";
      e[e.StrongMagnet = 1] = "StrongMagnet";
    })(s ||= {});
  },
  81171: (e, t, i) => {
    "use strict";

    i.d(t, {
      magnetEnabled: () => p,
      magnetMode: () => m,
      setIsMagnetEnabled: () => g,
      setMagnetMode: () => f
    });
    var s = i(32679);
    var o = i(64147);
    var n = i(92693);
    var r = i(928);
    var a = i(15764);
    var l = i(43550);
    const c = new o.WatchedValue(false);
    const h = new o.WatchedValue(n.MagnetMode.WeakMagnet);
    const d = (0, l.modifierPressed)();
    const u = (0, l.shiftPressed)();
    function _() {
      const e = d.value();
      if (u.value() && (r.isToolEditingNow.value() || r.isToolCreatingNow.value())) {
        c.setValue(false);
        return;
      }
      let t;
      let i;
      if (r.activePointSelectionMode.value() === r.SelectPointMode.Replay) {
        t = i = false;
      } else {
        const s = r.tool.value();
        const o = r.isStudyEditingNow.value() || r.activePointSelectionMode.value() === r.SelectPointMode.Study;
        t = e && ((0, a.isLineToolName)(s) || r.isToolEditingNow.value() || (0, r.toolIsMeasure)(s) || o);
        i = (0, r.properties)().childs().magnet.value();
      }
      h.setValue(!i && t ? n.MagnetMode.StrongMagnet : (0, r.properties)().childs().magnetMode.value());
      c.setValue(t ? !i : i);
    }
    function p() {
      return c;
    }
    function m() {
      return h;
    }
    function g(e) {
      (0, s.allowSavingDefaults)(true);
      (0, r.properties)().childs().magnet.setValue(e);
      (0, s.allowSavingDefaults)(false);
    }
    function f(e) {
      (0, s.allowSavingDefaults)(true);
      (0, r.properties)().childs().magnetMode.setValue(e);
      (0, r.properties)().childs().magnet.setValue(true);
      (0, s.allowSavingDefaults)(false);
    }
    (0, r.runOnDrawingStateReady)(() => {
      (0, r.properties)().childs().magnet.subscribe(null, _);
      (0, r.properties)().childs().magnetMode.subscribe(null, _);
      d.subscribe(_);
      u.subscribe(_);
      r.tool.subscribe(_);
      r.isToolEditingNow.subscribe(_);
      _();
    });
  },
  44672: (e, t, i) => {
    "use strict";

    i.d(t, {
      globalChangeEvent: () => a,
      hoverChangeEvent: () => _,
      selectionChangeEvent: () => d,
      sourceChangeEvent: () => n,
      viewportChangeEvent: () => c
    });
    var s;
    var o = i(83873);
    function n(e) {
      if ((0, o.default)(e)) {
        return {
          type: "data-source-change",
          sourceId: e
        };
      } else {
        return {
          type: "data-source-change",
          ...e
        };
      }
    }
    (function (e) {
      e.DataSourceChange = "data-source-change";
      e.ViewportChange = "viewport-change";
      e.GlobalChange = "global-change";
      e.SelectionChange = "selection-change";
      e.HoverChange = "hover-change";
    })(s ||= {});
    const r = {
      type: "global-change"
    };
    function a() {
      return r;
    }
    const l = {
      type: "viewport-change"
    };
    function c(e) {
      if (e) {
        return {
          type: "viewport-change",
          pane: e
        };
      } else {
        return l;
      }
    }
    const h = {
      type: "selection-change"
    };
    function d() {
      return h;
    }
    const u = {
      type: "hover-change"
    };
    function _() {
      return u;
    }
  },
  18172: (e, t, i) => {
    "use strict";

    i.d(t, {
      unpackNonSeriesData: () => n
    });
    var s = i(30551);
    var o = i(50151);
    async function n(e) {
      if (e === "") {
        return null;
      }
      const t = JSON.parse(e);
      if (!(0, s.isObject)(t) || typeof t == "function") {
        throw new Error("Non-object content in the non-series envelope");
      }
      if ((0, s.hasProperty)(t, "indexes_replace")) {
        return {
          indexes_replace: true
        };
      }
      const i = {
        indexes_replace: false
      };
      if ((0, s.hasProperty)(t, "offsets")) {
        i.offsets = t.offsets;
      }
      if ((0, s.hasProperty)(t, "isUpdate")) {
        if (typeof t.isUpdate != "boolean") {
          throw new Error("Invalid type of \"isUpdate\" field");
        }
        i.isUpdate = t.isUpdate;
      }
      if ((0, s.hasProperty)(t, "data")) {
        i.data = t.data;
      }
      if ((0, s.hasProperty)(t, "graphicsCmds")) {
        i.graphicsCmds = function (e) {
          if (!(0, s.isObject)(e)) {
            throw new Error("Graphics commands should be wrapped in an object");
          }
          (0, s.hasProperty)(e, "create");
          if ((0, s.hasProperty)(e, "erase")) {
            const t = e.erase;
            (0, o.assert)(Array.isArray(t), "Collection of erase commands should be array");
            for (const e of t) {
              if (!(0, s.isObject)(e) || !(0, s.hasProperty)(e, "action")) {
                throw new Error("Command should be an object with 'action' property");
              }
              (0, o.assert)(e.action === "all" || e.action === "one", "Erase command action should be 'all' or 'one'");
            }
          }
          return e;
        }(t.graphicsCmds);
      }
      return i;
    }
  },
  82587: (e, t, i) => {
    "use strict";

    i.d(t, {
      notAvailable: () => o
    });
    var s = i(11542);
    const o = i(56570).enabled("use_na_string_for_not_available_values") ? s.t(null, undefined, i(90091)) : "∅";
  },
  74079: (e, t, i) => {
    "use strict";

    i.d(t, {
      getNumericFormatter: () => c,
      getPercentageFormatter: () => h,
      getPipFormatter: () => _,
      getVolumeFormatter: () => d
    });
    var s = i(59623);
    var o = i(719);
    var n = i(725);
    class r extends n.PriceFormatter {
      constructor(e) {
        const {
          priceScale: t,
          minMove: i = 1,
          type: s,
          typespecs: o,
          minMove2: n,
          ignoreLocaleNumberFormat: r
        } = e;
        if ((s === "forex" || function (e, t) {
          return !!t?.includes("cfd") && ["commodity", "futures", "index", "stock", "fund"].includes(e);
        }(s, o)) && n) {
          super({
            priceScale: n,
            ignoreLocaleNumberFormat: r
          });
          this._isForex = true;
        } else {
          super({
            priceScale: 1,
            ignoreLocaleNumberFormat: r
          });
          this._isForex = false;
        }
        this._pipPriceScale = t;
        this._pipMinMove = i;
        this._pipMinMove2 = n;
      }
      format(e, t = {}) {
        const {
          signPositive: i,
          tailSize: s,
          ignoreLocaleNumberFormat: o
        } = t;
        let n = this._isForex ? this._pipMinMove2 : this._pipMinMove;
        if (n === undefined) {
          n = NaN;
        }
        return super.format(e * this._pipPriceScale / n, {
          signPositive: i,
          tailSize: s,
          ignoreLocaleNumberFormat: o
        });
      }
    }
    var a = i(46084);
    var l = i(58683);
    const c = (0, l.numDependencyFormatter)(e => new s.NumericFormatter({
      precision: e
    }));
    const h = (0, l.numDependencyFormatter)(e => new o.PercentageFormatter({
      priceScale: Math.pow(10, e ?? 2),
      minMove: 1
    }));
    const d = (0, l.numDependencyFormatter)(e => new a.VolumeFormatter({
      precision: e
    }));
    const u = new WeakMap();
    function _(e) {
      let t = u.get(e);
      if (!t) {
        t = new r({
          priceScale: e.pricescale,
          minMove: e.minmov,
          minMove2: e.minmove2,
          type: e.type,
          typespecs: e.typespecs
        });
        u.set(e, t);
      }
      return t;
    }
  },
  72791: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      PaneCursorType: () => s
    });
    (function (e) {
      e[e.Default = 0] = "Default";
      e[e.Pointer = 1] = "Pointer";
      e[e.Eraser = 2] = "Eraser";
      e[e.Dot = 3] = "Dot";
      e[e.Grabbing = 4] = "Grabbing";
      e[e.ZoomIn = 5] = "ZoomIn";
      e[e.VerticalResize = 6] = "VerticalResize";
      e[e.HorizontalResize = 7] = "HorizontalResize";
      e[e.DiagonalNeSwResize = 8] = "DiagonalNeSwResize";
      e[e.DiagonalNwSeResize = 9] = "DiagonalNwSeResize";
      e[e.Text = 10] = "Text";
    })(s ||= {});
  },
  65458: (e, t, i) => {
    "use strict";

    i.d(t, {
      PanePriceAxisView: () => n
    });
    var s = i(2844);
    class o {
      constructor(e) {
        this._priceAxisViewRenderer = null;
        this._rendererOptions = null;
        this._align = "right";
        this._textWidthCache = e;
      }
      setParams(e, t, i, s, o) {
        this._priceAxisViewRenderer = e;
        this._rendererOptions = t;
        this._align = o;
      }
      draw(e, t) {
        if (this._rendererOptions !== null && this._priceAxisViewRenderer !== null) {
          this._priceAxisViewRenderer.draw(e, t, this._rendererOptions, this._textWidthCache, this._align);
        }
      }
      hitTest(e, t) {
        if (this._priceAxisViewRenderer?.hitTest === undefined) {
          return null;
        } else {
          return this._priceAxisViewRenderer?.hitTest(e, t, this._align);
        }
      }
    }
    class n {
      constructor(e, t, i) {
        this._renderer = null;
        this._invalidated = true;
        this._priceAxisView = e;
        this._textWidthCache = new s.TextWidthCache(100);
        this._dataSource = t;
        this._chartModel = i;
        this._fontSize = -1;
        this._panePriceAxisViewRenderer = new o(this._textWidthCache);
      }
      update(e) {
        this._invalidated = true;
      }
      renderer(e) {
        if (this._invalidated) {
          this._updateImpl(e);
        }
        return this._renderer;
      }
      _position() {
        const e = this._chartModel.crosshairSource();
        const t = this._dataSource === e ? e.pane : this._chartModel.paneForSource(this._dataSource);
        if (t === null) {
          return null;
        }
        const i = this._priceScale();
        if (i === null) {
          return null;
        }
        let s = t.priceScalePosition(i);
        if (s === "overlay") {
          s = t.priceScalePosition(t.defaultPriceScale());
        }
        if (s === "overlay") {
          return null;
        } else {
          return s;
        }
      }
      _updateImpl(e) {
        this._renderer = null;
        const t = this._position();
        if (t === null) {
          return;
        }
        const i = this._chartModel.priceAxisRendererOptions();
        if (i.fontSize !== this._fontSize) {
          this._fontSize = i.fontSize;
          this._textWidthCache.reset();
        }
        this._panePriceAxisViewRenderer.setParams(this._priceAxisView.paneRenderer(), i, e.mediaSize.width, e.mediaSize.height, t);
        this._renderer = this._panePriceAxisViewRenderer;
        this._invalidated = false;
      }
      _priceScale() {
        return this._dataSource.priceScale();
      }
    }
  },
  52977: (e, t, i) => {
    "use strict";

    i.d(t, {
      applyColor: () => c
    });
    var s = i(83873);
    var o = i(5201);
    var n = i(46088);
    const r = new WeakMap();
    var a;
    var l;
    function c(e, t, i = 0, a = 3) {
      const {
        context: l,
        bitmapSize: c,
        mediaSize: h
      } = e;
      let d;
      if ((0, s.default)(t)) {
        d = t;
      } else if (t.type === n.ColorType.Solid) {
        d = t.color;
      } else {
        let e = r.get(l);
        if (e === undefined) {
          e = new o.CircularCacheBuffer(1000);
          r.set(l, e);
        }
        const s = i === 0 ? h.height : c.height;
        const n = `${t.startColor}_${t.endColor}_${s}`;
        let a = e.get(n);
        if (a === undefined) {
          a = l.createLinearGradient(0, 0, 0, s);
          a.addColorStop(0, t.startColor);
          a.addColorStop(1, t.endColor);
          e.set(n, a);
        }
        d = a;
      }
      if (a & 1) {
        l.strokeStyle = d;
      }
      if (a & 2) {
        l.fillStyle = d;
      }
    }
    (function (e) {
      e[e.Stroke = 1] = "Stroke";
      e[e.Fill = 2] = "Fill";
      e[e.Both = 3] = "Both";
    })(a ||= {});
    (function (e) {
      e[e.Media = 0] = "Media";
      e[e.Bitmap = 1] = "Bitmap";
    })(l ||= {});
  },
  67716: (e, t, i) => {
    "use strict";

    i.d(t, {
      AreaBackgroundItem: () => h,
      AreaBackgroundItemsGroup: () => l,
      AreaBackgroundRenderer: () => d,
      CachedMap: () => c
    });
    var s;
    var o;
    var n = i(50151);
    var r = i(30125);
    var a = i(59152);
    (function (e) {
      e[e.Solid = 0] = "Solid";
      e[e.Gradient = 1] = "Gradient";
    })(s ||= {});
    (function (e) {
      e[e.PurgeCachedMapCacheIterations = 50] = "PurgeCachedMapCacheIterations";
    })(o ||= {});
    class l extends a.CachedContainer {
      constructor(e) {
        super();
        this.color = e;
      }
    }
    class c {
      constructor() {
        this._map = new Map();
        this._usedKeys = new Set();
        this._invalidations = 0;
      }
      invalidateCache() {
        this._invalidations += 1;
        if (this._invalidations === 50) {
          this._deleteUnused();
          this._invalidations = 0;
        }
        this._usedKeys.clear();
        this._map.forEach((e, t) => e.invalidateCache());
      }
      get(e) {
        const t = this._map.get(e);
        if (t !== undefined) {
          this._usedKeys.add(e);
        }
        return t;
      }
      set(e, t) {
        this._usedKeys.add(e);
        this._map.set(e, t);
      }
      [Symbol.iterator]() {
        const e = Array.from(this._usedKeys)[Symbol.iterator]();
        return {
          [Symbol.iterator]() {
            return this;
          },
          next: () => {
            const t = e.next();
            if (t.value) {
              return {
                value: [t.value, (0, n.ensureDefined)(this._map.get(t.value))],
                done: false
              };
            } else {
              return {
                value: undefined,
                done: true
              };
            }
          }
        };
      }
      forEach(e) {
        this._map.forEach((t, i) => {
          if (this._usedKeys.has(i)) {
            e(t, i);
          }
        });
      }
      delete(e) {
        const t = this._map.get(e);
        if (t !== undefined) {
          t.invalidateCache();
        }
        this._usedKeys.delete(e);
      }
      _deleteUnused() {
        const e = [];
        this._map.forEach((t, i) => {
          if (!this._usedKeys.has(i)) {
            e.push(i);
          }
        });
        for (const t of e) {
          this._map.delete(t);
        }
      }
    }
    class h extends a.CachedContainer {
      constructor() {
        super();
        this.points1 = new a.CachedContainer();
        this.points2 = new a.CachedContainer();
        this.push(this.points1);
        this.push(this.points2);
      }
      addPoints1Point(e, t) {
        let i = this.points1.newItem();
        if (i !== null) {
          i.x = e;
          i.y = t;
        } else {
          i = {
            x: e,
            y: t
          };
        }
        this.points1.push(i);
      }
      addPoints2Point(e, t) {
        let i = this.points2.newItem();
        if (i !== null) {
          i.x = e;
          i.y = t;
        } else {
          i = {
            x: e,
            y: t
          };
        }
        this.points2.push(i);
      }
      invalidateCache() {
        this.points1.invalidateCache();
        this.points2.invalidateCache();
      }
    }
    class d extends r.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = null;
        this._data = e ?? null;
      }
      setData(e) {
        this._data = e;
      }
      hitTest(e) {
        return null;
      }
      _drawImpl(e) {
        if (this._data === null) {
          return;
        }
        const {
          context: t,
          horizontalPixelRatio: i,
          verticalPixelRatio: s
        } = e;
        const o = this._data.barSpacing * 0.25;
        for (const [, e] of this._data.colorAreas) {
          t.beginPath();
          for (let n = 0; n < e.length(); n++) {
            const r = e.at(n);
            if (r.points1.isEmpty() || r.points2.isEmpty()) {
              continue;
            }
            const a = r.points1.at(0).x;
            const l = r.points1.at(0).y;
            t.moveTo(Math.round(a * i), l * s);
            if (r.points1.length() !== 1 && r.points2.length() !== 1) {
              for (const e of r.points1.iterator(1)) {
                t.lineTo(Math.round(e.x * i), e.y * s);
              }
              for (const e of r.points2.iterator(r.points2.length() - 1, true)) {
                t.lineTo(Math.round(e.x * i), e.y * s);
              }
            } else {
              const e = r.points2.at(0).x;
              const n = r.points2.at(0).y;
              t.lineTo(Math.round((a + o) * i), l * s);
              t.lineTo(Math.round((e + o) * i), n * s);
              t.lineTo(Math.round((e - o) * i), n * s);
              t.lineTo(Math.round((a - o) * i), l * s);
            }
          }
          t.closePath();
          if (e.color.type === 0) {
            t.fillStyle = e.color.color;
          } else {
            const i = t.createLinearGradient(0, e.color.coordinate1 * s, 0, e.color.coordinate2 * s);
            i.addColorStop(0, e.color.color1 ?? "transparent");
            i.addColorStop(1, e.color.color2 ?? "transparent");
            t.fillStyle = i;
          }
          t.fill();
        }
      }
    }
  },
  2271: (e, t, i) => {
    "use strict";

    i.d(t, {
      PaneRendererArea: () => a
    });
    var s = i(74010);
    var o = i(61993);
    var n = i(37743);
    var r = i(52977);
    class a extends s.PaneRendererLine {
      constructor(e) {
        e.forceLineColor = false;
        super(e);
      }
      _drawImpl(e) {
        const t = this._data;
        if (t.items.length === 0) {
          return;
        }
        let i = this._data.visibleItemsRange?.startItemIndex ?? 0;
        let a = (this._data.visibleItemsRange?.endItemIndex ?? this._data.items.length) - 1;
        while (i < a && !(0, o.coordinateIsValid)(t.items[i].y)) {
          i++;
        }
        while (a >= 0 && !(0, o.coordinateIsValid)(t.items[a].y)) {
          a--;
        }
        if (i > a) {
          return;
        }
        const {
          context: l,
          horizontalPixelRatio: c,
          verticalPixelRatio: h
        } = e;
        l.save();
        l.scale(c, h);
        l.lineCap = "round";
        (0, r.applyColor)(e, t.lineColor, 0, 1);
        l.lineWidth = t.lineWidth;
        (0, n.setLineStyle)(l, t.lineStyle);
        l.lineWidth = 1;
        const d = new Map();
        const u = new s.PaneRendererLineItemsIterator(this._data.items, i, a + 1, this._data.skipHoles);
        while (u.next()) {
          const e = u.currentValue();
          let i;
          i = (0, s.isValidPoint)(e) && e.style ? e.style.color : t.lineColor;
          const o = u.nextValue();
          if ((0, s.isValidPoint)(o) && o?.style) {
            const t = o.style.color;
            if (i !== t) {
              const i = d.get(t) ?? [];
              i.push(e);
              d.set(t, i);
            }
          }
          const n = d.get(i) ?? [];
          n.push(e);
          d.set(i, n);
        }
        for (const [i, o] of d) {
          l.beginPath();
          let n = 0;
          for (let e = 0; e < o.length; e++) {
            const r = o[e];
            if ((0, s.isValidPoint)(r)) {
              if (r.style && r.style?.color !== i) {
                l.moveTo(Math.round(o[n].center), t.bottom);
                this._walkLine(l, o.slice(n, e), true, t.bottom, true);
                n = e;
              }
            }
          }
          l.moveTo(Math.round(o[n].center), t.bottom);
          this._walkLine(l, o.slice(n, o.length), true, t.bottom, true);
          l.closePath();
          if (t.isSeries) {
            const e = l.createLinearGradient(0, 0, 0, t.bottom);
            e.addColorStop(0, t.color1);
            e.addColorStop(1, t.color2);
            l.fillStyle = e;
            t.simpleMode = true;
          } else {
            (0, r.applyColor)(e, i, 0, 2);
          }
          l.fill();
        }
        l.lineWidth = t.lineWidth;
        l.restore();
        super._drawImpl(e);
      }
    }
  },
  30125: (e, t, i) => {
    "use strict";

    i.d(t, {
      BitmapCoordinatesPaneRenderer: () => o
    });
    var s = i(27714);
    class o {
      draw(e, t) {
        new s.CanvasRenderingTarget2D(e, t.mediaSize, t.bitmapSize).useBitmapCoordinateSpace(e => this._drawImpl(e));
      }
      drawBackground(e, t) {
        new s.CanvasRenderingTarget2D(e, t.mediaSize, t.bitmapSize).useBitmapCoordinateSpace(e => this._drawBackgroundImpl(e));
      }
      _drawBackgroundImpl(e) { }
    }
  },
  95201: (e, t, i) => {
    "use strict";

    i.d(t, {
      CompositeRenderer: () => s
    });
    class s {
      constructor() {
        this._renderers = [];
        this._globalAlpha = 1;
      }
      setGlobalAlpha(e) {
        this._globalAlpha = e;
      }
      append(e) {
        if (e) {
          this._renderers.push(e);
        }
      }
      insert(e, t) {
        this._renderers.splice(t, 0, e);
      }
      clear() {
        this._renderers.length = 0;
      }
      isEmpty() {
        return this._renderers.length === 0;
      }
      draw(e, t) {
        for (let i = 0; i < this._renderers.length; i++) {
          e.save();
          e.globalAlpha = this._globalAlpha;
          this._renderers[i].draw(e, t);
          e.restore();
        }
      }
      drawBackground(e, t) {
        e.save();
        e.globalAlpha = this._globalAlpha;
        for (let i = 0; i < this._renderers.length; i++) {
          const s = this._renderers[i];
          if (s.drawBackground) {
            s.drawBackground(e, t);
          }
        }
        e.restore();
      }
      hitTest(e, t) {
        let i = null;
        for (let s = this._renderers.length - 1; s >= 0; s--) {
          const o = this._renderers[s].hitTest(e, t);
          if (o !== null && (i === null || o.target() > i.target())) {
            i = o;
          }
        }
        return i;
      }
      doesIntersectWithBox(e, t) {
        return this._renderers.some(i => !!i.doesIntersectWithBox && i.doesIntersectWithBox(e, t));
      }
    }
  },
  37743: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      addHorizontalLineToPath: () => d,
      addLineToPath: () => T,
      addPixelPerfectLineToPath: () => I,
      addVerticalLineToPath: () => _,
      clearRectWithGradient: () => c,
      clipPolygonByEdge: () => A,
      computeDashPattern: () => P,
      createCircle: () => b,
      drawHorizontalLine: () => u,
      drawLine: () => x,
      drawPixelPerfectLine: () => M,
      drawPoly: () => w,
      drawRoundRect: () => f,
      drawRoundRectWithInnerBorder: () => y,
      drawVerticalLine: () => p,
      fillRectInnerBorder: () => h,
      fillRectWithBorder: () => S,
      scaleDrawRoundRectRadii: () => m,
      scaledDashPattern: () => v,
      setLineStyle: () => C
    });
    var s = i(86441);
    var o = i(5531);
    var n = i(51056);
    var r = i(85904);
    var a = i(7114);
    var l = i(64034);
    function c(e, t, i, s, o, n, r) {
      e.save();
      e.globalCompositeOperation = "copy";
      const a = e.createLinearGradient(0, 0, 0, o);
      a.addColorStop(0, n);
      a.addColorStop(1, r);
      e.fillStyle = a;
      e.fillRect(t, i, s, o);
      e.restore();
    }
    function h(e, t, i, s, o, n) {
      e.fillRect(t + n, i, s - n * 2, n);
      e.fillRect(t + n, i + o - n, s - n * 2, n);
      e.fillRect(t, i, n, o);
      e.fillRect(t + s - n, i, n, o);
    }
    function d(e, t, i, s) {
      const o = e.lineWidth % 2 ? 0.5 : 0;
      e.moveTo(i, t + o);
      e.lineTo(s, t + o);
    }
    function u(e, t, i, s) {
      e.beginPath();
      d(e, t, i, s);
      e.stroke();
    }
    function _(e, t, i, s) {
      const o = e.lineWidth % 2 ? 0.5 : 0;
      e.moveTo(t + o, i);
      e.lineTo(t + o, s);
    }
    function p(e, t, i, s) {
      e.beginPath();
      _(e, t, i, s);
      e.stroke();
    }
    function m(e, t) {
      if (Array.isArray(e)) {
        return e.map(e => Math.round(e * t));
      } else {
        return Math.round(e * t);
      }
    }
    function g(e, t) {
      if (Array.isArray(e)) {
        return e.map(e => e === 0 ? e : e + t);
      } else {
        return e + t;
      }
    }
    function f(e, t, i, s, o, n, r) {
      let a;
      let l;
      let c;
      let h;
      if (Array.isArray(n)) {
        if (n.length === 2) {
          const e = Math.max(0, n[0]);
          const t = Math.max(0, n[1]);
          a = e;
          l = e;
          c = t;
          h = t;
        } else {
          if (n.length !== 4) {
            throw new Error("Wrong border radius - it should be like css border radius");
          }
          a = Math.max(0, n[0]);
          l = Math.max(0, n[1]);
          c = Math.max(0, n[2]);
          h = Math.max(0, n[3]);
        }
      } else {
        const e = Math.max(0, n);
        a = e;
        l = e;
        c = e;
        h = e;
      }
      if (!r) {
        e.beginPath();
      }
      e.moveTo(t + a, i);
      e.lineTo(t + s - l, i);
      if (l !== 0) {
        e.arcTo(t + s, i, t + s, i + l, l);
      }
      e.lineTo(t + s, i + o - c);
      if (c !== 0) {
        e.arcTo(t + s, i + o, t + s - c, i + o, c);
      }
      e.lineTo(t + h, i + o);
      if (h !== 0) {
        e.arcTo(t, i + o, t, i + o - h, h);
      }
      e.lineTo(t, i + a);
      if (a !== 0) {
        e.arcTo(t, i, t + a, i, a);
      }
    }
    function y(e, t, i, s, o, n, a = 0, l = 0, c = "", h = r.LineStyle.Solid) {
      e.save();
      if (!l || !c || c === n) {
        f(e, t, i, s, o, a);
        e.fillStyle = n;
        e.fill();
        e.restore();
        return;
      }
      const d = l / 2;
      if (n !== "transparent") {
        const d = c !== "transparent" && h !== r.LineStyle.Solid;
        f(e, d ? t : t + l, d ? i : i + l, d ? s : s - l * 2, d ? o : o - l * 2, d ? a : g(a, -l));
        e.fillStyle = n;
        e.fill();
      }
      if (c !== "transparent") {
        f(e, t + d, i + d, s - l, o - l, g(a, -d));
        e.lineWidth = l;
        e.strokeStyle = c;
        C(e, h);
        e.closePath();
        e.stroke();
      }
      e.restore();
    }
    function v(e, t) {
      t = Math.max(1, t);
      return e.map(e => e * t);
    }
    function S(e, t, i, s, o, l, c, h, d) {
      const {
        context: _
      } = e;
      const p = l % 2 / 2;
      const m = t + p;
      const g = s + p;
      let f;
      let y;
      if (h) {
        const {
          borderMode: e,
          borderWidth: r,
          color: a,
          dashPattern: c,
          lineStyle: d
        } = h;
        switch (e) {
          case "outer":
            {
              const e = -l / 2 - r / 2;
              const t = -r / 2;
              y = {
                left: m + e,
                right: g - e,
                top: i + t,
                bottom: o - t
              };
              break;
            }
          case "center":
            {
              const e = r % 2 / 2;
              y = {
                left: t + e,
                right: s + e,
                top: i + e,
                bottom: o + e
              };
              break;
            }
          case "inner":
            {
              const e = -l / 2 + r / 2;
              const t = r / 2;
              y = {
                left: m + e,
                right: g - e,
                top: i + t,
                bottom: o - t
              };
            }
        }
        _.strokeStyle = a;
        _.lineWidth = r;
        let u = -1;
        if (c) {
          _.setLineDash(v(c, r));
        } else if (d !== undefined) {
          C(_, d);
          if (d === n.LINESTYLE_SOLID) {
            u = 1;
          }
        }
        f = {
          left: y.left + u * r / 2,
          top: y.top + u * r / 2,
          right: y.right - u * r / 2,
          bottom: y.bottom - u * r / 2
        };
      }
      if (c) {
        _.fillStyle = c.color;
        f ||= {
          left: m - l / 2,
          right: g + l / 2,
          top: i,
          bottom: o
        };
        _.fillRect(f.left, f.top, f.right - f.left, f.bottom - f.top);
      }
      if (d) {
        const {
          lineWidth: n,
          lineColor: r,
          lineStyle: l,
          excludeBoundaries: c
        } = d;
        _.save();
        _.lineCap = "butt";
        _.lineWidth = n;
        _.strokeStyle = r;
        C(_, l);
        const p = () => u(_, Math.floor((i + o) / 2), h?.rightToLeftStroke ? s : t, h?.rightToLeftStroke ? t : s);
        if (c) {
          (0, a.drawWithExclusionAreaByScope)(e, c, p);
        } else {
          p();
        }
        _.restore();
      }
      if (y) {
        if ((h?.lineStyle ?? r.LineStyle.Solid) === r.LineStyle.Solid) {
          _.strokeRect(y.left, y.top, y.right - y.left, y.bottom - y.top);
        } else {
          const e = h?.rightToLeftStroke ? y.right : y.left;
          const t = h?.rightToLeftStroke ? y.left : y.right;
          const i = y.top;
          const s = y.bottom;
          _.lineCap = "butt";
          [[e, i, t, i], [e, s, t, s], [e, i, e, s], [t, i, t, s]].forEach(([e, t, i, s]) => {
            _.beginPath();
            _.moveTo(e, t);
            _.lineTo(i, s);
            _.stroke();
          });
        }
      }
    }
    function b(e, t, i, s) {
      e.beginPath();
      e.arc(t, i, s, 0, Math.PI * 2, false);
      e.closePath();
    }
    function w(e, t, i) {
      e.beginPath();
      e.moveTo(t[0].x, t[0].y);
      for (const i of t) {
        e.lineTo(i.x, i.y);
      }
      e.closePath();
      e.stroke();
      if (i) {
        e.fill();
      }
    }
    function C(e, t) {
      let i = [];
      if (t !== n.LINESTYLE_SOLID) {
        i = P(e.lineWidth, t);
      }
      e.setLineDash(i);
    }
    function P(e, t) {
      return [[e, e * 2], [e * 5, e * 6], [e * 6, e * 6], [e, e * 4], [e * 2, e]][t - 1];
    }
    function T(e, t, i, s, o) {
      e.moveTo(t, i);
      e.lineTo(s, o);
    }
    function x(e, t, i, s, o) {
      if (isFinite(t) && isFinite(s) && isFinite(i) && isFinite(o)) {
        e.beginPath();
        T(e, t, i, s, o);
        e.stroke();
      }
    }
    function I(e, t, i, s, o, n) {
      const {
        horizontalPixelRatio: r,
        verticalPixelRatio: a
      } = n;
      let l;
      if (t === s) {
        l = [Math.round(t * r), i * a, Math.round(t * r), o * a];
        _(e, l[0], l[1], l[3]);
      } else if (i === o) {
        l = [t * r, Math.round(i * a), s * r, Math.round(i * a)];
        d(e, l[1], l[0], l[2]);
      } else {
        l = [t * r, i * a, s * r, o * a];
        T(e, l[0], l[1], l[2], l[3]);
      }
      return l;
    }
    function M(e, t, i, s, o, n = l.dpr1PixelRatioInfo) {
      e.beginPath();
      I(e, t, i, s, o, n);
      e.stroke();
    }
    function A(e, t, i, n) {
      const r = (0, s.equalPoints)(i, n[0]) ? (0, s.equalPoints)(i, n[1]) ? null : n[1] : n[0];
      if (e !== null && r !== null) {
        return (0, o.intersectPolygonAndHalfplane)(e, (0, s.halfplaneThroughPoint)((0, s.lineThroughPoints)(t, i), r));
      } else {
        return null;
      }
    }
  },
  61993: (e, t, i) => {
    "use strict";

    i.d(t, {
      coordinateIsValid: () => g,
      extendAndClipLineSegment: () => h,
      fillScaledRadius: () => y,
      getArrowPoints: () => d,
      interactionTolerance: () => m,
      optimalBarWidth: () => u,
      optimalCandlestickWidth: () => _,
      optimalHiLoWidth: () => p,
      roundToMax: () => S,
      setValidLineStyle: () => f,
      strokeScaledRadius: () => v
    });
    var s = i(86441);
    var o = i(5531);
    var n = i(69186);
    var r = i(37265);
    var a = i(37743);
    const l = {
      common: 13,
      line: 13,
      minDistanceBetweenPoints: 10,
      series: 14,
      curve: 10,
      anchor: 13,
      esd: 4
    };
    const c = {
      common: 3,
      line: 3,
      minDistanceBetweenPoints: 5,
      series: 2,
      curve: 3,
      anchor: 2,
      esd: 0
    };
    function h(e, t, i, n, r, a) {
      if ((0, s.equalPoints)(e, t)) {
        return null;
      }
      const l = new s.Point(0, 0);
      const c = new s.Point(i, n);
      if (r) {
        if (a) {
          const i = (0, o.intersectLineAndBox)((0, s.lineThroughPoints)(e, t), (0, s.box)(l, c));
          if (Array.isArray(i)) {
            return i;
          } else {
            return null;
          }
        }
        {
          const i = (0, o.intersectRayAndBox)(t, e, (0, s.box)(l, c));
          if (i === null || (0, s.equalPoints)(t, i)) {
            return null;
          } else {
            return (0, s.lineSegment)(t, i);
          }
        }
      }
      if (a) {
        const i = (0, o.intersectRayAndBox)(e, t, (0, s.box)(l, c));
        if (i === null || (0, s.equalPoints)(e, i)) {
          return null;
        } else {
          return (0, s.lineSegment)(e, i);
        }
      }
      {
        const i = (0, o.intersectLineSegmentAndBox)((0, s.lineSegment)(e, t), (0, s.box)(l, c));
        if (Array.isArray(i)) {
          return i;
        } else {
          return null;
        }
      }
    }
    function d(e, t, i, s, o) {
      const n = i * 0.5;
      const r = Math.sqrt(2);
      const a = t.subtract(e);
      const l = a.normalized();
      let c = i * 5;
      if (s) {
        c = Math.min(c, a.length() * 0.35);
      }
      const h = n * 1;
      if (c * r * 0.2 <= h) {
        return [];
      }
      const d = l.scaled(c);
      const u = t.subtract(d);
      const _ = l.transposed();
      const p = c * 1;
      const m = _.scaled(p);
      const g = u.add(m);
      const f = u.subtract(m);
      const y = g.subtract(t).normalized().scaled(h);
      const v = f.subtract(t).normalized().scaled(h);
      const S = o ? t : t.add(y);
      const b = o ? t : t.add(v);
      const w = n * (r - 1);
      const C = _.scaled(w);
      const P = Math.min(c - n * 1 / r, n * r * 1);
      const T = l.scaled(P);
      const x = t.subtract(C);
      const I = t.add(C);
      const M = t.subtract(T);
      return [[g, S], [b, f], [x, M.subtract(C)], [I, M.add(C)]];
    }
    function u(e, t) {
      t = t || 1;
      return Math.floor(e * 0.3 * t);
    }
    function _(e, t) {
      if (e >= 2.5 && e <= 4) {
        return Math.floor(t * 3);
      }
      const i = 1 - Math.atan(Math.max(4, e) - 4) * 0.2 / (Math.PI * 0.5);
      const s = Math.floor(e * i * t);
      const o = Math.floor(e * t);
      const n = Math.min(s, o);
      return Math.max(Math.floor(t), n);
    }
    function p(e) {
      return e * 0.4;
    }
    function m() {
      if ((0, n.lastMouseOrTouchEventInfo)().isTouch) {
        return l;
      } else {
        return c;
      }
    }
    function g(e) {
      return e != null && !(0, r.isNaN)(e);
    }
    function f(e, t) {
      if (t !== undefined) {
        (0, a.setLineStyle)(e, t);
      }
    }
    function y(e, t) {
      const i = Math.max(1, Math.floor(t)) % 2 ? 0.5 : 0;
      return Math.round(e * t) + i;
    }
    function v(e, t, i) {
      const s = Math.max(1, Math.floor(t)) % 2 ? 0.5 : 0;
      return Math.round(e * t) + (s !== i % 2 ? 0.5 : 0);
    }
    function S(e) {
      return Math.max(Math.floor(e), 1);
    }
  },
  50600: (e, t, i) => {
    "use strict";

    i.d(t, {
      HorizontalLineRenderer: () => l
    });
    var s = i(56468);
    var o = i(37743);
    var n = i(61993);
    var r = i(30125);
    var a = i(7114);
    class l extends r.BitmapCoordinatesPaneRenderer {
      constructor() {
        super(...arguments);
        this._data = null;
        this._hitTest = new s.HitTestResult(s.HitTarget.Regular);
      }
      setData(e) {
        this._data = e;
      }
      setHitTest(e) {
        this._hitTest = e;
      }
      hitTest(e) {
        if (this._data === null || this._data.visible === false || this._hitTest === null) {
          return null;
        }
        const t = (0, n.interactionTolerance)().line;
        const i = Math.abs(e.y - this._data.y) <= t + this._data.linewidth / 2;
        const s = this._data.left === undefined || this._data.left - e.x <= t;
        const o = this._data.right === undefined || e.x - this._data.right <= t;
        if (i && s && o) {
          return this._hitTest;
        } else {
          return null;
        }
      }
      _drawImpl(e) {
        if (this._data === null || this._data.visible === false) {
          return;
        }
        const {
          context: t,
          horizontalPixelRatio: i,
          verticalPixelRatio: s,
          mediaSize: n
        } = e;
        if (this._data.y < -this._data.linewidth / 2 || this._data.y > n.height + this._data.linewidth / 2) {
          return;
        }
        t.lineCap = "butt";
        t.strokeStyle = this._data.color;
        t.lineWidth = Math.max(1, Math.floor(this._data.linewidth * i));
        if (this._data.linestyle !== undefined) {
          (0, o.setLineStyle)(t, this._data.linestyle);
        }
        const r = this._data.left !== undefined ? Math.max(this._data.left, 0) : 0;
        const l = this._data.right !== undefined ? Math.min(this._data.right, n.width) : n.width;
        const c = Math.round(this._data.y * s);
        const h = Math.round(r * i);
        const d = Math.round(l * i);
        const u = this._data.excludeBoundaries;
        if (u !== undefined) {
          (0, a.addExclusionAreaByScope)(e, u);
        }
        (0, o.drawHorizontalLine)(t, c, h, d);
      }
    }
  },
  49857: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      LineEnd: () => s
    });
    (function (e) {
      e[e.Normal = 0] = "Normal";
      e[e.Arrow = 1] = "Arrow";
      e[e.Circle = 2] = "Circle";
    })(s ||= {});
  },
  74010: (e, t, i) => {
    "use strict";

    i.d(t, {
      PaneRendererLine: () => p,
      PaneRendererLineItemsIterator: () => _,
      isValidPoint: () => u
    });
    var s = i(50151);
    var o = i(86441);
    var n = i(4652);
    var r = i(56468);
    var a = i(61993);
    var l = i(37743);
    var c = i(30125);
    var h = i(52977);
    const d = {
      y: NaN
    };
    function u(e) {
      return e !== null && !isNaN(e.y);
    }
    class _ {
      constructor(e, t, i, o) {
        this._calculatedPrev = {
          index: null,
          currentBreakProcessed: false,
          value: null
        };
        this._calculatedCurrent = {
          index: null,
          currentBreakProcessed: false,
          value: null
        };
        this._calculatedNext = {
          index: null,
          currentBreakProcessed: false,
          value: null
        };
        this._preallocatedVariable = {
          index: null,
          currentBreakProcessed: false,
          value: null
        };
        if (e.length) {
          (0, s.assert)(t <= i, "First index must be less or equal to last index");
          (0, s.assert)(t < e.length, "First index must be less then array length");
          (0, s.assert)(i <= e.length, "Last index must be less or equal to array length");
        }
        this._items = e;
        this._firstIndexWithRange = t;
        this._lastIndexWithRange = i;
        this._skipHoles = o;
      }
      next() {
        if (this._items.length === 0) {
          return false;
        }
        if (this._calculatedNext.index !== null) {
          return this._calculatedNext.value !== null && (this._calculatedPrev = this._calculatedCurrent, this._calculatedCurrent = this._calculatedNext, this._calculatedNext = {
            index: null,
            currentBreakProcessed: false,
            value: null
          }, true);
        }
        let e;
        this._preallocatedVariable = {
          ...this._calculatedCurrent
        };
        do {
          if (this._preallocatedVariable.index === null) {
            this._preallocatedVariable.index = this._firstIndexWithRange;
            this._preallocatedVariable.currentBreakProcessed = false;
            e = this._preallocatedVariable.index < this._lastIndexWithRange;
          } else {
            this._incrementPointer(this._preallocatedVariable);
            e = this._isValidPointer(this._preallocatedVariable);
          }
          if (e) {
            this._calcVaue(this._preallocatedVariable);
          }
        } while (e && this._skipHoles && !u(this._preallocatedVariable.value));
        if (e) {
          this._calculatedPrev = this._calculatedCurrent;
          this._calculatedCurrent = this._preallocatedVariable;
          this._calculatedNext = {
            index: null,
            currentBreakProcessed: false,
            value: null
          };
        }
        return e;
      }
      prevValue() {
        return this._calculatedPrev.value;
      }
      currentValue() {
        return (0, s.ensureNotNull)(this._calculatedCurrent.value);
      }
      currentValueIsLast() {
        return (0, s.ensureNotNull)(this._calculatedCurrent.index) === this._items.length - 1;
      }
      currentValueIsFirst() {
        return (0, s.ensureNotNull)(this._calculatedCurrent.index) === 0;
      }
      nextValue() {
        if (this._calculatedNext.index !== null) {
          return this._calculatedNext.value;
        }
        let e;
        this._calculatedNext = {
          ...this._calculatedCurrent,
          value: null
        };
        do {
          this._incrementPointer(this._calculatedNext);
          e = this._isValidPointer(this._calculatedNext);
          if (e) {
            this._calcVaue(this._calculatedNext);
          } else {
            this._calculatedNext.value = null;
          }
        } while (e && this._skipHoles && !u(this._calculatedNext.value));
        return this._calculatedNext.value;
      }
      atStart() {
        return this._calculatedCurrent.index === this._firstIndexWithRange && !this._calculatedCurrent.currentBreakProcessed;
      }
      atEnd() {
        const e = (0, s.ensureNotNull)(this._calculatedCurrent.index);
        return e < this._lastIndexWithRange && (this._calculatedCurrent.currentBreakProcessed || !this._needBreakBefore(e));
      }
      _needBreakBefore(e) {
        return !!this._items[e].breakBefore && !this._skipHoles;
      }
      _calcVaue(e) {
        const t = (0, s.ensureNotNull)(e.index);
        if (this._needBreakBefore(t) && !e.currentBreakProcessed) {
          e.value = d;
        } else {
          e.value = this._items[t];
        }
      }
      _incrementPointer(e) {
        const t = (0, s.ensureNotNull)(e.index);
        if (this._needBreakBefore(t) && !this._calculatedCurrent.currentBreakProcessed) {
          e.currentBreakProcessed = true;
        } else {
          e.index = t + 1;
          e.currentBreakProcessed = false;
        }
      }
      _isValidPointer(e) {
        const t = (0, s.ensureNotNull)(e.index);
        return t < this._lastIndexWithRange || t === this._lastIndexWithRange - 1 && this._needBreakBefore(t) && e.currentBreakProcessed;
      }
    }
    class p extends c.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = e;
      }
      hitTest(e) {
        const t = (0, a.interactionTolerance)().series + this._data.lineWidth / 2;
        let i = this._data.visibleItemsRange?.startItemIndex ?? 0;
        let s = (this._data.visibleItemsRange?.endItemIndex ?? this._data.items.length) - 1;
        while (s - i > 2) {
          const t = Math.round((s + i) / 2);
          if (this._data.items[t].center <= e.x) {
            i = t;
          } else {
            s = t;
          }
        }
        i = Math.max(1, i - 1);
        s = Math.min(this._data.items.length - 1, s + 1);
        for (let a = i; a <= s; ++a) {
          const i = this._data.items[a - 1];
          const s = this._data.items[a];
          const l = i.center;
          const c = s.center;
          if ((0, n.distanceToSegment)(new o.Point(l, i.y), new o.Point(c, s.y), new o.Point(e.x, e.y)).distance <= t) {
            if (this._data.hittest) {
              return this._data.hittest;
            } else {
              return new r.HitTestResult(r.HitTarget.Regular);
            }
          }
        }
        return null;
      }
      _drawImpl(e) {
        const {
          context: t,
          horizontalPixelRatio: i,
          verticalPixelRatio: s
        } = e;
        t.scale(i, s);
        t.lineCap = "round";
        t.lineJoin = "round";
        (0, h.applyColor)(e, this._data.lineColor, 0, 3);
        t.lineWidth = this._data.lineWidth;
        (0, l.setLineStyle)(t, this._data.lineStyle);
        (0, a.setValidLineStyle)(t, this._data.lineStyle);
        if (this._data.simpleMode) {
          this._drawSimpleMode(e);
        } else {
          this._drawLines(t);
        }
      }
      _drawSimpleMode(e) {
        const {
          context: t,
          horizontalPixelRatio: i,
          verticalPixelRatio: s
        } = e;
        t.beginPath();
        this._walkLine(t, this._data.items, false, NaN);
        t.stroke();
        const o = this._data.lineWidth + 2;
        if (this._data.withMarkers && o * 2 < this._data.barSpacing) {
          t.scale(1 / i, 1 / s);
          (0, h.applyColor)(e, this._data.lineColor, 1, 2);
          const n = Math.max(1, Math.floor(i)) % 2 / 2;
          const r = o * s + n;
          const a = Math.PI * 2;
          t.beginPath();
          const l = this._data.visibleItemsRange?.startItemIndex ?? 0;
          for (let e = (this._data.visibleItemsRange?.endItemIndex ?? this._data.items.length) - 1 + 1; e-- >= l;) {
            const o = this._data.items[e];
            if (o) {
              const e = Math.round(o.center * i) + n;
              const l = o.y * s;
              t.moveTo(e, l);
              t.arc(e, l, r, 0, a);
            }
          }
          t.fill();
        }
      }
      _walkLine(e, t, i, s, o) {
        if (!t) {
          return;
        }
        const n = this._data.barSpacing * 0.25;
        let r;
        let a;
        let l = null;
        const c = o ? 0 : this._data.visibleItemsRange?.startItemIndex ?? 0;
        const h = o ? t.length : Math.min(this._data.visibleItemsRange?.endItemIndex ?? t.length, t.length);
        if (c > h || c >= t.length) {
          return;
        }
        const d = new _(t, c, h, this._data.skipHoles);
        while (d.next()) {
          r = d.currentValue();
          a = d.nextValue();
          if (u(r)) {
            const t = Math.round(r.center);
            if (l && u(l)) {
              e.lineTo(t, r.y);
              if (i && !u(a)) {
                e.lineTo(t, s);
              }
            } else if (a && u(a)) {
              if (i) {
                if (!d.atStart()) {
                  e.lineTo(t, s);
                }
                e.lineTo(t, r.y);
              } else {
                e.moveTo(t, r.y);
              }
            } else if (i) {
              if (!d.atStart()) {
                e.lineTo(t - n, s);
              }
              e.lineTo(t - n, r.y);
              e.lineTo(t + n, r.y);
              e.lineTo(t + n, s);
            } else {
              e.moveTo(t - n, r.y);
              e.lineTo(t + n, r.y);
            }
          }
          l = r;
        }
      }
      _drawLines(e) {
        if (!this._data.items.length) {
          return;
        }
        let t;
        let i;
        let s = null;
        const o = this._data.barSpacing * 0.25;
        e.beginPath();
        const n = this._data.visibleItemsRange?.startItemIndex ?? 0;
        const r = this._data.visibleItemsRange?.endItemIndex ?? this._data.items.length;
        if (n > r || n >= this._data.items.length) {
          return;
        }
        const l = this._data.items[n];
        if (l) {
          e.moveTo(l.center, l.y);
        }
        let c;
        let h = e.strokeStyle;
        let d = e.lineWidth;
        const p = new _(this._data.items, n, r, this._data.skipHoles);
        while (p.next()) {
          let n;
          let r;
          let l;
          s = p.prevValue();
          t = p.currentValue();
          i = p.nextValue();
          let _ = false;
          if (u(t)) {
            if (t.style && !this._data.forceLineColor) {
              n = t.style.color;
              r = t.style.width;
              l = t.style.style;
            } else {
              n = this._data.lineColor;
              r = this._data.lineWidth;
              l = this._data.lineStyle;
            }
            if (this._data.ignorePaletteLineWidth) {
              r = this._data.lineWidth;
            }
            _ = n !== h || r !== d || l !== c;
          }
          if (_) {
            h = n;
            d = r;
            c = l;
            e.stroke();
            e.beginPath();
            e.strokeStyle = n;
            e.lineWidth = r;
            (0, a.setValidLineStyle)(e, l);
            if (u(s)) {
              e.moveTo(s.center, s.y);
            } else {
              const i = t;
              e.moveTo(i.center, i.y);
            }
          }
          m = s;
          f = i;
          if (u(g = t)) {
            if (u(m)) {
              e.lineTo(g.center, g.y);
            } else if (f && u(f)) {
              e.moveTo(g.center, g.y);
            } else {
              e.moveTo(g.center - o, g.y);
              e.lineTo(g.center + o, g.y);
            }
          }
        }
        var m;
        var g;
        var f;
        e.stroke();
      }
    }
  },
  75919: (e, t, i) => {
    "use strict";

    i.d(t, {
      MediaCoordinatesPaneRenderer: () => o
    });
    var s = i(27714);
    class o {
      draw(e, t) {
        new s.CanvasRenderingTarget2D(e, t.mediaSize, t.bitmapSize).useMediaCoordinateSpace(e => this._drawImpl(e));
      }
      drawBackground(e, t) {
        new s.CanvasRenderingTarget2D(e, t.mediaSize, t.bitmapSize).useMediaCoordinateSpace(e => this._drawBackgroundImpl(e));
      }
      _drawBackgroundImpl(e) { }
    }
  },
  59152: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      CachedContainer: () => n,
      ObjectValuesCache: () => r
    });
    (function (e) {
      e[e.PurgeCachedContainerCacheIterations = 3000] = "PurgeCachedContainerCacheIterations";
    })(s ||= {});
    class o {
      constructor(e, t, i, s) {
        this._items = e;
        this._actualLength = t;
        this._step = s ? -1 : 1;
        this._currentIndex = i - this._step;
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        this._currentIndex += this._step;
        if (this._currentIndex >= this._actualLength || this._currentIndex < 0) {
          return {
            value: undefined,
            done: true
          };
        } else {
          return {
            done: false,
            value: this._items[this._currentIndex]
          };
        }
      }
    }
    class n {
      constructor() {
        this._items = [];
        this._actualLength = 0;
        this._invalidations = 0;
      }
      push(e) {
        if (this._items.length === this._actualLength) {
          this._items.push(e);
        } else if (this._items[this._actualLength] !== e) {
          this._items[this._actualLength] = e;
        }
        this._actualLength += 1;
      }
      newItem() {
        const e = this._items.length > this._actualLength ? this._items[this._actualLength] : null;
        if (e !== null && Boolean(e.invalidateCache)) {
          e.invalidateCache();
        }
        return e;
      }
      invalidateCache() {
        this._invalidations += 1;
        if (this._invalidations === 3000) {
          this._items.splice(this._actualLength);
          this._invalidations = 0;
        }
        this._actualLength = 0;
      }
      at(e) {
        return this._items[e];
      }
      data() {
        return this._items;
      }
      length() {
        return this._actualLength;
      }
      isEmpty() {
        return this._actualLength === 0;
      }
      iterator(e, t) {
        return new o(this._items, this._actualLength, e, t);
      }
    }
    class r extends n {
      constructor() {
        super(...arguments);
        this._startIndex = 0;
      }
      setStartIndex(e) {
        this._startIndex = e;
      }
      isValidIndex(e) {
        return e >= this._startIndex;
      }
      at(e) {
        const t = e - this._startIndex;
        while (t >= this._actualLength) {
          if (this._items.length <= t) {
            this._items.push(this._newObject());
          } else {
            this._clearObject(this._items[this._actualLength]);
          }
          this._actualLength += 1;
        }
        return this._items[t];
      }
    }
  },
  62189: (e, t, i) => {
    "use strict";

    i.d(t, {
      RectangleRenderer: () => _
    });
    var s;
    var o = i(50151);
    var n = i(86441);
    var r = i(34026);
    var a = i(4652);
    var l = i(19063);
    var c = i(56468);
    var h = i(85904);
    var d = i(37743);
    var u = i(30125);
    (function (e) {
      e[e.HitTestTolerance = 3] = "HitTestTolerance";
    })(s ||= {});
    class _ extends u.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = null;
        this._forceOverrideTransparency = Boolean(e);
      }
      setData(e) {
        this._data = e;
      }
      hitTest(e, t) {
        if (this._data === null || this._data.points.length < 2 || this._data.disableInteractions) {
          return null;
        }
        const i = t.mediaSize.width;
        const s = (0, n.box)(...this._data.points);
        const o = s.min;
        const r = s.max;
        const l = new n.Point(r.x, o.y);
        const h = new n.Point(o.x, r.y);
        const d = this._extendAndHitTestLineSegment(e, o, l, i);
        if (d !== null) {
          return d;
        }
        const u = this._extendAndHitTestLineSegment(e, h, r, i);
        if (u !== null) {
          return u;
        }
        let _ = (0, a.distanceToSegment)(l, r, e);
        if (_.distance <= 3) {
          return new c.HitTestResult(c.HitTarget.MovePoint);
        }
        _ = (0, a.distanceToSegment)(o, h, e);
        if (_.distance <= 3) {
          return new c.HitTestResult(c.HitTarget.MovePoint);
        }
        if (this._data.middleLine) {
          const t = s.min.add(s.max).scaled(0.5);
          const o = this._extendAndHitTestLineSegment(e, new n.Point(s.min.x, t.y), new n.Point(s.max.x, t.y), i);
          if (o !== null) {
            return o;
          }
        }
        if (this._data.fillBackground) {
          return this._hitTestBackground(e, o, r, i);
        } else {
          return null;
        }
      }
      getColor() {
        const e = (0, o.ensure)(this._data);
        if (e.transparency === undefined) {
          return e.backcolor;
        } else {
          return (0, l.generateColor)(e.backcolor, e.transparency, this._forceOverrideTransparency);
        }
      }
      visibleRectSegment(e) {
        const t = this._data;
        if (t === null) {
          return null;
        }
        const i = (0, n.box)(...t.points);
        const s = i.min;
        const o = i.max;
        const r = e.width;
        const a = e.height;
        const l = t.extendLeft ? 0 : Math.max(s.x, 0);
        const c = t.extendRight ? r : Math.min(o.x, r);
        if (l > c || c <= 0 || l >= r) {
          return null;
        }
        const h = Math.max(s.y, 0);
        const d = Math.min(o.y, a);
        if (h > d || d <= 0 || h > a) {
          return null;
        } else {
          return [new n.Point(l, h), new n.Point(c, d)];
        }
      }
      _drawImpl(e) {
        if (this._data === null || this._data.points.length < 2 || this._data.linewidth <= 0 && !this._data.fillBackground) {
          return;
        }
        const {
          horizontalPixelRatio: t,
          verticalPixelRatio: i,
          bitmapSize: s
        } = e;
        const {
          extendLeft: o,
          extendRight: r,
          linewidth: a,
          middleLine: l
        } = this._data;
        const c = (0, n.box)(...this._data.points);
        const u = this._data.linewidth ? Math.max(1, Math.floor(this._data.linewidth * t)) : 0;
        const _ = this._data.fillBackground ? this.getColor() : undefined;
        const p = Math.max(1, Math.floor(t));
        const m = o ? -a : Math.round(c.min.x * t);
        const g = r ? s.width + a : Math.round(c.max.x * t);
        const f = Math.round(c.min.y * i);
        const y = Math.round(c.max.y * i);
        (0, d.fillRectWithBorder)(e, m, f, g, y, p, _ === undefined ? undefined : {
          color: _
        }, u === 0 ? undefined : {
          color: this._data.color,
          lineStyle: this._data.linestyle ?? h.LineStyle.Solid,
          borderWidth: u,
          borderMode: "center",
          rightToLeftStroke: o && !r
        }, l ? {
          ...l,
          lineWidth: Math.max(1, Math.floor(l.lineWidth * i))
        } : undefined);
      }
      _extendAndHitTestLineSegment(e, t, i, s) {
        const o = this._extendAndClipLineSegment(t, i, s);
        if (o !== null) {
          if ((0, a.distanceToSegment)(o[0], o[1], e).distance <= 3) {
            return new c.HitTestResult(c.HitTarget.MovePoint);
          }
        }
        return null;
      }
      _extendAndClipLineSegment(e, t, i) {
        const s = (0, o.ensureNotNull)(this._data);
        if ((0, n.equalPoints)(e, t) && !s.extendLeft && !s.extendRight) {
          return null;
        }
        const r = Math.min(e.x, t.x);
        const a = Math.max(e.x, t.x);
        const l = s.extendLeft ? 0 : Math.max(r, 0);
        const c = s.extendRight ? i : Math.min(a, i);
        if (l > c || c <= 0 || l >= i) {
          return null;
        } else {
          return [new n.Point(l, e.y), new n.Point(c, t.y)];
        }
      }
      _hitTestBackground(e, t, i, s) {
        const o = this._extendAndClipLineSegment(t, i, s);
        if (o !== null && (0, r.pointInBox)(e, (0, n.box)(o[0], o[1]))) {
          return new c.HitTestResult(this._data?.backgroundHitTarget ?? c.HitTarget.MovePointBackground);
        } else {
          return null;
        }
      }
    }
  },
  12027: (e, t, i) => {
    "use strict";

    i.d(t, {
      svgRenderer: () => x
    });
    var s = i(50151);
    var o = i(9343);
    const n = (0, o.getLogger)("Chart.SvgParser");
    function r(e, t) {
      const i = e.split(/[,\s]/).map(e => parseFloat(e.trim()));
      let s = 0;
      for (const e of i) {
        if (!Number.isFinite(e) && s < t) {
          return null;
        }
        s += 1;
      }
      return i;
    }
    const a = /([a-zA-Z]+)\((.*)\)/g;
    function l(e) {
      const t = e.getAttribute("transform")?.toLowerCase();
      if (t === undefined) {
        return null;
      }
      const i = [];
      let s;
      a.lastIndex = 0;
      do {
        s = a.exec(t);
        if (s !== null) {
          const e = s[1];
          const t = s[2];
          switch (e) {
            case "matrix":
              const s = r(t, 6);
              if (s !== null) {
                i.push({
                  type: e,
                  a: s[0],
                  b: s[1],
                  c: s[2],
                  d: s[3],
                  e: s[4],
                  f: s[5]
                });
              }
              break;
            case "rotate":
              const o = r(t, 1);
              if (o !== null) {
                i.push({
                  type: e,
                  a: o[0],
                  x: o[1],
                  y: o[2]
                });
              }
              break;
            case "translate":
              const a = r(t, 1);
              if (a !== null) {
                i.push({
                  type: e,
                  x: a[0],
                  y: a[1]
                });
              }
              break;
            case "scale":
              const l = r(t, 1);
              if (l !== null) {
                i.push({
                  type: e,
                  x: l[0],
                  y: l[1]
                });
              }
              break;
            default:
              n.logWarn(`Unsupported transform operation: ${e}`);
          }
        }
      } while (s !== null);
      if (i.length === 0) {
        return null;
      } else {
        return i;
      }
    }
    function c(e, t) {
      for (const i of t) {
        switch (i.type) {
          case "matrix":
            e.transform(i.a, i.b, i.c, i.d, i.e, i.f);
            break;
          case "rotate":
            if (i.x !== undefined && i.y !== undefined) {
              e.translate(i.x, i.y);
            }
            e.rotate(i.a * Math.PI / 180);
            if (i.x !== undefined && i.y !== undefined) {
              e.translate(-i.x, -i.y);
            }
            break;
          case "scale":
            e.scale(i.x, i.y ?? i.x);
            break;
          case "translate":
            e.translate(i.x, i.y ?? 0);
        }
      }
    }
    function h(e, t) {
      return parseFloat(e.getAttribute(t) ?? "");
    }
    const d = /^url\(#(.*)\)/;
    function u(e) {
      return d.exec(e)?.[1] ?? null;
    }
    function _(e, t, i) {
      const o = {};
      const n = e.getAttribute("fill");
      if (n !== null) {
        const e = u(n);
        o.getFillStyle = e !== null ? i => (0, s.ensureDefined)(t.getStyle(e, i)) : e => n;
      }
      const r = e.getAttribute("stroke");
      if (r !== null) {
        const e = u(r);
        o.getStrokeStyle = e !== null ? i => (0, s.ensureDefined)(t.getStyle(e, i)) : e => r;
      }
      const a = h(e, "stroke-width");
      if (Number.isFinite(a)) {
        o.strokeWidth = a;
      }
      const c = h(e, "opacity");
      if (Number.isFinite(c)) {
        o.fillOpacity = c;
        o.strokeOpacity = c;
      }
      const d = h(e, "stroke-opacity");
      if (Number.isFinite(d)) {
        o.strokeOpacity = d;
      }
      const _ = h(e, "fill-opacity");
      if (Number.isFinite(_)) {
        o.fillOpacity = _;
      }
      if (i) {
        const t = l(e);
        if (t !== null) {
          o.transform = t;
        }
      }
      return o;
    }
    class p {
      constructor(e) {
        this._transformOperations = e;
      }
      apply(e, t) {
        if (this._transformOperations !== null) {
          e.save();
          c(e, this._transformOperations);
        } else {
          e.restore();
        }
      }
    }
    class m {
      constructor(e, t, i) {
        this._styleData = {
          ...i,
          ..._(e, t, true)
        };
      }
      apply(e, t) {
        if (!this._isValid()) {
          return;
        }
        const {
          getFillStyle: i,
          getStrokeStyle: s,
          strokeWidth: o,
          transform: n,
          strokeOpacity: r,
          fillOpacity: a
        } = this._styleData;
        const l = n !== undefined || r !== undefined || a !== undefined;
        if (l) {
          e.save();
          if (n !== undefined) {
            c(e, n);
          }
        }
        this._render(e);
        const h = i?.(e);
        if (h !== "none") {
          if (!t.doNotApplyColors) {
            if (a !== undefined) {
              e.globalAlpha = a;
            }
            e.fillStyle = h ?? "black";
          }
          this._fill(e);
        }
        const d = s?.(e);
        if (d !== undefined && d !== "none") {
          if (o !== undefined) {
            e.lineWidth = o;
          }
          if (!t.doNotApplyColors) {
            if (a !== undefined) {
              e.globalAlpha = a;
            }
            e.strokeStyle = d;
          }
          this._stroke(e);
        }
        if (l) {
          e.restore();
        }
      }
      _fill(e) {
        e.fill();
      }
      _stroke(e) {
        e.stroke();
      }
    }
    class g extends m {
      constructor(e, t, i) {
        super(e, t, i);
        const s = e.getAttribute("d");
        this._path = s !== null ? new Path2D(s) : null;
        this._fillRule = e.getAttribute("fill-rule") ?? undefined;
      }
      _fill(e) {
        e.fill((0, s.ensureNotNull)(this._path), this._fillRule);
      }
      _stroke(e) {
        e.stroke((0, s.ensureNotNull)(this._path));
      }
      _render(e) { }
      _isValid() {
        return this._path !== null;
      }
    }
    class f extends m {
      constructor(e, t, i) {
        super(e, t, i);
        this._cx = h(e, "cx");
        this._cy = h(e, "cy");
        this._r = h(e, "r");
      }
      _render(e) {
        e.beginPath();
        e.arc(this._cx, this._cy, this._r, 0, Math.PI * 2);
      }
      _isValid() {
        return Number.isFinite(this._cx) && Number.isFinite(this._cy) && Number.isFinite(this._r);
      }
    }
    class y extends m {
      constructor(e, t, i) {
        super(e, t, i);
        this._cx = h(e, "cx");
        this._cy = h(e, "cy");
        this._rx = h(e, "rx");
        this._ry = h(e, "ry");
      }
      _render(e) {
        e.beginPath();
        e.ellipse(this._cx, this._cy, this._rx, this._ry, 0, 0, Math.PI * 2);
      }
      _isValid() {
        return Number.isFinite(this._cx) && Number.isFinite(this._cy) && Number.isFinite(this._rx) && Number.isFinite(this._ry);
      }
    }
    class v {
      constructor(e) {
        this._originalViewBox = e;
      }
      apply(e, t) {
        const i = t.targetViewBox;
        e.translate(i.x, i.y);
        e.scale(i.width / this._originalViewBox.width, i.height / this._originalViewBox.height);
        e.beginPath();
        e.rect(0, 0, this._originalViewBox.width, this._originalViewBox.height);
        e.clip();
        e.translate(-this._originalViewBox.x, -this._originalViewBox.y);
      }
    }
    const S = (0, o.getLogger)("Chart.SvgParser");
    function b(e) {
      const t = e.getAttribute("gradientUnits");
      if (t === "objectBoundingBox") {
        S.logWarn(`Unsupported linearGradient gradientUnits: ${t}`);
        return;
      }
      const i = [];
      const s = e.getElementsByTagName("stop");
      for (let e = 0; e < s.length; ++e) {
        const t = s[e];
        const o = h(t, "offset");
        const n = t.getAttribute("stop-color");
        if (n !== null) {
          i.push([Number.isFinite(o) ? o : 0, n]);
        }
      }
      const o = h(e, "x1");
      const n = h(e, "y1");
      const r = h(e, "x2");
      const a = h(e, "y2");
      return e => {
        const t = e.createLinearGradient(o, n, r, a);
        for (const e of i) {
          t.addColorStop(e[0], e[1]);
        }
        return t;
      };
    }
    const w = (0, o.getLogger)("Chart.SvgParser");
    const C = new DOMParser();
    const P = (0, o.getLogger)("Chart.SvgParser");
    function T(e, t, i, s) {
      const o = e.children;
      let n;
      let r = s;
      if (e.tagName === "g" || e.tagName === "svg") {
        r = {
          ...r,
          ..._(e, i, false)
        };
        n = l(e) ?? undefined;
      }
      if (n !== undefined) {
        t.push(new p(n));
      }
      for (let e = 0; e < o.length; ++e) {
        const s = o[e];
        if (s.tagName !== "defs") {
          T(s, t, i, r);
        }
      }
      if (n !== undefined) {
        t.push(new p(null));
      }
      switch (e.tagName) {
        case "g":
        case "svg":
        case "defs":
          break;
        case "path":
          t.push(new g(e, i, s));
          break;
        case "circle":
          t.push(new f(e, i, s));
          break;
        case "ellipse":
          t.push(new y(e, i, s));
          break;
        default:
          P.logWarn(`Unsupported tag name: ${e.tagName}`);
      }
    }
    function x(e) {
      const t = C.parseFromString(e, "application/xml");
      const i = [];
      const o = t.getElementsByTagName("svg")[0];
      const n = (0, s.ensureNotNull)(o.getAttribute("viewBox")).split(" ").map(parseFloat);
      const r = {
        x: n[0],
        y: n[1],
        width: n[2],
        height: n[3]
      };
      i.push(new v(r));
      let a = {
        getStyle: () => { }
      };
      const l = o.getElementsByTagName("defs");
      if (l.length > 0) {
        a = function (e) {
          const t = {};
          const i = e.children;
          for (let e = 0; e < i.length; ++e) {
            const s = i[e];
            const o = s.getAttribute("id");
            if (o) {
              if (s.tagName === "linearGradient") {
                t[o] = b(s);
              } else {
                w.logWarn(`Unsupported defs tag: ${s.tagName}`);
              }
            }
          }
          const s = new WeakMap();
          return {
            getStyle: (e, i) => {
              const o = t[e];
              if (!o) {
                return;
              }
              let n = s.get(i);
              if (n === undefined) {
                n = new Map();
                s.set(i, n);
              }
              const r = n.get(e);
              if (r !== undefined) {
                return r;
              }
              const a = o(i);
              n.set(e, a);
              return a;
            }
          };
        }(l[0]);
      }
      T(o, i, a);
      return {
        viewBox: () => r,
        render: (e, t) => {
          e.save();
          for (const s of i) {
            s.apply(e, t);
          }
          e.restore();
        }
      };
    }
  },
  39429: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      StatsPosition: () => s
    });
    (function (e) {
      e[e.Left = 0] = "Left";
      e[e.Center = 1] = "Center";
      e[e.Right = 2] = "Right";
      e[e.Auto = 3] = "Auto";
    })(s ||= {});
  },
  3385: (e, t, i) => {
    "use strict";

    i.d(t, {
      PaneRendererStepLine: () => f,
      StepLineDecoration: () => s
    });
    var s;
    var o;
    var n = i(4652);
    var r = i(86441);
    var a = i(56468);
    var l = i(61993);
    var c = i(37743);
    var h = i(30125);
    var d = i(74010);
    var u = i(52977);
    (function (e) {
      e[e.None = 0] = "None";
      e[e.Diamonds = 1] = "Diamonds";
    })(s ||= {});
    (function (e) {
      e[e.SmallDiamondsSize = 8] = "SmallDiamondsSize";
      e[e.SmallDiamondsRadius = 2] = "SmallDiamondsRadius";
      e[e.LargeDiamondsSize = 21] = "LargeDiamondsSize";
      e[e.LargeDiamondsRadius = 5] = "LargeDiamondsRadius";
      e[e.LargeDiamondsAlpha = 0.15] = "LargeDiamondsAlpha";
      e[e.LeftUnplottableXCoord = -50] = "LeftUnplottableXCoord";
    })(o ||= {});
    class _ {
      constructor(e) {
        this._forceExtendFirstBar = !!e;
      }
      initialize(e, t, i) {
        const {
          context: s,
          horizontalPixelRatio: o,
          verticalPixelRatio: n
        } = t;
        const r = e.lineStyle;
        s.lineCap = "butt";
        s.lineJoin = "round";
        const a = Math.max(Math.floor(i.style?.width ?? e.lineWidth * o));
        if (r !== undefined) {
          (0, c.setLineStyle)(s, r);
        }
        const l = a % 2 ? 0.5 : 0;
        s.moveTo(Math.round(i.center * o) + l, Math.round(i.y * n) + l);
        (0, u.applyColor)(t, i.style?.color ?? e.lineColor, 1, 1);
        s.lineWidth = a;
      }
      startFragment(e, t, i, s) {
        e.beginPath();
        const o = i.firstItem && i.extendToBarsEndings ? t.center : t.left;
        e.moveTo(isNaN(o) ? -50 : o, t.y);
      }
      finishFragment(e, t, i) {
        if (t && i) {
          e.lineTo(t.left, i.y);
        }
        e.stroke();
      }
      hitTest(e, t, i, s) {
        if (!(0, d.isValidPoint)(t)) {
          return false;
        }
        const o = t.style?.width ?? e.lineWidth;
        const a = (0, l.interactionTolerance)().series + o / 2;
        const {
          left: c,
          y: h
        } = t;
        const u = isNaN(c) ? -50 : c;
        let _;
        let p;
        if (i && (0, d.isValidPoint)(i)) {
          _ = i.left;
          p = i.y;
        } else {
          _ = t.right;
          p = t.y;
        }
        return (!(u < s.x - a) || !(_ < s.x - a)) && (!(u > s.x + a) || !(_ > s.x + a)) && ((0, n.distanceToSegment)((0, r.point)(u, h), (0, r.point)(_, h), s).distance < a || h !== p && (0, n.distanceToSegment)((0, r.point)(_, h), (0, r.point)(_, p), s).distance < a);
      }
      applyColor(e, t) {
        (0, u.applyColor)(e, t, 1, 1);
      }
      applyLineWidth(e, t) {
        e.lineWidth = t;
      }
      drawItem(e, t, i, s) {
        const o = e.context;
        if (s !== undefined) {
          o.lineTo(t.left, s.y);
        }
        o.lineTo(!i.firstItem || i.extendToBarsEndings || this._forceExtendFirstBar ? t.left : t.center, t.y);
        o.lineTo(i.lastItem && !i.extendToBarsEndings ? t.center : t.right, t.y);
      }
    }
    class p {
      constructor() {
        this._lineWidth = 1;
        this._initialAlpha = 1;
      }
      initialize(e, t, i) {
        this._initialAlpha = t.context.globalAlpha;
        this.applyColor(t, i.style?.color ?? e.lineColor);
        this._lineWidth = Math.max(Math.floor(i.style?.width ?? e.lineWidth * t.horizontalPixelRatio));
      }
      startFragment(e, t, i, s) {
        e.beginPath();
      }
      finishFragment(e) {
        e.fill();
      }
      drawItem(e, t, i, s) {
        if (i.valIsNotSameAsPrev && !isNaN(t.left)) {
          const i = e.context;
          i.save();
          i.translate(t.left, t.y);
          i.rotate(Math.PI / 4);
          const s = this._scaleByLineWidth(this._lineWidth);
          i.scale(s, s);
          this._drawItemRotatedAndTranslated(e);
          i.restore();
        }
      }


      //   drawSignal(e, t) {
      //     if (t.position > 0) {
      //       var color = "#26A69A", os = t.radius / 4, w = os * 3, cx = t.x - 1, cy = t.y + os / 2, fs = w * 2;
      //       var bx1 = cx - w, bx2 = cx + w, by1 = cy - w, by2 = cy + w, ax1 = cx - os, ax2 = cx + os, ay = by1 - os;
      //       e.strokeStyle = color, e.fillStyle = color, e.lineWidth = t.theme.dotBorderWidth, e.beginPath(),
      //         e.moveTo(cx, by1), e.arcTo(bx2, by1, bx2, by2, 4), e.arcTo(bx2, by2, bx1, by2, 4), e.arcTo(bx1, by2, bx1, by1, 4), e.arcTo(bx1, by1, bx2, by1, 4),
      //         e.lineTo(ax2, by1), e.lineTo(cx, ay), e.lineTo(ax1, by1), e.closePath(), e.stroke(), e.fill(),
      //       t.label && t.radius > 6 && (e.textAlign = "center", e.textBaseline = "middle", e.font = "bold " + fs + "px " + o, e.fillStyle = 'white', e.fillText(t.label, cx, cy + 1))
      //     } else {
      //       var color = "#ED5A5A", os = t.radius / 4, w = os * 3, cx = t.x - 1, cy = t.y - os / 2, fs = w * 2;
      //       var bx1 = cx - w, bx2 = cx + w, by1 = cy - w, by2 = cy + w, ax1 = cx - os, ax2 = cx + os, ay = by2 + os;
      //       e.strokeStyle = color, e.fillStyle = color, e.lineWidth = t.theme.dotBorderWidth, e.beginPath(),
      //         e.moveTo(cx, by2), e.arcTo(bx1, by2, bx1, by1, 4), e.arcTo(bx1, by1, bx2, by1, 4), e.arcTo(bx2, by1, bx2, by2, 4), e.arcTo(bx2, by2, bx1, by2, 4),
      //         e.lineTo(ax2, by2), e.lineTo(cx, ay), e.lineTo(ax1, by2), e.closePath(), e.stroke(), e.fill(),
      //       t.label && t.radius > 6 && (e.textAlign = "center", e.textBaseline = "middle", e.font = "bold " + fs + "px " + o, e.fillStyle = 'white', e.fillText(t.label, cx, cy + 1))
      //     }
      //   }

      applyLineWidth(e, t) {
        this._lineWidth = t;
      }
      hitTest(e, t, i, s) {
        if (!t.valIsNotSameAsPrev) {
          return false;
        }
        const o = s.subtract((0, r.point)(t.left, t.y));
        return this._hitTestTranslated(o, t.style?.width ?? e.lineWidth);
      }
      _scaleByLineWidth(e) {
        return Math.sqrt(e);
      }
    }
    class m extends p {
      applyColor(e, t) {
        (0, u.applyColor)(e, t, 1, 2);
      }
      _hitTestTranslated(e, t) {
        return Math.abs(e.x) + Math.abs(e.y) < this._scaleByLineWidth(t) * 8 / 2;
      }
      _drawItemRotatedAndTranslated(e) {
        (0, c.drawRoundRect)(e.context, -4, -4, 8, 8, 2, true);
      }
    }
    class g extends p {
      applyColor(e, t) {
        e.context.globalAlpha = this._initialAlpha * 0.15;
        (0, u.applyColor)(e, t, 1, 2);
      }
      _hitTestTranslated(e, t) {
        return Math.abs(e.x) + Math.abs(e.y) < this._scaleByLineWidth(t) * 21 / 2;
      }
      _drawItemRotatedAndTranslated(e) {
        (0, c.drawRoundRect)(e.context, -10.5, -10.5, 21, 21, 5, true);
      }
    }
    class f extends h.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = null;
        this._data = e ?? null;
      }
      setData(e) {
        this._data = e;
      }
      hitTest(e) {
        const t = this._data;
        if (t === null || t.items.length === 0) {
          return null;
        }
        const {
          items: i,
          visibleItemsRange: o,
          skipHoles: n
        } = t;
        const r = o?.startItemIndex ?? 0;
        const l = o?.endItemIndex ?? i.length;
        if (l <= r) {
          return null;
        }
        const c = t.decoration === s.Diamonds ? [new _(), new g()] : [new _()];
        const h = new d.PaneRendererLineItemsIterator(i, r, l, n);
        while (h.next()) {
          const i = h.currentValue();
          const s = h.nextValue();
          for (const o of c) {
            if ((0, d.isValidPoint)(i) && o.hitTest(t, i, (0, d.isValidPoint)(s) ? s : null, e)) {
              return new a.HitTestResult(a.HitTarget.Regular);
            }
          }
        }
        return null;
      }
      _drawImpl(e) {
        if (this._data === null || this._data.items.length === 0) {
          return;
        }
        (this._data.decoration === s.Diamonds ? [new _(true), new m(), new g()] : [new _()]).forEach(t => this._drawDecorationItem(e, t));
      }
      _drawDecorationItem(e, t) {
        if (this._data === null || this._data.items.length === 0) {
          return;
        }
        const {
          lineWidth: i,
          lineColor: s,
          items: o,
          visibleItemsRange: n,
          skipHoles: r,
          extendToBarsEndings: a
        } = this._data;
        const {
          context: l,
          horizontalPixelRatio: c,
          verticalPixelRatio: h
        } = e;
        let u = Math.max(Math.floor((o[0].style?.width ?? i) * c));
        let _ = u % 2 ? 0.5 : 0;
        t.initialize(this._data, e, o[0]);
        const p = n?.startItemIndex ?? 0;
        const m = n?.endItemIndex ?? o.length;
        if (m <= p) {
          return;
        }
        let g;
        let f;
        let y;
        l.beginPath();
        t.applyColor(e, o[p].style?.color ?? s);
        t.applyLineWidth(l, u);
        let v = false;
        const S = new d.PaneRendererLineItemsIterator(o, p, m, r);
        while (S.next()) {
          const o = S.currentValue();
          if (!(0, d.isValidPoint)(o)) {
            g = undefined;
            v = true;
            continue;
          }
          const n = o.style?.color ?? s;
          const r = o.style?.width ?? i;
          const p = n !== f;
          const m = r !== y;
          const b = {
            firstItem: S.currentValueIsFirst(),
            lastItem: S.currentValueIsLast(),
            extendToBarsEndings: a,
            valIsNotSameAsPrev: o.valIsNotSameAsPrev
          };
          const w = {
            y: Math.round(o.y * h) + _,
            left: Math.round(o.left * c) + _,
            center: Math.round(o.center * c) + _,
            right: Math.round(o.right * c) + _
          };
          if (p || m || v) {
            if (f && y) {
              t.finishFragment(l, w, g);
            }
            if (p) {
              t.applyColor(e, n);
            }
            if (m) {
              u = Math.max(1, Math.floor(r * c));
              _ = u % 2 ? 0.5 : 0;
              t.applyLineWidth(l, u);
            }
            t.startFragment(l, w, b, g);
            v = false;
            f = n;
            y = r;
          }
          t.drawItem(e, w, b, g);
          g = w;
        }
        t.finishFragment(l);
      }
    }
  },
  17330: (e, t, i) => {
    "use strict";

    i.d(t, {
      TextRenderer: () => D,
      calculateLabelPosition: () => g,
      fontSize: () => M,
      getTextAlignInBox: () => k,
      getTextBoundaries: () => f,
      lineSpacing: () => I,
      needTextExclusionPath: () => y,
      wordWrap: () => b
    });
    var s = i(86441);
    var o = i(50151);
    var n = i(34026);
    var r = i(63273);
    var a = i(30699);
    var l = i(56468);
    var c = i(37743);
    var h = i(70262);
    var d = i(37265);
    var u = i(7114);
    var _ = i(51056);
    var p = i(29981);
    var m = i(2844);
    function g(e, t, i, o, n) {
      const r = (t.x + i.x) * 0.5;
      let a = i.y;
      if (t.y > i.y) {
        a -= e.height / 2 + o.y;
        a = Math.max(e.height / 2, a);
      } else {
        a += e.height / 2 + o.y;
        a = Math.min(n - e.height / 2, a);
      }
      return new s.Point(r, a);
    }
    function f(e, t, i) {
      if (e.isOutOfScreen(t, i)) {
        return null;
      }
      const s = e.getPolygonPoints();
      if (s.length === 0) {
        return null;
      } else {
        return s;
      }
    }
    function y(e) {
      const t = e.getLinesInfo().lines;
      if (t.length % 2 == 0) {
        return false;
      }
      if (t[Math.floor(t.length / 2)].text.trim() === "") {
        return false;
      }
      return true;
    }
    function v(e) {
      const t = [];
      do {
        const i = e.match(/\s+/);
        if (!i || i.index === undefined || i.index === -1) {
          t.push({
            word: e,
            spaces: ""
          });
          break;
        }
        t.push({
          word: e.slice(0, i.index),
          spaces: i[0]
        });
        e = e.slice(i.index + i[0].length);
      } while (e.length);
      return t;
    }
    function S(e, t, i, s) {
      const o = [];
      const n = [];
      for (let t = 0; t < e.length; ++t) {
        n.push(t);
      }
      while (e.length) {
        const r = Math.max(1, (0, p.upperbound)(n, s, (s, o) => (0, u.measureText)(e.slice(0, o + 1), t, i).width > s, 0, e.length));
        o.push(e.slice(0, r));
        e = e.slice(r);
      }
      return o;
    }
    function b(e, t, i, s = true, o) {
      o = (0, d.isString)(o) ? parseInt(o) : o;
      const n = (e += "").split(/\r\n|\r|\n|$/).map(e => ({
        text: e,
        hidden: false,
        wrappedLinePart: false,
        wrappedLineEnd: false
      }));
      if (!(0, d.isNumber)(o) || !isFinite(o) || o <= 0) {
        return n;
      }
      if ((0, u.measureText)("x", t, i).width > o) {
        return n;
      }
      const r = [];
      for (let e = 0; e < n.length; e++) {
        const a = n[e];
        if ((0, u.measureText)(a.text, t, i).width <= o) {
          r.push(a);
          continue;
        }
        const l = v(a.text);
        const c = true;
        let h = "";
        let d = 0;
        while (d < l.length) {
          const e = l[d];
          let n = `${h}${e.word}`;
          let a = (0, u.measureText)(n, t, i).width;
          if (a > o) {
            if (h !== "") {
              r.push({
                text: h,
                hidden: false,
                wrappedLinePart: c,
                wrappedLineEnd: false
              });
              h = "";
            } else if (n.length === 1) {
              r.push({
                text: n,
                hidden: false,
                wrappedLinePart: c,
                wrappedLineEnd: true
              });
              e.word = "";
            } else {
              const s = S(n, t, i, o);
              for (let e = 0; e < s.length - 1; e += 1) {
                r.push({
                  text: s[e],
                  hidden: false,
                  wrappedLinePart: c,
                  wrappedLineEnd: false
                });
              }
              e.word = s[s.length - 1];
            }
            continue;
          }
          let _ = n.length;
          n = `${h}${e.word}${e.spaces}`;
          a = (0, u.measureText)(n, t, i).width;
          if (a < o) {
            h = n;
            d += 1;
            continue;
          }
          const p = S(n, t, i, o);
          for (let e = 0; e < p.length; e += 1) {
            const t = p[e];
            _ -= t.length;
            const i = {
              text: t,
              hidden: e > 0,
              wrappedLinePart: c,
              wrappedLineEnd: d === l.length - 1 && e === p.length - 1
            };
            if (!i.hidden || !s) {
              r.push(i);
            }
          }
          h = "";
          d += 1;
        }
        if (h !== "") {
          r.push({
            text: h,
            wrappedLinePart: c,
            hidden: false,
            wrappedLineEnd: true
          });
        }
      }
      return r;
    }
    function w(e, t, i) {
      if (i === 0) {
        return e.clone();
      }
      const o = (e.x - t.x) * Math.cos(i) - (e.y - t.y) * Math.sin(i) + t.x;
      const n = (e.x - t.x) * Math.sin(i) + (e.y - t.y) * Math.cos(i) + t.y;
      return new s.Point(o, n);
    }
    function C(e) {
      if (e.boxPaddingVert !== undefined) {
        return e.boxPaddingVert * L(e);
      } else if (e.boxPadding !== undefined) {
        return e.boxPadding * L(e);
      } else {
        return M(e) / 3;
      }
    }
    function P(e) {
      if (e.boxPaddingHorz !== undefined) {
        return e.boxPaddingHorz * L(e);
      } else if (e.boxPadding !== undefined) {
        return e.boxPadding * L(e);
      } else {
        return M(e) / 3;
      }
    }
    function T(e) {
      if (e.boxPaddingLeft !== undefined) {
        return e.boxPaddingLeft * L(e);
      } else {
        return P(e);
      }
    }
    function x(e) {
      if (e.boxPaddingRight !== undefined) {
        return e.boxPaddingRight * L(e);
      } else {
        return P(e);
      }
    }
    function I(e) {
      let t = e.lineSpacing;
      if (t === undefined && e.lineHeight) {
        t = (e.lineHeight - 1) * A(e);
      }
      return (t ?? 0) * L(e);
    }
    function M(e) {
      return Math.ceil(A(e) * L(e));
    }
    function A(e) {
      return e.fontsize || e.fontSize || 30;
    }
    function L(e) {
      const t = Math.min(1, Math.max(0.2, e.scale || 1));
      if (t === 1) {
        return t;
      }
      const i = A(e);
      return Math.ceil(t * i) / i;
    }
    function k(e) {
      const {
        horzAlign: t,
        extendLeft: i = false,
        extendRight: o = false,
        width: n,
        leftPoint: r,
        rightPoint: l
      } = e;
      const c = (r.x <= n || i) && (l.x >= 0 || o);
      let h;
      let d;
      let u = t;
      switch (u) {
        case a.HorizontalAlign.Left:
          d = r.y;
          if (i) {
            h = c ? 0 : l.x;
          } else {
            h = r.x;
            u = a.HorizontalAlign.Right;
          }
          break;
        case a.HorizontalAlign.Right:
          d = l.y;
          if (o) {
            h = c ? n : r.x;
          } else {
            h = l.x;
            u = a.HorizontalAlign.Left;
          }
          break;
        default:
          h = ((i && c ? 0 : r.x) + (o && c ? n : l.x)) / 2;
          d = (r.y + l.y) / 2;
          break;
      }
      return [(0, s.point)(h, d), u];
    }
    class D {
      constructor(e, t) {
        this._data = null;
        this._textWidthCache = new m.TextWidthCache();
        this._internalData = null;
        this._boxSize = null;
        this._box = null;
        this._polygonPoints = null;
        this._linesInfo = null;
        this._fontInfo = null;
        this._centerTextRotationPoint = null;
        this._rotationPoint = null;
        this._hitTest = t || new l.HitTestResult(l.HitTarget.MovePoint, {
          areaName: l.AreaName.Text
        });
        if (e !== undefined) {
          this.setData(e);
        }
      }
      setHitTest(e) {
        this._hitTest = e;
      }
      data() {
        return this._data;
      }
      updateData(e) {
        this.setData({
          ...(0, o.ensureNotNull)(this._data),
          ...e
        });
      }
      setData(e) {
        if (e !== null) {
          (0, o.assert)(!e.decorator || e.wordWrapWidth === undefined, "Decorator is not supported with wordWrapWidth");
          if (e.text === undefined) {
            e.text = "";
          }
          e.horzTextAlign ||= e.horzAlign;
          if (!function (e, t) {
            if (e === null || t === null) {
              return e === null == (t === null);
            }
            if (e.points === undefined != (t.points === undefined)) {
              return false;
            }
            if (e.points !== undefined && t.points !== undefined) {
              if (e.points.length !== t.points.length) {
                return false;
              }
              for (let o = 0; o < e.points.length; ++o) {
                i = e.points[o];
                s = t.points[o];
                if (i.x !== s.x || i.y !== s.y) {
                  return false;
                }
              }
            }
            var i;
            var s;
            return e.text === t.text && e.decorator === t.decorator && e.vertAlign === t.vertAlign && e.horzAlign === t.horzAlign && e.horzTextAlign === t.horzTextAlign && e.font === t.font && e.offsetX === t.offsetX && e.offsetY === t.offsetY && e.bold === t.bold && e.italic === t.italic && e.fontsize === t.fontsize && e.fontSize === t.fontSize && e.backgroundRoundRect === t.backgroundRoundRect && e.forceTextAlign === t.forceTextAlign && e.wordWrapWidth === t.wordWrapWidth && e.forceCalculateMaxLineWidth === t.forceCalculateMaxLineWidth && e.lineHeight === t.lineHeight && e.lineSpacing === t.lineSpacing && e.scale === t.scale && e.highlightBorder === t.highlightBorder && e.boxPadding === t.boxPadding && e.boxPaddingVert === t.boxPaddingVert && e.boxPaddingLeft === t.boxPaddingLeft && e.boxPaddingRight === t.boxPaddingRight && e.boxPaddingHorz === t.boxPaddingHorz && e.angle === t.angle && e.maxHeight === t.maxHeight;
          }(this._data, e)) {
            this._data = e;
            this._internalData = null;
            this._boxSize = null;
            this._polygonPoints = null;
            this._centerTextRotationPoint = null;
            this._rotationPoint = null;
            this._linesInfo = null;
            this._fontInfo = null;
            this._box = null;
          } else {
            this._data = e;
          }
        } else {
          this._data = null;
        }
      }
      hitTest(e) {
        if (this._data === null || this._data.points === undefined || this._data.points.length === 0) {
          return null;
        } else if ((0, n.pointInPolygon)(e, this.getPolygonPoints())) {
          return this._hitTest;
        } else {
          return null;
        }
      }
      doesIntersectWithBox(e) {
        return this._data !== null && this._data.points !== undefined && this._data.points.length !== 0 && (0, n.pointInBox)(this._data.points[0], e);
      }
      measure() {
        if (this._data === null) {
          return {
            boxWidth: 0,
            boxHeight: 0,
            width: 0,
            height: 0
          };
        }
        const e = this._getBoxSize();
        return {
          boxWidth: e.boxWidth,
          boxHeight: e.boxHeight,
          width: e.textBoxWidth,
          height: e.textBoxHeight
        };
      }
      rect() {
        if (this._data === null) {
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        const {
          boxLeft: e,
          boxTop: t,
          boxWidth: i,
          boxHeight: s
        } = this._getBox();
        return {
          x: e,
          y: t,
          width: i,
          height: s
        };
      }
      isOutOfScreen(e, t) {
        if (this._data === null || this._data.points === undefined || this._data.points.length === 0) {
          return true;
        }
        const {
          boxLeft: i,
          boxWidth: o
        } = this._getBox();
        if (i + o < 0 || i > e) {
          const i = (0, s.box)(new s.Point(0, 0), new s.Point(e, t));
          return this.getPolygonPoints().every(e => !(0, n.pointInBox)(e, i));
        }
        return false;
      }
      setPoints(e, t) {
        (0, o.ensureNotNull)(this._data).points = e;
        this._hitTest = t || new l.HitTestResult(l.HitTarget.MovePoint);
      }
      setPoint(e, t, i) {
        const s = (0, o.ensureNotNull)(this._data);
        this.setData({
          ...s,
          points: [e],
          offsetX: t ?? s.offsetX,
          offsetY: i ?? s.offsetY
        });
      }
      point() {
        return this._data?.points?.[0] ?? null;
      }
      fontStyle(e) {
        if (this._data === null) {
          return "";
        } else {
          return this._getFontInfo().fontStyle;
        }
      }
      lineHeight() {
        if (this._data === null) {
          return 0;
        } else {
          return M(this._data);
        }
      }
      lineSpacing() {
        if (this._data === null) {
          return 0;
        } else {
          return I(this._data);
        }
      }
      draw(e, t) {
        if (this._data === null || this._data.points === undefined || this._data.points.length === 0) {
          return;
        }
        const {
          mediaSize: i,
          horizontalPixelRatio: n,
          verticalPixelRatio: r
        } = t;
        if (this.isOutOfScreen(i.width, i.height)) {
          return;
        }
        const a = this._getInternalData();
        const l = (0, o.ensureNotNull)(this.rotation());
        const h = (0, s.point)(l.x * n, l.y * r);
        e.save();
        if (l.angle !== 0) {
          e.translate(h.x, h.y);
          e.rotate(l.angle);
          e.translate(-h.x, -h.y);
        }
        const d = this._getFontInfo().fontSize;
        e.textBaseline = a.textBaseLine;
        e.textAlign = a.textAlign;
        e.font = this.fontStyle();
        const {
          scaledLeft: p,
          scaledRight: m,
          scaledTop: g,
          scaledBottom: f
        } = function (e, t) {
          const {
            horizontalPixelRatio: i,
            verticalPixelRatio: s
          } = t;
          const o = Math.round(e.boxLeft * i);
          const n = Math.round(e.boxTop * s);
          return {
            scaledLeft: o,
            scaledRight: o + Math.round(e.boxWidth * i),
            scaledTop: n,
            scaledBottom: n + Math.round(e.boxHeight * s)
          };
        }(a, t);
        if (this._data.backgroundColor || this._data.borderColor || this._data.highlightBorder && this._data.wordWrapWidth) {
          const t = this._data.borderWidth || Math.max(d / 12, 1);
          const i = Math.round(t * n);
          const s = i / 2;
          let o = false;
          if (this._data.boxShadow) {
            e.save();
            const {
              shadowColor: t,
              shadowBlur: i,
              shadowOffsetX: s = 0,
              shadowOffsetY: a = 0
            } = this._data.boxShadow;
            e.shadowColor = t;
            e.shadowBlur = i * n;
            e.shadowOffsetX = s * n;
            e.shadowOffsetY = a * r;
            o = true;
          }
          if (this._data.backgroundRoundRect) {
            if (this._data.backgroundColor) {
              (0, c.drawRoundRect)(e, p, g, m - p, f - g, this._data.backgroundRoundRect * n);
              e.fillStyle = this._data.backgroundColor;
              e.fill();
              if (o) {
                e.restore();
                o = false;
              }
            }
            if (this._data.borderColor) {
              (0, c.drawRoundRect)(e, p - s, g - s, m - p + i, f - g + i, this._data.backgroundRoundRect * n + i);
              e.strokeStyle = this._data.borderColor;
              e.lineWidth = i;
              e.stroke();
              if (o) {
                e.restore();
                o = false;
              }
            }
          } else {
            if (this._data.backgroundColor) {
              e.fillStyle = this._data.backgroundColor;
              e.fillRect(p, g, m - p, f - g);
              if (o) {
                e.restore();
                o = false;
              }
            }
            if (this._data.borderColor || this._data.highlightBorder) {
              let t;
              if (this._data.borderColor) {
                e.strokeStyle = this._data.borderColor;
                t = i;
              } else {
                e.strokeStyle = this._data.highlightBorderColor || this._data.color;
                (0, c.setLineStyle)(e, _.LINESTYLE_DASHED);
                t = Math.max(1, Math.floor(n));
              }
              e.lineWidth = t;
              e.beginPath();
              e.moveTo(p - t / 2, g - t / 2);
              e.lineTo(p - t / 2, f + t / 2);
              e.lineTo(m + t / 2, f + t / 2);
              e.lineTo(m + t / 2, g - t / 2);
              e.lineTo(p - t / 2, g - t / 2);
              e.stroke();
              if (o) {
                e.restore();
              }
            }
          }
        }
        this._drawSelectionIfNeeded(e, t);
        e.fillStyle = this._data.color;
        const y = (p + Math.round(a.textHorizStart * n)) / n;
        const v = d * 0.05;
        let S = (g + Math.round((a.textVertStart + v) * r)) / r;
        const b = I(this._data);
        const w = this.getLinesInfo();
        for (const t of w.lines) {
          (0, u.drawScaled)(e, n, r, () => e.fillText(t.text, y, S));
          S += d + b;
        }
        this._data.decorator?.draw(e, t, this._data, a);
        e.restore();
      }
      getPolygonPoints() {
        if (this._polygonPoints !== null) {
          return this._polygonPoints;
        }
        if (this._data === null) {
          return [];
        }
        const e = this._data.angle || 0;
        const {
          boxLeft: t,
          boxTop: i,
          boxWidth: o,
          boxHeight: n
        } = this._getBox();
        const r = this._getRotationPoint();
        this._polygonPoints = [w(new s.Point(t, i), r, e), w(new s.Point(t + o, i), r, e), w(new s.Point(t + o, i + n), r, e), w(new s.Point(t, i + n), r, e)];
        return this._polygonPoints;
      }
      centerTextRotation() {
        if (this._centerTextRotationPoint === null && this._data !== null) {
          const e = this._data.angle ?? 0;
          const t = this._getRotationPoint();
          const {
            textLeft: i,
            textTop: o,
            textRight: n,
            textBottom: r
          } = this._getInternalData();
          const a = w(new s.Point((i + n) / 2, (o + r) / 2), t, e);
          this._centerTextRotationPoint = {
            x: a.x,
            y: a.y,
            angle: e
          };
        }
        return this._centerTextRotationPoint;
      }
      rotation() {
        if (this._rotationPoint === null && this._data !== null) {
          const e = this._data.angle ?? 0;
          const t = this._getRotationPoint();
          this._rotationPoint = {
            x: t.x,
            y: t.y,
            angle: e
          };
        }
        return this._rotationPoint;
      }
      getLinesInfo() {
        if (this._linesInfo === null) {
          const e = (0, o.ensureNotNull)(this._data);
          const t = b(e.text, this.fontStyle(), this._textWidthCache, false, e.wordWrapWidth);
          let i = t.filter(e => !e.hidden);
          if (e.maxHeight !== undefined) {
            const t = function (e) {
              const t = (0, o.ensureDefined)(e.maxHeight);
              const i = M(e);
              const s = I(e);
              return Math.floor((t + s) / (i + s));
            }(e);
            if (i.length > t) {
              i = i.slice(0, t);
            }
          }
          this._linesInfo = {
            linesMaxWidth: this._getLinesMaxWidth(i),
            linesIncludingHidden: t,
            lines: i
          };
        }
        return this._linesInfo;
      }
      positionToCoordinate(e) {
        const t = (0, o.ensureNotNull)(this._data);
        const i = this._getInternalData();
        const s = this.getLinesInfo();
        const {
          x: n,
          y: r,
          lineNumber: a
        } = (0, h.getSymbolCoordinatesInfo)({
          symbolPosition: e,
          textWidth: i.textRight - i.textLeft,
          textByLines: s.linesIncludingHidden,
          lineHeight: M(t),
          font: this.fontStyle(),
          textAlign: i.textAlign,
          lineSpacing: this.lineSpacing()
        });
        return {
          x: n + i.textLeft,
          y: r + i.textTop,
          lineNumber: a
        };
      }
      _getInternalData() {
        if (this._internalData !== null) {
          return this._internalData;
        }
        const e = (0, o.ensureNotNull)(this._data);
        const {
          boxLeft: t,
          boxTop: i,
          boxWidth: s,
          boxHeight: n,
          textBoxWidth: l,
          textBoxHeight: c
        } = this._getBox();
        const h = T(e);
        const d = x(e);
        const u = C(e);
        const _ = e.decorator?.geometry(e);
        const p = _?.width ?? 0;
        const m = e.text.length === 0 ? 0 : _?.decoratorAndTextMargin ?? 0;
        const g = _?.ignoreRtl;
        const f = p + m;
        let y;
        const v = i + u + M(e) / 2;
        let S;
        const b = (0, r.isRtl)();
        const w = b && !g;
        const P = w ? t + s - d - p : t + h;
        switch ((0, o.ensureDefined)(e.horzTextAlign)) {
          case a.HorizontalAlign.Left:
            S = "start";
            y = P + f;
            if (b) {
              if (e.forceTextAlign) {
                S = "left";
              } else {
                y = w ? P - m : t + s - d;
                S = "right";
              }
            }
            break;
          case a.HorizontalAlign.Center:
            S = "center";
            const i = s - h - d - f;
            y = w ? P - m - i / 2 : P + f + i / 2;
            break;
          case a.HorizontalAlign.Right:
            S = "end";
            y = w ? P - m : t + s - d;
            if (b && e.forceTextAlign) {
              S = "right";
            }
        }
        this._internalData = {
          boxLeft: t,
          boxTop: i,
          boxWidth: s,
          boxHeight: n,
          textBoxWidth: l,
          textBoxHeight: c,
          textLeft: t + h + (w ? 0 : f),
          textRight: t + s - d - (w ? f : 0),
          textTop: i + u,
          textBottom: i + n - u,
          textHorizStart: y - t,
          textVertStart: v - i,
          textAlign: S,
          textBaseLine: "middle",
          decoratorLeft: P,
          decoratorWidth: p
        };
        return this._internalData;
      }
      _getFontInfo() {
        if (this._fontInfo === null) {
          const e = (0, o.ensureNotNull)(this._data);
          const t = M(e);
          const i = `${e.bold ? "bold " : ""}${e.italic ? "italic " : ""}${t}px ${e.font}`;
          this._fontInfo = {
            fontStyle: i,
            fontSize: t
          };
        }
        return this._fontInfo;
      }
      _drawSelectionIfNeeded(e, t) {
        const i = (0, o.ensureNotNull)(this._data);
        const s = M((0, o.ensureNotNull)(this._data));
        if (i.selectionHighlight) {
          const o = this.positionToCoordinate(i.selectionHighlight.start);
          const n = this.positionToCoordinate(i.selectionHighlight.end);
          const r = this._getInternalData();
          (0, h.drawSelection)(e, t, {
            lines: this.getLinesInfo().linesIncludingHidden,
            selectionStart: o,
            selectionEnd: n,
            left: r.textLeft,
            right: r.textRight,
            color: i.selectionHighlight.color,
            font: this.fontStyle(),
            lineHeight: s,
            lineSpacing: this.lineSpacing()
          });
        }
      }
      _getLinesMaxWidth(e) {
        const t = this.fontStyle();
        if (this._data !== null && this._data.wordWrapWidth && !this._data.forceCalculateMaxLineWidth) {
          return this._data.wordWrapWidth * L(this._data);
        }
        let i = 0;
        for (const s of e) {
          i = Math.max(i, (0, u.measureText)(s.text, t, this._textWidthCache).width);
        }
        return i;
      }
      _getBoxSize() {
        if (this._boxSize === null) {
          const e = this.getLinesInfo();
          const t = (0, o.ensureNotNull)(this._data);
          const i = function (e, t) {
            const i = e.decorator?.geometry(e);
            const s = Math.round(t + T(e) + x(e) + (i?.width ?? 0) + (e.text.length === 0 ? 0 : i?.decoratorAndTextMargin ?? 0));
            if (s % 2) {
              return s + 1;
            } else {
              return s;
            }
          }(t, e.linesMaxWidth);
          const s = function (e, t) {
            return M(e) * t + I(e) * (t - 1) + C(e) * 2;
          }(t, e.lines.length);
          this._boxSize = {
            textBoxWidth: i,
            textBoxHeight: s,
            boxWidth: t.boxWidth ?? i,
            boxHeight: t.boxHeight ?? s
          };
        }
        return this._boxSize;
      }
      _getBox() {
        if (this._box) {
          return this._box;
        }
        const e = (0, o.ensureNotNull)(this._data);
        const [t] = (0, o.ensureDefined)(e.points);
        const {
          boxWidth: i,
          boxHeight: s,
          textBoxWidth: n,
          textBoxHeight: r
        } = this._getBoxSize();
        let {
          y: l,
          x: c
        } = t;
        switch (e.vertAlign) {
          case a.VerticalAlign.Bottom:
            l -= s + e.offsetY;
            break;
          case a.VerticalAlign.Middle:
            l -= s / 2;
            break;
          case a.VerticalAlign.Top:
            l += e.offsetY;
        }
        switch (e.horzAlign) {
          case a.HorizontalAlign.Left:
            c += e.offsetX;
            break;
          case a.HorizontalAlign.Center:
            c -= i / 2;
            break;
          case a.HorizontalAlign.Right:
            c -= i + e.offsetX;
        }
        return this._box = {
          boxLeft: c,
          boxTop: l,
          boxWidth: i,
          boxHeight: s,
          textBoxWidth: n,
          textBoxHeight: r
        };
      }
      _getRotationPoint() {
        const {
          boxLeft: e,
          boxTop: t,
          boxWidth: i,
          boxHeight: n
        } = this._getBox();
        const {
          horzAlign: r,
          vertAlign: l
        } = (0, o.ensureNotNull)(this._data);
        let c;
        let h;
        switch (r) {
          case a.HorizontalAlign.Center:
            c = e + i / 2;
            break;
          case a.HorizontalAlign.Left:
            c = e;
            break;
          case a.HorizontalAlign.Right:
            c = e + i;
        }
        switch (l) {
          case a.VerticalAlign.Middle:
            h = t + n / 2;
            break;
          case a.VerticalAlign.Top:
            h = t;
            break;
          case a.VerticalAlign.Bottom:
            h = t + n;
        }
        return new s.Point(c, h);
      }
    }
  },
  91046: (e, t, i) => {
    "use strict";

    i.d(t, {
      TrendLineRenderer: () => _,
      drawArrow: () => u
    });
    var s = i(50151);
    var o = i(4652);
    var n = i(49857);
    var r = i(56468);
    var a = i(37743);
    var l = i(61993);
    var c = i(7114);
    var h = i(51056);
    function d(e, t, i, s, o) {
      t.save();
      t.fillStyle = "#000000";
      t.beginPath();
      t.arc(e.x * o, e.y * o, i * o, 0, Math.PI * 2, false);
      t.fill();
      if (s.strokeWidth) {
        t.lineWidth = s.strokeWidth;
        t.stroke();
      }
      t.restore();
    }
    function u(e, t, i, s, o, n = false) {
      if (t.subtract(e).length() < 1) {
        return;
      }
      const r = (0, l.getArrowPoints)(e, t, s, n, true).slice(0, 2);
      let a = null;
      const {
        horizontalPixelRatio: c,
        verticalPixelRatio: h
      } = o;
      for (let e = 0; e < r.length; ++e) {
        const t = r[e][0];
        const s = r[e][1];
        if (a === null || a.subtract(t).length() > 1) {
          i.moveTo(t.x * c, t.y * h);
        }
        i.lineTo(s.x * c, s.y * h);
        a = s;
      }
    }
    class _ {
      constructor() {
        this._data = null;
        this._hittest = new r.HitTestResult(r.HitTarget.MovePoint);
      }
      setData(e) {
        this._data = e;
      }
      setHitTest(e) {
        this._hittest = e;
      }
      draw(e, t) {
        const i = this._data;
        if (i === null) {
          return;
        }
        if ("points" in i && i.points.length < 2) {
          return;
        }
        const {
          horizontalPixelRatio: s
        } = t;
        if (i.excludeBoundaries !== undefined) {
          e.save();
          for (const s of i.excludeBoundaries) {
            (0, c.addExclusionArea)(e, t, s);
          }
        }
        const {
          linestyle: o,
          lineCap: n = o === h.LINESTYLE_SOLID ? "round" : "butt"
        } = i;
        e.lineCap = n;
        e.lineJoin = "round";
        e.strokeStyle = i.color;
        e.lineWidth = Math.max(1, Math.floor(i.linewidth * s));
        (0, a.setLineStyle)(e, o);
        const r = i.points[0];
        const l = i.points[1];
        let d = [];
        e.beginPath();
        if (i.overlayLineEndings) {
          d = [r.clone(), l.clone()];
        } else {
          this._drawEnds(e, [r, l], i.linewidth, t);
        }
        const u = this._extendAndClipLineSegment(r, l, t);
        if (u !== null && i.linewidth > 0) {
          (0, a.addPixelPerfectLineToPath)(e, u[0].x, u[0].y, u[1].x, u[1].y, t);
        }
        if (i.overlayLineEndings) {
          this._drawEnds(e, d, i.linewidth, t);
        }
        e.stroke();
        if (i.excludeBoundaries !== undefined) {
          e.restore();
        }
      }
      hitTest(e, t) {
        const i = this._data;
        if (i === null) {
          return null;
        }
        if ("points" in i && i.points.length < 2) {
          return null;
        }
        const s = (i.hitTestTolerance ?? (0, l.interactionTolerance)().line) + i.linewidth / 2;
        const n = i.points[0];
        const r = i.points[1];
        const a = this._extendAndClipLineSegment(n, r, t);
        if (a !== null) {
          if ((0, o.distanceToSegment)(a[0], a[1], e).distance <= s) {
            return this._hittest;
          }
        }
        return null;
      }
      _extendAndClipLineSegment(e, t, i) {
        const o = (0, s.ensureNotNull)(this._data);
        return (0, l.extendAndClipLineSegment)(e, t, i.mediaSize.width, i.mediaSize.height, o.extendleft, o.extendright);
      }
      _drawEnds(e, t, i, o) {
        const r = t[0];
        const a = t[1];
        const l = (0, s.ensureNotNull)(this._data);
        switch (l.leftend) {
          case n.LineEnd.Arrow:
            u(a, r, e, i, o);
            break;
          case n.LineEnd.Circle:
            d(r, e, i, (0, s.ensureDefined)(l.endstyle), o.horizontalPixelRatio);
        }
        switch (l.rightend) {
          case n.LineEnd.Arrow:
            u(r, a, e, i, o);
            break;
          case n.LineEnd.Circle:
            d(a, e, i, (0, s.ensureDefined)(l.endstyle), o.horizontalPixelRatio);
        }
      }
    }
  },
  95173: (e, t, i) => {
    "use strict";

    i.d(t, {
      VerticalLineRenderer: () => l
    });
    var s = i(56468);
    var o = i(37743);
    var n = i(61993);
    var r = i(7114);
    var a = i(30125);
    class l extends a.BitmapCoordinatesPaneRenderer {
      constructor() {
        super(...arguments);
        this._data = null;
        this._hitTest = new s.HitTestResult(s.HitTarget.MovePoint);
      }
      setData(e) {
        this._data = e;
      }
      setHitTest(e) {
        this._hitTest = e;
      }
      hitTest(e) {
        if (this._data === null || this._hitTest === null) {
          return null;
        }
        const t = (0, n.interactionTolerance)().line;
        const i = Math.abs(e.x - this._data.x) <= t + this._data.linewidth / 2;
        const s = this._data.top === undefined || this._data.top - e.y <= t;
        const o = this._data.bottom === undefined || e.y - this._data.bottom <= t;
        if (i && s && o) {
          return this._hitTest;
        } else {
          return null;
        }
      }
      _drawImpl(e) {
        if (this._data === null || this._data.linewidth <= 0) {
          return;
        }
        const {
          context: t,
          horizontalPixelRatio: i,
          verticalPixelRatio: s,
          mediaSize: n
        } = e;
        if (this._data.x < -this._data.linewidth / 2 || this._data.x > n.width + this._data.linewidth / 2) {
          return;
        }
        t.lineCap = "butt";
        t.strokeStyle = this._data.color;
        t.lineWidth = Math.max(1, Math.floor(this._data.linewidth * i));
        if (this._data.linestyle !== undefined) {
          (0, o.setLineStyle)(t, this._data.linestyle);
        }
        const a = this._data.top !== undefined ? Math.max(this._data.top, 0) : 0;
        const l = this._data.bottom !== undefined ? Math.min(this._data.bottom, n.height) : n.height;
        const c = Math.round(this._data.x * i);
        const h = Math.floor(a * s);
        const d = Math.ceil(l * s);
        const u = this._data.excludeBoundaries;
        if (u !== undefined) {
          (0, r.addExclusionAreaByScope)(e, u);
        }
        (0, o.drawVerticalLine)(t, c, h, d);
      }
    }
  },
  2718: (e, t, i) => {
    "use strict";

    i.d(t, {
      sortSources: () => o,
      sortSourcesPreOrdered: () => s
    });
    const s = {
      KeyFactsToday: 10000001,
      LatestUpdates: 10000002,
      BarMarks: 10000003,
      TimeScaleMarks: 10000004,
      ChartEventsSource: 10000005,
      Dividends: 10000006,
      Splits: 10000007,
      Earnings: 10000008,
      RollDates: 10000009,
      FutureContractExpiration: 10000010,
      LineToolOrder: 10000011,
      LineToolPosition: 10000012,
      LineToolExecution: 10000013,
      AlertLabelInactive: 10000014,
      AlertLabel: 10000015
    };
    function o(e, t) {
      if (e.length === 0) {
        return [];
      }
      if (!t) {
        return [...e].sort((e, t) => e.zorder() - t.zorder());
      }
      if (t.model().mainPane() !== t) {
        return [...e].sort((e, t) => e.zorder() - t.zorder());
      }
      const i = t.model().panes();
      const s = i.indexOf(t);
      const o = e => i.findIndex(t => t.hasDataSource(e));
      return e.map(e => {
        const i = !t.hasDataSource(e);
        return {
          source: e,
          isMultipane: i,
          aboveSeries: e.zorder() > t.model().mainSeries().zorder(),
          paneIndex: i ? o(e) : s
        };
      }).sort((e, t) => e.isMultipane || t.isMultipane ? e.isMultipane && !t.isMultipane ? t.aboveSeries ? -1 : 1 : !e.isMultipane && t.isMultipane ? e.aboveSeries ? 1 : -1 : e.paneIndex - t.paneIndex : e.source.zorder() - t.source.zorder()).map(e => e.source);
    }
  },
  64755: (e, t, i) => {
    "use strict";

    i.d(t, {
      PlotList: () => u,
      mergeMinMax: () => _
    });
    var s = i(50151);
    var o = i(29981);
    var n = i(50503);
    var r = i(9343);
    var a = i(8025);
    const l = (0, r.getLogger)("Chart.PlotList");
    const c = 30;
    function h(e) {
      return e.index;
    }
    function d(e) {
      return e.value[0];
    }
    class u {
      constructor(e = null, t = null) {
        this._items = [];
        this._start = 0;
        this._end = 0;
        this._shareRead = false;
        this._minMaxCache = new Map();
        this._rowSearchCacheByIndex = new Map();
        this._rowSearchCacheByIndexWithoutEmptyValues = new Map();
        this._rowSearchCacheByTime = new Map();
        this._rowSearchCacheByTimeWithoutEmptyValues = new Map();
        this._plotFunctions = e || new Map();
        this._emptyValuePredicate = t;
      }
      clear() {
        this._items = [];
        this._start = 0;
        this._end = 0;
        this._shareRead = false;
        this._minMaxCache.clear();
        this._invalidateSearchCaches();
      }
      first() {
        if (this.size() > 0) {
          return this._items[this._start];
        } else {
          return null;
        }
      }
      last() {
        if (this.size() > 0) {
          return this._items[this._end - 1];
        } else {
          return null;
        }
      }
      firstIndex() {
        if (this.size() > 0) {
          return this._indexAt(this._start);
        } else {
          return null;
        }
      }
      lastIndex() {
        if (this.size() > 0) {
          return this._indexAt(this._end - 1);
        } else {
          return null;
        }
      }
      clone() {
        const e = this.firstIndex();
        const t = this.lastIndex();
        if (e === null || t === null) {
          return new u();
        } else {
          return this.range(e, t);
        }
      }
      size() {
        return this._end - this._start;
      }
      isEmpty() {
        return this.size() === 0;
      }
      contains(e) {
        return this.search(e, a.PlotRowSearchMode.Exact) !== null;
      }
      valueAt(e) {
        const t = this.search(e);
        if (t !== null) {
          return t.value;
        } else {
          return null;
        }
      }
      add(e, t) {
        if (this._shareRead) {
          l.logDebug("add: readonly collection modification attempt");
          return false;
        }
        const i = {
          index: e,
          value: t
        };
        const s = this._nonCachedSearch(e, a.PlotRowSearchMode.Exact, h);
        this._invalidateSearchCaches();
        if (s === null) {
          this._items.splice(this._lowerbound(e, h), 0, i);
          this._start = 0;
          this._end = this._items.length;
          return true;
        } else {
          this._items[s] = i;
          return false;
        }
      }
      search(e, t = a.PlotRowSearchMode.Exact, i) {
        return this._searchImpl(e, t, this._rowSearchCacheByIndex, this._rowSearchCacheByIndexWithoutEmptyValues, h, i);
      }
      searchByTime(e, t = a.PlotRowSearchMode.Exact, i) {
        return this._searchImpl(e, t, this._rowSearchCacheByTime, this._rowSearchCacheByTimeWithoutEmptyValues, d, i);
      }
      fold(e, t) {
        let i = t;
        for (let t = this._start; t < this._end; ++t) {
          i = e(this._indexAt(t), this._valueAt(t), i);
        }
        return i;
      }
      findFirst(e, t) {
        const i = t !== undefined && Math.min(this._start + t, this._end) || this._end;
        for (let t = this._start; t < i; ++t) {
          const i = this._indexAt(t);
          const s = this._valueAt(t);
          if (e(i, s)) {
            return {
              index: i,
              value: s
            };
          }
        }
        return null;
      }
      findLast(e, t) {
        const i = t !== undefined && Math.max(this._end - t, this._start) || this._start;
        for (let t = this._end - 1; t >= i; --t) {
          const i = this._indexAt(t);
          const s = this._valueAt(t);
          if (e(i, s)) {
            return {
              index: i,
              value: s
            };
          }
        }
        return null;
      }
      each(e) {
        for (let t = this._start; t < this._end; ++t) {
          if (e(this._indexAt(t), this._valueAt(t))) {
            break;
          }
        }
      }
      reduce(e, t) {
        let i = t;
        for (let t = this._start; t < this._end; ++t) {
          i = e(i, this._indexAt(t), this._valueAt(t));
        }
        return i;
      }
      range(e, t) {
        const i = new u(this._plotFunctions, this._emptyValuePredicate);
        i._items = this._items;
        i._start = this._lowerbound(e, h);
        i._end = this._upperbound(t);
        i._shareRead = true;
        return i;
      }
      plottableRange(e) {
        const t = new u(this._plotFunctions, this._emptyValuePredicate);
        t._items = this._items;
        t._start = this._upperbound(n.UNPLOTTABLE_TIME_POINT_INDEX);
        t._end = this._end;
        t._shareRead = true;
        if (e === true && t._start > this._start) {
          t._start -= 1;
        }
        return t;
      }
      rangeCountback(e, t) {
        if (this.firstIndex() === null) {
          return new u();
        }
        const i = new u(this._plotFunctions, this._emptyValuePredicate);
        i._items = this._items;
        i._end = this._upperbound(e);
        i._start = Math.max(this._start, i._end - t);
        i._shareRead = true;
        return i;
      }
      rangeIterator(e, t) {
        const i = this._lowerbound(e, h);
        const s = this._upperbound(t);
        return this._rangeIteratorImpl(i, s);
      }
      fullRangeIterator() {
        return this._rangeIteratorImpl(this._start, this._end);
      }
      minMaxOnRangeCached(e, t, i) {
        if (this.isEmpty()) {
          return null;
        }
        let s = null;
        for (const o of i) {
          s = _(s, this._minMaxOnRangeCachedImpl(e - o.offset, t - o.offset, o.name));
        }
        return s;
      }
      minMaxOnRange(e, t, i) {
        if (this.isEmpty()) {
          return null;
        }
        let s = null;
        for (const o of i) {
          s = _(s, this._minMaxOnRange(e - o.offset, t - o.offset, o.name));
        }
        return s;
      }
      merge(e) {
        if (this._shareRead) {
          l.logDebug("merge: readonly collection modification attempt");
          return null;
        } else if (e.length === 0) {
          return null;
        } else if (this.isEmpty() || e[e.length - 1].index < this._items[0].index) {
          return this._prepend(e);
        } else if (e[0].index > this._items[this._items.length - 1].index) {
          return this._append(e);
        } else if (e.length === 1 && e[0].index === this._items[this._items.length - 1].index) {
          this._updateLast(e[0]);
          return e[0];
        } else {
          return this._merge(e);
        }
      }
      addTail(e, t = false) {
        if (e.length === 0) {
          return;
        }
        let i = 0;
        if (t && this._end - this._start > 0) {
          i = 1;
          this._items[this._end - this._start - 1].value = e[0].value;
        }
        for (let t = i; t < e.length; ++t) {
          const i = e[t];
          const s = this.lastIndex();
          if (s === null) {
            l.logError("Can't add tail to the empty plotlist");
            break;
          }
          this.add(s + 1, i.value);
        }
        this._invalidateSearchCaches();
      }
      move(e) {
        if (this._shareRead) {
          l.logDebug("move: readonly collection modification attempt");
          return;
        }
        if (e.length === 0) {
          return;
        }
        const t = this._items.slice();
        for (const i of e) {
          const e = this._bsearch(i.old, h);
          if (e !== null && t[e] !== undefined) {
            if (i.new === n.INVALID_TIME_POINT_INDEX) {
              t[e] = undefined;
            } else {
              t[e] = {
                index: i.new,
                value: t[e].value
              };
              const s = this._bsearch(i.new, h);
              if (s !== null) {
                const e = t[s];
                if (e !== undefined && e.index === i.new) {
                  t[s] = undefined;
                }
              }
            }
          }
        }
        this._items = t.filter(e => e !== undefined).sort((e, t) => e.index - t.index);
        this._invalidateSearchCaches();
        this._minMaxCache.clear();
        this._start = 0;
        this._end = this._items.length;
      }
      remove(e) {
        if (this._shareRead) {
          l.logDebug("remove: readonly collection modification attempt");
          return null;
        }
        const t = this._nonCachedSearch(e, a.PlotRowSearchMode.NearestRight, h);
        if (t === null) {
          return null;
        }
        const i = this._items.splice(t);
        this._end = this._items.length;
        this._minMaxCache.clear();
        this._invalidateSearchCaches();
        if (i.length > 0) {
          return i[0];
        } else {
          return null;
        }
      }
      state() {
        const e = this._items.slice(this._start, this._end);
        return {
          start: 0,
          end: e.length,
          data: e
        };
      }
      restoreState(e) {
        if (e) {
          this._start = e.start;
          this._end = e.end;
          this._shareRead = false;
          this._items = e.data;
          this._minMaxCache.clear();
          this._invalidateSearchCaches();
        } else {
          this.clear();
        }
      }
      _indexAt(e) {
        return this._items[e].index;
      }
      _valueAt(e) {
        return this._items[e].value;
      }
      _length() {
        return this._items.length;
      }
      _searchImpl(e, t, i, s, o, n) {
        const r = n !== undefined ? i : s;
        const a = n !== undefined ? (t + 1) * 10000 + n : t;
        let l = r.get(e);
        if (l !== undefined) {
          const e = l.get(a);
          if (e !== undefined) {
            return e;
          }
        }
        const c = this._nonCachedSearch(e, t, o, n);
        if (c === null) {
          return null;
        }
        const h = {
          index: this._indexAt(c),
          value: this._valueAt(c)
        };
        if (l === undefined) {
          l = new Map();
          r.set(e, l);
        }
        l.set(a, h);
        return h;
      }
      _nonCachedSearch(e, t, i, s) {
        const o = this._lowerbound(e, i);
        const n = o === this._end || e !== i(this._items[o]);
        if (n && t !== a.PlotRowSearchMode.Exact) {
          switch (t) {
            case a.PlotRowSearchMode.NearestLeft:
              return this._searchNearestLeft(o, s);
            case a.PlotRowSearchMode.NearestRight:
              return this._searchNearestRight(o, s);
            default:
              throw new TypeError("Unknown search mode");
          }
        }
        if (s === undefined || n || t === a.PlotRowSearchMode.Exact) {
          if (n) {
            return null;
          } else {
            return o;
          }
        }
        switch (t) {
          case a.PlotRowSearchMode.NearestLeft:
            return this._nonEmptyNearestLeft(o, s);
          case a.PlotRowSearchMode.NearestRight:
            return this._nonEmptyNearestRight(o, s);
          default:
            throw new TypeError("Unknown search mode");
        }
      }
      _nonEmptyNearestRight(e, t) {
        const i = (0, s.ensure)(this._emptyValuePredicate);
        const o = (0, s.ensure)(t);
        while (e < this._end && i(this._valueAt(e), o)) {
          e += 1;
        }
        if (e === this._end) {
          return null;
        } else {
          return e;
        }
      }
      _nonEmptyNearestLeft(e, t) {
        const i = (0, s.ensureNotNull)(this._emptyValuePredicate);
        const o = (0, s.ensure)(t);
        while (e >= this._start && i(this._valueAt(e), o)) {
          e -= 1;
        }
        if (e < this._start) {
          return null;
        } else {
          return e;
        }
      }
      _searchNearestLeft(e, t) {
        if (e === this._start) {
          return null;
        }
        const i = e - 1;
        const s = i !== this._end ? i : null;
        if (t !== undefined && s !== null) {
          return this._nonEmptyNearestLeft(s, t);
        } else {
          return s;
        }
      }
      _searchNearestRight(e, t) {
        const i = e;
        const s = i !== this._end ? i : null;
        if (t !== undefined && s !== null) {
          return this._nonEmptyNearestRight(s, t);
        } else {
          return s;
        }
      }
      _bsearch(e, t) {
        const i = this._lowerbound(e, t);
        if (i !== this._end && e === t(this._items[i])) {
          return i;
        } else {
          return null;
        }
      }
      _lowerbound(e, t) {
        return (0, o.lowerbound)(this._items, e, (e, i) => t(e) < i, this._start, this._end);
      }
      _upperbound(e) {
        return (0, o.upperbound)(this._items, e, (e, t) => t.index > e, this._start, this._end);
      }
      _plotMinMax(e, t, i) {
        let s = null;
        const o = this._plotFunctions.get(i);
        if (o === undefined) {
          throw new Error(`Plot "${i}" is not registered`);
        }
        for (let i = e; i < t; i++) {
          const e = o(this._items[i].value);
          if (e != null && !Number.isNaN(e)) {
            if (s === null) {
              s = {
                min: e,
                max: e
              };
            } else {
              if (e < s.min) {
                s.min = e;
              }
              if (e > s.max) {
                s.max = e;
              }
            }
          }
        }
        return s;
      }
      _invalidateCacheForRow(e) {
        const t = Math.floor(e.index / c);
        this._minMaxCache.forEach(e => e.delete(t));
      }
      _prepend(e) {
        (0, s.assert)(!this._shareRead, "collection should not be readonly");
        (0, s.assert)(e.length !== 0, "plotRows should not be empty");
        this._invalidateSearchCaches();
        this._minMaxCache.clear();
        this._items = e.concat(this._items);
        this._start = 0;
        this._end = this._items.length;
        return e[0];
      }
      _append(e) {
        (0, s.assert)(!this._shareRead, "collection should not be readonly");
        (0, s.assert)(e.length !== 0, "plotRows should not be empty");
        this._invalidateSearchCaches();
        this._minMaxCache.clear();
        this._items = this._items.concat(e);
        this._start = 0;
        this._end = this._items.length;
        return e[0];
      }
      _updateLast(e) {
        (0, s.assert)(!this.isEmpty(), "plot list should not be empty");
        const t = this._items[this._end - 1];
        (0, s.assert)(t.index === e.index, "last row index should match new row index");
        this._invalidateCacheForRow(e);
        this._invalidateSearchCaches();
        this._items[this._end - 1] = e;
      }
      _merge(e) {
        (0, s.assert)(e.length !== 0, "plot rows should not be empty");
        this._invalidateSearchCaches();
        this._minMaxCache.clear();
        this._items = function (e, t) {
          const i = function (e, t) {
            const i = e.length;
            const s = t.length;
            let o = i + s;
            let n = 0;
            let r = 0;
            while (n < i && r < s) {
              if (e[n].index < t[r].index) {
                n++;
              } else if (e[n].index > t[r].index) {
                r++;
              } else {
                n++;
                r++;
                o--;
              }
            }
            return o;
          }(e, t);
          const s = new Array(i);
          let o = 0;
          let n = 0;
          const r = e.length;
          const a = t.length;
          let l = 0;
          while (o < r && n < a) {
            if (e[o].index < t[n].index) {
              s[l] = e[o];
              o++;
            } else if (e[o].index > t[n].index) {
              s[l] = t[n];
              n++;
            } else {
              s[l] = t[n];
              o++;
              n++;
            }
            l++;
          }
          while (o < r) {
            s[l] = e[o];
            o++;
            l++;
          }
          while (n < a) {
            s[l] = t[n];
            n++;
            l++;
          }
          return s;
        }(this._items, e);
        this._start = 0;
        this._end = this._items.length;
        return e[0];
      }
      _minMaxOnRangeCachedImpl(e, t, i) {
        if (this.isEmpty()) {
          return null;
        }
        let o = null;
        const n = (0, s.ensureNotNull)(this.firstIndex());
        const r = (0, s.ensureNotNull)(this.lastIndex());
        const a = Math.max(e, n);
        const l = Math.min(t, r);
        const h = Math.ceil(a / c) * c;
        const d = Math.max(h, Math.floor(l / c) * c);
        o = _(o, this._minMaxOnRange(a, Math.min(h, t, l), i));
        let u = this._minMaxCache.get(i);
        if (u === undefined) {
          u = new Map();
          this._minMaxCache.set(i, u);
        }
        for (let e = Math.max(h + 1, a); e < d; e += c) {
          const t = Math.floor(e / c);
          let s = u.get(t);
          if (s === undefined) {
            const e = t * c;
            const o = (t + 1) * c - 1;
            s = this._minMaxOnRange(e, o, i);
            u.set(t, s);
          }
          o = _(o, s);
        }
        o = _(o, this._minMaxOnRange(d, l, i));
        return o;
      }
      _minMaxOnRange(e, t, i) {
        return this._plotMinMax(this._lowerbound(e, h), this._upperbound(t), i);
      }
      _rangeIteratorImpl(e, t) {
        let i = e - 1;
        return {
          [Symbol.iterator]() {
            return this;
          },
          next: () => {
            i += 1;
            if (i >= t) {
              return {
                done: true,
                value: undefined
              };
            } else {
              return {
                done: false,
                value: this._items[i]
              };
            }
          }
        };
      }
      _invalidateSearchCaches() {
        this._rowSearchCacheByIndex.clear();
        this._rowSearchCacheByIndexWithoutEmptyValues.clear();
        this._rowSearchCacheByTime.clear();
        this._rowSearchCacheByTimeWithoutEmptyValues.clear();
      }
    }
    function _(e, t) {
      if (e === null) {
        return t;
      }
      if (t === null) {
        return e;
      }
      return {
        min: Math.min(e.min, t.min),
        max: Math.max(e.max, t.max)
      };
    }
  },
  98558: (e, t, i) => {
    "use strict";

    i.d(t, {
      PriceAxisView: () => _
    });
    var s;
    var o = i(86441);
    var n = i(34026);
    var r = i(69186);
    var a = i(63273);
    var l = i(7114);
    var c = i(56468);
    var h = i(37743);
    (function (e) {
      e[e.HitTestTolerance = 0] = "HitTestTolerance";
      e[e.HitTestToleranceTouch = 10] = "HitTestToleranceTouch";
      e[e.AdditionalVisibilityTolerance = 3] = "AdditionalVisibilityTolerance";
      e[e.IconLabelExistingAlertWidth = 12] = "IconLabelExistingAlertWidth";
      e[e.IconLabelExistingAlertHeight = 10.73] = "IconLabelExistingAlertHeight";
      e[e.IconLabelExistingAlertHorzMargin = 11] = "IconLabelExistingAlertHorzMargin";
    })(s ||= {});
    new Path2D("");
    class d {
      constructor(e, t) {
        this._bodyBox = null;
        this.setData(e, t);
      }
      setData(e, t) {
        this._data = e;
        this._commonData = t;
      }
      lastDrawnBodyBox() {
        return this._bodyBox;
      }
      draw(e, t, i, s, n) {
        const r = this._data;
        const {
          mediaSize: c,
          bitmapSize: d,
          horizontalPixelRatio: u,
          verticalPixelRatio: _
        } = t;
        if (!r.visible || this._isOutOfScreen(i, c.height)) {
          return;
        }
        const p = this._commonData;
        const m = r.labelIcon !== undefined;
        const g = i.paddingTop + p.additionalPaddingTop;
        const f = i.paddingBottom + p.additionalPaddingBottom;
        const {
          paddingOuter: y,
          paddingInner: v,
          fontSize: S,
          borderSize: b
        } = i;
        const w = r.ignoreAdditionalPaddingInner ? 0 : i.additionalPaddingInner;
        let C = r.text;
        let P = r.textColor || p.textColor;
        let T = r.secondLine || "";
        let x = p.secondLineTextColor || P;
        let I = r.thirdLine || "";
        const M = p.thirdLineTextColor || P;
        if (T.length === 0) {
          T = I;
          x = M;
          I = "";
        }
        if (C.length === 0) {
          C = T;
          P = x;
          T = I;
          x = M;
          I = "";
        }
        e.save();
        if (p.globalAlpha !== undefined) {
          e.globalAlpha *= p.globalAlpha;
        }
        e.font = i.font;
        const A = s.yMidCorrection(e, C) * _;
        const L = S + g + f;
        const k = (r.labelIconMinWidth ?? 0) * u;
        const D = Boolean(T);
        const E = Boolean(I);
        const B = v + y + w;
        const V = [Math.ceil(s.measureText(e, C)), D ? Math.ceil(s.measureText(e, T)) : 0, E ? Math.ceil(s.measureText(e, I)) : 0];
        const R = Math.max(1, Math.floor(_));
        let N = Math.round(L * _);
        if (N % 2 != R % 2) {
          N += 1;
        }
        const O = Math.round((S + i.lineSpacing) * _);
        const F = Math.round((S + i.lineSpacing) * 2 * _);
        const W = Math.max(1, Math.floor(b * u));
        const H = r.separatorVisible ? W : 0;
        const z = r.borderVisible ? W : 0;
        const U = m ? Math.max(N, k) : Math.round((Math.max(...V) + B) * u);
        const j = Math.round(w * u);
        const G = d.width;
        const q = Math.ceil(v * u);
        const $ = Math.round((p.fixedCoordinate ?? p.coordinate) * _) - Math.floor(_ * 0.5);
        const K = Math.floor($ + R / 2 - N / 2);
        const Y = K + N;
        const Z = n === "right";
        const X = r.xCoord !== undefined ? Math.round(r.xCoord * u) + (Z ? 1 : -1) * Math.round(U / 2) : Z ? G - H : H;
        let J;
        let Q = X;
        const ee = r.backgroung ?? p.background;
        e.fillStyle = ee;
        const te = _ * 2;
        e.textAlign = Z ? "right" : "left";
        e.textBaseline = "middle";
        if (Z) {
          Q = X - U;
          J = X - j - q + H;
        } else {
          Q = X + U;
          J = X + j + q - H;
        }
        this._bodyBox = null;
        if (C || m) {
          const t = E ? N + F : D ? N + O : N;
          const i = p.borderColor ?? ee;
          const s = r.xCoord !== undefined ? te : 0;
          ((i, n, a) => {
            if (Z) {
              (0, h.drawRoundRectWithInnerBorder)(e, Q, K, U, t, i, r.overridenRadius ? (0, h.scaleDrawRoundRectRadii)(r.overridenRadius, _) : [te, s, s, te], z, n, a);
              const l = (0, o.point)(Q / u, K / _);
              const c = l.add((0, o.point)(U / u, t / _));
              this._bodyBox = (0, o.box)(l, c);
            } else {
              (0, h.drawRoundRectWithInnerBorder)(e, X, K, U, t, i, r.overridenRadius ? (0, h.scaleDrawRoundRectRadii)(r.overridenRadius, _) : [s, te, te, s], z, n, a);
              const l = (0, o.point)(X / u, K / _);
              const c = l.add((0, o.point)(U / u, t / _));
              this._bodyBox = (0, o.box)(l, c);
            }
          })(ee, i, p.borderStyle);
          if (m) {
            if (r.labelIcon === 0) {
              this._drawPlusIcon(e, X, Q, K, $, Y, R);
            }
            e.restore();
            return;
          }
          e.save();
          e.translate(J, (K + Y) / 2 + A);
          (0, l.drawScaled)(e, u, _, () => {
            e.fillStyle = P;
            e.fillText(C, 0, 0);
          });
          e.restore();
        }
        if (D) {
          e.fillStyle = x;
          e.save();
          e.translate(J, (K + Y) / 2 + A + O);
          (0, l.drawScaled)(e, u, _, () => {
            e.fillText((0, a.startWithLTR)(T), 0, 0);
          });
          e.restore();
        }
        if (E) {
          e.fillStyle = M;
          e.save();
          e.translate(J, (K + Y) / 2 + A + F);
          (0, l.drawScaled)(e, u, _, () => {
            e.fillText((0, a.startWithLTR)(I), 0, 0);
          });
          e.restore();
        }
        e.restore();
      }
      topBottomTotalHeight(e) {
        const t = this._lines();
        if (!this._data.visible || t === 0) {
          return {
            top: 0,
            bottom: 0,
            total: 0
          };
        }
        const i = e.fontSize / 2 + e.paddingTop + this._commonData.additionalPaddingTop;
        const s = (t - 0.5) * e.fontSize + (t - 1) * e.lineSpacing + e.paddingBottom + this._commonData.additionalPaddingBottom;
        return {
          top: i,
          bottom: s,
          total: i + s
        };
      }
      hitTest(e) {
        return function (e, t) {
          const i = (0, r.lastMouseOrTouchEventInfo)().isTouch ? 10 : 0;
          const s = e.hitTestData;
          if (s === undefined || !e.visible) {
            return null;
          }

          const {
            itemBox: a,
            clickHandler: l,
            tooltip: h
          } = s;
          if (a) {
            const r = (0, o.box)(new o.Point(a.min.x - i, a.min.y - i), new o.Point(a.max.x + i, a.max.y + i));
            if ((0, n.pointInBox)(t, r)) {
              return new c.HitTestResult(e.hitTarget ?? c.HitTarget.Custom, {
                clickHandler: l?.bind(null, t),
                tapHandler: l?.bind(null, t),
                hoverModelFromAxis: s.hoverModelFromAxis,
                activeItem: s.activeItem,
                tooltip: h
              });
            }
          }
          return null;
        }(this._data, e);
      }
      _drawPlusIcon(e, t, i, s, o, n, r) {
        e.fillStyle = this._commonData.textColor;
        e.strokeStyle = this._commonData.textColor;
        e.lineWidth = r;
        const a = Math.abs(t - i);
        let l = Math.round(a * 0.35);
        if (l % 2 != r % 2) {
          l += 1;
        }
        let c = Math.round(a * 0.65);
        if (c % 2 != r % 2) {
          c += 1;
        }
        const h = Math.floor((a - l) / 2);
        const d = Math.min(t, i);
        const u = d + Math.floor(a / 2 - r / 2);
        e.fillRect(d + h, o, l, r);
        e.fillRect(u, s + h, r, l);
        e.beginPath();
        e.arc(u + r / 2, o + r / 2, c / 2, 0, Math.PI * 2, false);
        e.stroke();
      }
      _drawClockExistingAlertIcon(e, t, i, s, o, n) { }
      _lines() {
        const e = this._data;
        return (e.text ? 1 : 0) + (e.secondLine ? 1 : 0) + (e.thirdLine ? 1 : 0);
      }
      _isOutOfScreen(e, t) {
        const i = this._commonData;
        const s = i.fixedCoordinate ?? i.coordinate;
        const {
          total: o
        } = this.topBottomTotalHeight(e);
        const n = o / this._lines();
        return s - n / 2 - 3 > t || s + (o - n / 2) + 3 < 0;
      }
    }
    var u = i(19063);
    class _ {
      constructor(e) {
        this._commonRendererData = {
          coordinate: 0,
          textColor: "#FFF",
          background: "#000",
          additionalPaddingBottom: 0,
          additionalPaddingTop: 0
        };
        this._axisRendererData = {
          text: "",
          visible: false,
          separatorVisible: true,
          borderVisible: false,
          ignoreAdditionalPaddingInner: false
        };
        this._paneRendererData = {
          text: "",
          visible: false,
          separatorVisible: false,
          borderVisible: false,
          ignoreAdditionalPaddingInner: true
        };
        this._invalidated = true;
        this._active = false;
        this._axisRenderer = new (e || d)(this._axisRendererData, this._commonRendererData);
        this._paneRenderer = new (e || d)(this._paneRendererData, this._commonRendererData);
      }
      setActive(e) {
        this._active = e;
      }
      text() {
        this._updateRendererDataIfNeeded();
        return this._axisRendererData.text;
      }
      secondLineText() {
        this._updateRendererDataIfNeeded();
        return this._axisRendererData.secondLine;
      }
      thirdLineText() {
        this._updateRendererDataIfNeeded();
        return this._axisRendererData.thirdLine;
      }
      background() {
        this._updateRendererDataIfNeeded();
        return this._commonRendererData.background;
      }
      color() {
        this._updateRendererDataIfNeeded();
        return this.generateTextColor(this.background());
      }
      generateTextColor(e) {
        return (0, u.colorFromBackground)(e);
      }
      coordinate() {
        this._updateRendererDataIfNeeded();
        return this._commonRendererData.coordinate;
      }
      floatCoordinate() {
        this._updateRendererDataIfNeeded();
        return this._commonRendererData.floatCoordinate ?? this._commonRendererData.coordinate;
      }
      update(e) {
        this._invalidated = true;
      }
      topBottomTotalHeight(e) {
        this._updateRendererDataIfNeeded();
        const {
          top: t,
          bottom: i,
          total: s
        } = this._axisRenderer.topBottomTotalHeight(e);
        const {
          top: o,
          bottom: n,
          total: r
        } = this._paneRenderer.topBottomTotalHeight(e);
        return {
          top: Math.max(t, o),
          bottom: Math.max(i, n),
          total: Math.max(s, r)
        };
      }
      getFixedCoordinate() {
        return this._commonRendererData.fixedCoordinate || 0;
      }
      setFixedCoordinate(e) {
        this._commonRendererData.fixedCoordinate = e;
      }
      isVisible() {
        this._updateRendererDataIfNeeded();
        return this._axisRendererData.visible || this._paneRendererData.visible;
      }
      isAxisLabelVisible() {
        this._updateRendererDataIfNeeded();
        return this._axisRendererData.visible;
      }
      isPaneLabelVisible() {
        this._updateRendererDataIfNeeded();
        return this._paneRendererData.visible;
      }
      renderer() {
        this._updateRendererDataIfNeeded();
        return this._axisRenderer;
      }
      paneRenderer() {
        this._updateRendererDataIfNeeded();
        return this._paneRenderer;
      }
      setPaneRendererLabelIcon(e) {
        this._paneRendererData.labelIcon = e;
      }
      setPaneLabelVisible(e) {
        this._paneRendererData.visible = e;
        this._invalidated = true;
      }
      ignoreAlignment() {
        return false;
      }
      _updateRendererDataIfNeeded() {
        if (this._invalidated) {
          this._commonRendererData.fixedCoordinate = undefined;
          this._updateRendererData(this._axisRendererData, this._paneRendererData, this._commonRendererData);
          this._invalidated = false;
        }
      }
    }
  },
  45579: (e, t, i) => {
    "use strict";

    i.d(t, {
      PriceDataSource: () => a,
      isPriceDataSource: () => r
    });
    var s = i(29137);
    var o = i(52033);
    var n = i(60074);
    function r(e) {
      return e instanceof a;
    }
    class a extends s.DataSource {
      constructor(e, t) {
        super(t);
        this._formatterChanged = new o.Delegate();
        this._priceStepChanged = new o.Delegate();
        this._currencyChanged = new o.Delegate();
        this._unitChanged = new o.Delegate();
        this._priceRangeReadyChanged = new o.Delegate();
        this._priceStep = null;
        this._priceRangeReady = true;
        this._model = e;
      }
      base() {
        return 0;
      }
      model() {
        return this._model;
      }
      currencyChanged() {
        return this._currencyChanged;
      }
      isCurrencySource() {
        return true;
      }
      isDisplayedInLegend() {
        return true;
      }
      unitChanged() {
        return this._unitChanged;
      }
      isUnitSource() {
        return true;
      }
      priceRange(e, t, i) {
        return null;
      }
      isDraggable() {
        return true;
      }
      priceLineColor(e) {
        return e;
      }
      formatterChanged() {
        return this._formatterChanged;
      }
      priceStep(e) {
        return this._priceStep;
      }
      priceStepChanged() {
        return this._priceStepChanged;
      }
      isIncludedInAutoScale() {
        return true;
      }
      correctScaleMargins(e) {
        return e;
      }
      priceRangeReady() {
        return this._priceRangeReady;
      }
      priceRangeReadyChanged() {
        return this._priceRangeReadyChanged;
      }
      disablePriceRangeReady() {
        const e = this.priceScale();
        if (e !== null && !e.isAutoScale() && e.mainSource() === this) {
          this._priceRangeReady = false;
          e.recalculatePriceRangeOnce();
        }
        this._priceRangeReadyChanged.fire(false);
      }
      statusView() {
        return null;
      }
      legendView() {
        return null;
      }
      marketStatusModel() {
        return null;
      }
      dataUpdatedModeModel() {
        return null;
      }
      dataProblemModel() {
        return null;
      }
      canHasAlertOnLineTools() {
        return true;
      }
      _enablePriceRangeReady() {
        this._priceRangeReady = true;
        this._priceRangeReadyChanged.fire(true);
      }
      _onSourceCurrencyChanged() {
        if (!(0, n.isActingAsSymbolSource)(this)) {
          this._currencyChanged.fire();
        }
      }
      _onSourceUnitChanged() {
        if (!(0, n.isActingAsSymbolSource)(this)) {
          this._unitChanged.fire();
        }
      }
      _onSourcePriceRangeReadyChanged(e) {
        if (!(0, n.isActingAsSymbolSource)(this) && !e) {
          this.disablePriceRangeReady();
        }
      }
    }
  },
  37626: (e, t, i) => {
    "use strict";

    i.d(t, {
      PriceLineAxisView: () => l,
      SeriesPriceLineAxisView: () => c,
      StudyPriceLineAxisView: () => h
    });
    var s = i(98558);
    var o = i(50151);
    var n = i(51056);
    var r = i(37743);
    class a {
      constructor(e, t) {
        this.setData(e, t);
      }
      setData(e, t) {
        this._data = e;
        this._commonData = t;
      }
      draw(e, t, i, s, a) {
        if (!this._data.visible) {
          return;
        }
        const {
          bitmapSize: l,
          verticalPixelRatio: c
        } = t;
        const h = this._commonData.fixedCoordinate ?? this._commonData.coordinate;
        e.lineWidth = Math.max(1, Math.floor((0, o.ensureDefined)(this._data.linewidth) * c));
        e.lineCap = "butt";
        (0, r.setLineStyle)(e, this._data.linestyle === undefined ? n.LINESTYLE_DOTTED : this._data.linestyle);
        e.strokeStyle = this._commonData.textColor;
        (0, r.drawHorizontalLine)(e, Math.round(h * c), 0, l.width);
      }
      topBottomTotalHeight(e) {
        return {
          top: 0,
          bottom: 0,
          total: 0
        };
      }
    }
    class l extends s.PriceAxisView {
      constructor(e) {
        super(e || a);
      }
      ignoreAlignment() {
        return true;
      }
      _updateRendererData(e, t, i) {
        t.visible = false;
        e.visible = false;
        if (!this._isVisible()) {
          return;
        }
        const s = this._value();
        if (!s.noData) {
          i.background = "";
          i.textColor = this._priceLineColor(s.color);
          i.coordinate = s.coordinate;
          i.floatCoordinate = s.floatCoordinate;
          e.linewidth = this._lineWidth();
          e.linestyle = this._lineStyle();
          e.backgroundAreaVisible = this._backgroundAreaVisible();
          e.backgroundAreaColor = this._backgroundAreaColor();
          e.backgroundAreaHeight = this._backgroundAreaHeight();
          e.visible = true;
        }
      }
      _lineStyle() {
        return n.LINESTYLE_DOTTED;
      }
      _backgroundAreaVisible() {
        return false;
      }
      _backgroundAreaColor() {
        return "";
      }
      _backgroundAreaHeight() {
        return 0;
      }
    }
    class c extends l {
      constructor(e) {
        super();
        this._series = e;
      }
      _value() {
        return this._series.lastValueData(undefined, true);
      }
      _priceLineColor(e) {
        return this._series.priceLineColor(e);
      }
      _lineWidth() {
        return this._series.properties().childs().priceLineWidth.value();
      }
      _isVisible() {
        const e = this._series.model().properties().childs().scalesProperties.childs().showSeriesLastValue.value();
        return this._series.properties().childs().showPriceLine.value() && e;
      }
    }
    class h extends l {
      constructor(e, t) {
        super();
        this._study = e;
        this._plotname = t;
      }
      update(e) {
        if (e.type !== "hover-change") {
          super.update(e);
        }
      }
      _value() {
        return this._study.lastValueData(this._plotname, true);
      }
      _lineWidth() {
        return this._study.properties().childs().styles.childs()[this._plotname].childs().linewidth.value();
      }
      _lineStyle() {
        return n.LINESTYLE_DOTTED;
      }
      _priceLineColor(e) {
        return e;
      }
      _isVisible() {
        const e = this._study.model().properties().childs().scalesProperties.childs().showStudyLastValue.value();
        const t = this._study.isPlotVisibleAt(this._plotname, 1);
        return this._study.properties().childs().styles.childs()[this._plotname].childs().trackPrice.value() && e && t;
      }
    }
  },
  94164: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      PriceAxisLastValueMode: () => s
    });
    (function (e) {
      e[e.LastPriceAndPercentageValue = 0] = "LastPriceAndPercentageValue";
      e[e.LastValueAccordingToScale = 1] = "LastValueAccordingToScale";
    })(s ||= {});
  },
  49256: (e, t, i) => {
    "use strict";

    i.d(t, {
      fromIndexedTo100: () => h,
      fromLog: () => p,
      fromPercent: () => a,
      getCurrentModePriceText: () => f,
      getOppositeModePriceText: () => y,
      logFormulaForBase: () => m,
      logFormulasAreSame: () => g,
      toIndexedTo100: () => d,
      toIndexedTo100Range: () => u,
      toLog: () => _,
      toPercent: () => l,
      toPercentRange: () => c
    });
    var s = i(93280);
    var o = i(9859);
    const n = {
      logicalOffset: 4,
      coordOffset: 0.0001
    };
    const r = 305;
    function a(e, t) {
      if (t < 0) {
        e = -e;
      }
      return e / 100 * t + t;
    }
    function l(e, t) {
      const i = (e - t) * 100 / (t || 1);
      if (t < 0) {
        return -i;
      } else {
        return i;
      }
    }
    function c(e, t) {
      const i = l(e.minValue(), t);
      const o = l(e.maxValue(), t);
      return new s.PriceRange(i, o);
    }
    function h(e, t) {
      if (t < 0) {
        e = -e;
      }
      return (e -= 100) / 100 * t + t;
    }
    function d(e, t) {
      const i = (e - t) * 100 / t + 100;
      if (t < 0) {
        return -i;
      } else {
        return i;
      }
    }
    function u(e, t) {
      const i = d(e.minValue(), t);
      const o = d(e.maxValue(), t);
      return new s.PriceRange(i, o);
    }
    function _(e, t) {
      const i = Math.min(10 ** r - t.coordOffset, Math.abs(e));
      if (i < 1e-25) {
        return 0;
      }
      const s = (0, o.log10)(i + t.coordOffset) + t.logicalOffset;
      if (e < 0) {
        return -s;
      } else {
        return s;
      }
    }
    function p(e, t) {
      const i = Math.abs(e);
      if (i < 1e-15) {
        return 0;
      }
      const s = Math.pow(10, Math.min(i - t.logicalOffset, r)) - t.coordOffset;
      if (e < 0) {
        return -s;
      } else {
        return s;
      }
    }
    function m(e) {
      if (e === null) {
        return n;
      }
      const t = 1 / e;
      if (t >= n.coordOffset || t < 1e-15) {
        return n;
      }
      const i = Math.abs(Math.log10(e));
      return {
        logicalOffset: i,
        coordOffset: 1 / Math.pow(10, i)
      };
    }
    function g(e, t) {
      return e.logicalOffset === t.logicalOffset && e.coordOffset === t.coordOffset;
    }
    function f(e, t) {
      if (e.isPercentage()) {
        return t.formattedPricePercentage;
      } else if (e.isIndexedTo100()) {
        return t.formattedPriceIndexedTo100;
      } else {
        return t.formattedPriceAbsolute;
      }
    }
    function y(e, t) {
      if (e.isPercentage() || e.isIndexedTo100()) {
        return t.formattedPriceAbsolute;
      } else {
        return t.formattedPricePercentage;
      }
    }
  },
  93280: (e, t, i) => {
    "use strict";

    i.d(t, {
      PriceRange: () => n
    });
    var s = i(97085);
    const o = (0, i(9343).getLogger)("Chart.PriceRange");
    class n {
      constructor(e, t) {
        if (e !== null && typeof e == "object") {
          const t = e;
          this._minValue = t.m_minValue;
          this._maxValue = t.m_maxValue;
        } else {
          const i = e;
          this._minValue = i;
          if (t !== undefined) {
            this._maxValue = t;
          }
        }
      }
      equals(e) {
        return this._minValue === e._minValue && this._maxValue === e._maxValue;
      }
      clone() {
        return new n(this._minValue, this._maxValue);
      }
      minValue() {
        return this._minValue;
      }
      setMinValue(e) {
        this._minValue = e;
      }
      maxValue() {
        return this._maxValue;
      }
      setMaxValue(e) {
        this._maxValue = e;
      }
      length() {
        return this._maxValue - this._minValue;
      }
      isEmpty() {
        return this._maxValue === this._minValue || this._maxValue != this._maxValue || this._minValue != this._minValue;
      }
      serialize() {
        return {
          m_maxValue: this._maxValue,
          m_minValue: this._minValue
        };
      }
      state() {
        return {
          max: this._maxValue,
          min: this._minValue
        };
      }
      merge(e) {
        return new n(Math.min(this.minValue(), e.minValue()), Math.max(this.maxValue(), e.maxValue()));
      }
      apply(e, t) {
        this._minValue = Math.min(this._minValue, e);
        this._maxValue = Math.max(this._maxValue, t);
      }
      set(e, t) {
        this._minValue = e;
        this._maxValue = t;
      }
      scaleAroundCenter(e) {
        if (!(0, s.isNumber)(e)) {
          o.logDebug("PriceRange.scaleAroundCenter: invalid coeff");
          return;
        }
        if (this._maxValue - this._minValue === 0) {
          return;
        }
        const t = (this._maxValue + this._minValue) * 0.5;
        let i = this._maxValue - t;
        let n = this._minValue - t;
        i *= e;
        n *= e;
        this._maxValue = t + i;
        this._minValue = t + n;
      }
      shift(e) {
        if ((0, s.isNumber)(e)) {
          this._maxValue += e;
          this._minValue += e;
        } else {
          o.logDebug("PriceRange.shift: invalid coeff");
        }
      }
      containsStrictly(e) {
        return e.minValue() > this._minValue && e.maxValue() < this._maxValue;
      }
      containPrice(e) {
        return e >= this._minValue && e <= this._maxValue;
      }
      intersection(e) {
        if (this.containPrice(e.minValue()) || this.containPrice(e.maxValue()) || e.containPrice(this._minValue)) {
          return new n(Math.max(this._minValue, e.minValue()), Math.min(this._maxValue, e.maxValue()));
        } else {
          return null;
        }
      }
      static compare(e, t) {
        if (e === null || t === null) {
          return e === t;
        } else {
          return e.equals(t);
        }
      }
      static mergedWithProgress(e, t, i) {
        const s = e.minValue() + (t.minValue() - e.minValue()) * i;
        const o = e.maxValue() + (t.maxValue() - e.maxValue()) * i;
        return new n(s, o);
      }
    }
  },
  17625: (e, t, i) => {
    "use strict";

    i.d(t, {
      createPrimitiveProperty: () => o
    });
    var s = i(12988);
    function o(e) {
      return new s.Property(e);
    }
  },
  7927: (e, t, i) => {
    "use strict";

    i.d(t, {
      isRootPath: () => a,
      propertyByPath: () => r,
      propertyPathForSource: () => o
    });
    var s = i(50151);
    function o(e, t = "properties") {
      return `charts.${e.model().id()}.sources.${e.id()}.${t}`;
    }
    function n(e, t) {
      if (t.length < 4) {
        throw new Error("Invalid chart path");
      }
      const i = function (e, t) {
        return (0, s.ensureDefined)(e.getAll().find(e => e.hasModel() && e.model().model().id() === t)).model().model();
      }(e, t[0]);
      const o = t[1];
      if (o === "sources") {
        return (0, s.ensureNotNull)(i.dataSourceForId(t[2])).propertyByPath(t.slice(3).join("."));
      }
      throw new Error(`Invalid chart path, unknown root: ${o}`);
    }
    function r(e, t) {
      const i = t.split(".");
      if (i.length < 1) {
        throw new Error("Invalid path");
      }
      const s = i[0];
      if (s === "charts") {
        return n(e, i.slice(1));
      }
      throw new Error(`Invalid path, unknown root: ${s}`);
    }
    function a(e) {
      return e.startsWith("charts.");
    }
  },
  23073: (e, t, i) => {
    "use strict";

    i.d(t, {
      PropertyBase: () => n
    });
    var s = i(50151);
    var o = i(52033);
    class n {
      constructor() {
        this._listeners = new o.Delegate();
        this._muteChildChanges = false;
        this._owner = null;
        this._name = "";
      }
      nameInOwner() {
        return this._name;
      }
      setNameInOwner(e) {
        this._name = e;
      }
      owner() {
        return this._owner;
      }
      setOwner(e) {
        this._owner = e;
      }
      pathToRoot() {
        const e = this._owner?.pathToRoot();
        if (e) {
          return `${e}.${this._name}`;
        } else {
          return this._name;
        }
      }
      pathToRootProperty() {
        if (!this._owner) {
          return "";
        }
        const e = this._owner.pathToRootProperty?.();
        if (e) {
          return `${e}.${this._name}`;
        } else {
          return this._name;
        }
      }
      removeProperty(e) {
        (0, s.assert)(false, `Trying to call "removeProperty" on property ${this.pathToRoot()}`);
      }
      addChild(e, t) {
        (0, s.assert)(false, `Trying to call "addChild" on property ${this.pathToRoot()}`);
      }
      hasChild(e) {
        return false;
      }
      childCount() {
        return 0;
      }
      childNames() {
        return [];
      }
      childs() {
        (0, s.assert)(false, `Trying to call "childs" on property ${this.pathToRoot()}`);
      }
      state(e, t) {
        return this.value();
      }
      merge(e, t) {
        (0, s.assert)(false, `Trying to call "merge" on property ${this.pathToRoot()}`);
      }
      mergeAndFire(e) {
        (0, s.assert)(false, `Trying to call "mergeAndFire" on property ${this.pathToRoot()}`);
      }
      child(e) {
        if (this.hasChild(e)) {
          return this.childs()[e];
        }
      }
      muteChildChanges(e) {
        this._muteChildChanges = e;
      }
      fireChanged() {
        this._listeners.fire(this, this.pathToRootProperty());
      }
      listeners() {
        return this._listeners;
      }
      subscribe(e, t) {
        this.listeners().subscribe(e, t, false);
      }
      unsubscribe(e, t) {
        this.listeners().unsubscribe(e, t);
      }
      unsubscribeAll(e) {
        this.listeners().unsubscribeAll(e);
      }
    }
  },
  72595: (e, t, i) => {
    "use strict";

    i.d(t, {
      DataTypes: () => s,
      createPropertySchema: () => d,
      dataType: () => l,
      isArraySchema: () => h,
      validateSchema: () => c
    });
    var s;
    var o = i(69708);
    var n = i(83873);
    var r = i(83350);
    var a = i(56052);
    function l(e) {
      if ((0, o.default)(e)) {
        return s.NUMBER;
      } else if ((0, n.default)(e)) {
        return s.STRING;
      } else if ((0, r.default)(e)) {
        return s.BOOLEAN;
      } else if ((0, a.default)(e)) {
        return s.ARRAY;
      } else if (e === null) {
        return s.UNKNOWN;
      } else if (typeof e == "object") {
        return s.OBJECT;
      } else {
        return s.UNKNOWN;
      }
    }
    function c(e, t) {
      const i = l(e);
      switch (t.type) {
        case s.ARRAY:
          return i === s.ARRAY && e.every(e => c(e, t.subschema));
        case s.OBJECT:
          {
            if (i !== s.OBJECT) {
              return false;
            }
            const o = Object.entries(t.subschema);
            for (const t of o) {
              if (!c(e[t[0]], t[1])) {
                return false;
              }
            }
            return true;
          }
        default:
          return i === t.type || t.type === s.UNKNOWN;
      }
    }
    function h(e) {
      return e.type === s.ARRAY;
    }
    function d(e, t) {
      let i;
      const o = l(e);
      switch (o) {
        case s.NUMBER:
        case s.STRING:
        case s.BOOLEAN:
          i = {
            type: o,
            saveFlags: t
          };
          break;
        case s.ARRAY:
          i = {
            type: s.ARRAY,
            saveFlags: t,
            subschema: d(e[0], t)
          };
          break;
        case s.OBJECT:
          {
            const o = {};
            for (const [i, s] of Object.entries(e)) {
              o[i] = d(s, t);
            }
            i = {
              type: s.OBJECT,
              saveFlags: t,
              subschema: o
            };
            break;
          }
        default:
          i = {
            type: s.UNKNOWN,
            saveFlags: t
          };
      }
      return i;
    }
    (function (e) {
      e.STRING = "string";
      e.NUMBER = "number";
      e.BOOLEAN = "boolean";
      e.OBJECT = "object";
      e.ARRAY = "array";
      e.UNKNOWN = "unknown";
    })(s ||= {});
  },
  39158: (e, t, i) => {
    "use strict";

    i.d(t, {
      combineProperty: () => o
    });
    var s = i(17625);
    function o(e, ...t) {
      const i = () => e(...t.map(e => e.value()));
      const o = (0, s.createPrimitiveProperty)(i());
      const n = () => o.setValue(i());
      const r = {};
      for (const e of t) {
        e.subscribe(r, n);
      }
      o.destroy = () => {
        t.forEach(e => e.unsubscribeAll(r));
        t.forEach(e => e.release());
      };
      return o;
    }
  },
  42752: (e, t, i) => {
    "use strict";

    i.d(t, {
      convertPropertyToWatchedValue: () => o
    });
    var s = i(64147);
    function o(e) {
      const t = new s.WatchedValue(e.value());
      let i = false;
      e.subscribe(t, () => {
        if (!i) {
          i = true;
          t.setValue(e.value());
          i = false;
        }
      });
      const o = () => {
        if (!i) {
          i = true;
          e.setValue(t.value());
          i = false;
        }
      };
      t.subscribe(o);
      return t.spawn(() => {
        e.unsubscribeAll(t);
        t.unsubscribe(o);
      });
    }
  },
  84425: (e, t, i) => {
    "use strict";

    i.d(t, {
      combineProperty: () => r.combineProperty,
      createWVFromGetterAndSubscription: () => s.createWVFromGetterAndSubscription,
      createWVFromGetterAndSubscriptions: () => o.createWVFromGetterAndSubscriptions,
      createWVFromProperty: () => n.createWVFromProperty
    });
    var s = i(12184);
    var o = i(23869);
    var n = i(43042);
    i(17625);
    var r = i(39158);
  },
  12184: (e, t, i) => {
    "use strict";

    i.d(t, {
      createWVFromGetterAndSubscription: () => o
    });
    var s = i(64147);
    function o(e, t) {
      const i = new s.WatchedValue(e());
      const o = {};
      t.subscribe(o, () => {
        i.setValue(e());
      });
      return i.readonly().spawn(() => t.unsubscribeAll(o));
    }
  },
  23869: (e, t, i) => {
    "use strict";

    i.d(t, {
      createWVFromGetterAndSubscriptions: () => o
    });
    var s = i(64147);
    function o(e, t) {
      const i = new s.WatchedValue(e());
      const o = {};
      t.forEach(t => t.subscribe(o, () => {
        i.setValue(e());
      }));
      return i.readonly().spawn(() => t.forEach(e => e.unsubscribeAll(o)));
    }
  },
  43042: (e, t, i) => {
    "use strict";

    i.d(t, {
      createWVFromProperty: () => o
    });
    var s = i(12184);
    function o(e) {
      return (0, s.createWVFromGetterAndSubscription)(() => e.value(), e);
    }
  },
  12988: (e, t, i) => {
    "use strict";

    i.d(t, {
      Property: () => m,
      isPrimitiveType: () => p
    });
    var s = i(69708);
    var o = i(83873);
    var n = i(83350);
    var r = i(88987);
    var a = i(56052);
    var l = i(50151);
    var c = i(9343);
    var h = i(34776);
    var d = i(23073);
    var u = i(72595);
    const _ = (0, c.getLogger)("Property");
    function p(e) {
      return e === null || (0, s.default)(e) && Number.isFinite(e) || (0, o.default)(e) || (0, n.default)(e);
    }
    class m extends d.PropertyBase {
      constructor(e, t) {
        super();
        this._childs = [];
        this._dependents = [];
        this._schema = t || (0, u.createPropertySchema)(e);
        if (e !== undefined) {
          if (!(0, u.validateSchema)(e, this._schema)) {
            _.logWarn(`The state with a data type: ${(0, u.dataType)(e)} does not match a schema`);
          }
          if (p(e)) {
            this._value = e;
          } else {
            let t = Object.entries(e);
            if ((0, u.isArraySchema)(this._schema)) {
              t = t.filter(([e]) => !Number.isNaN(+e));
            }
            for (const [e, i] of t) {
              this.addProperty(e, i);
            }
          }
        }
      }
      destroy() {
        this.listeners().destroy();
        for (const e of this._childs) {
          this.child(e)?.destroy?.();
        }
      }
      merge(e, t) {
        let i = null;
        let s = 0;
        if (t) {
          i = [];
          s = i.length;
        }
        if (e === undefined) {
          return i;
        }
        if (p(e)) {
          if (this._value !== e) {
            i?.push(this);
          }
          this._value = e;
          return i;
        }
        if ((0, a.default)(e)) {
          if (!(0, u.isArraySchema)(this._schema)) {
            _.logWarn("Property is not an array");
          }
          for (let s = 0; s < e.length; s++) {
            const o = this.childs()[s];
            if (o) {
              const n = o.merge(e[s], t);
              i?.push(...n);
            } else {
              const t = this.addProperty(`${s}`, e[s]);
              i?.push(t);
            }
          }
        } else {
          let s = Object.entries(e);
          if ((0, u.isArraySchema)(this._schema)) {
            s = s.filter(([e]) => !Number.isNaN(+e));
          }
          for (const [e, o] of s) {
            const s = this.childs()[e];
            if (s) {
              const e = s.merge(o, t);
              i?.push(...e);
            } else {
              const t = this.addProperty(e, o);
              i?.push(t);
            }
          }
        }
        if (i && i.length > s) {
          i.push(this);
        }
        return i;
      }
      mergeAndFire(e) {
        const t = (0, l.ensureNotNull)(this.merge(e, true));
        this._fireMergeAndFireChangedProps(t);
      }
      state(e, t) {
        const i = (0, r.default)(this.value) ? this.value() : undefined;
        if (i !== undefined) {
          return i;
        }
        const s = (0, u.isArraySchema)(this._schema) ? [] : {};
        for (const i of this._childs) {
          if (e && e.indexOf(i) !== -1) {
            continue;
          }
          if ((0, u.isArraySchema)(this._schema) && Number.isNaN(+i)) {
            continue;
          }
          if (t !== undefined && "subschema" in this._schema) {
            const e = (0, u.isArraySchema)(this._schema) ? this._schema.subschema : this._schema.subschema[i];
            if (this._schema.saveFlags !== undefined && !e) {
              continue;
            }
            if (e.saveFlags !== undefined && !(e.saveFlags & t)) {
              continue;
            }
          }
          const o = this.childs()[i];
          let n;
          if (e) {
            const s = [];
            for (const t of e) {
              if (t.startsWith(i + ".")) {
                s.push(t.substring(i.length + 1));
              }
            }
            n = o?.state(s, t);
          } else {
            n = o?.state();
          }
          if (n !== undefined || o?.storeStateIfUndefined()) {
            if ((0, a.default)(s)) {
              s[+i] = n;
            } else {
              s[i] = n;
            }
          }
        }
        return s;
      }
      clone() {
        return new m(this.state());
      }
      value() {
        return this._value;
      }
      childCount() {
        return this._childs.length;
      }
      childNames() {
        return this._childs;
      }
      childByPath(e) {
        let t = this;
        for (const i of e.split(".")) {
          if (t === undefined) {
            break;
          }
          t = t.child(i);
        }
        return t;
      }
      hasChild(e) {
        return this._childs.includes(e);
      }
      setValue(e, t) {
        if (this._value !== e || t) {
          this._value = e;
          this.fireChanged();
        }
      }
      setValueSilently(e) {
        this._value = e;
      }
      addProperty(e, t) {
        let i;
        if ((0, u.isArraySchema)(this._schema) && Number.isNaN(+e)) {
          _.logWarn("Property is an array");
        }
        this.removeProperty(e);
        if (this._schema.type === u.DataTypes.OBJECT) {
          i = this._schema.subschema[e];
        } else if (this._schema.type === u.DataTypes.ARRAY) {
          i = this._schema.subschema;
        }
        const s = new m(t, i);
        this[e] = s;
        this._childs.push(e);
        s.subscribe(this, (e, t) => {
          this._childChanged(e, t);
        });
        s.setOwner(this);
        s.setNameInOwner(e);
        return s;
      }
      removeProperty(e) {
        const t = this.child(e);
        if (t) {
          t.setNameInOwner("");
          t.setOwner(null);
          t.unsubscribeAll(this);
          delete this[e];
          this._childs = this._childs.filter(t => t !== e);
        }
      }
      addChild(e, t) {
        if ((0, u.isArraySchema)(this._schema) && Number.isNaN(+e)) {
          throw new Error("Property is an array");
        }
        if (this[e]) {
          this.removeProperty(e);
        }
        this[e] = t;
        if (this._childs.indexOf(e) === -1) {
          this._childs.push(e);
        }
        t.subscribe(this, (e, t) => this._childChanged(e, t));
        t.setOwner(this);
        t.setNameInOwner(e);
      }
      childs() {
        return this;
      }
      storeStateIfUndefined() {
        return true;
      }
      ownership() {
        return (0, h.ownership)(this);
      }
      weakReference() {
        return (0, h.weakReference)(this);
      }
      addDependent(e) {
        this._dependents.push(e);
      }
      removeDependent(e) {
        const t = this._dependents.indexOf(e);
        if (t >= 0) {
          this._dependents.splice(t, 1);
        }
      }
      dependents() {
        return this._dependents;
      }
      _childChanged(e, t) {
        if (!this._muteChildChanges) {
          this._listeners.fire(this, t);
        }
      }
      _fireMergeAndFireChangedProps(e) {
        this.muteChildChanges(true);
        for (const t of e) {
          t.muteChildChanges(true);
        }
        for (const t of e) {
          t.muteChildChanges(false);
          t.fireChanged();
        }
        this.muteChildChanges(false);
      }
    }
  },
  76742: (e, t, i) => {
    "use strict";

    i.d(t, {
      QuotesProvider: () => r
    });
    var s = i(42003);
    var o = i(52033);
    var n = i(92184);
    class r {
      constructor(e = "full", t) {
        this._quotes = null;
        this._quoteSessionSymbol = null;
        this._quoteSessionClientId = "";
        this._pausedQuoteSessionSymbol = null;
        this._quotesUpdate = new o.Delegate();
        this._quoteSymbolChanged = new o.Delegate();
        this._multiplexerType = e;
        this._hibernated = t;
        this._hibernated?.subscribe(e => {
          if (e) {
            this.pause();
          } else {
            this.resume();
          }
        });
      }
      setQuotesSessionSymbol(e) {
        if (this._quoteSessionSymbol !== e) {
          this._pausedQuoteSessionSymbol = null;
          this._quoteSessionClientId ||= "series-" + (0, n.guid)();
          this._unsubscribeQuoteSession();
          this._quoteSessionSymbol = e;
          this._quoteSymbolChanged.fire();
          if (e) {
            this._subscribeQuoteSession(e);
          }
        }
      }
      symbol() {
        return this._quoteSessionSymbol;
      }
      quotesUpdate() {
        return this._quotesUpdate;
      }
      quoteSymbolChanged() {
        return this._quoteSymbolChanged;
      }
      quotes() {
        return this._quotes;
      }
      async quotesSnapshot(e) {
        return (0, s.getQuoteSessionInstance)("simple").snapshot(e);
      }
      isPaused() {
        return this._pausedQuoteSessionSymbol !== null;
      }
      pause() {
        if (this._pausedQuoteSessionSymbol === null) {
          this._pausedQuoteSessionSymbol = this._quoteSessionSymbol;
          this._unsubscribeQuoteSession();
        }
      }
      resume() {
        if (this._pausedQuoteSessionSymbol !== null) {
          this._subscribeQuoteSession(this._pausedQuoteSessionSymbol);
          this._pausedQuoteSessionSymbol = null;
        }
      }
      destroy() {
        this._unsubscribeQuoteSession();
        this._hibernated?.release();
      }
      _onUpdate(e, t) {
        this._quotes = e && e.values || null;
        if (t && t.values) {
          this._quotesUpdate.fire(e, t);
        }
      }
      _subscribeQuoteSession(e) {
        this._quoteSessionSymbol = e;
        (0, s.getQuoteSessionInstance)(this._multiplexerType).subscribe(this._quoteSessionClientId, this._quoteSessionSymbol, this._onUpdate.bind(this));
      }
      _unsubscribeQuoteSession() {
        if (this._quoteSessionSymbol) {
          (0, s.getQuoteSessionInstance)(this._multiplexerType).unsubscribe(this._quoteSessionClientId, this._quoteSessionSymbol);
          this._quoteSessionSymbol = null;
          this._quotes = null;
        }
      }
    }
  },
  64034: (e, t, i) => {
    "use strict";

    i.d(t, {
      dpr1PixelRatioInfo: () => s,
      equalPixelRatios: () => o
    });
    i(27714);
    const s = {
      horizontalPixelRatio: 1,
      verticalPixelRatio: 1
    };
    function o(e, t) {
      return e.horizontalPixelRatio === t.horizontalPixelRatio && e.verticalPixelRatio === t.verticalPixelRatio;
    }
  },
  10074: (e, t, i) => {
    "use strict";

    i.d(t, {
      compareResolutions: () => m,
      convertResolutionsFromSettings: () => x,
      getApplicableIntervalForFrequency: () => g,
      getCustomResolutions: () => A,
      getMaxResolutionValue: () => T,
      getResolutionByChartStyle: () => w,
      getTranslatedResolution: () => L,
      getTranslatedResolutionModel: () => k,
      intervalIsSupported: () => R,
      isAvailable: () => S,
      isIntervalEnabled: () => V,
      isResolutionMultiplierValid: () => C,
      isSecondsEnabled: () => E,
      mergeResolutions: () => I,
      normalizeIntervalString: () => v,
      setLastUsedResolution: () => b,
      sortResolutions: () => M
    });
    var s = i(11542);
    var o = i(85049);
    var n = i(68805);
    var r = i(56840);
    var a = i(82992);
    var l = i(97144);
    var c = i(37265);
    var h = i(56570);
    var d = i(1819);
    const u = {
      [o.ResolutionKind.Ticks]: 1,
      [o.ResolutionKind.Seconds]: 60,
      [o.ResolutionKind.Minutes]: 1440,
      [o.SpecialResolutionKind.Hours]: 24,
      [o.ResolutionKind.Days]: 365,
      [o.ResolutionKind.Weeks]: 52,
      [o.ResolutionKind.Months]: 12,
      [o.ResolutionKind.Range]: 1000000,
      [o.ResolutionKind.Invalid]: NaN
    };
    const _ = {
      [o.ResolutionKind.Ticks]: 0,
      [o.ResolutionKind.Seconds]: 1,
      [o.ResolutionKind.Minutes]: 2,
      [o.SpecialResolutionKind.Hours]: 3,
      [o.ResolutionKind.Days]: 4,
      [o.ResolutionKind.Weeks]: 5,
      [o.ResolutionKind.Months]: 6,
      [o.ResolutionKind.Range]: 7,
      [o.ResolutionKind.Invalid]: 8
    };
    function p(e) {
      const t = o.Interval.parse(e);
      const i = t.multiplier() || 1;
      if (t.isMinuteHours()) {
        return [o.SpecialResolutionKind.Hours, i / 60];
      } else {
        return [t.kind(), i];
      }
    }
    function m(e, t) {
      if (e === t) {
        return 0;
      }
      const [i, s] = p(e);
      const [o, n] = p(t);
      if (i !== o) {
        return _[i] - _[o];
      } else {
        return s - n;
      }
    }
    function g(e, t) {
      if (m(t, e) >= 0) {
        return t;
      } else {
        return e;
      }
    }
    const f = [1, 10, 100, 1000];
    var y;
    function v(e) {
      return o.Interval.parse(e).value();
    }
    function S(e) {
      const t = o.Interval.parse(e);
      if (!E() && t.isSeconds()) {
        return false;
      }
      if (!(0, d.isTicksEnabled)() && t.isTicks()) {
        return false;
      }
      const i = t.value();
      const s = a.linking.dataFrequencyResolution.value();
      if (s !== undefined && m(i, s) < 0) {
        return false;
      }
      const n = a.linking.supportedResolutions.value();
      if (n !== undefined) {
        return n.find(e => v(e) === i) !== undefined;
      } else if (t.isSeconds()) {
        return Boolean(a.linking.seconds.value());
      } else if (t.isTicks()) {
        return Boolean(a.linking.ticks.value());
      } else if (t.isIntraday()) {
        return Boolean(a.linking.intraday.value());
      } else {
        return t.isDWM();
      }
    }
    function b(e) {
      if (o.Interval.isValid(e)) {
        if (o.Interval.isRange(e)) {
          r.setValue("chart.lastUsedRangeResolution", e);
        } else {
          r.setValue("chart.lastUsedTimeBasedResolution", e);
        }
      }
    }
    function w(e, t, i) {
      const s = n.isRangeStyle(e);
      const a = o.Interval.isRange(t);
      if (!s && a) {
        return function (e) {
          const t = r.getValue("chart.lastUsedTimeBasedResolution");
          if (t !== undefined && o.Interval.isTimeBased(t)) {
            return t;
          }
          let i = "1D";
          for (const t of e) {
            const e = o.Interval.parse(t);
            if (e.isTimeBased()) {
              const t = e.value();
              if (t === "1D") {
                return t;
              }
              i = t;
            }
          }
          return i;
        }(i);
      } else if (s && !a) {
        return function (e) {
          const t = r.getValue("chart.lastUsedRangeResolution");
          if (t !== undefined && o.Interval.isRange(t)) {
            return t;
          }
          let i = "100R";
          for (const t of e) {
            const e = o.Interval.parse(t);
            if (e.isRange()) {
              const t = e.value();
              if (t === "100R") {
                return t;
              }
              i = t;
            }
          }
          return i;
        }(i);
      } else {
        return t;
      }
    }
    function C(e) {
      const {
        interval: t,
        guiResolutionKind: i
      } = o.Interval.parseExt(e);
      if (!t.isValid()) {
        return false;
      }
      const s = t.multiplier();
      if ((0, d.isTicksEnabled)() && i === o.ResolutionKind.Ticks) {
        return f.includes(s);
      }
      return (i === o.SpecialResolutionKind.Hours ? s / 60 : s) <= P(i);
    }
    function P(e) {
      const t = u[e];
      if (Number.isNaN(t)) {
        return 1;
      } else {
        return t;
      }
    }
    function T(e) {
      return P(o.Interval.parseExt(e).guiResolutionKind);
    }
    function x(e) {
      if (Array.isArray(e)) {
        return e;
      } else {
        return Object.keys(e).map(o.Interval.normalize).filter(c.notNull);
      }
    }
    function I(...e) {
      let t = [].concat(...e);
      t = (0, l.uniq)(t.filter(C).map(v));
      return M(t);
    }
    function M(e) {
      return e.sort(m);
    }
    function A() {
      return [];
    }
    function L(e) {
      const {
        multiplier: t,
        shortKind: i
      } = k(e);
      return `${t}${i}`;
    }
    function k(e, t) {
      const i = o.Interval.parse(e);
      let s = i.multiplier();
      let n = i.kind();
      if (!i.isValid()) {
        if (t) {
          return null;
        }
        throw new TypeError(`Can't translate invalid interval: ${e}`);
      }
      if (i.isMinuteHours()) {
        s = Math.floor(s / 60);
        n = o.SpecialResolutionKind.Hours;
      }
      return {
        multiplier: s.toString(),
        shortKind: D(n),
        hint: `${s} ${D(n, s)}`,
        mayOmitMultiplier: i.isDWM() && s === 1,
        mayOmitShortKind: i.isMinutes() && !i.isMinuteHours()
      };
    }
    function D(e, t) {
      if (!t) {
        return {
          [o.ResolutionKind.Invalid]: "",
          [o.ResolutionKind.Ticks]: s.t(null, {
            context: "interval_short"
          }, i(82901)),
          [o.ResolutionKind.Seconds]: s.t(null, {
            context: "interval_short"
          }, i(68823)),
          [o.ResolutionKind.Minutes]: s.t(null, {
            context: "interval_short"
          }, i(68430)),
          [o.SpecialResolutionKind.Hours]: s.t(null, {
            context: "interval_short"
          }, i(38048)),
          [o.ResolutionKind.Days]: s.t(null, {
            context: "interval_short"
          }, i(38691)),
          [o.ResolutionKind.Weeks]: s.t(null, {
            context: "interval_short"
          }, i(7408)),
          [o.ResolutionKind.Months]: s.t(null, {
            context: "interval_short"
          }, i(77995)),
          [o.ResolutionKind.Range]: s.t(null, {
            context: "interval_short"
          }, i(93934))
        }[e];
      }
      switch (e) {
        case o.ResolutionKind.Ticks:
          return s.t(null, {
            plural: "ticks",
            count: t
          }, i(11913));
        case o.ResolutionKind.Days:
          return s.t(null, {
            plural: "days",
            count: t
          }, i(41807));
        case o.ResolutionKind.Weeks:
          return s.t(null, {
            plural: "weeks",
            count: t
          }, i(48898));
        case o.ResolutionKind.Months:
          return s.t(null, {
            plural: "months",
            count: t
          }, i(98393));
        case o.ResolutionKind.Seconds:
          return s.t(null, {
            plural: "seconds",
            count: t
          }, i(33232));
        case o.ResolutionKind.Minutes:
          return s.t(null, {
            plural: "minutes",
            count: t
          }, i(78318));
        case o.SpecialResolutionKind.Hours:
          return s.t(null, {
            plural: "hours",
            count: t
          }, i(42328));
        case o.ResolutionKind.Range:
          return s.t(null, {
            plural: "ranges",
            count: t
          }, i(89937));
        default:
          return e;
      }
    }
    function E() {
      return h.enabled("seconds_resolution");
    }
    function B(e) {
      return (!!E() || !e.isSeconds()) && (!!(0, d.isTicksEnabled)() || !e.isTicks());
    }
    function V(e) {
      return B(o.Interval.parse(e));
    }
    function R(e) {
      if (h.enabled("allow_supported_resolutions_set_only")) {
        const t = o.Interval.normalize(e);
        return t !== null && S(t);
      }
      {
        const t = o.Interval.parse(e);
        if (!t.isValid() || !B(t)) {
          return false;
        }
        if (!h.enabled("custom_resolutions")) {
          const t = o.Interval.normalize(e);
          const i = window.ChartApiInstance.defaultResolutions().filter(V);
          if (!t || i.indexOf(t) === -1) {
            return false;
          }
        }
        const i = a.linking.dataFrequencyResolution.value();
        if (i !== undefined && g(i, t.value()) !== t.value()) {
          return false;
        }
        if (t.isTicks()) {
          return a.linking.ticks.value();
        }
        if (t.isIntraday()) {
          return a.linking.intraday.value();
        }
        {
          const e = a.linking.supportedResolutions.value();
          return !e || e.includes(t.value());
        }
      }
    }
    (function (e) {
      e.CustomUserResolutionsKey = "IntervalWidget.intervals";
      e.LastUsedRangeResolutionKey = "chart.lastUsedRangeResolution";
      e.LastUsedTimeBasedResolutionKey = "chart.lastUsedTimeBasedResolution";
      e.DefaultRangeResolution = "100R";
      e.DefaultTimeBasedResolution = "1D";
    })(y ||= {});
  },
  59769: (e, t, i) => {
    "use strict";

    i.d(t, {
      barSpacingByScaleRatio: () => a,
      priceRangeByScaleRatio: () => r,
      scaleRatio: () => n
    });
    var s = i(93280);
    const o = 1e-10;
    function n(e, t) {
      if (t.isLog() || e.isEmpty() || t.isEmpty()) {
        return null;
      }
      const i = function (e) {
        if (e.isEmpty()) {
          return null;
        }
        const t = e.priceRange();
        if (t === null) {
          return null;
        }
        const i = t.length();
        return e.internalHeight() / i;
      }(t);
      if (i === null) {
        return null;
      }
      return e.getValidBarSpacing() / Math.max(o, i);
    }
    function r(e, t, i) {
      if (e.isLog() || i === null || e.isEmpty()) {
        return null;
      }
      const o = e.priceRange();
      if (o === null || o.isEmpty()) {
        return null;
      }
      const n = e.internalHeight() / (t / i);
      const r = o.length();
      if (n === r) {
        return o;
      }
      const a = (n - r) / 2;
      return new s.PriceRange(o.minValue() - a, o.maxValue() + a);
    }
    function a(e, t) {
      if (e.isLog() || t === null || e.isEmpty()) {
        return null;
      }
      const i = e.priceRange();
      if (i === null) {
        return null;
      }
      const s = i.length();
      return e.internalHeight() / s * t;
    }
  },
  34391: (e, t, i) => {
    "use strict";

    i.d(t, {
      allPriceScaleSelectionStrategyInfo: () => c,
      createPriceScaleSelectionStrategy: () => l
    });
    var s = i(50151);
    var o = i(11542);
    var n = i(79036);
    class r {
      constructor(e) {
        this._priceScalesLimit = 8;
        this._metaInfo = e;
      }
      metaInfo() {
        return this._metaInfo;
      }
      findSuitableScale(e, t, i, s) {
        if (s !== undefined) {
          return this._tryToGetDesiredPriceScale(e, t, s, i);
        }
        if ((0, n.isStudy)(t)) {
          const s = t.metaInfo();
          if (s.shortId === "Volume" && e.containsMainSeries()) {
            return e.createPriceScaleAtPosition("overlay");
          }
          const o = t.desiredPriceScalePosition();
          if (o !== null) {
            return this._tryToGetDesiredPriceScale(e, t, o, i);
          }
          if (i !== undefined && ((0, n.isStudy)(i) || e.isMainPane().value()) && s.is_price_study) {
            return this._getPriceScaleTheSameAsForSource(i, e);
          }
        }
        let o = false;
        if ((0, n.isStudy)(t)) {
          const i = t.metaInfo().groupingKey;
          if (i !== undefined) {
            const t = e.model().findNonOverlayStudyWithGroupingKey(i, e);
            if (t !== null) {
              return this._getPriceScaleTheSameAsForSource(t.study, t.pane);
            }
          }
          o = Boolean(t.metaInfo().is_price_study);
        } else if (t === e.model().mainSeries()) {
          o = true;
        }
        if (o) {
          const t = this._findFirstScaleForPriceStudy(e);
          if (t !== null) {
            return t;
          }
        }
        return this.createNewPriceScaleIfPossible(e);
      }
      canCreateNewPriceScale(e) {
        return e.leftPriceScales().length + e.rightPriceScales().length < this._priceScalesLimit;
      }
      _getPriceScaleTheSameAsForSource(e, t) {
        if (t.isOverlay(e)) {
          return t.createPriceScaleAtPosition("overlay");
        } else {
          return (0, s.ensureNotNull)(e.priceScale());
        }
      }
      _priceScaleIsPrice(e, t) {
        const i = e.mainSource();
        return !!i && (i === t.mainSeries() || !!(0, n.isStudy)(i) && Boolean(i.metaInfo().is_price_study));
      }
      _findFirstScaleForPriceStudy(e) {
        const t = e.model();
        for (let i = 0; i < this._priceScalesLimit; i++) {
          if (e.rightPriceScales().length > i && this._priceScaleIsPrice(e.rightPriceScales()[i], t)) {
            return e.rightPriceScales()[i];
          }
          if (e.leftPriceScales().length > i && this._priceScaleIsPrice(e.leftPriceScales()[i], t)) {
            return e.leftPriceScales()[i];
          }
        }
        return null;
      }
      _targetPriceScaleIndex(e, t) {
        if (e.mainSource() === t.mainSeries()) {
          return 0;
        }
      }
      _tryToGetDesiredPriceScale(e, t, i, o) {
        switch (i) {
          case "left":
            if (this.canCreateNewPriceScale(e)) {
              return e.createPriceScaleAtPosition("left");
            } else {
              return e.createPriceScaleAtPosition("overlay");
            }
          case "right":
            if (this.canCreateNewPriceScale(e)) {
              return e.createPriceScaleAtPosition("right");
            } else {
              return e.createPriceScaleAtPosition("overlay");
            }
          case "as-series":
            if (o !== undefined) {
              return (0, s.ensureNotNull)(o.priceScale());
            } else if (e.isMainPane().value()) {
              return (0, s.ensureNotNull)((0, s.ensureNotNull)(e.mainDataSource()).priceScale());
            } else {
              return this.createNewPriceScaleIfPossible(e);
            }
          case "overlay":
            return e.createPriceScaleAtPosition("overlay");
        }
      }
    }
    const a = [{
      name: "left",
      title: o.t(null, undefined, i(61507)),
      ctor: class extends r {
        constructor(e) {
          super(e);
        }
        apply(e) {
          const t = e.model();
          e.rightPriceScales().slice(0).forEach(i => e.movePriceScale(i, "left", this._targetPriceScaleIndex(i, t)));
        }
        createNewPriceScaleIfPossible(e) {
          if (this.canCreateNewPriceScale(e)) {
            return e.createPriceScaleAtPosition("left");
          } else {
            return e.createPriceScaleAtPosition("overlay");
          }
        }
      }
    }, {
      name: "right",
      title: o.t(null, undefined, i(97800)),
      ctor: class extends r {
        constructor(e) {
          super(e);
        }
        apply(e) {
          const t = e.model();
          e.leftPriceScales().slice(0).forEach(i => e.movePriceScale(i, "right", this._targetPriceScaleIndex(i, t)));
        }
        createNewPriceScaleIfPossible(e) {
          if (this.canCreateNewPriceScale(e)) {
            return e.createPriceScaleAtPosition("right");
          } else {
            return e.createPriceScaleAtPosition("overlay");
          }
        }
      }
    }, {
      name: "auto",
      title: o.t(null, undefined, i(21469)),
      ctor: class extends r {
        constructor(e) {
          super(e);
        }
        apply(e) {
          if (e.containsMainSeries()) {
            const t = (0, s.ensureNotNull)((0, s.ensureNotNull)(e.mainDataSource()).priceScale());
            e.movePriceScale(t, "right", 0);
          }
          const t = e.model();
          while (e.leftPriceScales().length > e.rightPriceScales().length) {
            const i = e.leftPriceScales()[e.leftPriceScales().length - 1];
            e.movePriceScale(i, "right", this._targetPriceScaleIndex(i, t));
          }
          while (e.rightPriceScales().length - e.leftPriceScales().length > 1) {
            const i = e.rightPriceScales()[e.rightPriceScales().length - 1];
            e.movePriceScale(i, "left", this._targetPriceScaleIndex(i, t));
          }
        }
        createNewPriceScaleIfPossible(e) {
          if (!this.canCreateNewPriceScale(e)) {
            return e.createPriceScaleAtPosition("overlay");
          }
          const t = e.leftPriceScales().length < e.rightPriceScales().length ? "left" : "right";
          return e.createPriceScaleAtPosition(t);
        }
      }
    }];
    function l(e) {
      const t = (0, s.ensureDefined)(a.find(t => t.name === e));
      return new t.ctor(t);
    }
    function c() {
      return a;
    }
  },
  66540: (e, t, i) => {
    "use strict";

    i.d(t, {
      SelectionIndexes: () => o
    });
    var s = i(50151);
    class o {
      constructor(e) {
        this._baseIndex = null;
        this._offsetInBar = null;
        this._offsetInTime = null;
        this._barsBetweenPoints = null;
        this._timescale = e;
      }
      indexes() {
        const e = this._timescale.visibleBarsStrictRange();
        if (e === null) {
          return [];
        }
        const t = e.firstBar();
        const i = e.lastBar();
        if (this._offsetInTime === null || this._barsBetweenPoints === null) {
          const e = this._timescale.barSpacing();
          this._barsBetweenPoints = Math.floor(120 / e);
          this._offsetInBar = i % this._barsBetweenPoints;
          this._offsetInTime = this._timescale.indexToTimePoint(this._offsetInBar);
          this._baseIndex = this._timescale.baseIndex();
        }
        const o = this._timescale.baseIndex();
        if (this._baseIndex !== o) {
          this._baseIndex = o;
          this._offsetInBar = (0, s.ensureNotNull)(this._timescale.timePointToIndex(this._offsetInTime));
        }
        const n = (0, s.ensureNotNull)(this._offsetInBar);
        const r = [];
        let a = Math.floor((t - n) / this._barsBetweenPoints);
        const l = Math.floor((i - n) / this._barsBetweenPoints);
        for (; a <= l; a++) {
          r.push(n + a * this._barsBetweenPoints);
        }
        return r;
      }
      clear() {
        this._offsetInBar = null;
        this._offsetInTime = null;
        this._baseIndex = null;
        this._barsBetweenPoints = null;
      }
    }
  },
  11064: (e, t, i) => {
    "use strict";

    i.d(t, {
      SelectionRenderer: () => d
    });
    var s = i(86441);
    var o = i(34026);
    var n = i(19625);
    var r = i(56468);
    var a = i(72791);
    var l = i(30125);
    const c = n.colorsPalette["color-tv-blue-600"];
    var h;
    (function (e) {
      e[e.Radius = 4] = "Radius";
      e[e.Tolerance = 2] = "Tolerance";
    })(h ||= {});
    class d extends l.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = e || null;
      }
      setData(e) {
        this._data = e;
      }
      hitTest(e) {
        if (!this._data || !this._data.visible) {
          return null;
        }
        for (let t = 0; t < this._data.points.length; t++) {
          const i = this._data.points[t];
          if (i.point.subtract(e).length() <= 6) {
            return new r.HitTestResult(this._data.hittestResult, {
              pointIndex: i.pointIndex,
              cursorType: i.cursorType ?? a.PaneCursorType.Default
            });
          }
        }
        return null;
      }
      doesIntersectWithBox(e) {
        return !!this._data && this._data.points.some(t => (0, o.pointInBox)(t.point, e));
      }
      _drawImpl(e) {
        if (this._data === null || !this._data.visible) {
          return;
        }
        const {
          points: t,
          bgColors: i,
          vertOffset: o = 0
        } = this._data;
        for (let r = 0; r < t.length; ++r) {
          const {
            point: a,
            lineWidth: l
          } = t[r];
          n = a;
          if (Number.isFinite(n.x) && Number.isFinite(n.y)) {
            this._drawMarker(e, a.add((0, s.point)(0, o)), this._data, i[r], l);
          }
        }
        var n;
      }
      _drawMarker(e, t, i, o, n = 1) {
        const {
          context: r,
          horizontalPixelRatio: a,
          verticalPixelRatio: l
        } = e;
        const {
          color: h = c,
          withOutline: d = true
        } = i;
        const _ = Math.max(1, Math.floor(a)) % 2 / 2;
        const p = (0, s.point)(Math.round(t.x * a) + _, Math.round(t.y * l) + _);
        const m = u(p, Math.round(a * 4));
        r.fillStyle = o;
        r.fill(d ? u(p, Math.round(a * 5) + _) : m);
        r.fillStyle = h;
        m.addPath(u(p, Math.floor((4 - n) * a)));
        r.fill(m, "evenodd");
      }
    }
    function u(e, t) {
      const i = new Path2D();
      i.arc(e.x, e.y, t, 0, Math.PI * 2, true);
      return i;
    }
  },
  90799: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesBarColorer: () => _
    });
    var s = i(19625);
    var o = i(50151);
    i(20596);
    var n = i(8025);
    var r = i(96000);
    const a = (0, s.getHexColorByName)("color-minty-green-500");
    const l = (0, s.getHexColorByName)("color-ripe-red-500");
    function c(e) {
      return {
        barColor: e.upColor.value(),
        barBorderColor: e.borderUpColor ? e.borderUpColor.value() : e.borderColor.value()
      };
    }
    function h(e) {
      return {
        barColor: e.downColor.value(),
        barBorderColor: e.borderDownColor ? e.borderDownColor.value() : e.borderColor.value()
      };
    }
    function d(e, t) {
      if (e.borderUpColorProjection && e.borderUpColor) {
        return {
          barColor: t ? e.upColorProjection.value() : e.upColor.value(),
          barBorderColor: t ? e.borderUpColorProjection.value() : e.borderUpColor.value()
        };
      } else {
        return {
          barColor: t ? e.upColorProjection.value() : e.upColor.value()
        };
      }
    }
    function u(e, t) {
      if (e.borderDownColorProjection && e.borderDownColor) {
        return {
          barColor: t ? e.downColorProjection.value() : e.downColor.value(),
          barBorderColor: t ? e.borderDownColorProjection.value() : e.borderDownColor.value()
        };
      } else {
        return {
          barColor: t ? e.downColorProjection.value() : e.downColor.value()
        };
      }
    }
    class _ extends r.AbstractBarColorer {
      constructor(e) {
        super();
        this._series = e;
      }
      applyBarStyle(e, t, i, s) {
        const o = i;
        o.barColor = undefined;
        o.barBorderColor = undefined;
        o.barWickColor = undefined;
        o.isBarHollow = undefined;
        o.isBarUp = undefined;
        o.upColor = undefined;
        o.downColor = undefined;
        o.isTwoColorBar = undefined;
        o.isMergedBar = undefined;
        const n = this._series.properties();
        switch (n.childs().style.value()) {
          case 2:
          case 14:
          case 15:
            this._applyLineStyle(e, t, i, s, n);
            break;
          case 18:
            this._applyLineStyle(e, t, i, s, n, true);
            break;
          case 3:
            this._applyAreaStyle(i, n);
            break;
          case 16:
            this._applyHLCAreaStyle(e, t, i, s, n);
            break;
          case 0:
            this._applyBarStyle(e, i, s, n);
            break;
          case 17:
          case 1:
          case 19:
            this._applyCandleStyle(e, i, s, n);
            break;
          case 9:
            this._applyHollowCandleStyle(e, i, s, n);
            break;
          case 8:
            this._applyHAStyle(e, t, i, s, n);
            break;
          case 10:
            this._applyBaseLineStyle(e, t, i, s, n);
            break;
          case 12:
            this._applyHiLoStyle(t, i, n);
            break;
          case 13:
            this._applyColumnStyle(e, i, s, n);
            break;
          case 4:
            this._applyRenkoStyle(e, t, i, s, n);
            break;
          case 7:
            this._applyPBStyle(e, t, i, s, n);
            break;
          case 5:
            this._applyKagiStyle(e, t, i, s, n);
            break;
          case 6:
            this._applyPnfStyle(e, t, i, s, n);
            break;
          case 11:
            this._applyRangeStyle(e, t, i, s, n);
            break;
          case 20:
            0;
            break;
          case 21:
            this._applyHLCBarsStyle(e, i, s, n);
        }
        return i;
      }
      static upColor(e, t) {
        const i = e.childs();
        const s = i.style.value();
        switch (s) {
          case 18:
            return {
              barColor: i.tpoStyle.childs().color.value()
            };
          case 20:
            return {
              barColor: i.svpStyle.childs().volumeProfile.childs().volumeColorUp.value()
            };
          case 2:
            return {
              barColor: i.lineStyle.childs().color.value()
            };
          case 14:
            return {
              barColor: i.lineWithMarkersStyle.childs().color.value()
            };
          case 15:
            return {
              barColor: i.steplineStyle.childs().color.value()
            };
          case 3:
            return {
              barColor: i.areaStyle.childs().linecolor.value()
            };
          case 16:
            return {
              barColor: i.hlcAreaStyle.childs().closeLineColor.value(),
              barBorderColor: a
            };
          case 0:
            return {
              barColor: i.barStyle.childs().upColor.value()
            };
          case 17:
            return c(i.volFootprintStyle.childs());
          case 19:
            return c(i.volCandlesStyle.childs());
          case 1:
            return c(i.candleStyle.childs());
          case 9:
            return c(i.hollowCandleStyle.childs());
          case 8:
            return c(i.haStyle.childs());
          case 10:
            return {
              barColor: i.baselineStyle.childs().topLineColor.value()
            };
          case 12:
            return {
              barColor: i.hiloStyle.childs().color.value(),
              barBorderColor: e.childs().hiloStyle.childs().borderColor.value()
            };
          case 13:
            return {
              barColor: i.columnStyle.childs().upColor.value()
            };
          case 4:
            return d(i.renkoStyle.childs(), t);
          case 7:
            return d(i.pbStyle.childs(), t);
          case 5:
            return d(i.kagiStyle.childs(), t);
          case 6:
            return d(i.pnfStyle.childs(), t);
          case 11:
            return {
              barColor: ""
            };
          case 21:
            return {
              barColor: i.hlcBarsStyle.childs().color.value()
            };
        }
        (0, o.ensureNever)(s);
      }
      static downColor(e, t) {
        const i = e.childs();
        const s = i.style.value();
        switch (s) {
          case 2:
            return {
              barColor: i.lineStyle.childs().color.value()
            };
          case 18:
            return {
              barColor: i.tpoStyle.childs().color.value()
            };
          case 20:
            return {
              barColor: i.svpStyle.childs().volumeProfile.childs().volumeColorUp.value()
            };
          case 14:
            return {
              barColor: i.lineWithMarkersStyle.childs().color.value()
            };
          case 15:
            return {
              barColor: i.steplineStyle.childs().color.value()
            };
          case 3:
            return {
              barColor: i.areaStyle.childs().linecolor.value()
            };
          case 16:
            return {
              barColor: i.hlcAreaStyle.childs().closeLineColor.value(),
              barBorderColor: l
            };
          case 0:
            return {
              barColor: i.barStyle.childs().downColor.value()
            };
          case 17:
            return h(i.volFootprintStyle.childs());
          case 1:
            return h(i.candleStyle.childs());
          case 19:
            return h(i.volCandlesStyle.childs());
          case 9:
            return h(i.hollowCandleStyle.childs());
          case 8:
            return h(i.haStyle.childs());
          case 10:
            return {
              barColor: i.baselineStyle.childs().bottomLineColor.value()
            };
          case 12:
            return {
              barColor: i.hiloStyle.childs().color.value(),
              barBorderColor: e.childs().hiloStyle.childs().borderColor.value()
            };
          case 13:
            return {
              barColor: i.columnStyle.childs().downColor.value()
            };
          case 4:
            return u(i.renkoStyle.childs(), t);
          case 7:
            return u(i.pbStyle.childs(), t);
          case 5:
            return u(i.kagiStyle.childs(), t);
          case 6:
            return u(i.pnfStyle.childs(), t);
          case 11:
            return {
              barColor: ""
            };
          case 21:
            return {
              barColor: i.hlcBarsStyle.childs().color.value()
            };
        }
        (0, o.ensureNever)(s);
      }
      _applyLineStyle(e, t, i, s, n, r) {
        i.barColor = _.upColor(n).barColor;
        if (r) {
          return;
        }
        const a = this._findBar(e, t, s);
        const l = this._series.barFunction()(a);
        const c = this._series.priceScale();
        const h = this._series.firstValue();
        if (l == null || c.isEmpty() || h == null) {
          return;
        }
        const d = c.priceToCoordinate(l, h);
        i.barColor = (0, o.ensureNotNull)(this._series.lineColorAtYPercentFromTop(d / c.height()));
      }
      _applyAreaStyle(e, t) {
        e.barColor = _.upColor(t).barColor;
      }
      _applyHLCAreaStyle(e, t, i, s, o) {
        const n = this._isUp(e, false, s, this._series.data().first()?.index !== e) ? _.upColor(o, t) : _.downColor(o, t);
        i.barColor = n.barColor;
        i.barBorderColor = n.barBorderColor;
      }
      _applyBarStyle(e, t, i, s) {
        const o = this._isUp(e, false, i, s.childs().barStyle.childs().barColorsOnPrevClose.value()) ? _.upColor(s) : _.downColor(s);
        t.barColor = o.barColor;
        t.barBorderColor = o.barBorderColor;
      }
      _applyCandleStyle(e, t, i, s) {
        const o = s.childs();
        const n = o.style.value() === 1 ? o.candleStyle.childs() : o.style.value() === 19 ? o.volCandlesStyle.childs() : o.volFootprintStyle.childs();
        const r = this._isUp(e, false, i, n.barColorsOnPrevClose.value() && this._series.data().first()?.index !== e);
        const a = r ? _.upColor(s) : _.downColor(s);
        t.barColor = a.barColor;
        t.barBorderColor = a.barBorderColor;
        t.barWickColor = r ? n.wickUpColor ? n.wickUpColor.value() : n.wickColor.value() : n.wickDownColor ? n.wickDownColor.value() : n.wickColor.value();
      }
      _applyHollowCandleStyle(e, t, i, s) {
        const o = s.childs().hollowCandleStyle.childs();
        const n = this._isUp(e, false, i, this._series.data().first()?.index !== e);
        const r = n ? _.upColor(s) : _.downColor(s);
        t.barColor = r.barColor;
        t.barBorderColor = r.barBorderColor;
        t.barWickColor = n ? o.wickUpColor ? o.wickUpColor.value() : o.wickColor.value() : o.wickDownColor ? o.wickDownColor.value() : o.wickColor.value();
        const a = this._findBar(e, false, i);
        t.isBarHollow = a[1] <= a[4];
      }
      _applyHAStyle(e, t, i, s, o) {
        const n = o.childs().haStyle.childs();
        const r = this._isUp(e, t, s, n.barColorsOnPrevClose.value());
        const a = r ? _.upColor(o) : _.downColor(o);
        i.barColor = a.barColor;
        i.barBorderColor = a.barBorderColor;
        i.barWickColor = r ? n.wickUpColor.value() : n.wickDownColor.value();
      }
      _applyBaseLineStyle(e, t, i, s, n) {
        const r = this._findBar(e, t, s);
        const a = n.childs().baselineStyle.childs();
        const l = this._series.priceScale();
        const c = Math.round(l.height() * (Math.abs(100 - a.baseLevelPercentage.value()) / 100));
        const h = (0, o.ensureNotNull)(this._series.firstValue());
        const d = l.coordinateToPrice(c, h);
        if (r[4] > d) {
          i.barColor = _.upColor(n, t).barColor;
        } else {
          i.barColor = _.downColor(n, t).barColor;
        }
      }
      _applyHiLoStyle(e, t, i) {
        const s = _.upColor(i, e);
        t.barColor = s.barColor;
        t.barBorderColor = s.barBorderColor;
      }
      _applyColumnStyle(e, t, i, s) {
        const o = s.childs().columnStyle.childs();
        const n = this._isUp(e, false, i, o.barColorsOnPrevClose.value()) ? _.upColor(s) : _.downColor(s);
        t.color = n.barColor;
        t.barColor = t.color;
      }
      _applyRenkoStyle(e, t, i, s, o) { }
      _applyPBStyle(e, t, i, s, o) { }
      _applyKagiStyle(e, t, i, s, o) { }
      _applyPnfStyle(e, t, i, s, o) { }
      _applyRangeStyle(e, t, i, s, o) { }
      _applySVPStyle(e, t, i, s) { }
      _applyHLCBarsStyle(e, t, i, s) {
        t.barColor = s.childs().hlcBarsStyle.childs().color.value();
      }
      _findBar(e, t, i) {
        if (i) {
          return i.value;
        } else {
          return this._getSeriesBars(t).valueAt(e) || [];
        }
      }
      _findPrevBar(e, t, i) {
        if (i && i.previousValue) {
          return i.previousValue;
        }
        const s = this._series.bars().search(e - 1, n.PlotRowSearchMode.NearestLeft, 4);
        if (s !== null) {
          return s.value;
        } else {
          return [];
        }
      }
      _getSeriesBars(e) {
        if (e) {
          return this._series.nsBars();
        } else {
          return this._series.bars();
        }
      }
      _isUp(e, t, i, s) {
        const o = this._findBar(e, t, i);
        if (s) {
          return this._findPrevBar(e, t, i)[4] <= o[4];
        }
        return o[1] <= o[4];
      }
    }
  },
  5171: (e, t, i) => {
    "use strict";

    var s;
    i.r(t);
    i.d(t, {
      ChartStyle: () => H,
      OldLineStyleTypes: () => w,
      SERIES_STATUS_TEXT: () => b,
      STATUS_CALCULATION_ERROR: () => f,
      STATUS_DELAYED: () => u,
      STATUS_DELAYED_STREAMING: () => _,
      STATUS_EOD: () => h,
      STATUS_ERROR: () => g,
      STATUS_INVALID_SYMBOL: () => l,
      STATUS_LOADING: () => r,
      STATUS_NO_BARS: () => p,
      STATUS_OFFLINE: () => o,
      STATUS_PULSE: () => d,
      STATUS_READY: () => a,
      STATUS_REPLAY: () => m,
      STATUS_RESOLVING: () => n,
      STATUS_SNAPSHOT: () => c,
      STATUS_UNSUPPORTED_RESOLUTION: () => y,
      STYLE_AREA: () => x,
      STYLE_BARS: () => C,
      STYLE_BASELINE: () => E,
      STYLE_CANDLES: () => P,
      STYLE_COLUMNS: () => R,
      STYLE_HEIKEN_ASHI: () => k,
      STYLE_HILO: () => V,
      STYLE_HLC_AREA: () => F,
      STYLE_HLC_BARS: () => W,
      STYLE_HOLLOW_CANDLES: () => D,
      STYLE_KAGI: () => M,
      STYLE_LINE: () => T,
      STYLE_LINE_WITH_MARKERS: () => N,
      STYLE_PB: () => L,
      STYLE_PNF: () => A,
      STYLE_RANGE: () => B,
      STYLE_RENKO: () => I,
      STYLE_SHORT_NAMES: () => z,
      STYLE_STEPLINE: () => O,
      SYMBOL_STRING_DATA: () => U,
      Status: () => s,
      chartStylesWithAttachedStudies: () => j,
      seriesLoadingStatuses: () => S,
      seriesReadyStatuses: () => v
    });
    (function (e) {
      e[e.Offline = 0] = "Offline";
      e[e.Resolving = 1] = "Resolving";
      e[e.Loading = 2] = "Loading";
      e[e.Ready = 3] = "Ready";
      e[e.InvalidSymbol = 4] = "InvalidSymbol";
      e[e.Snapshot = 5] = "Snapshot";
      e[e.EOD = 6] = "EOD";
      e[e.Pulse = 7] = "Pulse";
      e[e.Delayed = 8] = "Delayed";
      e[e.DelayedSteaming = 9] = "DelayedSteaming";
      e[e.NoBars = 10] = "NoBars";
      e[e.Replay = 11] = "Replay";
      e[e.Error = 12] = "Error";
      e[e.CalculationError = 13] = "CalculationError";
      e[e.UnsupportedResolution = 14] = "UnsupportedResolution";
    })(s ||= {});
    const o = 0;
    const n = 1;
    const r = 2;
    const a = 3;
    const l = 4;
    const c = 5;
    const h = 6;
    const d = 7;
    const u = 8;
    const _ = 9;
    const p = 10;
    const m = 11;
    const g = 12;
    const f = 13;
    const y = 14;
    const v = new Set([3, 6, 7, 8, 9, 11]);
    const S = new Set([1, 2]);
    const b = {
      [o]: "connecting",
      [n]: "loading",
      [r]: "loading",
      [a]: "realtime",
      [l]: "invalid",
      [c]: "snapshot",
      [h]: "endofday",
      [d]: "endofday",
      [u]: "delayed",
      [_]: "delayed_streaming",
      [p]: "forbidden",
      [m]: "replay",
      [g]: "error",
      [f]: "calculation_error",
      [y]: "unsupported_resolution"
    };
    var w;
    (function (e) {
      e[e.Markers = 0] = "Markers";
      e[e.Stepline = 1] = "Stepline";
      e[e.Simple = 2] = "Simple";
    })(w ||= {});
    const C = 0;
    const P = 1;
    const T = 2;
    const x = 3;
    const I = 4;
    const M = 5;
    const A = 6;
    const L = 7;
    const k = 8;
    const D = 9;
    const E = 10;
    const B = 11;
    const V = 12;
    const R = 13;
    const N = 14;
    const O = 15;
    const F = 16;
    const W = 21;
    var H;
    (function (e) {
      e[e.Bar = 0] = "Bar";
      e[e.Candle = 1] = "Candle";
      e[e.Line = 2] = "Line";
      e[e.Area = 3] = "Area";
      e[e.Renko = 4] = "Renko";
      e[e.Kagi = 5] = "Kagi";
      e[e.PnF = 6] = "PnF";
      e[e.LineBreak = 7] = "LineBreak";
      e[e.HeikinAshi = 8] = "HeikinAshi";
      e[e.HollowCandle = 9] = "HollowCandle";
      e[e.Baseline = 10] = "Baseline";
      e[e.Range = 11] = "Range";
      e[e.HiLo = 12] = "HiLo";
      e[e.Column = 13] = "Column";
      e[e.LineWithMarkers = 14] = "LineWithMarkers";
      e[e.Stepline = 15] = "Stepline";
      e[e.HLCArea = 16] = "HLCArea";
      e[e.VolFootprint = 17] = "VolFootprint";
      e[e.TPO = 18] = "TPO";
      e[e.VolCandle = 19] = "VolCandle";
      e[e.SVP = 20] = "SVP";
      e[e.HLCBars = 21] = "HLCBars";
    })(H ||= {});
    const z = {
      0: "bar",
      1: "candle",
      9: "hollowCandle",
      2: "line",
      14: "lineWithMarkers",
      15: "stepline",
      3: "area",
      16: "hlcArea",
      4: "renko",
      7: "pb",
      5: "kagi",
      6: "pnf",
      8: "ha",
      10: "baseline",
      11: "range",
      12: "hilo",
      13: "column",
      17: "volFootprint",
      18: "tpo",
      19: "volCandles",
      20: "svp",
      21: "hlcBars"
    };
    const U = {
      4: {
        type: "BarSetRenko@tv-prostudies",
        basicStudyVersion: 73
      },
      7: {
        type: "BarSetPriceBreak@tv-prostudies",
        basicStudyVersion: 34
      },
      5: {
        type: "BarSetKagi@tv-prostudies",
        basicStudyVersion: 73
      },
      6: {
        type: "BarSetPnF@tv-prostudies",
        basicStudyVersion: 73
      },
      8: {
        type: "BarSetHeikenAshi@tv-basicstudies",
        basicStudyVersion: 60
      },
      11: {
        type: "BarSetRange@tv-basicstudies",
        basicStudyVersion: 72
      },
      17: {
        type: "Footprint@tv-volumebyprice",
        basicStudyVersion: 104
      },
      18: {
        type: "TPOPeriodic@tv-volumebyprice",
        basicStudyVersion: 104
      },
      20: {
        type: "VbPSessions@tv-volumebyprice",
        basicStudyVersion: 126
      }
    };
    const j = [17, 18, 20];
  },
  3070: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesData: () => p,
      barFunction: () => u,
      barFunctions: () => l,
      seriesPlotFunctionMap: () => h
    });
    var s;
    var o;
    var n = i(50151);
    var r = i(64755);
    var a = i(85856);
    (function (e) {
      e[e.FromLeft = -1] = "FromLeft";
      e[e.FromRight = 1] = "FromRight";
    })(s ||= {});
    (function (e) {
      e[e.Time = 0] = "Time";
      e[e.Open = 1] = "Open";
      e[e.High = 2] = "High";
      e[e.Low = 3] = "Low";
      e[e.Close = 4] = "Close";
      e[e.Volume = 5] = "Volume";
      e[e.Adt = 6] = "Adt";
    })(o ||= {});
    const l = {
      open: e => e[1],
      high: e => e[2],
      low: e => e[3],
      close: e => e[4],
      hl2: e => (e[2] + e[3]) / 2,
      hlc3: e => (e[2] + e[3] + e[4]) / 3,
      ohlc4: e => (e[1] + e[2] + e[3] + e[4]) / 4
    };
    const c = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"];
    function h() {
      const e = new Map();
      c.forEach((t, i) => {
        e.set(t, u(t));
      });
      return e;
    }
    var d;
    function u(e, t, i) {
      const s = l[t ?? e];
      const o = l[e];
      const n = l[i ?? e];
      return (e, t) => {
        switch (t) {
          case 0:
            return s(e);
          case 2:
            return n(e);
          default:
            return o(e);
        }
      };
    }
    function _(e, t) {
      return e[t] == null;
    }
    (function (e) {
      e[e.FirstPrice = 0] = "FirstPrice";
      e[e.LastPrice = 1] = "LastPrice";
      e[e.LastValuePrice = 2] = "LastValuePrice";
    })(d ||= {});
    class p {
      constructor() {
        this.m_bars = new r.PlotList(h(), _);
        this.m_nsBars = new r.PlotList(h(), _);
        this._conflatedChunksBuilder = new a.ConflatedChunksBuilder(this.m_bars, e => l[e]);
      }
      bars() {
        return this.m_bars;
      }
      nsBars() {
        return this.m_nsBars;
      }
      conflatedChunks(e, t) {
        return this._conflatedChunksBuilder.conflatedChunks(e, t);
      }
      mergeRegularBars(e) {
        return this._conflatedChunksBuilder.mergeData(e);
      }
      size() {
        return this.m_bars.size() + this.m_nsBars.size();
      }
      each(e) {
        this.m_bars.each(e);
        this.m_nsBars.each(e);
      }
      clear() {
        this.m_nsBars.clear();
        this.lastProjectionPrice = undefined;
        this._conflatedChunksBuilder.clearData();
      }
      clone() {
        const e = new p();
        e.lastProjectionPrice = this.lastProjectionPrice;
        e.boxSize = this.boxSize;
        e.reversalAmount = this.reversalAmount;
        e.m_bars = this.m_bars.clone();
        e.m_nsBars = this.m_bars.clone();
        return e;
      }
      isEmpty() {
        return this.m_bars.isEmpty() && this.m_nsBars.isEmpty();
      }
      first() {
        if (this.m_bars.isEmpty()) {
          return this.m_nsBars.first();
        } else {
          return this.m_bars.first();
        }
      }
      last() {
        if (this.m_nsBars.isEmpty()) {
          return this.m_bars.last();
        } else {
          return this.m_nsBars.last();
        }
      }
      search(e, t, i) {
        if (this.nsBars().isEmpty()) {
          return this.bars().search(e, t, i);
        } else if (this.bars().isEmpty() || (0, n.ensureNotNull)(this.nsBars().firstIndex()) <= e) {
          return this.nsBars().search(e, t, i);
        } else {
          return this.bars().search(e, t, i);
        }
      }
      valueAt(e) {
        const t = this.search(e);
        if (t !== null) {
          return t.value;
        } else {
          return null;
        }
      }
      plotValueToTimePointIndex(e, t, i) {
        if (i === s.FromRight) {
          const i = (i, s) => {
            const o = s[t];
            return o != null && e >= o;
          };
          const s = this.m_bars.findLast(i);
          if (s !== null) {
            return s.index;
          }
          const o = this.m_nsBars.findLast(i);
          if (o !== null) {
            return o.index;
          } else {
            return this.m_bars.firstIndex();
          }
        }
        if (i === s.FromLeft) {
          const i = (i, s) => {
            const o = s[t];
            return o != null && e <= o;
          };
          const s = this.m_bars.findFirst(i);
          if (s !== null) {
            return s.index;
          }
          const o = this.m_nsBars.findFirst(i);
          if (o !== null) {
            return o.index;
          } else {
            return this.m_bars.lastIndex();
          }
        }
        throw new Error("plotValueToTimePointIndex: unsupported search mode");
      }
      moveData(e) {
        this._conflatedChunksBuilder.moveData(e);
        this.m_nsBars.move(e);
      }
    }
  },
  61105: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesTimeRangeVolumeCalculator: () => s
    });
    class s {
      constructor(e) {
        this._value = null;
        this._series = e;
        this._series.dataEvents().dataUpdated().subscribe(this, this._onSeriesUpdated);
      }
      destroy() {
        this._series.dataEvents().dataUpdated().unsubscribeAll(this);
      }
      volume(e, t) {
        if (this._value !== null && this._value.from === e && this._value.to === t) {
          return this._value.value;
        }
        let i = 0;
        const s = this._series.data().bars();
        const o = s.firstIndex();
        const n = s.lastIndex();
        if (o !== null && e < o && t < o || n !== null && e > n && t > n) {
          i = NaN;
        } else {
          const s = this._series.data().bars().rangeIterator(Math.min(e, t), Math.max(e, t));
          for (const e of s) {
            const t = e.value[5];
            if (t === undefined) {
              i = NaN;
              break;
            }
            i += t;
          }
        }
        this._value = {
          from: e,
          to: t,
          value: i
        };
        return i;
      }
      _onSeriesUpdated(e, t) {
        if (this._value === null) {
          return;
        }
        if (t) {
          this._value = null;
          return;
        }
        const i = this._series.data().bars().lastIndex();
        if (i === null || i <= this._value.to) {
          this._value = null;
        }
      }
    }
  },
  68805: (e, t, i) => {
    "use strict";

    i.d(t, {
      actualSymbol: () => ce,
      chartStyleStudyId: () => N,
      createSeriesFormatter: () => H,
      displayedSymbolExchange: () => le,
      displayedSymbolName: () => ae,
      extractLineToolSymbolFromSymbolInfo: () => ie,
      extractSymbolNameFromSymbolInfo: () => te,
      getChartStyleByResolution: () => R,
      getDefaultStyle: () => V,
      getLastUsedSingleValueBasedStyle: () => B,
      getLastUsedStyle: () => E,
      getSeriesDisplayErrorWV: () => ye,
      getSeriesPriceFormattingState: () => W,
      getSourceForEconomySymbol: () => ne,
      getSymbolDelaySeconds: () => ve,
      getSymbolExchange: () => fe,
      getTranslatedChartStyleName: () => P,
      hasVolume: () => me,
      isCloseBasedSymbol: () => ue,
      isConvertedToOtherCurrency: () => q,
      isConvertedToOtherUnit: () => Z,
      isEconomicSymbol: () => ge,
      isMeasureUnitSymbol: () => _e,
      isPriceSourceStyle: () => F,
      isRangeBasedStyle: () => x,
      isRangeStyle: () => M,
      isRegularSessionId: () => de,
      isSingleValueBasedStyle: () => k,
      isTimeBasedStyle: () => A,
      isValidStyle: () => L,
      measureUnitId: () => pe,
      preparePriceAxisProperties: () => O,
      proSymbol: () => he,
      setLastUsedStyle: () => D,
      styleChangeRequiresRestart: () => I,
      symbolBaseCurrency: () => G,
      symbolCurrency: () => U,
      symbolCurrencyConvertible: () => z,
      symbolHasElectronicSession: () => Q,
      symbolHasPreOrPostMarket: () => J,
      symbolHasSeveralSessions: () => ee,
      symbolOriginalCurrency: () => j,
      symbolOriginalUnit: () => Y,
      symbolTitle: () => re,
      symbolTitleSeparator: () => oe,
      symbolToSaveInState: () => se,
      symbolUnit: () => K,
      symbolUnitConvertibleGroupsIfExist: () => X
    });
    var s = i(11542);
    var o = i(56840);
    i(49483);
    var n = i(5171);
    var r = i(85049);
    var a = i(725);
    var l = i(56570);
    var c = i(46084);
    var h = i(719);
    var d = i(88960);
    var u = i(84425);
    var _ = i(36986);
    const p = l.enabled("pay_attention_to_ticker_not_symbol");
    const m = l.enabled("uppercase_instrument_names");
    const g = l.enabled("charting_library_single_symbol_request");
    const f = l.enabled("use_ticker_on_symbol_info_update");
    const y = l.enabled("hide_object_tree_and_price_scale_exchange_label");
    var v;
    (function (e) {
      e.LastUsedStyleKey = "chart.lastUsedStyle";
      e.LastUsedSingleValueBasedStyle = "chart.lastUsedSingleValueBasedStyle";
      e.LastUsedRawDataStyle = "chart.rawDataStyle";
    })(v ||= {});
    const S = [4, 5, 6, 7, 8];
    const b = [4, 5, 6, 7, 11];
    const w = [0, 1, 9, 19, 2, 14, 15, 3, 16, 10, 8, 12, 13, 18, 17, 20];
    const C = [2, 14, 15, 10, 3, 13, 18];
    function P(e) {
      return {
        0: s.t(null, undefined, i(27377)),
        1: s.t(null, undefined, i(45054)),
        2: s.t(null, undefined, i(3554)),
        14: s.t(null, undefined, i(9394)),
        15: s.t(null, undefined, i(69217)),
        3: s.t(null, undefined, i(34456)),
        16: s.t(null, undefined, i(99906)),
        9: s.t(null, undefined, i(13459)),
        10: s.t(null, undefined, i(59213)),
        12: s.t(null, undefined, i(98236)),
        13: s.t(null, undefined, i(55761)),
        4: s.t(null, undefined, i(88130)),
        7: s.t(null, undefined, i(43588)),
        5: s.t(null, undefined, i(83490)),
        6: s.t(null, undefined, i(76519)),
        11: s.t(null, undefined, i(55169)),
        8: s.t(null, undefined, i(63876)),
        17: s.t(null, undefined, i(92763)),
        18: s.t(null, undefined, i(17809)),
        19: s.t(null, undefined, i(93722)),
        20: s.t(null, undefined, i(83298)),
        21: s.t(null, undefined, i(886))
      }[e];
    }
    function T(e) {
      return S.indexOf(e) !== -1;
    }
    function x(e) {
      return b.indexOf(e) !== -1;
    }
    function I(e, t) {
      return !M(e) && !M(t) && e !== t && (!!T(e) || !!T(t));
    }
    function M(e) {
      return e === 11;
    }
    function A(e) {
      return w.indexOf(e) !== -1;
    }
    function L(e) {
      return x(e) || A(e);
    }
    function k(e) {
      switch (e) {
        case 3:
        case 10:
        case 2:
        case 14:
        case 15:
        case 13:
          return true;
        default:
          return false;
      }
    }
    function D(e, t) {
      var i;
      if (L(e)) {
        if (e !== 11) {
          o.setValue("chart.lastUsedStyle", e);
        }
        i = e;
        if (!n.SYMBOL_STRING_DATA[i]) {
          (function (e) {
            o.setValue("chart.rawDataStyle", e);
          })(e);
        }
        if (ue(t) && k(e)) {
          o.setValue("chart.lastUsedSingleValueBasedStyle", e);
        }
      }
    }
    function E() {
      const e = o.getInt("chart.lastUsedStyle");
      if (e === undefined) {
        return 1;
      } else {
        return e;
      }
    }
    function B() {
      const e = o.getInt("chart.lastUsedSingleValueBasedStyle");
      if (e === undefined) {
        return 14;
      } else {
        return e;
      }
    }
    function V(e) {
      if (e) {
        return 11;
      } else {
        return 1;
      }
    }
    function R(e, t) {
      const i = M(t);
      const s = r.Interval.isRange(e);
      if (!i && s) {
        return V(true);
      } else if (i && !s) {
        return V(false);
      } else {
        return t;
      }
    }
    function N(e, t) {
      const i = n.SYMBOL_STRING_DATA[e];
      if (i === undefined) {
        return null;
      } else if (t) {
        return `${i.type}-${i.basicStudyVersion}`;
      } else {
        return i.type;
      }
    }
    function O(e) {
      const t = e.priceAxisProperties;
      const i = t.lockScale.value();
      const s = e.style.value() === 6;
      if (s || i) {
        t.log.setValue(false);
        t.percentage.setValue(false);
      }
      t.logDisabled.setValue(!!s || !!i);
      t.percentageDisabled.setValue(!!s || !!i);
    }
    function F(e) {
      return C.includes(e);
    }
    function W(e, t = "default", i = false) {
      let s;
      let o;
      let n;
      let r = 100;
      let a = 1;
      if (t === "default") {
        if (e != null) {
          ({
            pricescale: r,
            minmov: a,
            minmove2: o,
            fractional: s
          } = e);
          n = e.variable_tick_size || undefined;
        }
      } else {
        let e = t.split(",");
        if (e.length !== 3) {
          e = ["100", "1", "false"];
        }
        r = parseInt(e[0]);
        a = parseInt(e[1]);
        s = e[2] === "true";
      }
      if (i) {
        a = 1;
      }
      return {
        priceScale: r,
        minMove: a,
        fractional: s,
        minMove2: o,
        variableMinTick: n,
        ignoreMinMove: i
      };
    }
    function H(e, t, i = false) {
      const {
        priceScale: s,
        minMove: o,
        fractional: n,
        minMove2: r,
        variableMinTick: l
      } = W(e, t, i);
      if (e != null) {
        const a = e.format;
        if (t === "default" && a === "volume") {
          return new c.VolumeFormatter({
            precision: 2
          });
        }
        if (a === "percent") {
          return new h.PercentageFormatter({
            priceScale: s,
            minMove: o,
            fractional: n,
            minMove2: r,
            variableMinTick: l,
            ignoreMinMove: i
          });
        }
      }
      return new a.PriceFormatter({
        priceScale: s,
        minMove: o,
        fractional: n,
        minMove2: r,
        variableMinTick: l,
        ignoreMinMove: i
      });
    }
    function z(e) {
      return e !== null && e.type !== "spread";
    }
    function U(e, t, i) {
      if (e === null) {
        return null;
      }
      const s = !t || i ? e.currency_id : e.currency_code;
      if (s === undefined || s === "") {
        return null;
      } else {
        return s;
      }
    }
    function j(e, t) {
      return (t ? e.original_currency_code : e.original_currency_id) ?? U(e, t);
    }
    function G(e) {
      return e.base_currency_id || null;
    }
    function q(e) {
      if (e === null || !z(e)) {
        return false;
      }
      const t = j(e);
      return t !== null && t !== U(e);
    }
    function $(e, t) {
      return t && e !== null && e.type !== "spread";
    }
    function K(e, t) {
      if (e === null || !t) {
        return null;
      }
      const i = e.unit_id;
      if (i === undefined || i === "") {
        return null;
      } else {
        return i;
      }
    }
    function Y(e, t) {
      if (t) {
        return e.original_unit_id || K(e, t);
      } else {
        return null;
      }
    }
    function Z(e, t) {
      return e !== null && !!$(e, t) && e.original_unit_id !== undefined && e.original_unit_id !== e.unit_id;
    }
    function X(e, t) {
      if (e !== null && $(e, t)) {
        return e.unit_conversion_types || null;
      } else {
        return [];
      }
    }
    function J(e) {
      return e !== null && e.subsessions !== undefined && e.subsessions.some(e => e.id === "premarket" || e.id === "postmarket");
    }
    function Q(e) {
      return e !== null && e.subsessions !== undefined && e.subsessions.some(e => e.id === "regular") && e.subsessions.some(e => e.id === "us_regular");
    }
    function ee(e) {
      return e !== null && e.subsessions !== undefined && e.subsessions.filter(e => !e.private).length > 1;
    }
    function te(e, t, i, s) {
      let o = e && (i && e.pro_name || e.full_name || e.name);
      if (g && t) {
        o = t;
      } else if ((f || !s && p) && e && e.ticker) {
        o = e.ticker;
      }
      if (m && o) {
        o = o.toUpperCase();
      }
      return o;
    }
    function ie(e, t) {
      return te(e, null, true, true) || t;
    }
    function se(e, t) {
      if (e) {
        return e.ticker ?? e.pro_name ?? t;
      } else {
        return t;
      }
    }
    const oe = "·";
    function ne(e, t) {
      if (ge(e)) {
        return e.source2?.description ?? null;
      } else {
        return null;
      }
    }
    function re(e, t, i = "exchange") {
      const s = ne(e) ?? e[i];
      if (t || y) {
        return e.name;
      } else {
        return `${e.name} ${oe} ${s}`;
      }
    }
    function ae(e) {
      let t = e && (function (e) {
        return e.type === "futures" && e.front_contract || null;
      }(e) || e.name) || "";
      if (t.length > 40) {
        t = t.substring(0, 37) + "...";
      }
      return t.trim();
    }
    function le(e) {
      const t = e ? e.exchange : "";
      if (m) {
        return t.toUpperCase();
      } else {
        return t;
      }
    }
    function ce(e, t) {
      if (e !== null) {
        return e.full_name;
      } else {
        return t;
      }
    }
    function he(e, t) {
      return e?.pro_name ?? t;
    }
    function de(e, t) {
      if ((0, _.getChartingLibraryGlobalContext)()?.configurationData?.is_tradingview_data) {
        return ["stock", "fund", "index", "dr"].includes(t.type) && e === "regular" || t.type === "futures" && e === "us_regular";
      } else {
        return e === "regular";
      }
    }
    function ue(e) {
      return e?.visible_plots_set === "c";
    }
    function _e(e) {
      return e !== null && e.measure === "unit" && pe(e) !== null;
    }
    function pe(e) {
      return e?.value_unit_id ?? null;
    }
    function me(e) {
      return e.visible_plots_set === "ohlcv";
    }
    function ge(e) {
      return e !== null && e.type === "economic";
    }
    function fe(e) {
      const t = ne(e);
      if (t !== null) {
        return t;
      }
      return e.exchange;
    }
    function ye(e) {
      return (0, d.combine)((t, i) => {
        switch (t) {
          case 4:
            {
              const t = e.seriesErrorMessage();
              if (t !== null && (t === "resolution_not_entitled" || t === "custom_resolution" || t === "seconds_not_entitled" || t === "ticks_not_entitled" || t.startsWith("study_not_auth:"))) {
                return null;
              } else {
                return {
                  type: "invalid_symbol"
                };
              }
            }
          case 13:
            {
              const t = e.seriesErrorMessage();
              if (t === null) {
                return null;
              } else {
                return {
                  type: "calculations_error",
                  errorMessage: t
                };
              }
            }
          case 14:
            {
              const t = e.unsupportedResolutionState().value();
              if (t === null) {
                return null;
              } else {
                return {
                  type: "unsupported_resolution",
                  reason: t.reason
                };
              }
            }
          case 1:
          case 2:
            return null;
          default:
            if (i) {
              return {
                type: "no_data"
              };
            }
        }
        return null;
      }, e.statusWV().weakReference(), (0, u.createWVFromGetterAndSubscription)(() => !e.bars().size() && !e.isInReplay().value(), e.dataEvents().dataUpdated()).ownership(), (0, u.createWVFromGetterAndSubscription)(() => ({}), e.model().onChartThemeLoaded()).ownership());
    }
    function ve(e) {
      return Math.max(0, e?.delay ?? 0);
    }
  },
  98017: (e, t, i) => {
    "use strict";

    i.d(t, {
      Series: () => pi
    });
    var s = i(50151);
    var o = i(51768);
    var n = i(76422);
    var r = i(9343);
    var a = i(14426);
    var l = i(45579);
    var c = i(80720);
    var h = i(3070);
    var d = i(64755);
    var u = i(8025);
    var _ = i(93280);
    var p = i(12988);
    var m = i(68805);
    var g = i(91007);
    var f = i(725);
    var y = i(5171);
    var v = i(27777);
    var S = i(11542);
    var b = i(56570);
    var w = i(22365);
    var C = i(27538);
    i(56530);
    var P = i(24708);
    i(64671);
    function T(e) {
      const t = (e = e || {}).exchange === "QUANDL";
      const s = {
        title: "",
        description: "",
        interval: "",
        exchange: "",
        provider: "",
        chartStyle: "",
        sessionDescription: "",
        priceSource: ""
      };
      let o = "";
      if (e.description && t) {
        if (e.description.split("/").length === 2) {
          o = e.description.split("/")[1];
        } else {
          e.description.split("'").filter(e => e.length).forEach(e => {
            let t = [];
            t = e && (e[0] === "/" || /\d+\/\(?/.test(e)) ? [e] : e.split("/").filter(e => e.length);
            o += t[t.length === 2 ? 1 : 0];
          });
        }
      } else {
        o = e.description ? e.description : e.symbol;
      }
      if (e.ticker) {
        s.title = e.ticker;
        s.description = x(o);
      } else {
        s.title = x(o);
      }
      if (e.interval) {
        s.interval = (0, P.translatedIntervalString)(e.interval);
      }
      if (t && e.description) {
        const t = /[\w_]+\/[\w_]+/.exec(e.description);
        if (t && t[0]) {
          s.provider = x(t[0].split("/")[0]);
        } else {
          s.provider = x(e.description.split("/")[0]);
        }
      }
      if (e.exchange) {
        s.exchange = x(e.exchange);
      }
      s.chartStyle = x(function (e) {
        e.inputs;
        if (e.style === 8) {
          return S.t(null, undefined, i(63876));
        } else {
          return "";
        }
      }(e));
      if (e.sessionDescription) {
        s.sessionDescription = x(e.sessionDescription);
      }
      if (e.priceSource !== undefined) {
        s.priceSource = x(e.priceSource);
      }
      return s;
    }
    function x(e) {
      return e.replace(/'/g, "");
    }
    var I = i(62825);
    const M = S.t(null, undefined, i(70963));
    const A = S.t(null, undefined, i(75546));
    const L = b.enabled("hide_unresolved_symbols_in_legend");
    const k = b.enabled("symbol_info_price_source");
    class D extends C.StatusProviderBase {
      constructor(e, t, i) {
        super();
        this._series = e;
        this._statusViewProperties = t;
        this._options = i || {};
      }
      text() {
        return function (e) {
          const t = T(e);
          return (e.ticker ? t.description : t.title) + (t.interval ? ", " + t.interval : "") + function (e, t = ", ") {
            return (e.provider ? `${t}${e.provider}` : "") + (e.exchange ? `${t}${e.exchange}` : "") + (e.chartStyle ? `${t}${e.chartStyle}` : "") + (e.branding ? `${t}${e.branding}` : "") + (e.sessionDescription ? `${t}${e.sessionDescription}` : "") + (e.priceSource ? `${t}${e.priceSource}` : "");
          }(t);
        }(this._getTitleGenerationOptions());
      }
      getSplitTitle() {
        return T(this._getTitleGenerationOptions());
      }
      bold() {
        return false;
      }
      size() {
        return this._statusViewProperties.childs().fontSize.value() + "px";
      }
      errorStatus() {
        const e = this._series.unsupportedResolutionState().value();
        const t = e ? (0, I.getErrorFromUnsupportedResolutionState)(e) : this._series.seriesErrorMessage();
        if (t !== null) {
          return {
            error: t,
            title: e ? A : M
          };
        } else {
          return null;
        }
      }
      _getTitleGenerationOptions() {
        const e = this._series.symbolInfo();
        const t = this._statusViewProperties.childs();
        const i = this._series.symbolTextSourceProxyProperty().value();
        let s;
        if (t.showExchange.value() && e) {
          s = (0, m.getSymbolExchange)(e);
        }
        const o = (k && e?.price_source_id ? this._series.model().availablePriceSources(this._series.getSymbolString()).name(e.price_source_id) : null) ?? undefined;
        const n = this._series.getInputsProperties().state();
        if (this._series.style() === 17) {
          n.type = this._series.properties().childs().volFootprintStyle.childs().type.value();
        }
        return {
          description: B(i, e),
          exchange: s,
          symbol: L && e === null ? "" : this._series.symbol(),
          interval: t.showInterval.value() && !this._options.hideResolution ? this._series.interval() : undefined,
          style: this._series.properties().childs().style.value(),
          inputs: n,
          boxSize: this._series.data().boxSize,
          reversalAmount: this._series.data().reversalAmount,
          ticker: E(i, e),
          priceSource: o
        };
      }
    }
    function E(e, t) {
      if (e !== "ticker-and-description") {
        return "";
      } else if (t !== null) {
        return t.name;
      } else {
        return undefined;
      }
    }
    function B(e, t) {
      if (t !== null) {
        if (e === "ticker") {
          return t.name;
        } else if (e === "long-description" && t.long_description !== undefined) {
          return t.long_description;
        } else {
          return (0, w.getTranslatedSymbolDescription)({
            pro_name: t.pro_name || undefined,
            short_name: t.name || undefined,
            description: t.description || undefined,
            short_description: t.short_description || undefined,
            local_description: t.local_description || undefined,
            language: t.language || undefined
          });
        }
      }
    }
    class V extends v.StatusView {
      constructor(e, t, i) {
        super(new D(e, t, i));
        this._invalidated = true;
        this._series = e;
        this._series.onRestarted().subscribe(this, this.update);
        this._series.dataEvents().symbolResolved().subscribe(this, this.update);
        this._series.dataEvents().completed().subscribe(this, this.update);
        this._series.boxSizeValue().subscribe(this.update.bind(this));
        t.childs().symbolTextSource.subscribe(this, this.update);
      }
      getSeriesPrecision() {
        let e = 4;
        const t = this._series.symbolInfo();
        if (t && t.pricescale) {
          e = Math.round(Math.log(t.pricescale) / Math.log(10));
        }
        return e;
      }
      round(e) {
        const t = this.getSeriesPrecision();
        const i = Math.round(e * Math.pow(10, t)) / Math.pow(10, t);
        if (i) {
          return i.toString();
        } else {
          return "";
        }
      }
      update() {
        this._invalidated = true;
      }
      text() {
        this._updateImpl();
        return super.text();
      }
      bold() {
        this._updateImpl();
        return super.bold();
      }
      size() {
        this._updateImpl();
        return super.size();
      }
      getSplitTitle() {
        this._updateImpl();
        return this._statusProvider.getSplitTitle();
      }
      _updateImpl() {
        if (this._invalidated) {
          this._bold = this._statusProvider.bold();
          this._size = this._statusProvider.size();
          this._text = this._statusProvider.text();
          this._invalidated = false;
        }
      }
    }
    var R = i(50335);
    var N = i(7576);
    var O = i(49483);
    var F = i(928);
    var W = i(15764);
    const H = O.CheckMobile.any();
    const z = b.enabled("hide_resolution_in_legend");
    class U extends N.DataWindowView {
      constructor(e, t) {
        super();
        this._invalidated = true;
        this._series = e;
        this._model = t;
        this.update();
      }
      update() {
        this._invalidated = true;
      }
      items() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        return this._items;
      }
      series() {
        return this._series;
      }
      canShowItems() {
        return !!this._model.mainPane()?.maximized().value() || this._model.panes().find(e => e.maximized().value()) === undefined;
      }
      _updateImpl() {
        const e = this._getValuesProvider();
        if (this._valuesProvider !== e) {
          this._valuesProvider = e;
          this._items = this._valuesProvider.getItems().map(e => new N.DataWindowItem(e.id, e.title, "", e.unimportant));
        }
        const t = this._series.symbolInfo();
        if (t) {
          const e = [t.name];
          if (!z) {
            e.push((0, P.translatedIntervalString)(this._series.interval()));
          }
          if ((0, m.isEconomicSymbol)(t)) {
            const i = (0, m.getSourceForEconomySymbol)(t);
            if (i !== null) {
              e.push(i);
            }
          } else {
            e.push((0, O.onWidget)() || t.type === "forex" ? t.exchange : t.listed_exchange);
          }
          this._header = e.join(` ${m.symbolTitleSeparator} `);
          this._title = t.description;
        } else {
          this._header = this._series.symbol();
        }
        let i = this._model.crosshairSource().appliedIndex();
        if (b.enabled("use_last_visible_bar_value_in_legend") && !(0, R.isNumber)(i)) {
          i = this._model.timeScale().visibleBarsStrictRange()?.lastBar() ?? NaN;
        }
        const s = this._valuesProvider.getValues(i);
        for (let e = 0; e < s.length; ++e) {
          const t = s[e];
          const i = this._items[e];
          i.setValue(t.value);
          i.setVisible(t.visible);
          i.setColor(t.color);
          i.setTitle(t.title);
        }
      }
      _getValuesProvider() {
        return this._series.dataWindowValuesProvider();
      }
      _showLastPriceAndChangeOnly() {
        return H && (this._model.crosshairSource().pane === null || (0, W.isLineToolName)(F.tool.value()) || this._model.lineBeingEdited() !== null);
      }
    }
    var j = i(84425);
    const G = S.t(null, undefined, i(72445));
    class q extends U {
      constructor(e, t) {
        super(e, t);
        this._backgroundColorSpawn = t.backgroundTopColor().spawn();
        this._backgroundColorSpawn.subscribe(this.update.bind(this));
        const i = t.properties().childs().paneProperties.childs().legendProperties.childs();
        this._visibilityProperty = (0, j.combineProperty)((e, t, i, s) => `${e}:${t}:${i}:${s}`, i.showBarChange.weakReference(), i.showSeriesOHLC.weakReference(), i.showVolume.weakReference(), i.showLastDayChange.weakReference());
        this._visibilityProperty.subscribe(this, this.update);
      }
      areValuesVisible() {
        return this._visibilityProperty.value().includes("true");
      }
      additional() {
        return null;
      }
      marketTitle() {
        const e = this._series.marketStatusModel().status().value();
        if (this._showLastPriceAndChangeOnly() && (e === "pre_market" || e === "post_market")) {
          return `${G}:`;
        } else {
          return "";
        }
      }
      destroy() {
        this._backgroundColorSpawn.destroy();
        this._visibilityProperty.destroy();
      }
      _getValuesProvider() {
        return this._series.legendValuesProvider();
      }
    }
    var $;
    var K = i(90823);
    var Y = i(50788);
    var Z = i(85049);
    var X = i(14381);
    var J = i(40644);
    var Q = i(92184);
    (function (e) {
      e[e.ExtrapolateBarsLimit = 2000] = "ExtrapolateBarsLimit";
    })($ ||= {});
    let ee = 0;
    class te {
      constructor(e, t) {
        this._extrapolatedData = [];
        this._cacheForFuture = false;
        this._modelId = ee++;
        this._builderCache = null;
        this._uniqueId = (0, Q.randomHashN)(6);
        this._resolution = t;
        this._symbolInfo = e;
        this._valid = Boolean(e.timezone) && Boolean(e.session);
        this._session = new X.SessionInfo(e.timezone, e.session, e.session_holidays, e.corrections);
      }
      syncSourceTarget() {
        return {
          uniqueId: this._uniqueId,
          resolution: this._resolution,
          session: this._session.state()
        };
      }
      getSymbolInfo() {
        return this._symbolInfo;
      }
      getSession() {
        return this._session;
      }
      getResolution() {
        return this._resolution;
      }
      uniqueId() {
        return this._modelId;
      }
      distance(e, t) {
        if (!this.isValid()) {
          return {
            success: false
          };
        }
        if (e > t) {
          return {
            success: false
          };
        }
        if (e === t) {
          return {
            success: true,
            result: 0
          };
        }
        let i = this._extrapolatedData.length;
        let s = i !== 0 ? this._extrapolatedData[0] : null;
        let o = s !== null ? this._extrapolatedData[i - 1] : null;
        const n = e < t;
        if (e * 1000 !== s || this._cacheForFuture !== n) {
          this._extrapolatedData = [e * 1000];
          i = 1;
          s = null;
          o = null;
        }
        if (s === null || o !== null && t * 1000 > o) {
          const s = (0, J.extrapolateBarsFrontToTime)(this.barBuilder(), o || e * 1000, t * 1000, 2000, true);
          this._extrapolatedData = this._extrapolatedData.concat(s.times);
          i = this._extrapolatedData.length;
          this._cacheForFuture = n;
        }
        o = this._extrapolatedData[i - 1];
        if (o < t * 1000) {
          return {
            success: false
          };
        }
        const r = this._extrapolatedData.indexOf(t * 1000);
        if (r === -1) {
          return {
            success: false
          };
        } else {
          return {
            success: true,
            result: r
          };
        }
      }
      projectTime(e, t) {
        if (!this.isValid()) {
          return e;
        }
        let i = this._extrapolatedData.length;
        let s = i > 0 ? this._extrapolatedData[0] : null;
        let o = s !== null ? this._extrapolatedData[i - 1] : null;
        const n = t >= 0;
        if (e * 1000 !== s || this._cacheForFuture !== n) {
          this._extrapolatedData = [e * 1000];
          i = 1;
          s = null;
          o = null;
        }
        const r = Math.abs(t);
        if (s === null || r >= i) {
          const s = (0, J.extrapolateBarsFrontByCount)(this.barBuilder(), o || e * 1000, Math.sign(t) * (r - i + 1), true);
          this._extrapolatedData = this._extrapolatedData.concat(s.times);
          i = this._extrapolatedData.length;
          this._cacheForFuture = n;
        }
        if (i < r) {
          return e;
        } else {
          return this._extrapolatedData[r] / 1000;
        }
      }
      isValid() {
        return this._valid;
      }
      dataSize() {
        return this._extrapolatedData.length;
      }
      createNewModelWithResolution(e) {
        return new te(this._symbolInfo, e);
      }
      barBuilder() {
        if (this._builderCache === null) {
          this._builderCache = (0, X.newBarBuilder)(this._resolution, this._session, this._session);
        }
        return this._builderCache;
      }
    }
    var ie = i(91676);
    var se = i(22118);
    i(13665);
    (0, r.getLogger)("Chart.Definitions.Series");
    function oe(e, t) {
      if (e === "TickByTick") {
        return {
          mode: e,
          updatePeriod: t
        };
      } else {
        return {
          mode: e
        };
      }
    }
    async function ne(e, t, i) {
      const s = [];
      if ((0, se.isDelay)(e.delay)) {
        return async function (e) {
          const t = [];
          if ((0, se.witoutRealtime)(e)) {
            t.push(oe("DelayNoRealtime"));
          } else {
            t.push(oe("DelayToRealtime"));
          }
          return t;
        }(e);
      } else if ((0, se.isEod)(e, t)) {
        s.push(oe("EOD"));
        return s;
      } else {
        return s;
      }
    }
    class re {
      constructor(e, t, i) {
        this._dataUpdatedInfoStatus = new ie.WatchedObject(null);
        this._symbolInfo = e;
        this._status = t;
        this._updatePeriod = i;
        this._symbolInfo.subscribe(this._update.bind(this));
        this._status.subscribe(this._update.bind(this));
        this._updatePeriod.subscribe(this._update.bind(this));
      }
      destroy() {
        this._symbolInfo.release();
        this._status.release();
        this._updatePeriod.release();
      }
      status() {
        return this._dataUpdatedInfoStatus.readonly();
      }
      symbolName() {
        const e = this._symbolInfo.value();
        if (e !== null) {
          return e.name;
        } else {
          return "";
        }
      }
      time() {
        const e = this._symbolInfo.value();
        const t = e !== null && e.delay && e.delay > 0 ? e.delay : 900;
        return Math.round(t / 60);
      }
      listedExchange() {
        const e = this._symbolInfo.value();
        if (e !== null) {
          return e.listed_exchange;
        } else {
          return "";
        }
      }
      async description() {
        const e = this._symbolInfo.value();
        if (e === null) {
          return "";
        }
        return {}.description || e.listed_exchange;
      }
      exchange() {
        const e = this._symbolInfo.value();
        if (e !== null) {
          return e.exchange;
        } else {
          return "";
        }
      }
      proName() {
        const e = this._symbolInfo.value();
        if (e !== null) {
          return e.pro_name;
        } else {
          return "";
        }
      }
      country() {
        return this._symbolInfo.value()?.country || "";
      }
      proPerm() {
        const e = this._symbolInfo.value();
        if (e !== null) {
          return e.pro_perm;
        } else {
          return "";
        }
      }
      firstReplacedByBatsExchange() {
        const e = this._symbolInfo.value();
        return e && (0, se.firstReplacedByBatsExchange)(e);
      }
      isSpread() {
        const e = this._symbolInfo.value();
        return e !== null && e.type === "spread";
      }
      isDelay() {
        const e = this._symbolInfo.value();
        return Boolean(e?.delay);
      }
      async _update() {
        const e = this._symbolInfo.value();
        if (e === null) {
          this._dataUpdatedInfoStatus.setValue(null);
          return;
        }
        const t = this._status.value();
        if (typeof t == "string") {
          this._dataUpdatedInfoStatus.setValue(null);
          return;
        }
        if (t === 2 || t === 1) {
          return;
        }
        const i = await ne(e, t, this._updatePeriod.value());
        if (i.length !== 0) {
          this._dataUpdatedInfoStatus.setValue(i);
        } else {
          this._dataUpdatedInfoStatus.setValue(null);
        }
      }
    }
    i(84906);
    var ae = i(37265);
    (0, r.getLogger)("Chart.DataProblemModel");
    class le {
      constructor(e, t) {
        this._mainDataProblem = new ie.WatchedObject(null);
        this._supportPortalProblems = new ie.WatchedObject([]);
        this._allDataProblems = new ie.WatchedObject([]);
        this._pushStreamHandler = null;
        this._destroyed = false;
        this._quotesProvider = e;
        this._quotesProvider.quotesUpdate().subscribe(this, this._update.bind(this));
        this._symbolInfo = t;
        this._symbolInfo.subscribe(e => {
          if (!e) {
            this._mainDataProblem.setValue(null);
          }
        });
        this._mainDataProblem.subscribe(() => this._updateAllDataProblems());
        this._supportPortalProblems.subscribe(() => this._updateAllDataProblems());
        this._requestSupportPortalProblems();
      }
      destroy() {
        this._quotesProvider.quotesUpdate().unsubscribeAll(this);
        this._symbolInfo.release();
        this._destroyed = true;
      }
      dataProblems() {
        return this._allDataProblems;
      }
      _resetStatus() {
        this._mainDataProblem.setValue(null);
      }
      _update(e) {
        if (e.values === undefined || e.values.data_problem === undefined) {
          this._resetStatus();
        } else {
          this._mainDataProblem.setValue((0, ae.clone)(e.values.data_problem));
        }
      }
      _updateAllDataProblems() {
        const e = this._mainDataProblem.value();
        const t = this._supportPortalProblems.value();
        this._allDataProblems.setValue(e === null ? t : [e, ...t]);
      }
      async _requestSupportPortalProblems() {
        0;
      }
    }
    var ce = i(76742);
    var he = i(19063);
    var de = i(98558);
    var ue = i(94164);
    var _e = i(32956);
    var pe = i(49256);
    var me = i(44672);
    const ge = b.enabled("force_exchange_as_title");
    const fe = b.enabled("chart_style_hilo_last_price");
    const ye = {
      alwaysShowGlobalLast: false,
      visibleOnHistoryOnly: false,
      showCountdown: true,
      showSymbolLabel: true,
      useSolidBodyColor: true
    };
    class ve extends de.PriceAxisView {
      constructor(e, t, i) {
        super();
        this._previousCountdown = "";
        this._source = e;
        this._model = t;
        this._options = {
          ...ye,
          ...i
        };
      }
      updateCountdown() {
        if (this._countdownText() !== this._previousCountdown) {
          this.update((0, me.sourceChangeEvent)(this._source.id()));
          this._model.updateSourcePriceScale(this._source);
        }
      }
      _getSource() {
        return this._source;
      }
      _getModel() {
        return this._model;
      }
      _isCountdownEnabled() {
        return this._options.showCountdown;
      }
      _countdownText() {
        const e = Z.Interval.parse(this._source.interval());
        if (e.isDWM() || e.isTicks() || e.isSeconds() && e.multiplier() === 1) {
          return "";
        }
        const t = this._source.data().bars().last();
        if (t === null) {
          return "";
        }
        const i = (0, s.ensure)(t.value[0]) * 1000;
        const o = Z.Interval.parse(this._source.interval()).inMilliseconds();
        const n = i.valueOf() + o;
        let r = Math.round((n - this._currentTime()) / 1000);
        if (r <= 0) {
          return "";
        }
        r = Math.min(r, o / 1000);
        let a = null;
        if (r >= 3600) {
          a = (0, _e.addLeadingZero)(Math.floor(r / 3600));
        }
        r %= 3600;
        const l = (0, _e.addLeadingZero)(Math.floor(r / 60));
        r %= 60;
        const c = (0, _e.addLeadingZero)(Math.floor(r));
        if (a !== null) {
          return `${a}:${l}:${c}`;
        } else {
          return `${l}:${c}`;
        }
      }
      _updateRendererData(e, t, i) {
        e.visible = false;
        t.visible = false;
        if (!this._source.isVisible()) {
          return;
        }
        const o = this._source.properties().childs();
        if (!fe && o.style.value() === 12) {
          return;
        }
        const n = this._model.timeScale().visibleBarsStrictRange();
        const r = this._source.data().last();
        if (n === null || r === null) {
          return;
        }
        if (this._options.visibleOnHistoryOnly && n.contains(r.index)) {
          return;
        }
        const a = this._model.properties().childs().scalesProperties.childs();
        let l = a.showSeriesLastValue.value();
        let c = this._isCountdownEnabled() && o.showCountdown.value() && ((h = o.style.value()) === 12 ? fe : (0, m.isTimeBasedStyle)(h)) && (this._options.alwaysShowGlobalLast || n.contains(r.index));
        var h;
        let d = this._options.showSymbolLabel && a.showSymbolLabels.value();
        const u = a.seriesLastValueMode.value() === ue.PriceAxisLastValueMode.LastPriceAndPercentageValue;
        const _ = this._source.lastValueData(undefined, this._options.alwaysShowGlobalLast);
        if (_.noData) {
          return;
        }
        const p = o.style.value() === 8;
        if ((l || c || d) && p && o.haStyle.childs().showRealLastPrice.value()) {
          const e = this._source.lastValueData(undefined, false);
          const t = this._source.lastValueData(undefined, true);
          if (!e.noData && !t.noData && e.index === t.index) {
            l = false;
            c = false;
            d = false;
          }
        }
        const g = (0, he.resetTransparency)(this._source.priceLineColor(_.color));
        if (this._options.useSolidBodyColor) {
          i.background = g;
          i.borderColor = undefined;
        } else {
          i.background = this._model.backgroundColorAtYPercentFromTop((i.fixedCoordinate ?? i.coordinate) / (0, s.ensureNotNull)(this._model.paneForSource(this._source)).height());
          i.borderColor = g;
        }
        i.coordinate = _.coordinate;
        i.floatCoordinate = _.floatCoordinate;
        if (l || c) {
          const t = this._axisFirstLineText(_, l);
          e.text = t;
          if (this._options.useSolidBodyColor) {
            i.textColor = this.generateTextColor(i.background);
            e.borderVisible = false;
          } else {
            e.borderVisible = true;
            i.textColor = g;
          }
          e.textColor = i.textColor;
          const s = l && u ? (0, pe.getOppositeModePriceText)(this._source.priceScale(), _) : "";
          e.secondLine = s;
          i.secondLineTextColor = i.textColor;
          const o = c ? this._countdownText() : "";
          this._previousCountdown = o;
          e.thirdLine = o;
          i.thirdLineTextColor = (0, he.generateColor)(i.textColor, 25);
          if (t.length !== 0 || s.length !== 0 || o.length !== 0) {
            e.visible = true;
          }
        }
        if (d) {
          t.text = this._paneText(d);
          t.visible = t.text.length > 0;
        }
      }
      _paneText(e) {
        let t = "";
        const i = this._source.symbolInfo();
        if (ge) {
          t = (0, m.displayedSymbolExchange)(i);
        } else if (e) {
          t = (0, m.displayedSymbolName)(i);
        }
        return t;
      }
      _axisFirstLineText(e, t) {
        if (t) {
          return (0, pe.getCurrentModePriceText)(this._source.priceScale(), e);
        } else {
          return "";
        }
      }
      _currentTime() {
        return window.ChartApiInstance.serverTime();
      }
    }
    var Se = i(18112);
    var be = i(39772);
    var we = i(37626);
    class Ce extends ve {
      lastPrice() {
        return this._getSource().data().lastProjectionPrice;
      }
      _updateRendererData(e, t, i) {
        e.visible = false;
        t.visible = false;
        const o = this._getModel();
        const n = this._getSource();
        const r = n.priceScale();
        const a = o.timeScale();
        const l = this.lastPrice();
        if (a.isEmpty() || r.isEmpty() || l === undefined) {
          return;
        }
        const c = a.visibleBarsStrictRange();
        if (c === null) {
          return;
        }
        const h = c.firstBar();
        const d = c.lastBar();
        const _ = n.data();
        const p = _.search(d, u.PlotRowSearchMode.NearestLeft);
        if (p === null) {
          return;
        }
        const m = n.nearestIndex(h, u.PlotRowSearchMode.NearestRight);
        if (m === undefined) {
          return;
        }
        const g = n.model().properties().childs().scalesProperties.childs();
        const f = (0, s.ensureNotNull)(_.valueAt(m))[4];
        let y = i.background;
        let v = g.showSeriesLastValue.value();
        let S = false;
        let b = false;
        let w = false;
        const C = n.lastValueData(4, false);
        const P = n.properties().childs();
        if (P.style.value() === 8 && P.haStyle.childs().showRealLastPrice.value()) {
          const e = n.lastValueData(4, true);
          if (!e.noData && e.color !== i.background) {
            y = (0, he.resetTransparency)(e.color);
          }
          if (!e.noData && !C.noData) {
            const t = e.index === C.index;
            S = t && g.showSymbolLabels.value();
            b = g.seriesLastValueMode.value() === ue.PriceAxisLastValueMode.LastPriceAndPercentageValue;
            v = v && t;
            w = t && this._isCountdownEnabled() && P.showCountdown.value();
          }
        } else {
          const e = n.barColorer().barStyle(p.index, true);
          y = (0, he.resetTransparency)(e.barColor);
        }
        i.background = y;
        i.textColor = this.generateTextColor(y);
        i.secondLineTextColor = i.textColor;
        i.thirdLineTextColor = (0, he.generateColor)(i.textColor, 25);
        i.coordinate = r.priceToCoordinate(l, f);
        e.visible = v || w;
        if (!C.noData) {
          const i = n.priceScale().isPercentage();
          C.formattedPriceAbsolute = r.formatPriceAbsolute(l);
          C.formattedPricePercentage = r.formatPricePercentage(l, f, {
            signPositive: true
          });
          C.text = i ? C.formattedPricePercentage : C.formattedPriceAbsolute;
          e.text = this._axisFirstLineText(C, v);
          e.secondLine = v && b ? i ? C.formattedPriceAbsolute : C.formattedPricePercentage : "";
          e.thirdLine = w ? this._countdownText() : "";
          t.text = this._paneText(S);
        }
        t.visible = S;
      }
    }
    var Pe = i(65458);
    var Te = i(52397);
    var xe = i(19625);
    var Ie = i(51056);
    const Me = {
      light: {
        lineStyle: Ie.LINESTYLE_DOTTED,
        lineWidth: 1,
        backgroundColor: xe.colorsPalette["color-tv-blue-50"],
        lineColor: xe.colorsPalette["color-cold-gray-500"]
      },
      dark: {
        lineStyle: Ie.LINESTYLE_DOTTED,
        lineWidth: 1,
        backgroundColor: xe.colorsPalette["color-tv-blue-a800"],
        lineColor: xe.colorsPalette["color-cold-gray-500"]
      }
    };
    function Ae(e) {
      if (e) {
        return Me.dark;
      } else {
        return Me.light;
      }
    }
    class Le extends Te.HorizontalLinePaneView {
      constructor(e, t, i) {
        super();
        this._model = e;
        this._isVisible = t.lineVisible;
        this._lineColor = t.lineColor;
        this._lineWidth = t.lineWidth;
        this._getValue = i;
      }
      _updateImpl() {
        const e = this._lineRendererData;
        e.visible = false;
        if (!this._isVisible.value()) {
          return;
        }
        const t = this._model.mainSeries();
        const i = t.priceScale();
        const s = t.firstValue();
        const o = this._getValue();
        if (s === null || o === null) {
          return;
        }
        const n = Ae(this._model.dark().value());
        const r = this._lineColor.value() || n.lineColor;
        const a = this._lineWidth.value() || n.lineWidth;
        e.visible = true;
        e.y = i.priceToCoordinate(o, s);
        e.linestyle = n.lineStyle;
        e.linewidth = a;
        e.color = r;
      }
    }
    class ke extends de.PriceAxisView {
      constructor(e, t, i, s) {
        super();
        this._model = e;
        this._label = t;
        this._isVisible = i.labelVisible;
        this._backgroundColor = i.lineColor;
        this._getValue = s;
      }
      _updateRendererData(e, t, i) {
        e.visible = false;
        t.visible = false;
        if (!this._isVisible.value()) {
          return;
        }
        const s = this._model.mainSeries();
        const o = s.priceScale();
        const n = s.firstValue();
        const r = this._getValue();
        if (n === null || r === null) {
          return;
        }
        const a = Ae(this._model.dark().value());
        const l = (0, he.resetTransparency)(this._backgroundColor.value() || a.backgroundColor);
        e.visible = true;
        t.visible = true;
        e.text = o.formatPriceAbsolute(r);
        t.text = this._label;
        i.coordinate = o.priceToCoordinate(r, n);
        i.background = l;
        i.textColor = this.generateTextColor(l);
      }
    }
    class De extends we.PriceLineAxisView {
      constructor(e, t, i) {
        super();
        this._model = e;
        this._isLineVisible = t;
        this._getValue = i;
      }
      _isVisible() {
        return this._isLineVisible.value();
      }
      _lineWidth() {
        return Ae(this._model.dark().value()).lineWidth;
      }
      _lineStyle() {
        return Ae(this._model.dark().value()).lineStyle;
      }
      _priceLineColor(e) {
        return Ae(this._model.dark().value()).lineColor;
      }
      _value() {
        const e = this._model.mainSeries();
        const t = e.priceScale();
        const i = e.firstValue();
        const s = this._getValue();
        if (i === null || s === null) {
          return {
            noData: true
          };
        }
        const o = t.priceToCoordinate(s, i);
        return {
          noData: false,
          floatCoordinate: o,
          coordinate: o,
          color: "",
          formattedPricePercentage: "",
          formattedPriceAbsolute: "",
          formattedPriceIndexedTo100: "",
          text: "",
          index: 0
        };
      }
    }
    var Ee;
    (function (e) {
      e[e.High = 0] = "High";
      e[e.Low = 1] = "Low";
    })(Ee ||= {});
    const Be = S.t(null, undefined, i(78254));
    const Ve = S.t(null, undefined, i(65318));
    function Re(e, t, i, s) {
      const o = new Le(e, i, s);
      const n = new ke(e, i.label, i, s);
      return {
        paneView: o,
        panePriceAxisView: new Pe.PanePriceAxisView(n, t, e),
        priceAxisView: n,
        priceLineAxisView: new De(e, i.lineVisible, s)
      };
    }
    const Ne = {
      light: {
        lineStyle: Ie.LINESTYLE_DOTTED,
        lineWidth: 1,
        textColor: (0, xe.getHexColorByName)("color-cold-gray-900"),
        backgroundColor: (0, xe.getHexColorByName)("color-tv-blue-50"),
        lineColor: (0, xe.getHexColorByName)("color-cold-gray-500")
      },
      dark: {
        lineStyle: Ie.LINESTYLE_DOTTED,
        lineWidth: 1,
        textColor: (0, xe.getHexColorByName)("color-white"),
        backgroundColor: (0, xe.getHexColorByName)("color-tv-blue-a800"),
        lineColor: (0, xe.getHexColorByName)("color-cold-gray-500")
      }
    };
    function Oe(e) {
      if (e) {
        return Ne.dark;
      } else {
        return Ne.light;
      }
    }
    class Fe extends Te.HorizontalLinePaneView {
      constructor(e, t, i) {
        super();
        this._model = e;
        this._isVisible = t.lineVisible;
        this._lineColor = t.lineColor;
        this._lineWidth = t.lineWidth;
        this._getValue = i;
      }
      _updateImpl() {
        const e = this._lineRendererData;
        e.visible = false;
        if (!this._isVisible.value()) {
          return;
        }
        const t = this._model.mainSeries();
        const i = t.priceScale();
        const s = t.firstValue();
        const o = this._getValue();
        if (s === null || o === null) {
          return;
        }
        const n = Oe(this._model.dark().value());
        const r = this._lineColor.value() ? this._lineColor.value() : n.lineColor;
        const a = this._lineWidth.value() ? this._lineWidth.value() : n.lineWidth;
        e.visible = true;
        e.y = i.priceToCoordinate(o, s);
        e.linestyle = n.lineStyle;
        e.linewidth = a;
        e.color = r;
      }
    }
    class We extends de.PriceAxisView {
      constructor(e, t, i, s) {
        super();
        this._model = e;
        this._label = t;
        this._isVisible = i;
        this._getValue = s;
      }
      _updateRendererData(e, t, i) {
        e.visible = false;
        t.visible = false;
        if (!this._isVisible.value()) {
          return;
        }
        const s = this._model.mainSeries();
        const o = s.priceScale();
        const n = s.firstValue();
        const r = this._getValue();
        if (n === null || r === null) {
          return;
        }
        const a = Oe(this._model.dark().value());
        e.visible = true;
        t.visible = true;
        e.text = o.formatPriceAbsolute(r);
        t.text = this._label;
        i.coordinate = o.priceToCoordinate(r, n);
        i.background = a.backgroundColor;
        i.textColor = a.textColor;
      }
    }
    class He extends we.PriceLineAxisView {
      constructor(e, t, i) {
        super();
        this._model = e;
        this._isLineVisible = t;
        this._getValue = i;
      }
      _isVisible() {
        return this._isLineVisible.value();
      }
      _lineWidth() {
        return Oe(this._model.dark().value()).lineWidth;
      }
      _lineStyle() {
        return Oe(this._model.dark().value()).lineStyle;
      }
      _priceLineColor(e) {
        return Oe(this._model.dark().value()).lineColor;
      }
      _value() {
        const e = this._model.mainSeries();
        const t = e.priceScale();
        const i = e.firstValue();
        const s = this._getValue();
        if (i === null || s === null) {
          return {
            noData: true
          };
        }
        const o = t.priceToCoordinate(s, i);
        return {
          noData: false,
          floatCoordinate: o,
          coordinate: o,
          color: "",
          formattedPricePercentage: "",
          formattedPriceAbsolute: "",
          formattedPriceIndexedTo100: "",
          text: "",
          index: 0
        };
      }
    }
    var ze;
    (function (e) {
      e[e.Avg = 0] = "Avg";
    })(ze ||= {});
    const Ue = S.t(null, undefined, i(73025));
    function je(e, t, i, s) {
      const o = i.childs();
      const n = function (e, t, i, s) {
        const o = new Fe(e, i, s);
        const n = new We(e, i.label, i.labelVisible, s);
        const r = new Pe.PanePriceAxisView(n, t, e);
        const a = new He(e, i.lineVisible, s);
        return {
          paneView: o,
          panePriceAxisView: r,
          priceAxisView: n,
          priceLineAxisView: a
        };
      }(e, t, {
        label: Ue,
        labelVisible: o.averageClosePriceLabelVisible,
        lineVisible: o.averageClosePriceLineVisible,
        lineColor: o.averagePriceLineColor,
        lineWidth: o.averagePriceLineWidth
      }, () => s(0));
      return {
        paneViews: [n.paneView],
        panePriceAxisViews: [n.panePriceAxisView],
        priceAxisViews: [n.priceAxisView],
        priceLineAxisViews: [n.priceLineAxisView]
      };
    }
    var Ge = i(76748);
    const qe = {
      open: S.t(null, {
        context: "in_legend"
      }, i(46728)),
      high: S.t(null, {
        context: "in_legend"
      }, i(43253)),
      low: S.t(null, {
        context: "in_legend"
      }, i(89923)),
      close: S.t(null, {
        context: "in_legend"
      }, i(2696)),
      hl2: S.t(null, {
        context: "in_legend"
      }, i(61372)),
      hlc3: S.t(null, {
        context: "in_legend"
      }, i(55096)),
      ohlc4: S.t(null, {
        context: "in_legend"
      }, i(94174))
    };
    class $e extends Ge.SeriesValuesProvider {
      constructor(e, t) {
        super(e, t);
        const i = t.properties().childs().paneProperties.childs().legendProperties.childs();
        this._showBarChange = i.showBarChange;
        this._showLastDayChange = i.showLastDayChange;
        this._showSeriesOHLC = i.showSeriesOHLC;
        this._showVolume = i.showVolume;
        this._seriesStyle = e.properties().childs().style;
        const s = this._emptyValues[0];
        const o = this._emptyValues[1];
        const n = this._emptyValues[2];
        s.title = qe.open;
        o.title = qe.high;
        n.title = qe.low;
        s.unimportant = true;
        o.unimportant = true;
        n.unimportant = true;
        this._emptyValues[6].title = "";
        this._emptyValues[8].title = "";
        this._emptyValues[4].title = "";
      }
      getValues(e) {
        const t = super.getValues(e);
        const i = this._series.style();
        const s = i !== 12;
        const o = this._showSeriesOHLC.value();
        const n = s && this._showBarChange.value();
        const r = s && this._showLastDayChange.value();
        if (this._showLastPriceAndChangeOnly()) {
          const e = t[5];
          e.visible = e.visible && o;
          t[6].visible &&= n;
          t[8].visible = false;
          return t;
        }
        const a = i !== 12 && i !== 16 && i !== 21;
        const l = i !== 12;
        const c = this._series.intervalObj().is1Tick();
        const h = t[7];
        h.visible = h.visible && this._showVolume.value();
        const d = (0, m.isPriceSourceStyle)(this._seriesStyle.value());
        const u = o && !d;
        const _ = o && d;
        t[0].visible = u && a && !c;
        t[1].visible = u && !c;
        t[2].visible = u && !c;
        t[3].visible = u && l;
        t[3].title = c ? "" : qe.close;
        t[4].visible = _;
        t[6].visible &&= n;
        t[8].visible &&= r;
        if (i === 16) {
          const e = this._series.properties().childs().hlcAreaStyle.childs();
          t[1].color = e.highLineColor.value();
          t[2].color = e.lowLineColor.value();
          t[3].color = e.closeLineColor.value();
        }
        return t;
      }
    }
    var Ke;
    var Ye = i(52033);
    var Ze = i(76350);
    var Xe = i(73698);
    var Je = i(86441);
    class Qe {
      constructor() {
        this._data = null;
      }
      setData(e) {
        this._data = e;
      }
      data() {
        return this._data;
      }
      draw(e, t) {
        const i = this._data;
        if (i === null) {
          return;
        }
        const {
          horizontalPixelRatio: s,
          verticalPixelRatio: o
        } = t;
        e.save();
        const n = Math.max(1, Math.floor(s));
        const r = n % 2 / 2;
        const a = Math.round(i.center.x * s) + r;
        const l = i.center.y * o;
        e.fillStyle = i.seriesLineColor;
        e.beginPath();
        const c = Math.max(2, i.seriesLineWidth * 1.5) * s;
        e.arc(a, l, c, 0, Math.PI * 2, false);
        e.fill();
        e.fillStyle = i.fillColor;
        e.beginPath();
        e.arc(a, l, i.radius * s, 0, Math.PI * 2, false);
        e.fill();
        e.lineWidth = n;
        e.strokeStyle = i.strokeColor;
        e.beginPath();
        e.arc(a, l, i.radius * s + n / 2, 0, Math.PI * 2, false);
        e.stroke();
        e.restore();
      }
      hitTest(e) {
        return null;
      }
    }
    function et(e) {
      return e;
    }
    (function (e) {
      e[e.AnimationPeriod = 2600] = "AnimationPeriod";
      e[e.Stage1Period = 0.25] = "Stage1Period";
      e[e.Stage2Period = 0.275] = "Stage2Period";
      e[e.Stage3Period = 0.475] = "Stage3Period";
      e[e.Stage1StartCircleRadius = 4] = "Stage1StartCircleRadius";
      e[e.Stage1EndCircleRadius = 10] = "Stage1EndCircleRadius";
      e[e.Stage1StartFillAlpha = 0.25] = "Stage1StartFillAlpha";
      e[e.Stage1EndFillAlpha = 0] = "Stage1EndFillAlpha";
      e[e.Stage1StartStrokeAlpha = 0.4] = "Stage1StartStrokeAlpha";
      e[e.Stage1EndStrokeAlpha = 0.8] = "Stage1EndStrokeAlpha";
      e[e.Stage2StartCircleRadius = 10] = "Stage2StartCircleRadius";
      e[e.Stage2EndCircleRadius = 14] = "Stage2EndCircleRadius";
      e[e.Stage2StartFillAlpha = 0] = "Stage2StartFillAlpha";
      e[e.Stage2EndFillAlpha = 0] = "Stage2EndFillAlpha";
      e[e.Stage2StartStrokeAlpha = 0.8] = "Stage2StartStrokeAlpha";
      e[e.Stage2EndStrokeAlpha = 0] = "Stage2EndStrokeAlpha";
      e[e.Stage3StartCircleRadius = 14] = "Stage3StartCircleRadius";
      e[e.Stage3EndCircleRadius = 14] = "Stage3EndCircleRadius";
      e[e.Stage3StartFillAlpha = 0] = "Stage3StartFillAlpha";
      e[e.Stage3EndFillAlpha = 0] = "Stage3EndFillAlpha";
      e[e.Stage3StartStrokeAlpha = 0] = "Stage3StartStrokeAlpha";
      e[e.Stage3EndStrokeAlpha = 0] = "Stage3EndStrokeAlpha";
    })(Ke ||= {});
    const tt = [{
      start: 0,
      end: 0.25,
      startRadius: 4,
      endRadius: 10,
      startFillAlpha: 0.25,
      endFillAlpha: 0,
      startStrokeAlpha: 0.4,
      endStrokeAlpha: 0.8,
      easing: et
    }, {
      start: 0.25,
      end: 0.525,
      startRadius: 10,
      endRadius: 14,
      startFillAlpha: 0,
      endFillAlpha: 0,
      startStrokeAlpha: 0.8,
      endStrokeAlpha: 0,
      easing: et
    }, {
      start: 0.525,
      end: 1,
      startRadius: 14,
      endRadius: 14,
      startFillAlpha: 0,
      endFillAlpha: 0,
      startStrokeAlpha: 0,
      endStrokeAlpha: 0,
      easing: et
    }];
    function it(e, t, i, s) {
      const o = i + (s - i) * t;
      return (0, he.applyTransparency)(e, (0, he.alphaToTransparency)(o));
    }
    const st = (0, xe.getHexColorByName)("color-minty-green-400");
    const ot = (0, xe.getHexColorByName)("color-ripe-red-500");
    function nt(e, t, i) {
      const s = e % 2600 / 2600;
      let o;
      for (const e of tt) {
        if (s >= e.start && s <= e.end) {
          o = e;
          break;
        }
      }
      if (o === undefined) {
        throw new Error("Last price animation internal logic error");
      }
      const n = o.easing((s - o.start) / (o.end - o.start));
      return {
        fillColor: it(i, n, o.startFillAlpha, o.endFillAlpha),
        strokeColor: it(i, n, o.startStrokeAlpha, o.endStrokeAlpha),
        radius: (r = n, a = o.startRadius, l = o.endRadius, a + (l - a) * r)
      };
      var r;
      var a;
      var l;
    }
    class rt {
      constructor(e) {
        this._renderer = new Qe();
        this._invalidated = true;
        this._stageInvalidated = true;
        this._startTime = performance.now();
        this._endTime = this._startTime - 1;
        this._prevRenderedPrice = null;
        this._series = e;
      }
      update(e) {
        this._invalidated = true;
        if (e.type === "data-source-change" && e.sourceId === this._series.id() && e.realtime && this._series.seriesLoaded()) {
          const e = performance.now();
          const t = this._endTime - e;
          if (t > 0) {
            if (t < 650) {
              this._endTime += 2600;
            }
            return;
          }
          this._startTime = e;
          this._endTime = e + 2600;
        }
      }
      invalidateStage() {
        this._stageInvalidated = true;
      }
      animationActive() {
        return performance.now() <= this._endTime;
      }
      stopAnimation() {
        this._endTime = this._startTime - 1;
      }
      renderer(e) {
        if (this._invalidated) {
          this._updateImpl(e);
          this._invalidated = false;
          this._stageInvalidated = false;
        } else if (this._stageInvalidated) {
          this._updateRendererDataStage();
          this._stageInvalidated = false;
        }
        return this._renderer;
      }
      _updateImpl(e) {
        this._renderer.setData(null);
        const t = this._series.model().timeScale();
        const i = t.visibleBarsStrictRange();
        const s = this._series.firstValue();
        const o = this._series.lastValueData(undefined, true, true);
        if (i === null || s === null || o.index === undefined || o.price === undefined || !i.contains(o.index)) {
          return;
        }
        const n = new Je.Point(t.indexToCoordinate(o.index), this._series.priceScale().priceToCoordinate(o.price, s));
        const r = o.color;
        const a = this._series.properties().childs();
        let l;
        switch (this._series.style()) {
          case 3:
            l = a.areaStyle.childs().linewidth.value();
            break;
          case 10:
            const t = a.baselineStyle;
            const i = Math.round(e.mediaSize.height * (Math.abs(100 - t.childs().baseLevelPercentage.value()) / 100));
            l = n.y <= i ? t.childs().topLineWidth.value() : t.childs().bottomLineWidth.value();
            break;
          case 14:
            l = a.lineWithMarkersStyle.childs().linewidth.value();
            break;
          case 15:
            l = a.steplineStyle.childs().linewidth.value();
            break;
          default:
            l = a.lineStyle.childs().linewidth.value();
        }
        this._lastBaseColor = this._prevRenderedPrice === null || this._prevRenderedPrice === o.price ? r : this._prevRenderedPrice < o.price ? st : ot;
        const c = nt(this._duration(), 0, this._lastBaseColor);
        this._renderer.setData({
          seriesLineColor: r,
          seriesLineWidth: l,
          fillColor: c.fillColor,
          strokeColor: c.strokeColor,
          radius: c.radius,
          center: n
        });
        this._prevRenderedPrice = o.price;
      }
      _updateRendererDataStage() {
        const e = this._renderer.data();
        if (e !== null) {
          const t = nt(this._duration(), e.seriesLineColor, this._lastBaseColor);
          e.fillColor = t.fillColor;
          e.strokeColor = t.strokeColor;
          e.radius = t.radius;
        }
      }
      _duration() {
        if (this.animationActive()) {
          return performance.now() - this._startTime;
        } else {
          return 2599;
        }
      }
    }
    var at = i(62288);
    var lt = i(64147);
    var ct = i(18172);
    var ht = i(4340);
    class dt {
      constructor() {
        this._created = new Ye.Delegate();
        this._modified = new Ye.Delegate();
        this._loading = new Ye.Delegate();
        this._completed = new Ye.Delegate();
        this._error = new Ye.Delegate();
        this._symbolError = new Ye.Delegate();
        this._symbolResolved = new Ye.Delegate();
        this._seriesError = new Ye.Delegate();
        this._symbolNotPermitted = new Ye.Delegate();
        this._symbolInvalid = new Ye.Delegate();
        this._symbolGroupNotPermitted = new Ye.Delegate();
        this._chartTypeNotPermitted = new Ye.Delegate();
        this._intradaySpreadNotPermitted = new Ye.Delegate();
        this._intradayExchangeNotPermitted = new Ye.Delegate();
        this._customIntervalNotPermitted = new Ye.Delegate();
        this._secondsIntervalNotPermitted = new Ye.Delegate();
        this._ticksIntervalNotPermitted = new Ye.Delegate();
        this._barReceived = new Ye.Delegate();
        this._seriesTimeFrame = new Ye.Delegate();
        this._dataUpdated = new Ye.Delegate();
        this._unsupportedResolutionRequested = new Ye.Delegate();
      }
      destroy() {
        this._created.destroy();
        this._modified.destroy();
        this._loading.destroy();
        this._completed.destroy();
        this._error.destroy();
        this._symbolError.destroy();
        this._symbolResolved.destroy();
        this._seriesError.destroy();
        this._symbolInvalid.destroy();
        this._symbolNotPermitted.destroy();
        this._symbolGroupNotPermitted.destroy();
        this._chartTypeNotPermitted.destroy();
        this._intradaySpreadNotPermitted.destroy();
        this._intradayExchangeNotPermitted.destroy();
        this._customIntervalNotPermitted.destroy();
        this._secondsIntervalNotPermitted.destroy();
        this._ticksIntervalNotPermitted.destroy();
        this._barReceived.destroy();
        this._seriesTimeFrame.destroy();
        this._dataUpdated.destroy();
        this._unsupportedResolutionRequested.destroy();
      }
      created() {
        return this._created;
      }
      modified() {
        return this._modified;
      }
      loading() {
        return this._loading;
      }
      completed() {
        return this._completed;
      }
      error() {
        return this._error;
      }
      symbolError() {
        return this._symbolError;
      }
      symbolResolved() {
        return this._symbolResolved;
      }
      seriesError() {
        return this._seriesError;
      }
      symbolInvalid() {
        return this._symbolInvalid;
      }
      symbolNotPermitted() {
        return this._symbolNotPermitted;
      }
      symbolGroupNotPermitted() {
        return this._symbolGroupNotPermitted;
      }
      chartTypeNotPermitted() {
        return this._chartTypeNotPermitted;
      }
      intradaySpreadNotPermitted() {
        return this._intradaySpreadNotPermitted;
      }
      intradayExchangeNotPermitted() {
        return this._intradayExchangeNotPermitted;
      }
      customIntervalNotPermitted() {
        return this._customIntervalNotPermitted;
      }
      secondsIntervalNotPermitted() {
        return this._secondsIntervalNotPermitted;
      }
      ticksIntervalNotPermitted() {
        return this._ticksIntervalNotPermitted;
      }
      barReceived() {
        return this._barReceived;
      }
      seriesTimeFrame() {
        return this._seriesTimeFrame;
      }
      dataUpdated() {
        return this._dataUpdated;
      }
      unsupportedResolutionRequested() {
        return this._unsupportedResolutionRequested;
      }
      fireCompleted(e) {
        this._completed.fire(e);
      }
      fireCreated(e) {
        this._created.fire(e);
      }
      fireModified() {
        this._modified.fire();
      }
      fireLoading(e) {
        this._loading.fire(e);
      }
      fireError() {
        this._error.fire();
      }
      fireSymbolError(e) {
        this._symbolError.fire(e);
        this.fireError();
      }
      fireSymbolResolved(e) {
        this._symbolResolved.fire(e);
      }
      fireSeriesError(e) {
        this._seriesError.fire(e);
        this.fireError();
      }
      fireSymbolInvalid() {
        this._symbolInvalid.fire();
      }
      fireSymbolNotPermitted(e) {
        this._symbolNotPermitted.fire(e);
      }
      fireSymbolGroupNotPermitted(e) {
        this._symbolGroupNotPermitted.fire(e);
      }
      fireChartTypeNotPermitted(e) {
        this._chartTypeNotPermitted.fire(e);
        this.fireError();
      }
      fireIntradaySpreadNotPermitted() {
        this._intradaySpreadNotPermitted.fire();
        this.fireError();
      }
      fireIntradayExchangeNotPermitted() {
        this._intradayExchangeNotPermitted.fire();
        this.fireError();
      }
      fireCustomIntervalNotPermitted(e) {
        this._customIntervalNotPermitted.fire(e);
        this.fireError();
      }
      fireSecondsIntervalNotPermitted() {
        this._secondsIntervalNotPermitted.fire();
        this.fireError();
      }
      fireTicksIntervalNotPermitted() {
        this._ticksIntervalNotPermitted.fire();
        this.fireError();
      }
      fireBarReceived(e) {
        this._barReceived.fire(e);
      }
      fireSeriesTimeFrame(e, t, i, s, o) {
        this._seriesTimeFrame.fire(e, t, i, s, o);
      }
      fireDataUpdated(e, t, i, s) {
        this._dataUpdated.fire(e, t, i, s);
      }
      fireUnsupportedResolutionRequested() {
        this._unsupportedResolutionRequested.fire();
      }
    }
    var ut = i(52270);
    const _t = (0, r.getLogger)("Chart.SeriesDataSource");
    var pt;
    (function (e) {
      e[e.Idle = 0] = "Idle";
      e[e.AwaitingConnection = 1] = "AwaitingConnection";
      e[e.AwaitingFirstDataUpdate = 2] = "AwaitingFirstDataUpdate";
      e[e.Active = 3] = "Active";
    })(pt ||= {});
    let mt = 1;
    let gt = 1;
    function ft(e) {
      if (e.startDate) {
        if (e.endDate || e.count) {
          if (e.endDate) {
            return ["from_to", e.startDate, e.endDate];
          } else {
            return ["bar_count", e.startDate, (0, s.ensure)(e.count)];
          }
        } else {
          return ["from_to", e.startDate];
        }
      } else {
        return e.count || 300;
      }
    }
    function yt(e) {
      if ((0, ae.isString)(e.symbol)) {
        return e.symbol;
      } else {
        return e.symbol.symbol;
      }
    }
    function vt(e, t) {
      if ((0, ae.isString)(e.symbol)) {
        e.symbol = t;
      } else {
        e.symbol.symbol = t;
      }
    }
    class St {
      constructor(e, t, i, s) {
        this._extSymbol = null;
        this._lastResolvedSymbol = "";
        this._createSeriesOverriddenParams = 0;
        this._instanceId = null;
        this._symbolInstanceId = null;
        this._resolution = null;
        this._timeFrame = null;
        this._data = new h.SeriesData();
        this._dataEvents = new dt();
        this._status = pt.Idle;
        this._turnaroundCounter = 1;
        this._boundOnGatewayIsConnectedChanged = this._onGatewayIsConnectedChanged.bind(this);
        this._ongoingDataUpdate = Promise.resolve();
        this._gateway = e;
        this._turnaroundPrefix = t;
        this._createSeriesParams = ft(i ?? {
          count: 300
        });
        this._timeFrame = s || null;
        this._gateway.isConnected().subscribe(this._boundOnGatewayIsConnectedChanged);
      }
      destroy() {
        this.stop();
        this._gateway.isConnected().unsubscribe(this._boundOnGatewayIsConnectedChanged);
        this._dataEvents.destroy();
      }
      modifySeries(e, t, i = null, o = false, n = null) {
        if (o) {
          _t.logNormal("Due to force flag clearing symbol & resolution to force re-requesting data.");
          this._extSymbol = null;
          this._resolution = null;
        }
        const r = yt(e);
        const a = !this.symbolSameAsResolved(r);
        if (a) {
          this._lastResolvedSymbol = "";
        }
        if (this._extSymbol && !a) {
          vt(e, yt(this._extSymbol));
        }
        const l = this._extSymbol;
        const c = this._resolution;
        this._extSymbol = e;
        this._resolution = t;
        if (this._instanceId === null) {
          this._timeFrame = i;
          return;
        }
        const h = !(0, ae.deepEquals)(l, e)[0];
        if (h) {
          vt(this._extSymbol, r);
        }
        const d = c === null || !Z.Interval.isEqual(c, t);
        if (h || d || i !== null) {
          this._timeFrame = null;
          if (h || d) {
            this._turnaroundCounter++;
          }
          if (h) {
            this._resolveSymbol();
          }
          this._gateway.modifySeries(this._instanceId, this.turnaround(), (0, s.ensureNotNull)(this._symbolInstanceId), this._resolution, n, i, this._onMessage.bind(this));
          this._dataEvents.fireModified();
        }
      }
      requestMoreData(e) {
        if (this._instanceId !== null) {
          this._gateway.requestMoreData(this._instanceId, e, this._onMessage.bind(this));
        }
      }
      requestMoreTickmarks(e) {
        if (this._instanceId !== null) {
          this._gateway.requestMoreTickmarks(this._instanceId, e, this._onMessage.bind(this));
        }
      }
      setFutureTickmarksMode(e) {
        if (this._instanceId !== null) {
          this._gateway.setFutureTickmarksMode(e);
        }
      }
      isStarted() {
        return this._status !== pt.Idle;
      }
      isActive() {
        return this._status === pt.Active;
      }
      resolution() {
        return this._resolution;
      }
      start() {
        if (this.isStarted()) {
          _t.logNormal("start: data source is already started, nothing to do");
        } else {
          (0, s.assert)(this._extSymbol !== null, "symbol must be set before start");
          (0, s.assert)(this._resolution !== null, "resolution must be set before start");
          if (this._gateway.isConnected().value()) {
            this._createSeries();
          } else {
            this._changeStatusTo(pt.AwaitingConnection);
          }
        }
      }
      stop() {
        if (this.isStarted()) {
          if (this._instanceId !== null) {
            this._gateway.removeSeries(this._instanceId);
            this._instanceId = null;
          }
          this._symbolInstanceId = null;
          this._changeStatusTo(pt.Idle);
        } else {
          _t.logNormal("stop: data source is already stopped, nothing to do");
        }
      }
      instanceId() {
        return this._instanceId;
      }
      data() {
        return this._data;
      }
      setData(e) {
        this._data = e;
      }
      clearData() {
        if (this.isStarted()) {
          this._enqueueUpdate(() => this._clearDataImpl());
        } else {
          this._clearDataImpl();
        }
      }
      dataEvents() {
        return this._dataEvents;
      }
      turnaround() {
        return `${this._turnaroundPrefix}${this._turnaroundCounter}`;
      }
      symbolInstanceId() {
        return this._symbolInstanceId;
      }
      symbol() {
        return this._extSymbol;
      }
      moveData(e) {
        this._enqueueUpdate(() => this._data.moveData(e));
      }
      setInitialRequestOptions(e) {
        this._createSeriesOverriddenParams = ft(e);
      }
      symbolSameAsResolved(e) {
        return this._extSymbol !== null && (0, ut.symbolSameAsResolved)(e, yt(this._extSymbol), this._lastResolvedSymbol);
      }
      resolvedSymbol() {
        if (this._extSymbol === null) {
          return null;
        } else {
          return yt(this._extSymbol);
        }
      }
      _resolveSymbol() {
        if (this._extSymbol !== null) {
          this._symbolInstanceId = this._gateway.resolveSymbol("sds_sym_" + mt++, (0, Xe.encodeExtendedSymbolOrGetSimpleSymbolString)(this._extSymbol), this._onMessage.bind(this));
        }
      }
      _clearDataImpl() {
        this._data.clear();
      }
      _changeStatusTo(e) {
        (0, s.assert)(this._status !== e, "Source and destination status should be distinct");
        _t.logNormal(`Status changed from ${pt[this._status]} to ${pt[e]}`);
        this._status = e;
      }
      _createSeries() {
        (0, s.assert)(this._status !== pt.Active, "Status should not be \"Active\" when creating a study");
        this._instanceId = "sds_" + gt++;
        this._resolveSymbol();
        const e = this._createSeriesOverriddenParams || this._createSeriesParams;
        this._createSeriesOverriddenParams &&= 0;
        this._gateway.createSeries(this._instanceId, this.turnaround(), (0, s.ensureNotNull)(this._symbolInstanceId), (0, s.ensureNotNull)(this._resolution), e, this._timeFrame, this._onMessage.bind(this));
        this._timeFrame = null;
        this._changeStatusTo(pt.AwaitingFirstDataUpdate);
        this._dataEvents.fireCreated(this._instanceId);
      }
      _onGatewayIsConnectedChanged(e) {
        if (e) {
          this._onGatewayConnected();
        } else {
          this._onGatewayDisconnected();
        }
      }
      _onGatewayConnected() {
        if (this._status === pt.AwaitingConnection) {
          this._createSeries();
        }
      }
      _onGatewayDisconnected() {
        if (this._status !== pt.Idle && this._status !== pt.AwaitingConnection) {
          this._instanceId = null;
          this._changeStatusTo(pt.AwaitingConnection);
        }
        this._turnaroundCounter = 1;
      }
      _onMessage(e) {
        this._enqueueUpdate(() => this._onMessageImpl(e));
      }
      async _onMessageImpl(e) {
        switch (e.method) {
          case "symbol_resolved":
            {
              const [t, i] = e.params;
              if (t !== this._symbolInstanceId) {
                if (this._symbolInstanceId !== null) {
                  _t.logNormal(`Resolve for old symbol, expected: ${this._symbolInstanceId}, actual ${e.params[0]}`);
                }
                break;
              }
              this._onSymbolResolved(i);
              break;
            }
          case "symbol_error":
            if (e.params[0] !== this._symbolInstanceId) {
              if (this._symbolInstanceId !== null) {
                _t.logNormal(`Symbol error for old symbol, expected: ${this._symbolInstanceId}, actual ${e.params[0]}`);
              }
              break;
            }
            this._onSymbolError(e);
            break;
          case "series_timeframe":
            {
              const [t, i, s, o, n, r, a] = e.params;
              if (!this._checkTurnaround(t, i)) {
                _t.logNormal(`Time frame for old data, expected: ${this._symbolInstanceId} (${this.turnaround()}), actual ${t} (${i})`);
                break;
              }
              this._onSeriesTimeFrame(s, o, n, r, a);
              break;
            }
          case "series_error":
            {
              const [t, i] = e.params;
              if (!this._checkTurnaround(t, i)) {
                _t.logNormal(`Series error for old data, expected: ${this._symbolInstanceId} (${this.turnaround()}), actual ${t} (${i})`);
                break;
              }
              this._onSeriesError(e.params[2]);
              break;
            }
          case "series_loading":
            {
              const [t, i] = e.params;
              if (!this._checkTurnaround(t, i)) {
                break;
              }
              this._onSeriesLoading(e.time);
              break;
            }
          case "series_completed":
            {
              const [t, i, s, o] = e.params;
              if (!this._checkTurnaround(t, s)) {
                _t.logNormal(`Series completed for old data, expected: ${this._symbolInstanceId} (${this.turnaround()}), actual ${t} (${s})`);
                break;
              }
              this._onSeriesCompleted(i, e.time, o);
              break;
            }
          case "data_update":
            if (!this._checkTurnaround(e.params.customId, e.params.turnaround)) {
              _t.logNormal(`Data update for old data, expected: ${this._symbolInstanceId} (${this.turnaround()}), actual ${e.params.customId} (${e.params.turnaround})`);
              break;
            }
            await this._onDataUpdate(e.params.plots, e.params.nonseries, e.params.lastBar);
            break;
          case "clear_data":
            if (e.params.turnaround !== this.turnaround()) {
              _t.logNormal(`Clear data for old data, expected: ${this.turnaround()}, actual ${e.params.turnaround}`);
              break;
            }
            this._clearDataImpl();
            this._dataEvents.fireDataUpdated(undefined, false, null, false);
        }
      }
      _onSeriesError(e) {
        let t;
        let i;
        if (typeof e == "string") {
          i = {
            error: e
          };
          t = e;
        } else {
          i = e;
          if (e.ctx) {
            const i = {};
            Object.entries(e.ctx).forEach(([e, t]) => {
              i[e] = t.toString();
            });
            t = e.error.format(i);
          } else {
            t = e.error;
          }
        }
        if (t.startsWith("study_not_auth:")) {
          const e = t.split(":", 2)[1].split("@", 2)[0];
          if (["BarSetRenko", "BarSetPriceBreak", "BarSetKagi", "BarSetPnF"].includes(e)) {
            this._dataEvents.fireChartTypeNotPermitted(e);
          } else {
            if (e === "BarSetSpread") {
              this._dataEvents.fireIntradaySpreadNotPermitted();
              return;
            }
            if (e === "BarSetRange") {
              const e = `${(0, s.ensureNotNull)(this._extSymbol).inputs.range}R`;
              this._dataEvents.fireCustomIntervalNotPermitted(e);
            }
          }
        } else {
          if (t.startsWith("unsupported")) {
            this._dataEvents.fireUnsupportedResolutionRequested();
            return;
          }
          if (t === "resolution_not_entitled") {
            this._dataEvents.fireIntradayExchangeNotPermitted();
          } else if (t === "custom_resolution") {
            this._dataEvents.fireCustomIntervalNotPermitted((0, s.ensureNotNull)(this._resolution));
          } else if (t === "seconds_not_entitled") {
            this._dataEvents.fireSecondsIntervalNotPermitted();
          } else if (t === "ticks_not_entitled") {
            this._dataEvents.fireTicksIntervalNotPermitted();
          }
        }
        this._dataEvents.fireSeriesError(i);
      }
      _onSeriesTimeFrame(e, t, i, s, o) {
        this._dataEvents.fireSeriesTimeFrame(e, t, i, s ?? true, o);
      }
      _onSymbolError(e) {
        if (e.params[1] === ht.permissionDenied) {
          switch (e.params[2]) {
            case ht.SymbolErrorPermissionDeniedReason.Symbol:
              this._dataEvents.fireSymbolNotPermitted(e.params[3]);
              break;
            case ht.SymbolErrorPermissionDeniedReason.GroupPermission:
              this._dataEvents.fireSymbolGroupNotPermitted(e.params[3]);
              break;
            default:
              this._dataEvents.fireSymbolNotPermitted(e.params[2]);
          }
        } else if (e.params[1] === ht.invalidSymbol) {
          this._dataEvents.fireSymbolInvalid();
        }
        this._dataEvents.fireSymbolError(e.params[1]);
      }
      _onSymbolResolved(e) {
        this._lastResolvedSymbol = (0, s.ensureNotNull)((0, m.extractSymbolNameFromSymbolInfo)(e, ""));
        this._dataEvents.fireSymbolResolved(e);
      }
      async _onDataUpdate(e, t, i) {
        this._onDataUnpacked(e, i, await async function (e) {
          if (e === undefined) {
            return {
              projectionPlots: [],
              boxSize: null
            };
          }
          if (e.d === "" || e.indexes === "nochange") {
            return null;
          }
          const t = await (0, ct.unpackNonSeriesData)(e.d);
          if (t === null || t.indexes_replace) {
            return null;
          }
          const i = e.indexes;
          const {
            bars: s,
            price: o,
            boxSize: n,
            reversalAmount: r
          } = t.data;
          const a = (s || []).map(e => {
            let t;
            if ("factor" in e) {
              t = e.factor;
            } else if ("additionalPrice" in e) {
              t = e.additionalPrice;
            }
            return {
              index: i[e.time],
              value: [0, e.open, e.high, e.low, e.close, e.volume, t]
            };
          });
          return {
            lastPrice: o,
            projectionPlots: a,
            reversalAmount: r,
            boxSize: n
          };
        }(t));
      }
      _enqueueUpdate(e) {
        this._ongoingDataUpdate = this._ongoingDataUpdate.then(e, e);
        return this._ongoingDataUpdate;
      }
      _onDataUnpacked(e, t, i) {
        if (this._status === pt.Idle) {
          return;
        }
        if (this._status === pt.AwaitingFirstDataUpdate) {
          this._changeStatusTo(pt.Active);
          this._clearDataImpl();
        }
        const s = this._data.bars().size();
        const o = this._data.bars().firstIndex();
        const n = this._data.mergeRegularBars(e);
        if (i !== null) {
          this._data.nsBars().clear();
          this._data.nsBars().merge(i.projectionPlots);
          this._data.lastProjectionPrice = i.lastPrice;
          if (i.boxSize !== null) {
            this._data.boxSize = i.boxSize;
          }
          this._data.reversalAmount = i.reversalAmount;
        }
        const r = o === null;
        const a = r || n !== null && n.index < o;
        this._dataEvents.fireDataUpdated(t, a, n, r);
        if (s !== this._data.bars().size() && n !== null) {
          this._dataEvents.fireBarReceived(n);
        }
      }
      _onSeriesLoading(e) {
        this._dataEvents.fireLoading(e);
      }
      _onSeriesCompleted(e, t, i) {
        this._dataEvents.fireCompleted({
          updateMode: e,
          time: t,
          flags: i
        });
      }
      _checkTurnaround(e, t) {
        return this._instanceId === e && (t === undefined || t === this.turnaround());
      }
    }
    var bt = i(22820);
    var wt = i(10074);
    var Ct = i(45687);
    class Pt extends Te.HorizontalLinePaneView {
      constructor(e) {
        super();
        this._series = e;
        this._model = e.model();
      }
    }
    const Tt = b.enabled("chart_style_hilo_last_price");
    class xt extends Pt {
      constructor(e) {
        super(e);
        this._lineRendererData.linestyle = Ie.LINESTYLE_DOTTED;
      }
      _updateImpl() {
        this._lineRendererData.visible = false;
        const e = this._series.properties().childs();
        if (!e.showPriceLine.value()) {
          return;
        }
        if (!Tt && e.style.value() === 12) {
          return;
        }
        const t = e.style.value() === 8 && e.haStyle.childs().showRealLastPrice.value();
        const i = this._series.lastValueData(t ? 4 : undefined, true);
        if (i.noData) {
          return;
        }
        let s = i.coordinate;
        if (t) {
          const e = this._series.firstValue();
          const t = this._series.data().lastProjectionPrice;
          if (e === null || t === undefined) {
            return;
          }
          s = this._series.priceScale().priceToCoordinate(t, e);
        }
        this._lineRendererData.visible = true;
        this._lineRendererData.y = s;
        this._lineRendererData.color = this._series.priceLineColor(i.color);
        this._lineRendererData.linewidth = e.priceLineWidth.value();
      }
    }
    var It = i(12374);
    var Mt = i(83379);
    var At = i(53766);
    var Lt = i(99800);
    var kt = i(72476);
    var Dt = i(80941);
    var Et = i(84626);
    var Bt = i(70527);
    var Vt = i(95201);
    var Rt = i(61993);
    var Nt = i(11064);
    var Ot = i(25201);
    class Ft extends kt.SeriesCandlesPaneView {
      renderer() {
        if (this._invalidated) {
          this._updateImpl(null);
          this._invalidated = false;
        }
        const e = this._source.priceScale();
        if (!e) {
          return null;
        }
        const t = this._source.properties().childs().haStyle.childs();
        const i = this._model.timeScale().barSpacing();
        const s = {
          bars: this._bars,
          barSpacing: i,
          bodyVisible: t.drawBody.value(),
          borderVisible: t.drawBorder.value(),
          borderColor: t.borderColor.value(),
          wickColor: t.wickColor.value(),
          barWidth: (0, Rt.optimalBarWidth)(i),
          wickVisible: t.drawWick.value(),
          isPriceScaleInverted: e.isInverted()
        };
        const o = new Vt.CompositeRenderer();
        o.append(new Ot.PaneRendererCandles(s));
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
          o.append(new Nt.SelectionRenderer(this._selectionData));
        }
        return o;
      }
    }
    var Wt = i(15599);
    var Ht = i(93250);
    var zt = i(15716);
    var Ut = i(90799);
    var jt = i(79036);
    var Gt = i(24526);
    var qt = i(88145);
    i(20596);
    var $t = i(19466);
    var Kt = i(42989);
    class Yt extends Pt {
      constructor(e) {
        super(e);
      }
      _updateImpl() {
        this._lineRendererData.visible = false;
        const e = this._series.priceScale().mode();
        if (!e.percentage && !e.indexedTo100) {
          return;
        }
        const t = this._series.firstValue();
        if (t !== null) {
          this._lineRendererData.visible = true;
          this._lineRendererData.y = this._series.priceScale().priceToCoordinate(t, t);
          this._lineRendererData.color = this._series.properties().childs().baseLineColor.value();
        }
      }
    }
    var Zt = i(88960);
    var Xt = i(678);
    var Jt = i(46088);
    var Qt = i(18032);
    const ei = b.enabled("price_scale_always_last_bar_value");
    const ti = b.enabled("display_data_mode");
    const ii = !b.enabled("hide_series_legend_item");
    const si = b.enabled("hide_price_scale_global_last_bar_value");
    const oi = b.enabled("show_average_close_price_line_and_label");
    const ni = b.enabled("no_bars_status");
    const ri = b.enabled("charting_library_debug_mode");
    const ai = b.enabled("chart_style_hilo_last_price");
    const li = (0, r.getLogger)("Chart.Series");
    const ci = b.enabled("pre_post_market_sessions");
    const hi = {
      countdownEnabled: true,
      lastPriceAnimationEnabled: true
    };
    function di(e, t, i) {
      if (t === undefined) {
        return null;
      } else {
        return `${e}=${t} (${i ? "changed" : "unchanged"})`;
      }
    }
    function ui(e) {
      const t = e.state();
      t.data.forEach(e => e.value.splice(7, 1));
      return t;
    }
    function _i(e) {
      const {
        seriesStatus: t,
        additionalStudyStatus: i
      } = e;
      if (y.seriesLoadingStatuses.has(t)) {
        return 2;
      }
      if (i) {
        if (t !== 4 && i.type === Xt.StudyStatusType.Error) {
          return 13;
        }
        if (y.seriesReadyStatuses.has(t) && (i.type === Xt.StudyStatusType.Loading || i.type === Xt.StudyStatusType.Undefined)) {
          return 2;
        }
      }
      return t;
    }
    class pi extends l.PriceDataSource {
      constructor(e, t, i, o) {
        t.removeProperty("currencyId");
        super(e, "_seriesId");
        this.isSeries = true;
        this.requestingStyleIsNotSupported = new Ye.Delegate();
        this.requestingStyleSupportRecovered = new Ye.Delegate();
        this._paneView = null;
        this._futureBarsPaneView = null;
        this._projectionBarsPaneView = null;
        this._waterlineView = null;
        this._priceLineView = null;
        this._gotoDateView = null;
        this._baseHorizontalLineView = null;
        this._priceStep = null;
        this._symbolInfo = new lt.WatchedValue(null);
        this._isPrePostMarketPricesAvailableProperty = new p.Property(false);
        this._isBackAdjustmentForbiddenProperty = new p.Property(true);
        this._isSettlementAsCloseForbiddenProperty = new p.Property(true);
        this._highLowPriceCache = new Map();
        this._averagePriceCache = new Map();
        this._prevClosePriceAxisView = null;
        this._priceScaleAboutToBeChanged = new Ye.Delegate();
        this._onRestarted = new Ye.Delegate();
        this._onStatusChanged = new Ye.Delegate();
        this._tagsChanged = new Ye.Delegate();
        this._intervalChanged = new Ye.Delegate();
        this._sessionIdChanged = new Ye.Delegate();
        this._requestMoreDataAvailable = true;
        this._lineStyleLastPriceCirclePaneView = new rt(this);
        this._prevClosePriceLineView = null;
        this._dataPoweredBy = null;
        this._symbolResolvingActive = new lt.WatchedValue(false);
        this._predictBars = 0;
        this._syncModel = null;
        this._data = null;
        this._lastCompleteFlags = null;
        this._haStyle = {
          studyId: (0, s.ensureNotNull)((0, m.chartStyleStudyId)(8, true))
        };
        this._renkoStyle = {
          studyId: (0, s.ensureNotNull)((0, m.chartStyleStudyId)(4, true))
        };
        this._pbStyle = {
          studyId: (0, s.ensureNotNull)((0, m.chartStyleStudyId)(7, true))
        };
        this._kagiStyle = {
          studyId: (0, s.ensureNotNull)((0, m.chartStyleStudyId)(5, true))
        };
        this._pnfStyle = {
          studyId: (0, s.ensureNotNull)((0, m.chartStyleStudyId)(6, true))
        };
        this._rangeStyle = {
          studyId: (0, s.ensureNotNull)((0, m.chartStyleStudyId)(11, true))
        };
        this._volFootprintStyle = {
          studyId: (0, s.ensureNotNull)((0, m.chartStyleStudyId)(17, true))
        };
        this._tpoStyle = {
          studyId: (0, s.ensureNotNull)((0, m.chartStyleStudyId)(18, true))
        };
        this._svpStyle = {
          studyId: (0, s.ensureNotNull)((0, m.chartStyleStudyId)(20, true))
        };
        this._barColorerCache = null;
        this._boxSizeValue = new lt.WatchedValue();
        this._base = 100;
        this._pointValue = 1;
        this._formattingDeps = null;
        this._defaultFormatter = new f.PriceFormatter({
          priceScale: this._base
        });
        this._formatter = new f.PriceFormatter({
          priceScale: this._base
        });
        this._ignoreMinMoveFormatter = new f.PriceFormatter({
          priceScale: this._base
        });
        this._ignoreMinMovePriceStep = null;
        this._lastBarCloseTime = null;
        this._onSessionIdPropertyChangedBound = this._onSessionIdPropertyChanged.bind(this);
        this._ignoreSessionIdProxyPropertyChanges = false;
        this._textSourceIsAlwaysTickerRestrictionEnabled = false;
        this._lastPriceAnimationActive = false;
        this._currentSession = "out_of_session";
        this._onStyleChanged = new Ye.Delegate();
        this._intervalObj = null;
        this._obsoleteZOrder = 0;
        this._seriesErrorMessage = null;
        this._seriesAlwaysFalseHibernatedVW = new lt.WatchedValue(false);
        this._styleToRecover = null;
        this._precomputedBarStyles = new WeakMap();
        this._doNotShowLastAvailableBar = false;
        this._gotoDateResultCleared = false;
        this._endOfDataPaneView = null;
        this._pendingTimeRange = null;
        this._replaySubscriber = new lt.WatchedValue(null);
        this._symbolIntervalChanged = new Ye.Delegate();
        this._isReplayResolutionAvailableForUser = null;
        this._onInReplayStateChanged = new Ye.Delegate();
        this._onReplaySubscriberSeriesModified = new Ye.Delegate();
        this._paramsNotApplicableForReplay = new Ye.Delegate();
        this._onTimeFrameApplied = new Ye.Delegate();
        this._seriesLoaded = false;
        this._seriesCompleted = false;
        this._status = new lt.WatchedValue({
          seriesStatus: 0
        });
        this._prevRequestedInterval = "";
        this._isActingAsSymbolSource = new lt.WatchedValue(true);
        this._unsupportedResolutionState = new lt.WatchedValue(null);
        this._countdownUpdateTimer = null;
        this._deferredDestroyed = (0, a.createDeferredPromise)();
        this._volumePointWeights = null;
        this._studyBindings = null;
        this._lineColorAtYPercentFromTop = new be.GradientColorCache();
        this._savedLeftEdge = null;
        this._pendingScrollToLeftEdge = null;
        this._updateTimeScaleTimePointWeights = () => {
          0;
        };
        this._seriesStatus = (0, Zt.combine)(_i, this._status.weakReference());
        this._seriesSource = new St(e.chartApi(), "s", o);
        const n = this._seriesSource.dataEvents();
        n.symbolResolved().subscribe(this, this._onSymbolResolved);
        n.symbolError().subscribe(this, this._onSymbolError);
        n.seriesTimeFrame().subscribe(this, this._onSeriesTimeFrame);
        n.seriesError().subscribe(this, this._onSeriesError);
        n.loading().subscribe(this, this._onSeriesLoading);
        n.completed().subscribe(this, this._onSeriesCompleted);
        n.dataUpdated().subscribe(this, this._onDataUpdated);
        n.barReceived().subscribe(this, this._onBarReceived);
        n.unsupportedResolutionRequested().subscribe(this, this._onUnsupportedResolutionRequested);
        this._quotesProvider = new ce.QuotesProvider(undefined, e.collapsed().spawnOwnership());
        this._quotesProvider.quotesUpdate().subscribe(this, this._onQuotesUpdate);
        const r = t.childs();
        if (t.hasChild("extendedHours")) {
          if ((0, s.ensureDefined)(r.extendedHours).value() && !t.hasChild("sessionId")) {
            t.addChild("sessionId", new p.Property("extended"));
          }
          t.removeProperty("extendedHours");
        }
        if (!t.hasChild("sessionId")) {
          t.addChild("sessionId", new p.Property(g.SubsessionId.Regular));
        }
        if (!(0, Kt.allChartStyles)().includes(r.style.value())) {
          r.style.setValueSilently(2);
        }
        const l = r.lineStyle.childs();
        if (r.lineStyle.hasChild("styleType")) {
          let e;
          let t;
          const i = l.styleType.value();
          if (i === 0) {
            t = 14;
            e = r.lineWithMarkersStyle.childs();
          }
          if (i === 1) {
            t = 15;
            e = r.steplineStyle.childs();
          }
          if (e) {
            e.color.setValueSilently(l.color.value());
            e.linestyle.setValueSilently(l.linestyle.value());
            e.linewidth.setValueSilently(l.linewidth.value());
            e.priceSource.setValueSilently(l.priceSource.value());
          }
          if (t !== undefined && r.style.value() === 2) {
            r.style.setValue(t);
          }
          r.lineStyle.removeProperty("styleType");
        }
        this._studyBindings?.bindToSeriesProperties(t);
        this._setProperties(t);
        this._sessionIdProxyProperty = new p.Property(r.sessionId.value());
        r.sessionId.subscribe(this, () => this._updateSessionIdProxyProperty());
        this._sessionIdProxyProperty.subscribe(this, this._onSessionIdProxyPropertyChanged);
        this._symbolTextSourceProxyProperty = new p.Property();
        this._recalcSymbolTextSourceProxyProperty();
        r.statusViewStyle.childs().symbolTextSource.subscribe(this, this._recalcSymbolTextSourceProxyProperty);
        this._symbolTextSourceProxyProperty.subscribe(this, () => e.lightUpdate());
        this._options = (0, ae.merge)((0, ae.clone)(hi), i);
        this._prevChartStyle = r.style.value();
        this._priceAxisView = new ve(this, e, {
          alwaysShowGlobalLast: !si,
          showCountdown: i.countdownEnabled
        });
        let c = null;
        if (!ei && !si) {
          c = new ve(this, e, {
            visibleOnHistoryOnly: true,
            showSymbolLabel: false,
            showCountdown: false,
            alwaysShowGlobalLast: false,
            useSolidBodyColor: false
          });
        }
        this._priceLinePriceAxisView = new we.SeriesPriceLineAxisView(this);
        this._priceLineAxisViews = [this._priceLinePriceAxisView];
        this._projectionPriceAxisView = new Ce(this, e, {
          showCountdown: i.countdownEnabled
        });
        this._priceAxisViews = [this._priceAxisView, this._projectionPriceAxisView];
        if (c !== null) {
          this._priceAxisViews.push(c);
        }
        this._panePriceAxisView = new Pe.PanePriceAxisView(this._priceAxisView, this, e);
        this._historyPricePanePriceAxisView = c !== null ? new Pe.PanePriceAxisView(c, this, e) : null;
        this._projectionPanePriceAxisView = new Pe.PanePriceAxisView(this._projectionPriceAxisView, this, e);
        this._labelPaneViews = [this._panePriceAxisView, this._projectionPanePriceAxisView];
        if (this._historyPricePanePriceAxisView !== null) {
          this._labelPaneViews.push(this._historyPricePanePriceAxisView);
        }
        this._highLowAvgPaneViews = [];
        this._averagePaneViews = [];
        if (oi) {
          this._createAverageViews();
        }
        this._createHighLowAvgViews();
        this._subscribeRestartToSessionIdChange();
        r.visible.subscribe(this, this._updateLastPriceAnimationActive);
        this._updateLastPriceAnimationActive();
        r.minTick.subscribe(this, this._onFormatterPropsChanged);
        this._dataWindowView = new U(this, e);
        this._legendView = new q(this, e);
        this._statusView = new V(this, r.statusViewStyle);
        this._marketStatusModel = new K.MarketStatusModel(this._quotesProvider);
        this._dataUpdatedModeModel = ti ? new re(this._symbolInfo.spawn().ownership(), this._seriesStatus.spawn().ownership(), (0, j.createWVFromGetterAndSubscription)(() => this._lastCompleteFlags?.rt_update_period, n.completed()).ownership()) : null;
        this._dataProblemModel = new le(this._quotesProvider, this._symbolInfo.spawn().ownership());
        this._symbolResolvingActive.subscribe(() => e.realignLineTools());
        this._intervalChanged.subscribe(this, () => e.realignLineTools());
        this._intervalChanged.subscribe(this, () => this._checkChartStyle());
        this._studyBindings?.syncStudy(this.style());
        this.createPaneView();
        this._properties.addExcludedKey("visible", 1);
        this._properties.addExcludedKey("currencyId", 1);
        this._futureBarsPaneView = null;
        this._priceLineView = null;
        this._baseHorizontalLineView = new Yt(this);
        for (const [, e] of Object.entries(y.STYLE_SHORT_NAMES)) {
          this._properties.child(`${e}Style`)?.subscribe(this, () => this.invalidateBarStylesCache());
        }
        const h = r.renkoStyle.childs().inputs.childs();
        h.boxSize.subscribe(this, this.restart);
        h.style.subscribe(this, this.restart);
        h.atrLength.subscribe(this, this.restart);
        h.percentageLTP.subscribe(this, this.restart);
        h.wicks.subscribe(this, this.restart);
        h.sources.subscribe(this, this.restart);
        r.pbStyle.childs().inputs.childs().lb.subscribe(this, this.restart);
        const d = r.kagiStyle.childs().inputs.childs();
        d.reversalAmount.subscribe(this, this.restart);
        d.style.subscribe(this, this.restart);
        d.atrLength.subscribe(this, this.restart);
        d.percentageLTP.subscribe(this, this.restart);
        const u = r.pnfStyle.childs().inputs.childs();
        u.boxSize.subscribe(this, this.restart);
        u.reversalAmount.subscribe(this, this.restart);
        u.sources.subscribe(this, this.restart);
        u.style.subscribe(this, this.restart);
        u.atrLength.subscribe(this, this.restart);
        u.percentageLTP.subscribe(this, this.restart);
        u.oneStepBackBuilding.subscribe(this, this.restart);
        r.rangeStyle.childs().inputs.childs().phantomBars.subscribe(this, this.restart);
        this._isDWMProperty = new p.Property(this.isDWM());
        this._onRestarted.subscribe(this, () => this._isDWMProperty.setValue(this.isDWM()));
        r.showCountdown.subscribe(this, this._onShowCountdownChanged);
        this._onShowCountdownChanged(r.showCountdown);
        this._recreatePriceFormattingDependencies();
        r.lineStyle.childs().priceSource.subscribe(this, this._updateBarFunction);
        r.lineWithMarkersStyle.childs().priceSource.subscribe(this, this._updateBarFunction);
        r.steplineStyle.childs().priceSource.subscribe(this, this._updateBarFunction);
        r.areaStyle.childs().priceSource.subscribe(this, this._updateBarFunction);
        r.baselineStyle.childs().priceSource.subscribe(this, this._updateBarFunction);
        r.columnStyle.childs().priceSource.subscribe(this, this._updateBarFunction);
        this._updateBarFunction();
        this._isInReplay = (0, Zt.combine)(e => e !== null, this._replaySubscriber.weakReference());
        this._legendValuesProvider = new $e(this, this.model());
        this._dataWindowValuesProvider = new Ge.SeriesValuesProvider(this, this.model());
      }
      setId(e) {
        super.setId(e);
        (0, Se.getPersistentLogger)()?.addPersistentLogEntry(`Set series Id to ${e}`, r.LOGLEVEL.INFO, "chart.series");
      }
      supportsConflatedChunks() {
        return true;
      }
      conflatedChunks(e, t) {
        return this.data().conflatedChunks(e, t);
      }
      seriesErrorMessage() {
        const {
          seriesStatus: e,
          additionalStudyStatus: t
        } = this._status.value();
        if (this.isFailed()) {
          return this._seriesErrorMessage;
        } else if (y.seriesLoadingStatuses.has(e)) {
          return null;
        } else if (t?.type === Xt.StudyStatusType.Error) {
          return (0, Xt.convertStudyStatusToString)({
            type: Xt.StudyStatusType.Error,
            errorDescription: t.errorDescription
          }, true);
        } else {
          return null;
        }
      }
      destroy() {
        this._seriesStatus.destroy();
        this._quotesProvider.quotesUpdate().unsubscribeAll(this);
        this._quotesProvider.destroy();
        this.clearGotoDateResult();
        this._legendView.destroy();
        this._marketStatusModel.destroy();
        if (this._studyBindings) {
          this._studyBindings.destroy();
        }
        if (this._dataUpdatedModeModel !== null) {
          this._dataUpdatedModeModel.destroy();
        }
        this._dataProblemModel.destroy();
        if (this._paneView && this._paneView.destroy) {
          this._paneView.destroy();
        }
        this._seriesSource.destroy();
        this._quotesProvider.quotesUpdate().unsubscribeAll(this);
        this._model.timeScale().visibleBarsStrictRangeChanged().unsubscribeAll(this);
        this._unsubscribeRestartToSessionIdChange();
        this._paramsNotApplicableForReplay.destroy();
        this._onTimeFrameApplied.destroy();
        this._deferredDestroyed.resolve();
        this._properties.destroy();
        this._isInReplay.destroy();
        super.destroy();
      }
      isActingAsSymbolSource() {
        return this._isActingAsSymbolSource.readonly();
      }
      barColorer() {
        if (this._barColorerCache) {
          return this._barColorerCache;
        }
        let e = null;
        const t = this._model.dataSources();
        for (let i = t.length - 1; i >= 0; i--) {
          const o = t[i];
          if ((0, jt.isStudy)(o) && o.hasBarColorer() && !o.isSourceHidden()) {
            const t = (0, s.ensureNotNull)(o.barColorer());
            if (e === null) {
              e = t;
            } else {
              e.pushBackBarColorer(t);
            }
          }
        }
        if (e === null) {
          e = new Ut.SeriesBarColorer(this);
        } else {
          e.pushBackBarColorer(new Ut.SeriesBarColorer(this));
        }
        this._barColorerCache = e;
        return e;
      }
      createPaneView() {
        this._paneView = null;
        this._projectionBarsPaneView = null;
        this._waterlineView = null;
        this._priceLineView = this.hasClosePrice() ? new xt(this) : null;
        const e = this._properties.childs().style.value();
        switch (e) {
          case 0:
            this._paneView = new Lt.SeriesBarsPaneView(this, this._model);
            break;
          case 17:
          case 19:
          case 1:
            this._paneView = new kt.SeriesCandlesPaneView(this, this._model, e === 1 || e === 19 ? 1 : 0.2);
            break;
          case 2:
          case 18:
          case 14:
          case 15:
            this._paneView = new Dt.SeriesLinePaneView(this, this._model);
            break;
          case 3:
            this._paneView = new Et.SeriesAreaPaneView(this, this._model);
            break;
          case 16:
            this._paneView = new Bt.SeriesHLCAreaPaneView(this, this._model);
            break;
          case 8:
            this._paneView = new Ft(this, this._model);
            break;
          case 9:
            this._paneView = new Wt.SeriesHollowCandlesPaneView(this, this._model);
            break;
          case 13:
            this._paneView = new At.SeriesColumnsPaneView(this, this._model);
            break;
          case 10:
            {
              this._paneView = new Ht.SeriesBaselinePaneView(this, this._model);
              const e = this._properties.childs().baselineStyle.childs();
              this._waterlineView = new It.SeriesWaterlinePaneView({
                paneHeight: () => this.priceScale().height(),
                color: () => e.baselineColor.value(),
                baseLevelPercentage: () => e.baseLevelPercentage.value()
              });
              break;
            }
          case 12:
            this._paneView = new Mt.SeriesHiLoPaneView(this, this._model);
            break;
          case 21:
            this._paneView = new Qt.SeriesHLCBarsPaneView(this, this._model);
        }
        if (this._paneView === null) {
          throw Error("Unknown chart style assigned: " + e);
        }
      }
      properties() {
        return this._properties;
      }
      zorder() {
        return 0;
      }
      quotesProvider() {
        return this._quotesProvider;
      }
      currentSession() {
        return this._currentSession;
      }
      syncModel() {
        if (!this._syncModel) {
          const e = this.symbolInfo();
          const t = this.interval();
          if (!e || !t) {
            return null;
          }
          this._syncModel = new te(e, t);
        }
        return this._syncModel;
      }
      labelPaneViews() {
        return this._labelPaneViews;
      }
      topPaneViews() {
        const e = [];
        if (this._gotoDateView !== null) {
          e.push(this._gotoDateView);
        }
        if (this._lastPriceAnimationActive) {
          const t = this._lineStyleLastPriceCirclePaneView;
          if (t.animationActive()) {
            setTimeout(() => this._model.invalidate(at.InvalidationMask.cursor()), 0);
          }
          t.invalidateStage();
          e.push(t);
        }
        if (e.length !== 0) {
          return e;
        } else {
          return null;
        }
      }
      paneViews(e) {
        if (!this.properties().childs().visible.value() || !this._model.isSnapshot() && !this._wasCompletedBefore()) {
          return null;
        }
        const t = e === this._model.paneForSource(this);
        const i = t ? [(0, s.ensureNotNull)(this._baseHorizontalLineView), (0, s.ensureNotNull)(this._paneView)] : [];
        i.push(...(this._studyBindings?.paneViews(e) ?? []));
        if (t) {
          if (this._endOfDataPaneView) {
            i.push(this._endOfDataPaneView);
          }
          if (this._futureBarsPaneView) {
            i.push(this._futureBarsPaneView);
          }
          if (this._projectionBarsPaneView) {
            i.push(this._projectionBarsPaneView);
          }
          if (this._waterlineView !== null) {
            i.push(this._waterlineView);
          }
          if (this._priceLineView !== null) {
            i.push(this._priceLineView);
          }
          if (window.TradingView.printing && this._lastPriceAnimationActive) {
            this._lineStyleLastPriceCirclePaneView.stopAnimation();
            i.push(this._lineStyleLastPriceCirclePaneView);
          }
          i.push(...this._highLowAvgPaneViews);
          i.push(...this._averagePaneViews);
        }
        return i;
      }
      widgetSideAreaViews(e) {
        return this._studyBindings?.widgetSideAreaViews(e) ?? null;
      }
      priceAxisViews(e, t) {
        return e.findTargetPriceAxisViews(this, t, this._priceAxisViews, this._priceLineAxisViews);
      }
      clearHighLowPriceCache() {
        this._highLowPriceCache.clear();
      }
      clearAveragePriceCache() {
        this._averagePriceCache.clear();
      }
      priceScale() {
        return (0, s.ensureNotNull)(this._priceScale);
      }
      setPriceScale(e) {
        if (this._priceScale !== e) {
          this._priceScaleAboutToBeChanged.fire();
          this._priceScale = e;
          this._properties.removeProperty("priceAxisProperties");
          this._properties.addChild("priceAxisProperties", e.properties());
          this._properties.childs().priceAxisProperties.fireChanged();
          (0, n.emit)("series_event", "price_scale_changed");
          this._priceScaleChanged.fire(e);
        }
      }
      priceScaleChanged() {
        return this._priceScaleChanged;
      }
      priceScaleAboutToBeChanged() {
        return this._priceScaleAboutToBeChanged;
      }
      applyPreferences(e) {
        const t = (0, ae.clone)(e);
        this.priceScale().setMode({
          autoScale: t.priceAxisProperties.autoScale,
          percentage: t.priceAxisProperties.percentage,
          log: t.priceAxisProperties.log,
          lockScale: t.priceAxisProperties.lockScale
        });
        this.setChartStyleWithIntervalIfNeeded(t.style);
        const {
          style: i,
          interval: s,
          ...o
        } = t;
        this._properties.mergePreferences(o);
        this._properties.saveDefaults();
        this.createPaneView();
        this.invalidateBarStylesCache();
      }
      disconnect() {
        this._studyBindings?.stop();
        this._seriesSource.stop();
        this._predictBars = 0;
        this._updateStatus({
          ...this._status.value(),
          seriesStatus: 0
        });
        if (!this._model.isSnapshot()) {
          this._symbolInfo.setValue(null);
        }
      }
      isStarted() {
        return this._seriesSource.isStarted();
      }
      isCompleted() {
        return this._seriesCompleted;
      }
      restart(e, t, i) {
        if (this._status.value().seriesStatus === 5) {
          return;
        }
        this._seriesLoaded = false;
        this._seriesCompleted = false;
        this._lastCompleteFlags = null;
        this._onRestarted.fire();
        this._setStatus(1);
        this._updateSymbolInfo(null);
        const s = this._properties.childs().interval.value();
        if (Z.Interval.isEqual(s, this._prevRequestedInterval)) {
          this._notifyIntervalChanged(s);
        }
        let o = null;
        if (this._pendingTimeRange) {
          o = this._pendingTimeRange;
          this._pendingTimeRange = null;
        }
        this._onBeforeModifySeries(this.getSymbolString(), s);
        this._onTimeFrameApplied.fire(o);
        const n = (0, Ct.getServerInterval)(s);
        this._data = null;
        this.model().recalcVisibleRangeStudies(c.RecalcVisibleRangeStudiesReason.SeriesRestart);
        this._seriesSource.modifySeries(this._getResolvingSymbolObject(), n, o);
        if (!this._seriesSource.isStarted()) {
          this._seriesSource.start();
        }
        this._prevRequestedInterval = this.interval();
        this.updateAllViews((0, me.sourceChangeEvent)(this.id()));
        this._model.lightUpdate();
      }
      isSymbolInvalid() {
        return this._status.value().seriesStatus === 4;
      }
      getSymbolString() {
        return (0, Xe.encodeExtendedSymbolOrGetSimpleSymbolString)(this._getSymbolObject());
      }
      getAlertSymbolString() {
        return (0, Xe.encodeExtendedSymbolOrGetSimpleSymbolString)(this._getSymbolObject(this.actualSymbol()));
      }
      invalidateBarStylesCache(e) {
        li.logDebug("Invalidate style cache starting from " + e);
        this._clearStylePlot(this.bars(), e);
        this._clearStylePlot(this.nsBars());
      }
      isLoading() {
        return y.seriesLoadingStatuses.has(this.statusWV().value());
      }
      isFailed() {
        const e = this.status();
        return e === 12 || e === 4 || e === 10 || e === 14;
      }
      isStatusError() {
        return this.status() === 12;
      }
      unsupportedResolutionState() {
        return this._unsupportedResolutionState.readonly();
      }
      actualSymbol() {
        return (0, m.actualSymbol)(this.symbolInfo(), this.symbol());
      }
      proSymbol() {
        return (0, m.proSymbol)(this.symbolInfo(), this.symbol());
      }
      onStyleChanged() {
        return this._onStyleChanged;
      }
      style() {
        return this.properties().childs().style.value();
      }
      setStyle(e) {
        this.setSymbolParams({
          style: e
        });
      }
      isRangeBasedStyle() {
        return (0, m.isRangeBasedStyle)(this.style());
      }
      symbolSameAsCurrent(e) {
        return this.symbol() === e || (0, Ze.symbolSameAsCurrent)(e, this.symbolInfo());
      }
      symbolSameAsResolved(e) {
        if (this._model.isSnapshot()) {
          return this.symbolSameAsCurrent(e);
        } else {
          return this._seriesSource.symbolSameAsResolved(e);
        }
      }
      status() {
        return this._seriesStatus.value();
      }
      statusWV() {
        return this._seriesStatus;
      }
      compositeStatusVW() {
        return this._status;
      }
      symbol() {
        return this.properties().childs().symbol.value();
      }
      symbolChanged() {
        return this.properties().childs().symbol;
      }
      seriesSource() {
        return this._seriesSource;
      }
      symbolInfo() {
        return this._symbolInfo.value();
      }
      symbolResolved() {
        return this.dataEvents().symbolResolved();
      }
      symbolResolvingActive() {
        return this._symbolResolvingActive;
      }
      symbolHibernated() {
        return this._seriesAlwaysFalseHibernatedVW;
      }
      getSymbolName() {
        return this.symbolInfo()?.name ?? "";
      }
      firstValue() {
        const e = this.firstBar();
        if (e === null) {
          return null;
        } else {
          return this._barFunction(e, 0);
        }
      }
      firstBar() {
        const e = this.model().timeScale().visibleBarsStrictRange();
        if (e === null) {
          return null;
        }
        const t = e.firstBar();
        const i = this.data().search(t, u.PlotRowSearchMode.NearestRight);
        if (i !== null) {
          return i.value;
        } else {
          return null;
        }
      }
      formatter(e = true) {
        if (e) {
          return this._formatter;
        } else {
          return this._ignoreMinMoveFormatter;
        }
      }
      defaultFormatter() {
        return this._defaultFormatter;
      }
      priceStep(e = true) {
        if (e) {
          return this._priceStep;
        } else {
          return this._ignoreMinMovePriceStep;
        }
      }
      bars() {
        return this.data().bars();
      }
      nsBars() {
        return this.data().nsBars();
      }
      interval() {
        return this.properties().childs().interval.value();
      }
      setInterval(e) {
        this.setSymbolParams({
          interval: e
        });
      }
      intervalObj() {
        const e = this.interval();
        if (this._intervalObj !== null && this._intervalObj.resolutionString === e) {
          return this._intervalObj.interval;
        }
        const t = Z.Interval.parse(e);
        this._intervalObj = {
          resolutionString: e,
          interval: t
        };
        return t;
      }
      prevClose() {
        const e = this.priceScale();
        if (e.isEmpty() || this.data().isEmpty()) {
          return null;
        }
        const t = this.quotes();
        const i = this.firstValue();
        if (t === null || i === null) {
          return null;
        }
        const s = t.prev_close_price;
        if (s === undefined) {
          return null;
        } else {
          return {
            coordinate: e.priceToCoordinate(s, i),
            floatCoordinate: e.priceToCoordinate(s, i),
            formattedPricePercentage: e.formatPricePercentage(s, i, {
              signPositive: true
            }),
            formattedPriceAbsolute: e.formatPriceAbsolute(s),
            formattedPriceIndexedTo100: e.formatPriceIndexedTo100(s, i)
          };
        }
      }
      priceLineColor(e) {
        return this.properties().childs().priceLineColor.value() || e;
      }
      hasClosePrice() {
        return ai || this.properties().childs().style.value() !== 12;
      }
      lastValueData(e, t, i) {
        const s = {
          noData: true
        };
        const o = this.priceScale();
        if (this.model().timeScale().isEmpty() || o.isEmpty() || this.data().isEmpty()) {
          return s;
        }
        const n = this.model().timeScale().visibleBarsStrictRange();
        const r = this.firstValue();
        if (n === null || r === null) {
          return s;
        }
        let a;
        let l;
        if (t) {
          const e = this.data().bars().last();
          if (e === null) {
            return s;
          }
          a = e.value;
          l = e.index;
        } else {
          const e = this.data().bars().search(n.lastBar(), u.PlotRowSearchMode.NearestLeft);
          if (e === null) {
            return s;
          }
          a = e.value;
          l = e.index;
        }
        const c = (e !== undefined ? a[e] : this._barFunction(a, 2)) ?? NaN;
        const h = this.barColorer().barStyle(l, false);
        const d = o.priceToCoordinate(c, r);
        const _ = {
          ...o.getFormattedValues(c, r, true),
          noData: false,
          color: h.barColor,
          floatCoordinate: d,
          coordinate: d,
          index: l
        };
        if (i) {
          _.price = c;
        }
        return _;
      }
      isDWM() {
        return this.intervalObj().isDWM();
      }
      isPulse() {
        const e = this.symbolInfo();
        return e !== null && (e.resolutions ?? []).length > 0;
      }
      data() {
        return this._data ?? this._seriesSource.data();
      }
      clearData() {
        (0, s.assert)(this._data === null, "Cannot clear loaded data");
        this._studyBindings?.clearData();
        this._seriesSource.clearData();
      }
      nearestData(e, t) {
        return this.data().search(e, t) ?? undefined;
      }
      nearestIndex(e, t) {
        return this.nearestData(e, t)?.index;
      }
      nearestValue(e, t, i) {
        const s = this.nearestData(e, i);
        return s?.value[t] ?? undefined;
      }
      onSymbolIntervalChanged() {
        return this._symbolIntervalChanged;
      }
      onIntervalChanged() {
        return this._intervalChanged;
      }
      onStatusChanged() {
        return this._onStatusChanged;
      }
      onRestarted() {
        return this._onRestarted;
      }
      fixLastBar(e) {
        0;
      }
      requestMoreData(e) {
        if (!y.seriesReadyStatuses.has(this._status.value().seriesStatus)) {
          return;
        }
        if (this._model.timeScale().isEmpty()) {
          return;
        }
        const t = this._model.timeScale().visibleBarsStrictRange();
        if (t === null) {
          return;
        }
        if (this.bars().size() === 0) {
          return;
        }
        const i = t.lastBar() - (0, s.ensureNotNull)(this.data().last()).index;
        if (this._predictBars < i) {
          this._predictBars = i;
          this._seriesSource.requestMoreTickmarks(i);
        }
        if (!this._requestMoreDataAvailable) {
          return;
        }
        const o = (0, s.ensureNotNull)(this.bars().firstIndex());
        const n = e || Math.max(o - t.firstBar(), o - (this._studyBindings?.requestMoreDataIndex() ?? o));
        if (!(n <= 0)) {
          if (Number.isFinite(n)) {
            this._requestMoreDataAvailable = false;
            this._seriesSource.requestMoreData(n);
            this._setStatus(2);
          } else {
            li.logWarn("requestMoreData: invalid bar count: " + n + ", visible bars: [" + t.firstBar() + ", " + t.lastBar() + "], last index: " + (0, s.ensureNotNull)(this.data().last()).index + ", predicted bars: " + this._predictBars + ", required bars:" + e);
          }
        }
      }
      isNeedRestart(e) {
        return this._status.value().seriesStatus !== 5 && (e === undefined && (e = this.properties().childs().style.value()), (0, m.styleChangeRequiresRestart)(this._prevChartStyle, e));
      }
      isStyleSupported(e) {
        return true;
      }
      sessionId() {
        return this.properties().childs().sessionId.value();
      }
      sessionIdChanged() {
        return this._sessionIdChanged;
      }
      priceRange(e, t, i) {
        const o = this._priceScale;
        if (this.data().isEmpty() || !o) {
          return null;
        }
        if (o.isLockScale()) {
          const e = this._model.mainSeriesScaleRatio();
          if (e !== null) {
            const i = o.internalHeight() / (this.model().timeScale().barSpacing() / e);
            const n = (0, s.ensureNotNull)(this.data().search(t, u.PlotRowSearchMode.NearestLeft)).value;
            const r = ((0, s.ensure)(n[2]) + (0, s.ensure)(n[3])) / 2;
            return new _.PriceRange(r - i * 0.5, r + i * 0.5);
          }
        }
        const n = this.priceSource();
        let r;
        let a;
        let l;
        if (n !== null) {
          r = this.data().bars().minMaxOnRangeCached(e, t, [{
            name: n,
            offset: 0
          }]);
          a = this.data().nsBars().minMaxOnRangeCached(e, t, [{
            name: n,
            offset: 0
          }]);
        } else {
          r = this.data().bars().minMaxOnRangeCached(e, t, [{
            name: "low",
            offset: 0
          }, {
            name: "high",
            offset: 0
          }]);
          a = this.data().nsBars().minMaxOnRange(e, t, [{
            name: "low",
            offset: 0
          }, {
            name: "high",
            offset: 0
          }]);
        }
        r = (0, d.mergeMinMax)(r, a);
        if (r === null) {
          l = new _.PriceRange(-0.5, 0.5);
        } else if (r.min === r.max) {
          const e = 5 / (this.symbolInfo()?.pricescale ?? 100);
          l = new _.PriceRange(r.min - e, r.max + e);
        } else {
          l = new _.PriceRange(r.min, r.max);
        }
        if (o.isLog()) {
          return new _.PriceRange(o.priceToLogical(l.minValue()), o.priceToLogical(l.maxValue()));
        } else {
          return l;
        }
      }
      autoScaleInfo(e, t, i) {
        let s = {
          range: this.priceRange(e, t, {
            ...i,
            scaleSeriesOnly: true
          }),
          topPixelMargin: this._paneView?.topPixelMargin?.(),
          bottomPixelMargin: this._paneView?.bottomPixelMargin?.()
        };
        if (!i.scaleSeriesOnly) {
          const o = this._model.allStudies().filter(e => e.isVisible());
          const n = (e, t) => e === undefined ? t : t === undefined ? e : Math.max(e, t);
          const r = o.map(s => s.autoScaleInfo(e, t, {
            ...i,
            forceOverlayOnly: true
          }));
          if (this._studyBindings) {
            r.push(...this._studyBindings.autoScaleInfos(e, t, i));
          }
          const a = (e, t) => ({
            range: e.range ? t.range ? e.range.merge(t.range) : e.range : t.range,
            topPixelMargin: n(e.topPixelMargin, t.topPixelMargin),
            bottomPixelMargin: n(e.bottomPixelMargin, t.bottomPixelMargin)
          });
          s = r.reduce(a, s);
        }
        return s;
      }
      onChartStyleChanged() {
        this._updateBarFunction();
        if (this.isNeedRestart()) {
          this.data().clear();
          if (!this._saveLeftEdgeIfRequired(false)) {
            this.model().timeScale().scrollToRealtime(false);
          }
          this.restart();
        }
        const e = this.properties();
        if (this._prevChartStyle !== e.childs().style.value()) {
          this._studyBindings?.syncStudy(this.style());
        }
        this._prevChartStyle = e.childs().style.value();
        this._onStyleChanged.fire(e.childs().style.value());
        this.invalidateBarStylesCache();
        this._updateLastPriceAnimationActive();
        if (this._styleToRecover?.originalStyle !== this.style()) {
          this._styleToRecover = null;
        }
        this._updateTimeScaleTimePointWeights();
      }
      setChartStyleWithIntervalIfNeeded(e, t) {
        const i = this.interval();
        const s = t ?? (0, wt.getResolutionByChartStyle)(e, i, this._model.defaultResolutions());
        const o = Z.Interval.isEqual(s, i);
        this.setSymbolParams({
          interval: o ? undefined : s,
          style: e
        });
      }
      getInputsProperties() {
        const e = this._properties.child(`${this.getStyleShortName()}Style`);
        return e?.childs().inputs ?? new p.Property();
      }
      getInputsInfoProperties() {
        const e = this._studyBindings?.getInputsInfoProperties();
        if (e) {
          return e;
        }
        const t = this._properties.child(`${this.getStyleShortName()}Style`);
        return t?.childs().inputInfo ?? new p.Property();
      }
      getSourceIcon() {
        return {
          type: "loadSvg",
          svgId: `series.${this.style()}`
        };
      }
      onSourceIconChanged() {
        return this._onStyleChanged;
      }
      purgeSymbolInfo() {
        this._symbolInfo.setValue(null);
      }
      idForAlert() {
        return super.idForAlert();
      }
      hasStateForAlert() {
        return false;
      }
      stateForAlert() {
        throw new Error("Not implemented");
      }
      styleStudyInfos() {
        return {
          haStyle: this._haStyle,
          renkoStyle: this._renkoStyle,
          pbStyle: this._pbStyle,
          kagiStyle: this._kagiStyle,
          pnfStyle: this._pnfStyle,
          rangeStyle: this._rangeStyle,
          volFootprintStyle: this._volFootprintStyle,
          tpoStyle: this._tpoStyle,
          svpStyle: this._svpStyle
        };
      }
      dataEvents() {
        return this._seriesSource.dataEvents();
      }
      isSpread() {
        return this.symbolInfo()?.type === "spread";
      }
      isYield() {
        const e = this.symbolInfo();
        return e !== null && (0, qt.isYield)(e);
      }
      dividendsAdjustmentProperty() {
        return null;
      }
      sessionIdProxyProperty() {
        return this._sessionIdProxyProperty;
      }
      symbolTextSourceProxyProperty() {
        return this._symbolTextSourceProxyProperty;
      }
      setTextSourceIsAlwaysTickerRestrictionEnabled(e) {
        this._textSourceIsAlwaysTickerRestrictionEnabled = e;
        this._recalcSymbolTextSourceProxyProperty();
      }
      isDWMProperty() {
        return this._isDWMProperty;
      }
      isPrePostMarketPricesAvailableProperty() {
        return this._isPrePostMarketPricesAvailableProperty;
      }
      isSettlementAsCloseForbiddenProperty() {
        return this._isSettlementAsCloseForbiddenProperty;
      }
      isBackAdjustmentForbiddenProperty() {
        return this._isBackAdjustmentForbiddenProperty;
      }
      getStyleShortName() {
        const e = this.style();
        const t = y.STYLE_SHORT_NAMES[e];
        (0, s.assert)(!!t, `Missed short name for style ${e}`);
        return t;
      }
      invalidateBarColorerCache() {
        this._barColorerCache = null;
        this.invalidateBarStylesCache();
      }
      paramsNotApplicableForReplay() {
        throw new Error("Not implemented");
      }
      onTimeFrameApplied() {
        return this._onTimeFrameApplied;
      }
      onInReplayStateChanged() {
        throw new Error("Not implemented");
      }
      onReplayModified() {
        throw new Error("Not implemented");
      }
      dataWindowView() {
        return this._dataWindowView;
      }
      statusView() {
        if (ii) {
          return this._statusView;
        } else {
          return null;
        }
      }
      legendView() {
        return this._legendView;
      }
      marketStatusModel() {
        return this._marketStatusModel;
      }
      isMainSeries() {
        return true;
      }
      dataUpdatedModeModel() {
        return this._dataUpdatedModeModel;
      }
      dataProblemModel() {
        return this._dataProblemModel;
      }
      setDefaultTimeframe(e) {
        this._pendingTimeRange = e;
      }
      loadDataTo(e) {
        const t = this._properties.childs().interval.value();
        this._onTimeFrameApplied.fire(e);
        this._seriesSource.modifySeries(this._getResolvingSymbolObject(), (0, Ct.getServerInterval)(t), e);
      }
      isInReplay() {
        return this._isInReplay;
      }
      quotes() {
        if (this.data().isEmpty()) {
          return null;
        } else {
          return this._quotesProvider.quotes();
        }
      }
      base() {
        return this._base;
      }
      pointValue() {
        return this._pointValue;
      }
      barCloseTime() {
        return this._lastBarCloseTime;
      }
      priceSource() {
        let e = null;
        const t = this._properties.childs();
        switch (t.style.value()) {
          case 2:
            e = t.lineStyle.childs().priceSource.value();
            break;
          case 18:
            e = t.tpoStyle.childs().priceSource.value();
            break;
          case 14:
            e = t.lineWithMarkersStyle.childs().priceSource.value();
            break;
          case 15:
            e = t.steplineStyle.childs().priceSource.value();
            break;
          case 3:
            e = t.areaStyle.childs().priceSource.value();
            break;
          case 10:
            e = t.baselineStyle.childs().priceSource.value();
            break;
          case 13:
            e = t.columnStyle.childs().priceSource.value();
        }
        return e;
      }
      lineColorAtYPercentFromTop(e) {
        let t;
        switch (this.style()) {
          case 2:
            t = this.properties().childs().lineStyle.childs();
            break;
          case 14:
            t = this.properties().childs().lineWithMarkersStyle.childs();
            break;
          case 15:
            t = this.properties().childs().steplineStyle.childs();
            break;
          default:
            t = null;
        }
        if (t) {
          if (t.colorType?.value() === Jt.ColorType.Solid) {
            return t.color.value();
          } else {
            return this._lineColorAtYPercentFromTop.gradientColor((0, s.ensureDefined)(t.gradientStartColor).value(), (0, s.ensureDefined)(t.gradientEndColor).value(), e);
          }
        } else {
          return null;
        }
      }
      updateAllViews(e) {
        if (e.type === "hover-change") {
          return;
        }
        this._paneView?.update(e);
        this._dataWindowView.update();
        this._legendView.update();
        this._statusView.update();
        this._averagePaneViews.forEach(t => t.update(e));
        this._highLowAvgPaneViews.forEach(t => t.update(e));
        this._labelPaneViews.forEach(t => t.update(e));
        this._priceAxisViews.forEach(t => t.update(e));
        this._priceLineAxisViews.forEach(t => t.update(e));
        this._futureBarsPaneView?.update(e);
        this._projectionBarsPaneView?.update(e);
        this._waterlineView?.update(e);
        this._priceLineView?.update(e);
        this._gotoDateView?.update(e);
        this._endOfDataPaneView?.update(e);
        this._baseHorizontalLineView?.update(e);
        const t = this._model.activeStrategySource().value();
        t?.updateAllViews(e);
        this._model.replayStudyStrategy().value()?.updateAllViews(e);
        this._lineStyleLastPriceCirclePaneView.update(e);
        this._studyBindings?.updateAllViews(e);
      }
      styleStudyInfo(e) {
        return this.styleStudyInfos()[e];
      }
      barFunction() {
        return this._barFunction;
      }
      precomputedBarStyle(e) {
        return this._precomputedBarStyles.get(e);
      }
      setPrecomputedBarStyle(e, t) {
        this._precomputedBarStyles.set(e, t);
      }
      symbolParams() {
        return (0, Ze.symbolParams)(this);
      }
      compareSymbolParams(e) {
        return (0, Ze.compareSymbolParams)(this, e, this._model.unitConversionEnabled());
      }
      setSymbolParams(e) {
        const {
          symbol: t,
          currency: i,
          unit: o,
          style: n,
          interval: r
        } = e;
        const {
          symbolChanged: a,
          intervalChanged: l,
          currencyChanged: c,
          unitChanged: h,
          styleChanged: d
        } = this.compareSymbolParams(e);
        const u = [di("symbol", t, a), di("interval", r, l), di("currency", i, c), di("unit", o, h), di("style", n, d)].filter(e => e !== null).join("; ");
        li.logInfo(`Applying series symbol params: ${u}`);
        const _ = this.properties().childs();
        if (t !== undefined) {
          _.symbol.setValue(t);
        }
        if (i !== undefined) {
          _.currencyId.setValue(i);
        }
        if (o !== undefined) {
          _.unitId.setValue(o);
        }
        if (l) {
          _.interval.setValue((0, s.ensureDefined)(r));
        }
        if (n !== undefined && d) {
          _.style.setValue(n);
        }
        let p = false;
        if (d) {
          p = this.isNeedRestart();
          this.onChartStyleChanged();
        }
        let m = Promise.resolve();
        if (!p && (a || l || c || h)) {
          m = this._applySymbolParamsChanges({
            symbolChanged: a,
            currencyChanged: c,
            unitChanged: h,
            intervalChanged: l,
            styleChanged: d
          });
        }
        if (a || c || h) {
          this.model().checkLineToolSelection();
        }
        return m;
      }
      setSymbol(e) {
        this.setSymbolParams({
          symbol: e
        });
      }
      currency() {
        return this.properties().childs().currencyId.value() || null;
      }
      setCurrency(e) {
        this.setSymbolParams({
          currency: e
        });
      }
      isConvertedToOtherCurrency() {
        return (0, m.isConvertedToOtherCurrency)(this.symbolInfo());
      }
      unit() {
        return this.properties().childs().unitId.value() || null;
      }
      setUnit(e) {
        this.setSymbolParams({
          unit: e
        });
      }
      measureUnitId() {
        return (0, m.measureUnitId)(this.symbolInfo());
      }
      isConvertedToOtherUnit() {
        return (0, m.isConvertedToOtherUnit)(this.symbolInfo(), this._model.unitConversionEnabled());
      }
      valueAt(e, t) {
        return this.data().search(e)?.value[t] ?? null;
      }
      symbolSource() {
        return this;
      }
      barsProvider() {
        return this;
      }
      title(e) {
        return this.symbolTitle(e);
      }
      name() {
        return this.symbolTitle($t.TitleDisplayTarget.StatusLine);
      }
      symbolTitle(e, t, i, s = "exchange") {
        let o = this.properties().childs().symbol.value();
        const n = this.symbolInfo();
        if (n !== null) {
          const {
            type: e
          } = n;
          o = (0, m.symbolTitle)(n, t, e === "forex" ? "exchange" : s);
        }
        if (i) {
          return o;
        } else {
          return `${o}, ${(0, P.translatedIntervalString)(this.properties().childs().interval.value())}`;
        }
      }
      setObsoleteZOrder(e) {
        this._obsoleteZOrder = e;
      }
      obsoleteZOrder() {
        return this._obsoleteZOrder;
      }
      legendValuesProvider() {
        return this._legendValuesProvider;
      }
      dataWindowValuesProvider() {
        return this._dataWindowValuesProvider;
      }
      statusProvider(e) {
        return new D(this, this.properties().childs().statusViewStyle, e);
      }
      moveItem(e, t, i) {
        if (this.style() === 10 && t === 0) {
          const t = this.priceScale();
          const i = this.properties().childs().baselineStyle;
          const s = t.height();
          const o = 100 - e.y / s * 100;
          const n = o < 0 ? 0 : Math.round(o * 10) / 10;
          i.childs().baseLevelPercentage.setValue(Math.max(Math.min(n, 100), 0));
        }
      }
      rerequestData() {
        this._applySymbolParamsChanges({
          force: true
        });
      }
      switchToReplay(e, t) {
        throw new Error("Not implemented");
      }
      switchToRealtime() {
        throw new Error("Not implemented");
      }
      async canChangeResolution(e) {
        return true;
      }
      async canChangeSymbol(e) {
        return {
          result: true
        };
      }
      requestMoreDataAvailable() {
        return this._requestMoreDataAvailable;
      }
      seriesLoaded() {
        return this._seriesLoaded;
      }
      endOfData() {
        return this._lastCompleteFlags?.data_completed !== undefined;
      }
      endOfDataType() {
        return this._lastCompleteFlags?.data_completed ?? null;
      }
      dataPoweredBy() {
        return null;
      }
      boxSizeValue() {
        return this._boxSizeValue;
      }
      isUserDeletable() {
        return false;
      }
      changeTimeFrame() {
        (0, o.trackEvent)("GUI", "Change timeframe");
      }
      onTagsChanged() {
        return this._tagsChanged;
      }
      state(e) {
        const t = this.obsoleteZOrder();
        let i = {
          type: "MainSeries",
          id: this.id(),
          zorder: t,
          haStyle: this._haStyle,
          renkoStyle: this._renkoStyle,
          pbStyle: this._pbStyle,
          kagiStyle: this._kagiStyle,
          pnfStyle: this._pnfStyle,
          rangeStyle: this._rangeStyle,
          volFootprintStyle: this._volFootprintStyle,
          tpoStyle: this._tpoStyle,
          svpStyle: this._svpStyle,
          formattingDeps: this._formattingDeps,
          studyBindings: this._studyBindings?.state(!!e)
        };
        const s = this.properties().state(undefined, 2);
        s.symbol = (0, m.symbolToSaveInState)(this.symbolInfo() ?? this._model.chartApi().lastSymbolResolveInfo(s.symbol), s.symbol);
        if (!this._model.unitConversionEnabled()) {
          s.unitId = null;
        }
        i.state = s;
        if (e) {
          let e = this.bars();
          const t = this._model.timeScale().visibleExtendedDataRange(e, 0);
          if (t !== null) {
            e = e.range(t.firstBar(), t.lastBar());
          }
          i = {
            ...i,
            bars: ui(e),
            nsBars: ui(this.nsBars()),
            symbolInfo: this.symbolInfo(),
            rtPrice: this.data().lastProjectionPrice,
            boxSize: this.data().boxSize,
            reversalAmount: this.data().reversalAmount
          };
        }
        return i;
      }
      restoreState(e, t) {
        if (t) {
          this._setStatus(5);
        }
        if (!this._model.unitConversionEnabled() && e.state) {
          delete e.state.unitId;
        }
        if (e.state && Z.Interval.isRange(e.state.interval)) {
          e.state.style = 11;
        }
        const i = e.state;
        if (i !== undefined) {
          const e = i.style;
          const t = undefined;
          if (t && !this._model.isSnapshot()) {
            i.style = 2;
            runOrGoProWithoutSync(() => {
              i.style = e;
            }, t.feature, {
              feature: t.featureName
            });
          }
        }
        this._properties.mergeAndFire(e.state);
        this._prevChartStyle = this.properties().childs().style.value();
        this.createPaneView();
        if (t) {
          const t = e;
          this.restoreData(t.bars, t.nsBars, t.symbolInfo, t.rtPrice, t.boxSize, t.reversalAmount);
        }
        if (e.formattingDeps) {
          this._formattingDeps = e.formattingDeps;
          this._recreatePriceFormattingDependencies();
        }
        this._studyBindings?.restoreState(e.studyBindings ?? {}, t);
        this._studyBindings?.syncStudy(this.style());
      }
      restoreData(e, t, i, s, o, n) {
        this._updateStatus({
          seriesStatus: 5
        });
        this._data = new h.SeriesData();
        this._data.bars().restoreState(e);
        this._data.nsBars().restoreState(t);
        this._updateSymbolInfo(i);
        this._data.lastProjectionPrice = s;
        this._data.boxSize = o;
        const r = this.properties().childs();
        if (!o) {
          if (r.style.value() === 6) {
            this._data.boxSize = r.pnfStyle.childs().inputs.childs().boxSize.value();
          } else if (r.style.value() === 4) {
            this._data.boxSize = r.renkoStyle.childs().inputs.childs().boxSize.value();
          }
        }
        this._data.reversalAmount = n;
        if (!n) {
          if (r.style.value() === 5) {
            this._data.reversalAmount = r.kagiStyle.childs().inputs.childs().reversalAmount.value();
          }
        }
      }
      async setGotoDateResult(e, t) {
        this._gotoDateResultCleared = false;
        const s = await Promise.all([i.e(6778), i.e(4079)]).then(i.bind(i, 40481));
        if (!this._gotoDateResultCleared) {
          this._gotoDateView = new s.GotoDateView(this, e, t);
          this._gotoDateView.doNotShowLastAvailableBar(this._doNotShowLastAvailableBar);
          this._model.updateSource(this);
        }
      }
      clearGotoDateResult() {
        this._gotoDateView = null;
        this._gotoDateResultCleared = true;
      }
      doNotShowLastAvailableBar(e) {
        this._doNotShowLastAvailableBar = e;
        this._gotoDateView?.doNotShowLastAvailableBar(e);
      }
      dataUpdated() {
        return this.dataEvents().dataUpdated();
      }
      moveData(e) {
        this._seriesSource.moveData(e);
        if (this._volumePointWeights !== null) {
          this._volumePointWeights.moveData(e);
        }
      }
      async seriesCreated() {
        const e = this._seriesSource.instanceId();
        if (e !== null) {
          return e;
        }
        const t = await Promise.race([this._deferredDestroyed.promise.then(() => { }), this._model.isSnapshot() ? Promise.resolve(null) : new Promise(e => {
          this.dataEvents().created().subscribe(this, e, true);
        })]);
        if (t === undefined) {
          throw new Error("Series has been destroyed");
        }
        return t;
      }
      activeStudyBinding() {
        return this._studyBindings?.activeStudy() ?? null;
      }
      _updateBarFunction() {
        this._barFunction = (0, zt.barFunctionByStyle)(this.style(), this.priceSource());
      }
      _setProperties(e) {
        if (!e.hasChild("timeframe")) {
          e.merge({
            timeframe: ""
          });
        }
        if (!e.hasChild("shortName")) {
          e.merge({
            shortName: ""
          });
        }
        if (!e.hasChild("currencyId")) {
          e.addChild("currencyId", new p.Property(null));
        }
        if (!e.hasChild("unitId")) {
          e.addChild("unitId", new p.Property(null));
        }
        this._properties = e;
        const t = e.childs();
        t.currencyId.subscribe(this, this._onCurrencyChanged);
        t.unitId.subscribe(this, this._onUnitChanged);
        t.timeframe.subscribe(this, this.changeTimeFrame);
        e.subscribe(this, this._onPropertiesChanged);
      }
      _updateSessionIdProxyProperty(e) {
        const t = this._properties.childs().sessionId.value();
        let i = t;
        if (e) {
          const e = this.symbolInfo();
          if (e !== null) {
            i = e.subsession_id || t;
          }
        }
        this._ignoreSessionIdProxyPropertyChanges = true;
        this._sessionIdProxyProperty.setValue(i);
        this._ignoreSessionIdProxyPropertyChanges = false;
      }
      _onSessionIdProxyPropertyChanged() {
        if (!this._ignoreSessionIdProxyPropertyChanges) {
          this._properties.childs().sessionId.setValue(this._sessionIdProxyProperty.value());
        }
        this._updateLastPriceAnimationActive();
      }
      _onSymbolResolved(e) {
        this._seriesErrorMessage = null;
        this._updateSymbolInfo(e);
        this._model.updateSource(this);
        if (!this._model.onWidget()) {
          (0, o.trackEvent)("Symbol", e.listed_exchange, e.name);
          (0, o.trackEvent)("Symbol Type", e.type, e.listed_exchange);
        }
        const t = e.minmov / e.pricescale;
        const i = this.properties().childs();
        if (i.style.value() === 4 && i.renkoStyle.childs().inputs.childs().boxSize.value() < t) {
          i.renkoStyle.childs().inputs.merge({
            boxSize: t
          });
        } else if (i.style.value() === 6 && i.pnfStyle.childs().inputs.childs().boxSize.value() < t) {
          i.pnfStyle.childs().inputs.merge({
            boxSize: t
          });
        } else if (i.style.value() === 5 && i.kagiStyle.childs().inputs.childs().reversalAmount.value() < t) {
          i.kagiStyle.childs().inputs.merge({
            reversalAmount: t
          });
        }
        this._checkChartStyle();
        this._formattingDeps = {
          format: e.format,
          pricescale: e.pricescale,
          minmov: e.minmov,
          fractional: e.fractional,
          minmove2: e.minmove2,
          variable_tick_size: e.variable_tick_size
        };
      }
      _onSymbolError(e) {
        this._setStatus(4);
        this._properties.childs().shortName.setValue(this._properties.childs().symbol.value());
        this._model.clearAllStudies();
        this.updateAllViews((0, me.sourceChangeEvent)(this.id()));
        this._model.updateSource(this);
        this._symbolResolvingActive.setValue(false);
      }
      _sendTelemetryCounter(e, t) { }
      _getTelemetryAdditionalData(e, t) {
        return {};
      }
      _onSeriesTimeFrame(e, t, i, s, o) {
        const n = (0, m.isSingleValueBasedStyle)(this.style()) ? e + 0.5 : e;
        let r = t;
        if (o === undefined) {
          if (i === null || i.type === "period-back") {
            r += this._model.studyAwareDefaultRightOffset();
          }
        } else if (o.applyDefaultRightMargin) {
          r += this._model.studyAwareDefaultRightOffset();
        } else if (o.percentRightMargin) {
          const e = t - n + 1;
          const i = Math.max(0, Math.min(0.99, o.percentRightMargin / 100));
          r += i * e / (1 - i);
        }
        this._model.setTimeViewport(n, r);
      }
      _onSeriesError(e) {
        let t = e.error;
        const i = e.ctx;
        if (i) {
          const e = {};
          Object.keys(i).forEach(t => {
            e[t] = i[t].toString();
          });
          t = t.format(e);
        }
        if (ri) {
          li.logNormal("Error reason: " + t);
        }
        this._seriesErrorMessage = decodeURIComponent(t.split(":", 2)[0]);
        const s = t !== "unknown_symbol" ? 12 : ni && this.symbolInfo() ? 10 : 4;
        this._setStatus(s);
        this._seriesLoaded = true;
        this._enablePriceRangeReady();
      }
      _onSeriesLoading(e) {
        this._setStatus(2);
      }
      _onDataUpdated(e, t, i, o) {
        this.symbolInfo();
        if (this._volumePointWeights !== null) {
          const e = t ? this.bars().fullRangeIterator() : i ? this.bars().rangeIterator(i.index, (0, s.ensureNotNull)(this.bars().lastIndex())) : null;
          if (e !== null) {
            for (const t of e) {
              this._volumePointWeights.setVolume(t.index, t.value[5]);
            }
          }
        }
        if (t) {
          this._requestMoreDataAvailable = true;
        } else if (this._lastPriceAnimationActive && this._seriesLoaded) {
          this._lineStyleLastPriceCirclePaneView.update((0, me.sourceChangeEvent)(this.id()));
        }
        this._lastBarCloseTime = e && e.closeTime || null;
        this._boxSizeValue.setValue(this.data().boxSize);
        this._statusView.update();
        this.clearAveragePriceCache();
        this.clearHighLowPriceCache();
        const n = this.model();
        const r = (0, s.ensureNotNull)(n.paneForSource(this));
        n.recalculatePane(r, (0, me.sourceChangeEvent)({
          sourceId: this.id(),
          realtime: !t,
          firstUpdatedTimePointIndex: i?.index ?? undefined
        }));
        n.updateSource(this);
      }
      _setStatus(e) {
        const t = {
          ...this._status.value(),
          seriesStatus: e
        };
        this._updateStatus(t);
        this._statusView.update();
        this.model().updateSource(this);
        this._onStatusChanged.fire();
      }
      _onBarReceived(e) {
        this.model().recalcVisibleRangeStudies(c.RecalcVisibleRangeStudiesReason.DataUpdate);
      }
      _onUnsupportedResolutionRequested() {
        const e = (0, s.ensureNotNull)(this._getStateForUnsupportedResolution());
        this._seriesErrorMessage = e.reason;
        this._unsupportedResolutionState.setValue(e);
        this._setStatus(14);
        this._seriesLoaded = true;
        this._seriesSource.clearData();
        this._model.timeScale().points().clear();
        this._enablePriceRangeReady();
      }
      _getStateForUnsupportedResolution() {
        const e = this.symbolInfo();
        if (e === null) {
          return null;
        }
        const t = this.interval();
        const i = (0, I.getResolutionUnsupportedReason)(e, t);
        if (i === null) {
          return null;
        }
        const o = e.name;
        if (i !== "less_than_frequency") {
          let s = ["D", "W", "M"];
          s = e.supported_resolutions;
          return {
            ticker: o,
            reason: i,
            unsupportedResolution: t,
            applicableResolution: s[0],
            supportedResolutions: s
          };
        }
        {
          const n = (0, s.ensureDefined)(e.data_frequency);
          let r = (0, wt.getApplicableIntervalForFrequency)(n, t);
          this._model.defaultResolutions();
          return {
            ticker: o,
            reason: i,
            applicableResolution: r,
            unsupportedResolution: t,
            supportedResolutions: []
          };
        }
      }
      _recreateFormatter() {
        let e = null;
        e = Gt.customFormatters?.priceFormatterFactory?.(this.symbolInfo(), this.properties().childs().minTick.value()) ?? null;
        if (e !== null) {
          this._formatter = e;
          this._ignoreMinMoveFormatter = e;
        } else {
          this._defaultFormatter = (0, m.createSeriesFormatter)(this.symbolInfo() ?? this._formattingDeps, "default");
          this._formatter = (0, m.createSeriesFormatter)(this.symbolInfo() ?? this._formattingDeps, this.properties().childs().minTick.value());
          this._ignoreMinMoveFormatter = (0, m.createSeriesFormatter)(this.symbolInfo(), this.properties().childs().minTick.value(), true);
        }
        this._priceScale?.updateFormatter();
        this._formatterChanged.fire();
      }
      _recreatePriceStep() {
        const {
          minMove: e,
          priceScale: t
        } = (0, m.getSeriesPriceFormattingState)(this.symbolInfo());
        const i = e / t;
        this._ignoreMinMovePriceStep = 1 / t;
        if (this._priceStep !== i) {
          this._priceStep = i;
          this._priceStepChanged.fire();
        }
      }
      _recreatePriceFormattingDependencies() {
        this._recreateFormatter();
        this._recreatePriceStep();
      }
      _onQuotesUpdate(e, t) {
        if (e.values.current_session !== undefined && e.values.current_session !== this._currentSession) {
          this._currentSession = e.values.current_session;
          this._updateLastPriceAnimationActive();
        }
      }
      _updateIsPrePostMarketPricesForbiddenProperty() {
        const e = this.symbolInfo();
        const t = (0, m.symbolHasPreOrPostMarket)(e) && (this.isDWM() || !!e && (0, m.isRegularSessionId)(this.sessionIdProxyProperty().value(), e));
        this._isPrePostMarketPricesAvailableProperty.setValue(t);
      }
      _updateSettlementAsCloseForbiddenProperty() { }
      _updateBackAdjustmentForbiddenProperty() { }
      _removeReplaySubscriber() {
        throw new Error("Not implemented");
      }
      _getSymbolForApi() {
        return this.symbol();
      }
      _getSymbolObject(e) {
        const t = this._getExtendedSymbolObject(e);
        const i = this.properties().childs().style.value();
        if (y.SYMBOL_STRING_DATA.hasOwnProperty(i) && !y.chartStylesWithAttachedStudies.includes(i)) {
          return {
            symbol: t,
            type: this.styleStudyInfo(this.getStyleShortName() + "Style").studyId + "!",
            inputs: this.getInputsProperties().state()
          };
        }
        return t;
      }
      _getExtendedSymbolObject(e) {
        const t = {
          symbol: e ?? this._getSymbolForApi()
        };
        const i = this.properties().childs();
        if (this.currency() !== null) {
          t["currency-id"] = this.currency();
        }
        const s = this.unit();
        if (this._model.unitConversionEnabled() && s !== null) {
          t["unit-id"] = s;
        }
        if (!this.isDWM() && ci) {
          t.session = i.sessionId.value();
        }
        return t;
      }
      _checkChartStyle() {
        const e = this.style();
        if ((0, m.isCloseBasedSymbol)(this.symbolInfo()) || this.intervalObj().is1Tick()) {
          if (!(0, m.isSingleValueBasedStyle)(e)) {
            this.requestingStyleIsNotSupported.fire();
            this._styleToRecover = {
              correctedStyle: this.style(),
              originalStyle: e
            };
          }
        } else if (this._styleToRecover !== null) {
          this.requestingStyleSupportRecovered.fire(this._styleToRecover.originalStyle);
          this._styleToRecover = null;
        }
      }
      _updateSymbolInfo(e) {
        this._symbolInfo.setValue(e);
        if (e) {
          const t = this._properties.childs();
          t.shortName.setValue(e.name);
          const i = (0, m.extractSymbolNameFromSymbolInfo)(e, this.symbol());
          if (i) {
            t.symbol.setValue(i);
          }
          const s = (0, m.symbolCurrency)(e);
          const o = (0, m.symbolUnit)(e, this._model.unitConversionEnabled());
          if ((0, Y.currencyUnitVisibilityProperty)().value() !== "alwaysOff" && (s !== t.currencyId.value() || o !== t.unitId.value())) {
            this._model.fullUpdate();
          }
          t.currencyId.setValue(s);
          t.unitId.setValue(o);
          this._updateSessionIdProxyProperty(true);
        }
        this._base = e ? e.pricescale / e.minmov : 100;
        this._pointValue = e && e.pointvalue || 1;
        const t = (0, Xe.encodeExtendedSymbolOrGetSimpleSymbolString)(this._getExtendedSymbolObject());
        this._quotesProvider.setQuotesSessionSymbol(t);
        this._marketStatusModel.setSymbolInfo(e);
        if (e) {
          this._recreatePriceFormattingDependencies();
        }
        this._statusView.update();
        this.priceScale().updateFormatter();
        this._symbolResolvingActive.setValue(!e);
        if (ci) {
          this._updateIsPrePostMarketPricesForbiddenProperty();
        }
      }
      _createHighLowAvgViews() {
        const e = this.properties().childs().highLowAvgPrice;
        const t = this._getHighLowPrice.bind(this);
        const i = function (e, t, i, s) {
          const o = i.childs();
          const n = Re(e, t, {
            label: Be,
            labelVisible: o.highLowPriceLabelsVisible,
            lineVisible: o.highLowPriceLinesVisible,
            lineColor: o.highLowPriceLinesColor,
            lineWidth: o.highLowPriceLinesWidth
          }, () => s(0));
          const r = Re(e, t, {
            label: Ve,
            labelVisible: o.highLowPriceLabelsVisible,
            lineVisible: o.highLowPriceLinesVisible,
            lineColor: o.highLowPriceLinesColor,
            lineWidth: o.highLowPriceLinesWidth
          }, () => s(1));
          return {
            paneViews: [n.paneView, r.paneView],
            panePriceAxisViews: [n.panePriceAxisView, r.panePriceAxisView],
            priceAxisViews: [n.priceAxisView, r.priceAxisView],
            priceLineAxisViews: [n.priceLineAxisView, r.priceLineAxisView]
          };
        }(this._model, this, e, t);
        this._highLowAvgPaneViews.push(...i.paneViews);
        this._labelPaneViews.push(...i.panePriceAxisViews);
        this._priceAxisViews.push(...i.priceAxisViews);
        this._priceLineAxisViews.push(...i.priceLineAxisViews);
      }
      _createAverageViews() {
        const e = this.properties().childs().highLowAvgPrice;
        const t = this._getAveragePrice.bind(this);
        const i = je(this._model, this, e, t);
        this._averagePaneViews.push(...i.paneViews);
        this._labelPaneViews.push(...i.panePriceAxisViews);
        this._priceAxisViews.push(...i.priceAxisViews);
        this._priceLineAxisViews.push(...i.priceLineAxisViews);
      }
      _getHighLowPrice(e) {
        if (!this._highLowPriceCache.has(e)) {
          const e = this._model.timeScale().visibleBarsStrictRange();
          if (e === null) {
            return null;
          }
          const t = function (e, t, i) {
            return e.minMaxOnRangeCached(t, i, [{
              name: "low",
              offset: 0
            }, {
              name: "high",
              offset: 0
            }]);
          }(this._model.mainSeries().bars(), e.firstBar(), e.lastBar());
          if (t === null) {
            return null;
          }
          this._highLowPriceCache.set(1, t.min);
          this._highLowPriceCache.set(0, t.max);
        }
        return this._highLowPriceCache.get(e);
      }
      _getAveragePrice(e) {
        if (!this._averagePriceCache.has(e)) {
          const e = this._model.timeScale().visibleBarsStrictRange();
          if (e === null) {
            return null;
          }
          const t = function (e, t, i) {
            0;
            const s = (0, h.barFunction)("close");
            let o = 0;
            let n = 0;
            for (let r = t; r <= i; r++) {
              const t = e.valueAt(r);
              if (t !== null) {
                o += s(t);
                n++;
              }
            }
            if (n) {
              return o / n;
            } else {
              return null;
            }
          }(this._model.mainSeries().bars(), e.firstBar(), e.lastBar());
          if (t === null) {
            return null;
          }
          this._averagePriceCache.set(0, t);
        }
        return this._averagePriceCache.get(e);
      }
      _updateCompleteStatusMode(e) {
        switch (e = e === "pulsed" ? "delayed" : e) {
          case "streaming":
            this._setStatus(3);
            break;
          case "endofday":
            this._setStatus(6);
            break;
          case "delayed":
            this._setStatus(8);
            break;
          case "replay":
            this._setStatus(11);
        }
        if (e.match(/delayed_streaming/)) {
          this._setStatus(9);
        }
      }
      _onSeriesCompleted(e) {
        if (this._status.value().seriesStatus === 14) {
          return;
        }
        this._seriesErrorMessage = null;
        this._updateCompleteStatusMode(e.updateMode);
        this._lastCompleteFlags = e.flags ?? null;
        const t = (0, s.ensureNotNull)(this._model.paneForSource(this));
        t.recalculatePriceScale(this.priceScale(), (0, me.sourceChangeEvent)(this.id()));
        const i = at.InvalidationMask.full();
        if (this._model.appliedTimeFrame().value() !== null) {
          i.lockVisibleTimeRangeOnResize();
        }
        this._model.invalidate(i);
        if (!!this.priceScale().isLockScale() && !this.model().timeScale().isEmpty() && !this._seriesLoaded) {
          this.model().timeScale().correctOffset();
          this.model().timeScale().correctBarSpacing();
          this.model().resetPriceScale(t, this.priceScale());
        }
        this._seriesLoaded = true;
        this._seriesCompleted = true;
        this.model().recalcVisibleRangeStudies(c.RecalcVisibleRangeStudiesReason.SeriesCompleted);
        this.model().recalcStudyBasedLineTools();
        if (this._savedLeftEdge !== null && this._status.value().seriesStatus !== 2) {
          const e = this._savedLeftEdge * 1000;
          const t = this._pendingScrollToLeftEdge;
          setTimeout(() => {
            this._model.syncTimeWithModel((0, s.ensureNotNull)(this.syncModel()).syncSourceTarget(), e, {
              targetPointAlignment: "left",
              alignIfTargetPointIsVisible: true,
              autoscaleAfterScroll: false
            }).then(() => {
              t?.resolve();
            }).catch(() => { });
          }, 0);
          this._savedLeftEdge = null;
          this._pendingScrollToLeftEdge = null;
        }
        this._enablePriceRangeReady();
      }
      _notifyIntervalChanged(e) {
        const t = {
          timeframe: this._pendingTimeRange ?? undefined
        };
        this._intervalChanged.fire(e, t);
        this._pendingTimeRange = t.timeframe ?? null;
      }
      _onCurrencyChanged() {
        this._currencyChanged.fire();
      }
      _onUnitChanged() {
        this._unitChanged.fire();
      }
      _saveLeftEdgeIfRequired(e, t = null) {
        this._savedLeftEdge = null;
        if (!t && !e && this._model.properties().childs().scalesProperties.childs().saveLeftEdge.value()) {
          const e = this._model.timeScale();
          if (!e.isEmpty()) {
            let t = e.visibleBarsStrictRange()?.firstBar();
            if (t !== undefined) {
              const i = this._seriesSource.data()?.bars().first();
              if (i != null) {
                t = Math.max(t, i.index);
              }
              this._savedLeftEdge = e.indexToTimePoint(t);
              this._pendingScrollToLeftEdge = (0, a.createDeferredPromise)();
              return true;
            }
          }
        }
        return false;
      }
      async _processReplayOnApplySymbolParamsChanges(e, t) { }
      async _applySymbolParamsChanges(e) {
        this._lastCompleteFlags = null;
        this.clearGotoDateResult();
        const t = this.interval();
        this.currency();
        this.unit();
        if (Z.Interval.isRange(t)) {
          this._properties.childs().rangeStyle.childs().inputs.childs().range.setValue(Z.Interval.parse(t).multiplier());
        }
        const {
          symbolChanged: i,
          intervalChanged: s,
          currencyChanged: o,
          unitChanged: n,
          force: r
        } = e;
        const a = ci && s && Z.Interval.parse(t).isDWM() != Z.Interval.parse(t).isDWM();
        this._syncModel = null;
        this._prevRequestedInterval = t;
        if (this._status.value().seriesStatus !== 5 && (!this._seriesSource.isStarted() || i || o || n || a)) {
          this._updateSymbolInfo(null);
        }
        this._processReplayOnApplySymbolParamsChanges(!!s, t);
        if (this._status.value().seriesStatus === 5) {
          this._model.realignLineTools();
          return;
        }
        this._setStatus(1);
        if (ci) {
          this._updateIsPrePostMarketPricesForbiddenProperty();
        }
        this._symbolIntervalChanged.fire();
        if (s) {
          this._notifyIntervalChanged(t);
        }
        this._onRestarted.fire();
        this._seriesLoaded = false;
        this._seriesCompleted = false;
        this._lineStyleLastPriceCirclePaneView.stopAnimation();
        let l = null;
        if (this._pendingTimeRange) {
          l = this._pendingTimeRange;
          this._pendingTimeRange = null;
        }
        this._onTimeFrameApplied.fire(l);
        this._onBeforeModifySeries(this.getSymbolString(), t);
        const h = this._shouldDefineNumberOfBarsForModifySeries(e) && this._visibleBarsCount() || null;
        this.model().recalcVisibleRangeStudies(c.RecalcVisibleRangeStudiesReason.SeriesRestart);
        this._saveLeftEdgeIfRequired(!!i, l);
        this._data = null;
        this._seriesSource.modifySeries(this._getResolvingSymbolObject(), (0, Ct.getServerInterval)(t), l, r, h);
        if (!this._seriesSource.isStarted()) {
          this._predictBars = 0;
          this._seriesSource.start();
        }
        if (i || o || n) {
          this.disablePriceRangeReady();
        }
        this.updateAllViews((0, me.sourceChangeEvent)(this.id()));
        this._model.lightUpdate();
        if (this._pendingScrollToLeftEdge) {
          await this._pendingScrollToLeftEdge.promise;
        }
      }
      async _onBeforeModifySeries(e, t) {
        const i = null;
        i?.modifySeries(e, t);
      }
      _getResolvingSymbolObject() {
        let e = this._getSymbolObject(this._symbolForResolve());
        const t = null;
        if (t) {
          e = t.generateReplaySymbol(e);
        }
        return e;
      }
      _onSessionIdPropertyChanged() {
        this._sessionIdChanged.fire();
        if (!this.isDWM()) {
          this._saveLeftEdgeIfRequired(false);
          this.restart(this._properties.childs().sessionId, "sessionId", true);
          this._updateLastPriceAnimationActive();
        }
      }
      _subscribeRestartToSessionIdChange() {
        this.properties().childs().sessionId.subscribe(this, this._onSessionIdPropertyChangedBound);
      }
      _unsubscribeRestartToSessionIdChange() {
        this.properties().childs().sessionId.unsubscribe(this, this._onSessionIdPropertyChangedBound);
      }
      _updateLastPriceAnimationActive() {
        if (!this._options.lastPriceAnimationEnabled || b.enabled("disable_pulse_animation")) {
          return;
        }
        const e = this._lastPriceAnimationActive;
        const t = this.properties().childs();
        const i = t.style.value();
        const s = i === 3 || i === 10 || i === 2 || i === 14 || i === 15;
        const o = this.symbolInfo();
        if (!this._model.isSnapshot() && t.visible.value() && s && o) {
          const e = this.currentSession();
          const t = !(0, m.isRegularSessionId)(this.sessionIdProxyProperty().value(), o) && !this.isDWM();
          this._lastPriceAnimationActive = e === "market" || t && (e === "pre_market" || e === "post_market");
        } else {
          this._lastPriceAnimationActive = false;
        }
        if (this._lastPriceAnimationActive && e !== this._lastPriceAnimationActive) {
          this.model().invalidate(at.InvalidationMask.cursor());
        }
      }
      _onPropertiesChanged(e) {
        const t = this._properties.childs();
        if (e === t.symbol || e === t.interval || e === t.timeframe) {
          return;
        }
        const i = this._id.value();
        this._tagsChanged.fire();
        this.createPaneView();
        this.updateAllViews((0, me.sourceChangeEvent)(i));
        this.model().updateSource(this);
        (0, n.emit)("series_properties_changed", i);
      }
      _recalcSymbolTextSourceProxyProperty() {
        if (this._textSourceIsAlwaysTickerRestrictionEnabled) {
          this._symbolTextSourceProxyProperty.setValue("ticker");
        } else {
          this._symbolTextSourceProxyProperty.setValue(this._properties.childs().statusViewStyle.childs().symbolTextSource.value());
        }
      }
      _clearStylePlot(e, t) {
        if (e.size() === 0) {
          return;
        }
        if (t === undefined && e !== this.nsBars()) {
          this._precomputedBarStyles = new WeakMap();
          return;
        }
        const i = t ?? (0, s.ensureNotNull)(e.firstIndex());
        const o = (0, s.ensureNotNull)(e.lastIndex()) + 1;
        e.range(i, o).each((e, t) => {
          this._precomputedBarStyles.delete(t);
          return false;
        });
      }
      _visibleBarsCount() {
        const e = this._model.timeScale().visibleBarsStrictRange();
        return e?.count();
      }
      _symbolForResolve() {
        const e = this.symbol();
        if (this._seriesSource.symbolSameAsResolved(e)) {
          return this._seriesSource.resolvedSymbol() ?? e;
        } else {
          return e;
        }
      }
      _shouldDefineNumberOfBarsForModifySeries(e) {
        return b.enabled("request_only_visible_range_on_reset") && e.force || false;
      }
      _onShowCountdownChanged(e) {
        if (e.value()) {
          this._countdownUpdateTimer = this._model.setInterval(() => {
            this._priceAxisView.updateCountdown?.();
            this._projectionPriceAxisView.updateCountdown?.();
          }, 500);
        } else if (this._countdownUpdateTimer !== null) {
          this._model.clearInterval(this._countdownUpdateTimer);
          this._countdownUpdateTimer = null;
        }
      }
      _onFormatterPropsChanged() {
        this._recreateFormatter();
        this._model.fullUpdate();
      }
      _updateStatus(e) {
        if (e.seriesStatus !== 14) {
          this._unsupportedResolutionState.setValue(null);
        }
        this._status.setValue(e);
      }
      _wasCompletedBefore() {
        return this.isCompleted() && (this._studyBindings?.wasCompletedBefore() ?? true);
      }
      _updateTpoSummary() {
        if (this._model.isInRestoreState()) {
          return;
        }
        const e = this._model.dataSourceForId(tpoSummaryDataSourceId);
        if (this.style() !== 18 || !isFeatureEnabled("tpo_summary")) {
          if (e) {
            this._model.removeSource(e);
          }
          return;
        }
        const t = this._properties.childs().tpoStyle.childs().summary.childs().visible.value();
        if (t && !e) {
          const e = (0, s.ensureNotNull)(this._model.paneForSource(this));
          const t = this._model.panes().indexOf(e);
          this._model.createPane(t + 1, undefined, undefined, bt.PaneMode.Widget).insertDataSource(new TpoSummaryDataSource(this._model), null, 0);
        } else if (!t && e) {
          this._model.removeSource(e);
        }
      }
    }
  },
  84626: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesAreaPaneView: () => l
    });
    var s = i(19063);
    var o = i(2271);
    var n = i(95201);
    var r = i(11064);
    var a = i(36897);
    class l extends a.SeriesSingleLinePaneView {
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        const e = this._source.priceScale();
        if (!e) {
          return null;
        }
        const t = this._source.properties().childs().areaStyle.childs();
        const i = t.transparency.value();
        const a = {
          simpleMode: false,
          barSpacing: this._model.timeScale().barSpacing(),
          items: this._items,
          lineColor: t.linecolor.value(),
          lineStyle: t.linestyle.value(),
          lineWidth: t.linewidth.value(),
          isSeries: true,
          withMarkers: false,
          bottom: e.height(),
          color1: (0, s.generateColor)(t.color1.value(), i),
          color2: (0, s.generateColor)(t.color2.value(), i),
          skipHoles: true
        };
        const l = new n.CompositeRenderer();
        l.append(new o.PaneRendererArea(a));
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
          l.append(new r.SelectionRenderer(this._selectionData));
        }
        return l;
      }
    }
  },
  59432: (e, t, i) => {
    "use strict";

    i.d(t, {
      PaneRendererBars: () => n
    });
    var s = i(61993);
    var o = i(3774);
    class n extends o.PaneRendererSeriesBase {
      constructor(e) {
        super();
        this._bars = e.bars;
        this._dontDrawOpen = e.dontDrawOpen;
        this._thinBars = e.thinBars;
      }
      _drawImpl(e) {
        const {
          context: t,
          horizontalPixelRatio: i,
          verticalPixelRatio: s
        } = e;
        t.save();
        let o = null;
        for (const e of this._bars) {
          let n = this._calcRealBarWidth(e.right - e.left, i);
          if (n >= 2) {
            if (Math.max(1, Math.floor(i)) % 2 != n % 2) {
              n--;
            }
          }
          const r = this._thinBars ? Math.min(n, Math.floor(i)) : n;
          const a = r <= n && e.right - e.left >= Math.floor(i * 1.5);
          if (o !== e.color) {
            t.fillStyle = e.color;
            o = e.color;
          }
          const l = Math.floor(r * 0.5);
          const c = Math.round(e.center * i);
          const h = c - l;
          const d = r;
          const u = h + d - 1;
          const _ = Math.min(e.high, e.low);
          const p = Math.max(e.high, e.low);
          const m = Math.round(_ * s) - l;
          const g = Math.round(p * s) + l;
          const f = Math.max(g - m, r);
          t.fillRect(h, m, d, f);
          const y = Math.ceil(n * 1.5);
          if (a) {
            const i = c - y;
            const o = c + y;
            const n = Math.min(h - i, o - u);
            if (!this._dontDrawOpen) {
              let o = Math.max(m, Math.round(e.open * s) - l);
              let r = o + d - 1;
              if (r > m + f - 1) {
                r = m + f - 1;
                o = r - d + 1;
              }
              t.fillRect(i, o, n, r - o + 1);
            }
            let r = Math.max(m, Math.round(e.close * s) - l);
            let a = r + d - 1;
            if (a > m + f - 1) {
              a = m + f - 1;
              r = a - d + 1;
            }
            t.fillRect(u + 1, r, n, a - r + 1);
          }
        }
        t.restore();
      }
      _getTolerance() {
        return (0, s.interactionTolerance)().series;
      }
      _calcRealBarWidth(e, t) {
        const i = Math.floor(t);
        return Math.max(i, Math.floor((0, s.optimalBarWidth)(e, t)));
      }
    }
  },
  99800: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesBarsPaneView: () => a
    });
    var s = i(95201);
    var o = i(11064);
    var n = i(24997);
    var r = i(59432);
    class a extends n.SeriesBarCandlesPaneView {
      renderer() {
        if (this._invalidated) {
          this._updateImpl(null);
          this._invalidated = false;
        }
        const e = this._source.properties().childs();
        const t = {
          bars: this._bars,
          dontDrawOpen: e.barStyle.childs().dontDrawOpen.value(),
          thinBars: e.style.value() === 11 ? e.rangeStyle.childs().thinBars.value() : e.barStyle.childs().thinBars.value()
        };
        const i = new s.CompositeRenderer();
        i.append(new r.PaneRendererBars(t));
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
          i.append(new o.SelectionRenderer(this._selectionData));
        }
        return i;
      }
      _createItem(e, t, i) {
        const s = {
          center: NaN,
          open: NaN,
          high: NaN,
          low: NaN,
          close: NaN,
          color: i.barColor,
          left: NaN,
          right: NaN,
          timePointIndex: e
        };
        if ((0, n.baseBarCandlesUpdater)(t, s)) {
          return s;
        } else {
          return null;
        }
      }
    }
  },
  93250: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesBaselinePaneView: () => g
    });
    var s;
    var o = i(19063);
    var n = i(95201);
    var r = i(86441);
    var a = i(5531);
    var l = i(4652);
    var c = i(61993);
    var h = i(29981);
    var d = i(75919);
    var u = i(56468);
    (function (e) {
      e[e.Top = 0] = "Top";
      e[e.Bottom = 1] = "Bottom";
    })(s ||= {});
    class _ extends d.MediaCoordinatesPaneRenderer {
      constructor() {
        super(...arguments);
        this._data = null;
      }
      setData(e) {
        this._data = e;
      }
      hitTest(e) {
        if (this._data === null) {
          return null;
        }
        const {
          items: t,
          topLineWidth: i,
          bottomLineWidth: s
        } = this._data;
        const o = (0, c.interactionTolerance)().series + (i + s) / 4;
        const n = (0, h.lowerbound)(t, e, (e, t) => e.center <= t.x);
        const a = Math.max(1, n - 1);
        const d = Math.min(t.length - 1, n + 1);
        for (let i = a; i <= d; ++i) {
          const s = t[i - 1];
          const n = t[i];
          const {
            distance: a
          } = (0, l.distanceToSegment)((0, r.point)(s.center, s.y), (0, r.point)(n.center, n.y), (0, r.point)(e.x, e.y));
          if (a <= o) {
            return new u.HitTestResult(u.HitTarget.Regular);
          }
        }
        return null;
      }
      _drawImpl(e) {
        if (this._data === null) {
          return;
        }
        const {
          items: t,
          baseLevelCoordinate: i,
          bottom: s,
          bottomFillColor1: o,
          bottomFillColor2: n,
          topFillColor1: l,
          topFillColor2: h,
          topLineColor: d,
          bottomLineColor: u,
          topLineWidth: _,
          bottomLineWidth: p
        } = this._data;
        if (!function (e) {
          if (e.length === 0) {
            return false;
          }
          const t = e.findIndex(e => (0, c.coordinateIsValid)(e.y));
          if (t === -1) {
            return false;
          }
          let i = e.length - 1;
          while (i > t && !(0, c.coordinateIsValid)(e[i].y)) {
            i--;
          }
          return !(t > i);
        }(t)) {
          return;
        }
        const m = e.context;
        const {
          topItems: g,
          bottomItems: f
        } = function (e, t) {
          const i = [];
          const s = [];
          let o = null;
          for (let n = 0; n < e.length; n++) {
            let l = e[n];
            const h = e[n + 1] || {};
            if ((0, c.coordinateIsValid)(l.y)) {
              if (l.y <= t) {
                i.push(l);
              }
              if (l.y >= t) {
                s.push(l);
              }
              o = l;
            } else {
              if (o === null) {
                continue;
              }
              l = o;
            }
            if ((0, c.coordinateIsValid)(h.y) && (l.y > t && h.y < t || l.y < t && h.y > t)) {
              if (Math.abs(l.center - h.center) < 1) {
                const e = {
                  center: l.center,
                  y: t
                };
                i.push(e);
                s.push(e);
              } else {
                const e = (0, a.intersectLineSegments)((0, r.point)(l.center, l.y), (0, r.point)(h.center, h.y), (0, r.point)(l.center, t), (0, r.point)(h.center, t));
                if (e !== null) {
                  const t = {
                    center: l.center + (h.center - l.center) * e,
                    y: l.y + (h.y - l.y) * e
                  };
                  i.push(t);
                  s.push(t);
                }
              }
            }
          }
          return {
            topItems: i,
            bottomItems: s
          };
        }(t, i);
        m.lineCap = "round";
        m.lineJoin = "round";
        if (g.length !== 0) {
          m.beginPath();
          m.moveTo(g[0].center, i);
          this._makeLine(m, g, true, 0);
          m.closePath();
          m.fillStyle = this._makeLinearGradient(m, l, h, i - s, i);
          m.fill();
          m.beginPath();
          this._makeLine(m, g, false, 0);
          m.lineWidth = _;
          m.strokeStyle = d;
          m.stroke();
        }
        if (f.length !== 0) {
          m.beginPath();
          m.moveTo(f[0].center, i);
          this._makeLine(m, f, true, 1);
          m.closePath();
          m.fillStyle = this._makeLinearGradient(m, o, n, i, i + s);
          m.fill();
          m.beginPath();
          this._makeLine(m, f, false, 1);
          m.lineWidth = p;
          m.strokeStyle = u;
          m.stroke();
        }
      }
      _makeLine(e, t, i, s) {
        if (this._data === null) {
          return;
        }
        const o = t.findIndex(e => (0, c.coordinateIsValid)(e.y));
        if (o === -1) {
          return;
        }
        const {
          barSpacing: n,
          baseLevelCoordinate: r
        } = this._data;
        const a = n * 0.25;
        let l;
        const h = t.length;
        for (let n = o; n < h; n++) {
          const h = t[n];
          const d = t[n + 1] || {};
          if ((0, c.coordinateIsValid)(h.y)) {
            if (s === 0) {
              if (l && l.y >= r && h.y >= r) {
                e.moveTo(h.center, h.y);
                continue;
              }
            } else if (l && l.y <= r && h.y <= r) {
              e.moveTo(h.center, h.y);
              continue;
            }
            if (l && (0, c.coordinateIsValid)(l.y)) {
              e.lineTo(h.center, h.y);
              if (i && !(0, c.coordinateIsValid)(d.y)) {
                e.lineTo(h.center, r);
              }
            } else if (d && (0, c.coordinateIsValid)(d.y)) {
              if (i) {
                if (n !== o) {
                  e.lineTo(h.center, r);
                }
                e.lineTo(h.center, h.y);
              } else {
                e.moveTo(h.center, h.y);
              }
            } else if (i) {
              if (n === 0) {
                continue;
              }
              if (n !== o) {
                e.lineTo(h.center - a, r);
              }
              e.lineTo(h.center - a, h.y);
              e.lineTo(h.center + a, h.y);
              e.lineTo(h.center + a, r);
            } else {
              e.moveTo(h.center - a, h.y);
              e.lineTo(h.center + a, h.y);
            }
            l = h;
          }
        }
      }
      _makeLinearGradient(e, t, i, s, o) {
        const n = e.createLinearGradient(0, s, 0, o);
        n.addColorStop(0, t);
        n.addColorStop(1, i);
        return n;
      }
    }
    var p = i(11064);
    var m = i(36897);
    class g extends m.SeriesSingleLinePaneView {
      constructor() {
        super(...arguments);
        this._renderer = new _();
        this._topFillColor1 = "";
        this._topFillColor2 = "";
        this._bottomFillColor1 = "";
        this._bottomFillColor2 = "";
        this._topLineColor = "";
        this._bottomLineColor = "";
        this._topLineWidth = 0;
        this._bottomLineWidth = 0;
        this._barSpacing = 0;
        this._bottom = 0;
        this._baseLevelCoordinate = 0;
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        this._renderer.setData({
          items: this._items,
          topFillColor1: this._topFillColor1,
          topFillColor2: this._topFillColor2,
          bottomFillColor1: this._bottomFillColor1,
          bottomFillColor2: this._bottomFillColor2,
          topLineColor: this._topLineColor,
          bottomLineColor: this._bottomLineColor,
          topLineWidth: this._topLineWidth,
          bottomLineWidth: this._bottomLineWidth,
          barSpacing: this._barSpacing,
          baseLevelCoordinate: this._baseLevelCoordinate,
          bottom: this._bottom
        });
        const e = new n.CompositeRenderer();
        e.append(this._renderer);
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
          e.append(new p.SelectionRenderer(this._selectionData));
        }
        return e;
      }
      _updateImpl() {
        super._updateImpl();
        const e = this._source.priceScale();
        if (!e) {
          return;
        }
        const t = this._source.properties().childs().baselineStyle.childs();
        const i = t.transparency.value();
        this._topFillColor1 = (0, o.generateColor)(t.topFillColor1.value(), i);
        this._topFillColor2 = (0, o.generateColor)(t.topFillColor2.value(), i);
        this._bottomFillColor1 = (0, o.generateColor)(t.bottomFillColor1.value(), i);
        this._bottomFillColor2 = (0, o.generateColor)(t.bottomFillColor2.value(), i);
        this._topLineColor = t.topLineColor.value();
        this._bottomLineColor = t.bottomLineColor.value();
        this._topLineWidth = t.topLineWidth.value();
        this._bottomLineWidth = t.bottomLineWidth.value();
        this._barSpacing = this._model.timeScale().barSpacing();
        this._bottom = e.height();
        this._baseLevelCoordinate = Math.round(this._bottom * (Math.abs(100 - t.baseLevelPercentage.value()) / 100));
      }
    }
  },
  12374: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesWaterlinePaneView: () => a
    });
    var s = i(52397);
    var o = i(72791);
    var n = i(56468);
    var r = i(51056);
    class a extends s.HorizontalLinePaneView {
      constructor(e) {
        super();
        this._getters = e;
        const t = {
          cursorType: o.PaneCursorType.VerticalResize,
          activeItem: 0,
          areaName: n.AreaName.SourceItemMove
        };
        this._lineRenderer.setHitTest(new n.HitTestResult(n.HitTarget.MovePoint, t));
        this._lineRendererData.visible = true;
        this._lineRendererData.linestyle = r.LINESTYLE_SPARSE_DOTTED;
      }
      _updateImpl() {
        const {
          baseLevelPercentage: e,
          paneHeight: t,
          color: i
        } = this._getters;
        const s = Math.abs(100 - e());
        this._lineRendererData.y = Math.round(t() * (s / 100));
        this._lineRendererData.color = i();
      }
    }
  },
  3774: (e, t, i) => {
    "use strict";

    i.d(t, {
      PaneRendererSeriesBase: () => n
    });
    var s = i(56468);
    var o = i(30125);
    class n extends o.BitmapCoordinatesPaneRenderer {
      constructor() {
        super(...arguments);
        this._bars = [];
      }
      hitTest(e) {
        const t = this._bars;
        if (t.length === 0) {
          return null;
        }
        const i = this._getTolerance();
        const s = t[0];
        const o = t[t.length - 1];
        if (e.x < s.left - i) {
          return null;
        }
        if (e.x > o.right + i) {
          return null;
        }
        let n = 0;
        let r = t.length - 1;
        let a = -1;
        while (n <= r) {
          const i = Math.floor((n + r) / 2);
          const s = t[i];
          if (e.x >= s.left && e.x <= s.right) {
            a = i;
            break;
          }
          if (e.x > s.right) {
            n = i + 1;
          } else {
            r = i - 1;
          }
        }
        if (a === -1) {
          return null;
        }
        if (this._isPointAtBar(t[a], e.y, i)) {
          return this._getHitTest();
        }
        let l = a;
        while (l >= 1 && e.x - t[l - 1].right < i) {
          l--;
        }
        let c = a;
        while (c <= t.length - 2 && t[c + 1].left - e.x < i) {
          c++;
        }
        const h = Math.max(0, l);
        const d = Math.min(t.length - 1, c);
        for (let s = h; s <= d; s++) {
          if (s !== a && this._isPointAtBar(t[s], e.y, i)) {
            return this._getHitTest();
          }
        }
        return null;
      }
      _getHitTest() {
        return new s.HitTestResult(s.HitTarget.Regular);
      }
      _isPointAtBar(e, t, i) {
        const s = Math.min(e.high, e.low);
        const o = Math.max(e.high, e.low);
        return s - i <= t && t <= o + i;
      }
    }
  },
  25201: (e, t, i) => {
    "use strict";

    i.d(t, {
      PaneRendererCandles: () => h
    });
    var s;
    var o = i(50151);
    var n = i(56468);
    var r = i(37743);
    var a = i(61993);
    var l = i(3774);
    function c(e, t, i, s) {
      const o = Math.floor(t);
      return e.map(e => {
        let n = (0, a.optimalCandlestickWidth)((e.right - e.left) * s, t);
        if (n >= 2 && o % 2 != n % 2) {
          n--;
        }
        const r = Math.floor(n * 0.5);
        const l = function (e, t) {
          let i = Math.floor(t * 1);
          if (e <= i * 2) {
            i = Math.floor((e - 1) * 0.5);
          }
          const s = Math.max(Math.floor(t), i);
          if (e <= s * 2) {
            return Math.max(Math.floor(t), Math.floor(t * 1));
          }
          return s;
        }(n, t);
        const c = Math.round(e.center * t);
        const h = c - r;
        const d = h + n - 1;
        const u = Math.abs(Math.max(e.open, e.close) - Math.min(e.open, e.close)) * i;
        const _ = Math.round(Math.min(e.open, e.close) * i);
        const p = Math.round(Math.max(e.open, e.close) * i);
        let m = Math.min(Math.floor(t), Math.floor(n * t));
        m = Math.max(Math.floor(t), Math.min(m, n));
        const g = Math.floor(m * 0.5);
        return {
          rawBodyHeight: u,
          top: _,
          bottom: p,
          center: c,
          left: h,
          right: d,
          candleWidth: n,
          high: Math.round(e.high * i),
          low: Math.round(e.low * i),
          wickWidth: m,
          wickOffset: g,
          borderWidth: l
        };
      });
    }
    (function (e) {
      e[e.BarBorderWidth = 1] = "BarBorderWidth";
    })(s ||= {});
    class h extends l.PaneRendererSeriesBase {
      constructor(e) {
        super();
        this._scaleCoeff = 1;
        this._borderVisible = false;
        this._wickVisible = false;
        this._bodyVisible = true;
        this._borderColor = undefined;
        this._wickColor = undefined;
        this._hittest = undefined;
        this._isPriceScaleInverted = false;
        if (e) {
          this.setData(e);
        }
      }
      setData(e) {
        this._bars = e.bars;
        this._scaleCoeff = e.scaleCoeff ?? 1;
        this._borderVisible = e.borderVisible;
        this._bodyVisible = e.bodyVisible;
        this._wickVisible = e.wickVisible;
        this._borderColor = e.borderColor;
        this._wickColor = e.wickColor;
        this._hittest = e.hittest;
        this._isPriceScaleInverted = e.isPriceScaleInverted;
      }
      hitTest(e) {
        if (this._wickVisible || this._borderVisible || this._bodyVisible) {
          return super.hitTest(e);
        } else {
          return null;
        }
      }
      _drawImpl(e) {
        const {
          context: t,
          horizontalPixelRatio: i,
          verticalPixelRatio: s
        } = e;
        if (this._bars.length === 0) {
          return;
        }
        const o = c(this._bars, i, s, this._scaleCoeff);
        if (this._wickVisible) {
          this._drawWicks(t, o);
        }
        if (this._borderVisible) {
          this._drawBorder(t, o);
        }
        if (this._bodyVisible) {
          this._drawCandles(t, o);
        }
      }
      _getTolerance() {
        return (0, a.interactionTolerance)().series;
      }
      _getHitTest() {
        return this._hittest || new n.HitTestResult(n.HitTarget.Regular);
      }
      _isPointAtBar(e, t, i) {
        const s = this._bodyVisible || this._borderVisible;
        const o = this._wickVisible;
        if (!s && !o) {
          return false;
        }
        if (s) {
          const s = o ? Math.min(e.high, e.low) : Math.min(e.open, e.close);
          const n = o ? Math.max(e.high, e.low) : Math.max(e.open, e.close);
          return s - i <= t && t <= n + i;
        }
        {
          const s = Math.min(e.open, e.close);
          const o = Math.max(e.open, e.close);
          return e.high - i <= t && t <= s + i || o - i <= t && t <= e.low + i;
        }
      }
      _drawWicks(e, t) {
        let i = "";
        let s = null;
        this._bars.forEach((n, r) => {
          const a = n.wickColor ? n.wickColor : (0, o.ensureDefined)(this._wickColor);
          if (a !== i) {
            e.fillStyle = a;
            i = a;
          }
          let {
            top: l,
            bottom: c
          } = t[r];
          const {
            rawBodyHeight: h,
            borderWidth: d,
            center: u,
            high: _,
            low: p,
            wickWidth: m,
            wickOffset: g
          } = t[r];
          if (this._isPriceScaleInverted) {
            [c, l] = [l, c];
          }
          let f = u - g;
          const y = f + m - 1;
          if (s !== null) {
            f = Math.max(s + 1, f);
            f = Math.min(f, y);
          }
          const v = y - f + 1;
          if (h <= d) {
            if (l !== _) {
              l = Math.round(l - d * 0.5);
            }
            c = c !== p ? Math.round(l - d * 0.5) + d - 1 : p - 1;
          }
          if (l !== _) {
            e.fillRect(f, _, v, l - _);
          }
          if (p - c - 1) {
            e.fillRect(f, c + 1, v, p - c - 1);
          }
          s = y;
        });
      }
      _drawBorder(e, t) {
        let i = "";
        let s = null;
        this._bars.forEach((n, a) => {
          if (n.borderColor !== i) {
            e.fillStyle = n.borderColor ? n.borderColor : (0, o.ensureDefined)(this._borderColor);
            i = n.borderColor;
          }
          if (this._bodyVisible && n.hollow) {
            return;
          }
          let {
            left: l
          } = t[a];
          const {
            rawBodyHeight: c,
            top: h,
            bottom: d,
            right: u,
            borderWidth: _
          } = t[a];
          if (s !== null) {
            l = Math.max(s + 1, l);
            l = Math.min(l, u);
          }
          const p = u - l + 1;
          if (c <= _) {
            e.fillRect(l, Math.round(h - _ * 0.5), p, _);
          } else if (p > _ * 2) {
            (0, r.fillRectInnerBorder)(e, l, h, u - l + 1, d - h + 1, _);
          } else {
            e.fillRect(l, h, p, d - h + 1);
          }
          s = u;
        });
      }
      _drawCandles(e, t) {
        let i = "";
        this._bars.forEach((s, o) => {
          let {
            top: n,
            bottom: a,
            left: l,
            right: c
          } = t[o];
          const {
            rawBodyHeight: h,
            borderWidth: d,
            candleWidth: u
          } = t[o];
          if (!this._borderVisible || !(u <= d * 2) || s.hollow) {
            if (s.color !== i) {
              const t = s.color;
              e.fillStyle = t;
              i = t;
            }
            if (s.hollow) {
              e.fillStyle = s.color;
              if (h <= d) {
                e.fillRect(l, Math.round(n - d * 0.5), u, d);
              } else {
                (0, r.fillRectInnerBorder)(e, l, n, c - l + 1, a - n + 1, d);
              }
            } else {
              if (!this._borderVisible && h <= d) {
                e.fillRect(l, Math.round(n - d * 0.5), u, d);
                return;
              }
              if (this._borderVisible) {
                l += d;
                n += d;
                c -= d;
                a -= d;
              }
              if (n > a) {
                return;
              }
              e.fillRect(l, n, c - l + 1, a - n + 1);
            }
          }
        });
      }
    }
  },
  72476: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesCandlesPaneView: () => l
    });
    var s = i(95201);
    var o = i(61993);
    var n = i(11064);
    var r = i(24997);
    var a = i(25201);
    class l extends r.SeriesBarCandlesPaneView {
      constructor(e, t, i = 1) {
        super(e, t);
        this._scaleCoeff = 1;
        this._scaleCoeff = i;
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl(null);
          this._invalidated = false;
        }
        const e = this._source.priceScale();
        if (!e) {
          return null;
        }
        const t = this._source.properties().childs();
        const i = t.style.value() === 1 ? t.candleStyle.childs() : t.style.value() === 19 ? t.volCandlesStyle.childs() : t.volFootprintStyle.childs();
        const r = this._model.timeScale().barSpacing();
        const l = {
          bars: this._bars,
          barSpacing: r,
          bodyVisible: i.drawBody.value(),
          borderVisible: i.drawBorder.value(),
          borderColor: i.borderColor.value(),
          wickColor: i.wickColor.value(),
          barWidth: (0, o.optimalBarWidth)(r),
          wickVisible: i.drawWick.value(),
          isPriceScaleInverted: e.isInverted(),
          scaleCoeff: this._scaleCoeff
        };
        const c = new s.CompositeRenderer();
        c.append(new a.PaneRendererCandles(l));
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
          c.append(new n.SelectionRenderer(this._selectionData));
        }
        return c;
      }
      _createItem(e, t, i) {
        const s = {
          center: NaN,
          open: NaN,
          high: NaN,
          low: NaN,
          close: NaN,
          left: NaN,
          right: NaN,
          timePointIndex: e,
          color: i.barColor,
          borderColor: i.barBorderColor,
          wickColor: i.barWickColor,
          hollow: i.isBarHollow
        };
        if ((0, r.baseBarCandlesUpdater)(t, s)) {
          return s;
        } else {
          return null;
        }
      }
    }
  },
  53766: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesColumnsPaneView: () => p
    });
    var s = i(50151);
    var o = i(86441);
    var n = i(56570);
    var r = i(69708);
    var a = i(56468);
    var l = i(95201);
    var c = i(8025);
    var h = i(66540);
    var d = i(11064);
    var u = i(81368);
    var _ = i(49256);
    class p {
      constructor(e, t) {
        this._items = [];
        this._invalidated = true;
        this._isMarkersEnabled = (0, n.enabled)("source_selection_markers");
        this._selectionData = null;
        this._histogramBase = 0;
        this._source = e;
        this._model = t;
        this._selectionIndexer = new h.SelectionIndexes(t.timeScale());
      }
      update() {
        this._invalidated = true;
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        const e = {
          barSpacing: this._model.timeScale().barSpacing(),
          items: this._items,
          lineColor: "",
          histogramBase: this._histogramBase
        };
        const t = new l.CompositeRenderer();
        t.append(new u.PaneRendererColumns(e));
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
          t.append(new d.SelectionRenderer(this._selectionData));
        }
        return t;
      }
      _updateImpl() {
        this._items = [];
        const e = this._model.timeScale();
        const t = this._source.priceScale();
        if (e.isEmpty() || !t || t.isEmpty()) {
          return;
        }
        const i = e.visibleBarsStrictRange();
        if (i === null) {
          return;
        }
        if (this._source.bars().size() === 0) {
          return;
        }
        const n = this._source.nearestIndex(i.firstBar(), c.PlotRowSearchMode.NearestRight);
        const l = this._source.nearestIndex(i.lastBar(), c.PlotRowSearchMode.NearestLeft);
        if (n === undefined || l === undefined) {
          return;
        }
        const h = this._source.barColorer();
        const d = {};
        const u = this._source.barFunction();
        for (const {
          index: e,
          value: t
        } of this._source.bars().rangeIterator(n, l)) {
          const i = u(t);
          if (!(0, r.default)(i)) {
            continue;
          }
          d.value = t;
          let s = this._source.precomputedBarStyle(t);
          if (s === undefined) {
            s = h.barStyle(e, false, d);
            this._source.setPrecomputedBarStyle(t, s);
          }
          this._items.push({
            timePointIndex: e,
            left: NaN,
            center: NaN,
            right: NaN,
            y: i,
            style: s
          });
          d.previousValue = t;
        }
        const p = this._source.firstValue();
        if (p === null) {
          return;
        }
        t.pointsArrayToCoordinates(this._items, p);
        e.fillBarBorders(this._items);
        const m = this._source.properties().childs().columnStyle.childs().baselinePosition?.value();
        if (m === "zero") {
          const e = t.isPercentage() ? (0, _.fromPercent)(0, p) : 0;
          this._histogramBase = t.priceToCoordinate(e, p);
        } else {
          this._histogramBase = t.isInverted() ? 0 : t.height();
        }
        if (this._model.selection().isSelected(this._source)) {
          const i = this._selectionIndexer.indexes();
          this._selectionData = {
            points: [],
            bgColors: [],
            visible: true,
            barSpacing: e.barSpacing(),
            hittestResult: a.HitTarget.Regular
          };
          const n = (0, s.ensureNotNull)(this._model.paneForSource(this._source)).height();
          this._selectionData.hittestResult = a.HitTarget.Regular;
          for (let s = 0; s < i.length; s++) {
            const r = i[s];
            const a = this._source.bars().valueAt(r);
            if (a === null) {
              continue;
            }
            const l = u(a);
            const c = e.indexToCoordinate(r);
            const h = t.priceToCoordinate(l, p);
            this._selectionData.points.push({
              point: new o.Point(c, h)
            });
            this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(h / n));
          }
        } else {
          this._selectionIndexer.clear();
        }
      }
    }
  },
  83379: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesHiLoPaneView: () => f
    });
    var s = i(59332);
    var o = i(68979);
    var n = i(29981);
    var r = i(61993);
    var a = i(56468);
    var l = i(75919);
    class c extends l.MediaCoordinatesPaneRenderer {
      constructor() {
        super(...arguments);
        this._data = null;
        this._barWidth = null;
      }
      setData(e) {
        this._data = e;
        this._barWidth = Math.max(1, Math.round((0, r.optimalHiLoWidth)(e.barSpacing)));
      }
      hitTest(e) {
        if (this._data === null || this._barWidth === null) {
          return null;
        }
        const t = this._data.bars;
        const i = this._data.barSpacing * 0.5;
        if (t.length === 0) {
          return null;
        }
        if (e.x < t[0].center - i) {
          return null;
        }
        if (e.x > t[t.length - 1].center + i) {
          return null;
        }
        const s = t[(0, n.lowerbound)(t, e.x - i, (e, t) => e.center < t)];
        if (e.x < s.center - i || e.x > s.center + i) {
          return null;
        }
        const o = (0, r.interactionTolerance)().series + this._barWidth / 2;
        const l = Math.min(s.high, s.low);
        const c = Math.max(s.high, s.low);
        const h = this._data.fontSize;
        if (l - o - h <= e.y && e.y <= l + o || c - o <= e.y && e.y <= c + o + h) {
          return new a.HitTestResult(a.HitTarget.Regular);
        } else {
          return null;
        }
      }
      _drawImpl(e) {
        if (this._data === null || this._barWidth === null) {
          return;
        }
        const {
          font: t,
          fontSize: i,
          labelColor: s,
          bars: n,
          inverted: r,
          labelsPadding: a
        } = this._data;
        const l = e.context;
        l.textAlign = "center";
        l.fillStyle = s;
        l.font = (0, o.makeFont)(i, t);
        for (let e = 0; e < n.length; ++e) {
          const t = n[e];
          const i = Math.round(Math.min(t.high, t.low));
          const s = Math.round(Math.max(t.high, t.low));
          const o = Math.round(t.center);
          l.textBaseline = "alphabetic";
          l.fillText(r ? t.lowLabel : t.highLabel, o, i - a);
          l.textBaseline = "top";
          l.fillText(r ? t.highLabel : t.lowLabel, o, s + a);
        }
      }
    }
    var h;
    var d = i(95201);
    var u = i(11064);
    var _ = i(15938);
    var p = i(7114);
    var m = i(25201);
    var g = i(24997);
    (function (e) {
      e[e.MaxFontSize = 36] = "MaxFontSize";
      e[e.MinFontSize = 8] = "MinFontSize";
    })(h ||= {});
    class f extends g.SeriesBarCandlesPaneView {
      constructor(e, t) {
        super(e, t);
        this._labelsRenderer = new c();
        this._candlesRenderer = new m.PaneRendererCandles();
        this._maxLengthLabel = "";
        this._calculateFontSize = (0, s.default)((e, t) => Math.max(1, (0, n.lowerboundExt)(e => e + 1, null, i => {
          const s = (0, o.makeFont)(i, _.CHART_FONT_FAMILY);
          return (0, p.measureText)(e, s).width <= t;
        }, 7, 36)), (e, t) => `${e}/${t}`);
      }
      renderer() {
        const e = this._source.priceScale();
        if (!e || e.isEmpty()) {
          return null;
        }
        const t = new d.CompositeRenderer();
        const i = this._needLabels();
        const s = this._source.properties().childs().hiloStyle.childs();
        const o = this._model.timeScale().barSpacing();
        if (this._invalidated) {
          const e = this._source.formatter();
          this._maxLengthLabel = "";
          this._updateImpl({
            generateLabels: i,
            formatter: e
          });
          this._invalidated = false;
        }
        this._candlesRenderer.setData({
          bars: this._bars,
          wickVisible: false,
          bodyVisible: s.drawBody.value(),
          barSpacing: o,
          borderVisible: s.showBorders.value(),
          barWidth: (0, r.optimalHiLoWidth)(o),
          isPriceScaleInverted: e.isInverted()
        });
        t.append(this._candlesRenderer);
        if (i) {
          const i = this._calculateLabelFontSize();
          if (i && i >= 8) {
            this._labelsRenderer.setData({
              bars: this._bars,
              barSpacing: o,
              font: _.CHART_FONT_FAMILY,
              fontSize: i,
              labelColor: s.labelColor.value(),
              inverted: e.isInverted(),
              labelsPadding: i * 0.4
            });
            t.append(this._labelsRenderer);
          }
        }
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
          t.append(new u.SelectionRenderer(this._selectionData));
        }
        return t;
      }
      topPixelMargin() {
        return this._margin();
      }
      bottomPixelMargin() {
        return this._margin();
      }
      _createItem(e, t, i, s) {
        const o = {
          center: NaN,
          left: NaN,
          right: NaN,
          open: NaN,
          high: NaN,
          low: NaN,
          close: NaN,
          color: i.barColor,
          borderColor: i.barBorderColor,
          hollow: false,
          highLabel: "",
          lowLabel: "",
          timePointIndex: e
        };
        if (!(0, g.baseBarCandlesUpdater)(t, o)) {
          return null;
        }
        o.open = o.high;
        o.close = o.low;
        if (s.generateLabels) {
          const e = s.formatter.format(o.high);
          const t = s.formatter.format(o.low);
          o.highLabel = e;
          o.lowLabel = t;
          const i = (e.length > t.length ? e : t).replace(/\d/g, "0");
          if (i.length > this._maxLengthLabel.length) {
            this._maxLengthLabel = i;
          }
        }
        return o;
      }
      _margin() {
        if (this._needLabels()) {
          const e = this._calculateLabelFontSize();
          if (e && e >= 8) {
            return e * 1.4;
          }
        }
        return 0;
      }
      _calculateLabelFontSize() {
        if (this._maxLengthLabel === "") {
          return null;
        } else {
          return this._calculateFontSize(this._maxLengthLabel, Math.floor(this._model.timeScale().barSpacing()) - 2);
        }
      }
      _needLabels() {
        const e = this._source.properties().childs().hiloStyle.childs().showLabels.value();
        const t = this._model.timeScale().barSpacing();
        return e && t > 5;
      }
    }
  },
  70527: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesHLCAreaPaneView: () => g
    });
    var s = i(86441);
    var o = i(50151);
    var n = i(56570);
    var r = i(67716);
    var a = i(66540);
    var l = i(11064);
    var c = i(8025);
    var h = i(61993);
    var d = i(95201);
    var u = i(56468);
    var _ = i(74010);
    var p = i(59152);
    class m extends p.ObjectValuesCache {
      _newObject() {
        return {
          high: undefined,
          close: undefined,
          low: undefined
        };
      }
      _clearObject(e) {
        e.high = undefined;
        e.close = undefined;
        e.low = undefined;
      }
    }
    class g {
      constructor(e, t) {
        this._isMarkersEnabled = (0, n.enabled)("source_selection_markers");
        this._hlcAreaCache = new m();
        this._highPoints = new p.CachedContainer();
        this._closePoints = new p.CachedContainer();
        this._lowPoints = new p.CachedContainer();
        this._barsBorders = new p.CachedContainer();
        this._filledAreas = new r.CachedMap();
        this._renderer = new d.CompositeRenderer();
        this._invalidated = true;
        this._source = e;
        this._model = t;
        this._selectionIndexer = new a.SelectionIndexes(t.timeScale());
      }
      update() {
        this._invalidated = true;
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        return this._renderer;
      }
      _updateImpl() {
        this._renderer.clear();
        const e = this._model.timeScale();
        const t = this._source.priceScale();
        if (e.isEmpty() || !t || t.isEmpty()) {
          return;
        }
        const i = e.visibleBarsStrictRange();
        if (i === null) {
          return;
        }
        if (this._source.bars().size() === 0) {
          return;
        }
        const n = this._source.firstValue();
        if (n === null) {
          return;
        }
        const a = this._source.nearestIndex(i.firstBar() - 1, c.PlotRowSearchMode.NearestLeft) ?? i.firstBar() - 1;
        const d = this._source.nearestIndex(i.lastBar() + 1, c.PlotRowSearchMode.NearestRight) ?? i.lastBar() + 1;
        this._hlcAreaCache.invalidateCache();
        this._hlcAreaCache.setStartIndex(a);
        this._barsBorders.invalidateCache();
        this._highPoints.invalidateCache();
        this._lowPoints.invalidateCache();
        this._closePoints.invalidateCache();
        this._filledAreas.invalidateCache();
        let p;
        let m;
        let g;
        this._source.bars().range(a, d).each((e, t) => {
          if (this._hlcAreaCache.isValidIndex(e)) {
            const i = this._hlcAreaCache.at(e);
            i.close = t[4];
            i.high = t[2];
            i.low = t[3];
          }
          return false;
        });
        const f = new Map();
        const y = a + this._hlcAreaCache.length();
        for (let e = a; e < y; e++) {
          const t = this._hlcAreaCache.at(e);
          const i = t.close ?? null;
          const s = t.high ?? null;
          const o = t.low ?? null;
          if (i !== null || s !== null || o !== null || Number.isFinite(p) || Number.isFinite(m) || Number.isFinite(g)) {
            p = i;
            m = s;
            g = o;
            this._highPoints.push(s);
            this._closePoints.push(i);
            this._lowPoints.push(o);
            this._barsBorders.push({
              timePointIndex: e,
              left: NaN,
              center: NaN,
              right: NaN
            });
            f.set(e, this._barsBorders.length() - 1);
          }
        }
        t.pricesArrayToCoordinates(this._highPoints.data(), n, this._highPoints.length());
        t.pricesArrayToCoordinates(this._closePoints.data(), n, this._closePoints.length());
        t.pricesArrayToCoordinates(this._lowPoints.data(), n, this._lowPoints.length());
        e.fillBarBorders(this._barsBorders.data(), {
          startItemIndex: 0,
          endItemIndex: this._barsBorders.length()
        });
        const v = this._source.properties().childs().hlcAreaStyle.childs();
        const S = v.highCloseFillColor.value();
        const b = v.closeLowFillColor.value();
        const w = this._filledAreas.get(S) ?? new r.AreaBackgroundItemsGroup({
          type: 0,
          color: S
        });
        const C = w.newItem() ?? new r.AreaBackgroundItem();
        w.push(C);
        this._filledAreas.set(S, w);
        const P = this._filledAreas.get(b) ?? new r.AreaBackgroundItemsGroup({
          type: 0,
          color: b
        });
        const T = P.newItem() ?? new r.AreaBackgroundItem();
        P.push(T);
        this._filledAreas.set(b, P);
        const x = [];
        const I = [];
        const M = [];
        const A = this._barsBorders.length();
        for (let e = 0; e < A; e++) {
          const t = this._closePoints.at(e);
          const i = this._highPoints.at(e);
          const s = this._lowPoints.at(e);
          const o = this._barsBorders.at(e);
          const n = o.center;
          const r = (0, h.coordinateIsValid)(t);
          const a = (0, h.coordinateIsValid)(i);
          const l = (0, h.coordinateIsValid)(s);
          if (r && a && l) {
            C.addPoints1Point(n, i);
            C.addPoints2Point(n, t);
            T.addPoints1Point(n, t);
            T.addPoints2Point(n, s);
            x.push({
              y: i,
              ...o
            });
            I.push({
              y: t,
              ...o
            });
            M.push({
              y: s,
              ...o
            });
          }
        }
        const L = e.barSpacing();
        this._renderer.append(new r.AreaBackgroundRenderer({
          barSpacing: L,
          colorAreas: this._filledAreas
        }));
        this._renderer.append(new _.PaneRendererLine({
          barSpacing: L,
          items: M,
          simpleMode: true,
          withMarkers: false,
          lineColor: v.lowLineColor.value(),
          lineStyle: v.lowLineStyle.value(),
          lineWidth: v.lowLineWidth.value(),
          skipHoles: true
        }));
        this._renderer.append(new _.PaneRendererLine({
          barSpacing: L,
          items: x,
          simpleMode: true,
          withMarkers: false,
          lineColor: v.highLineColor.value(),
          lineStyle: v.highLineStyle.value(),
          lineWidth: v.highLineWidth.value(),
          skipHoles: true
        }));
        this._renderer.append(new _.PaneRendererLine({
          barSpacing: L,
          items: I,
          simpleMode: true,
          withMarkers: false,
          lineColor: v.closeLineColor.value(),
          lineStyle: v.closeLineStyle.value(),
          lineWidth: v.closeLineWidth.value(),
          skipHoles: true
        }));
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled) {
          const t = this._selectionIndexer.indexes();
          const i = [];
          const n = [];
          const r = (0, o.ensureNotNull)(this._model.paneForSource(this._source)).height();
          for (let e = 0; e < t.length; e++) {
            const o = t[e];
            const a = f.get(o);
            if (a === undefined) {
              continue;
            }
            const l = this._closePoints.at(a);
            const c = this._barsBorders.at(a).center;
            i.push({
              point: new s.Point(c, l)
            });
            n.push(this._model.backgroundColorAtYPercentFromTop(l / r));
          }
          this._renderer.append(new l.SelectionRenderer({
            bgColors: n,
            points: i,
            visible: true,
            barSpacing: e.barSpacing(),
            hittestResult: u.HitTarget.Regular
          }));
        } else {
          this._selectionIndexer.clear();
        }
      }
    }
  },
  18032: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesHLCBarsPaneView: () => a
    });
    var s = i(95201);
    var o = i(11064);
    var n = i(59432);
    var r = i(99800);
    class a extends r.SeriesBarsPaneView {
      renderer() {
        if (this._invalidated) {
          this._updateImpl(null);
          this._invalidated = false;
        }
        const e = this._source.properties().childs();
        const t = {
          bars: this._bars,
          dontDrawOpen: true,
          thinBars: e.hlcBarsStyle.childs().thinBars.value()
        };
        const i = new s.CompositeRenderer();
        i.append(new n.PaneRendererBars(t));
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
          i.append(new o.SelectionRenderer(this._selectionData));
        }
        return i;
      }
    }
  },
  15599: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesHollowCandlesPaneView: () => l
    });
    var s = i(95201);
    var o = i(61993);
    var n = i(11064);
    var r = i(25201);
    var a = i(72476);
    class l extends a.SeriesCandlesPaneView {
      renderer() {
        if (this._invalidated) {
          this._updateImpl(null);
          this._invalidated = false;
        }
        const e = this._source.priceScale();
        if (!e) {
          return null;
        }
        const t = this._source.properties().childs().hollowCandleStyle.childs();
        const i = this._model.timeScale().barSpacing();
        const a = {
          bars: this._bars,
          barSpacing: i,
          bodyVisible: t.drawBody.value(),
          borderVisible: t.drawBorder.value(),
          borderColor: t.borderColor.value(),
          wickColor: t.wickColor.value(),
          barWidth: (0, o.optimalBarWidth)(i),
          wickVisible: t.drawWick.value(),
          isPriceScaleInverted: e.isInverted()
        };
        const l = new s.CompositeRenderer();
        l.append(new r.PaneRendererCandles(a));
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
          l.append(new n.SelectionRenderer(this._selectionData));
        }
        return l;
      }
    }
  },
  80941: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesLinePaneView: () => h
    });
    var s = i(56468);
    var o = i(95201);
    var n = i(74010);
    var r = i(3385);
    var a = i(11064);
    var l = i(36897);
    var c = i(46088);
    class h extends l.SeriesSingleLinePaneView {
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        const e = this._source.properties().childs();
        const t = e.style.value();
        let i;
        let l = false;
        if (t === 2) {
          i = e.lineStyle.childs();
        } else if (t === 14) {
          i = e.lineWithMarkersStyle.childs();
          l = true;
        } else if (t === 15) {
          i = e.steplineStyle.childs();
        } else if (t === 18) {
          i = e.tpoStyle.childs();
        }
        const h = this._model.timeScale().barSpacing();
        const d = i.colorType?.value() !== c.ColorType.Gradient ? {
          type: c.ColorType.Solid,
          color: i.color.value()
        } : {
          type: c.ColorType.Gradient,
          startColor: i.gradientStartColor.value(),
          endColor: i.gradientEndColor.value()
        };
        const u = {
          barSpacing: h,
          items: this._items,
          lineColor: d,
          lineStyle: i.linestyle.value(),
          withMarkers: l,
          lineWidth: i.linewidth.value(),
          simpleMode: true,
          hitTestResult: s.HitTarget.Regular,
          skipHoles: true
        };
        let _;
        let p;
        _ = t === 15 ? new r.PaneRendererStepLine(u) : new n.PaneRendererLine(u);
        if (this._model.selection().isSelected(this._source) && this._isMarkersEnabled && this._selectionData) {
          const e = new o.CompositeRenderer();
          e.append(_);
          e.append(new a.SelectionRenderer(this._selectionData));
          p = e;
        } else {
          p = _;
        }
        return p;
      }
    }
  },
  24997: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesBarCandlesPaneView: () => h,
      baseBarCandlesUpdater: () => c
    });
    var s = i(86441);
    var o = i(56570);
    var n = i(66540);
    var r = i(8025);
    var a = i(56468);
    function l(e) {
      return e != null;
    }
    function c(e, t) {
      const i = e[1];
      const s = e[2];
      const o = e[3];
      const n = e[4];
      return !!l(i) && !!l(s) && !!l(o) && !!l(n) && (t.open = i, t.high = s, t.low = o, t.close = n, true);
    }
    class h {
      constructor(e, t) {
        this._bars = [];
        this._invalidated = true;
        this._isMarkersEnabled = (0, o.enabled)("source_selection_markers");
        this._selectionData = null;
        this._source = e;
        this._model = t;
        this._selectionIndexer = new n.SelectionIndexes(t.timeScale());
      }
      items() {
        return this._bars;
      }
      update() {
        this._invalidated = true;
      }
      _updateImpl(e) {
        const t = this._model.timeScale();
        const i = this._source.priceScale();
        this._bars = [];
        if (t.isEmpty() || !i || i.isEmpty()) {
          return;
        }
        const o = t.visibleBarsStrictRange();
        if (o === null) {
          return;
        }
        if (this._source.bars().size() === 0) {
          return;
        }
        let n = this._source.nearestIndex(o.firstBar(), r.PlotRowSearchMode.NearestRight);
        const l = this._source.nearestIndex(o.lastBar(), r.PlotRowSearchMode.NearestLeft);
        if (n === undefined || l === undefined) {
          return;
        }
        for (; n <= l; n++) {
          if (this._source.bars().valueAt(n) !== null) {
            break;
          }
        }
        if (n > l) {
          return;
        }
        const c = this._source.bars().range(n, l);
        const h = this._source.barColorer();
        const d = {};
        c.each((t, i) => {
          d.value = i;
          const s = h.firstColoredBar(t);
          let o;
          if (s !== null && s >= t) {
            this._source.setPrecomputedBarStyle(i, undefined);
          } else {
            o = this._source.precomputedBarStyle(i);
          }
          if (o === undefined) {
            o = h.barStyle(t, false, d);
            this._source.setPrecomputedBarStyle(i, o);
          }
          const n = this._createItem(t, i, o, e);
          return !!n && (d.previousValue = i, this._bars.push(n), false);
        });
        if (this._bars.length === 0) {
          return;
        }
        const u = this._source.firstValue();
        if (u !== null) {
          i.barPricesToCoordinates(this._bars, u);
          t.fillBarBorders(this._bars);
          if (this._model.selection().isSelected(this._source)) {
            const e = this._selectionIndexer.indexes();
            this._selectionData = {
              points: [],
              bgColors: [],
              visible: true,
              hittestResult: a.HitTarget.Regular,
              barSpacing: t.barSpacing()
            };
            const o = this._model.paneForSource(this._source);
            if (!o) {
              return;
            }
            const n = o.height();
            for (let o = 0; o < e.length; o++) {
              const r = e[o];
              const a = this._source.bars().valueAt(r);
              if (a === null) {
                continue;
              }
              const l = a[1];
              const c = a[4];
              if (l == null || c == null) {
                continue;
              }
              const h = (l + c) * 0.5;
              const d = t.indexToCoordinate(r);
              const _ = i.priceToCoordinate(h, u);
              this._selectionData.points.push({
                point: new s.Point(d, _)
              });
              this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(_ / n));
            }
          } else {
            this._selectionIndexer.clear();
          }
        }
      }
    }
  },
  9624: (e, t, i) => {
    "use strict";

    i.d(t, {
      mainSeriesProperties: () => n
    });
    var s = i(51056);
    i(85904);
    i(64671);
    var o = i(20596);
    const n = {
      style: 1,
      esdShowDividends: true,
      esdShowSplits: true,
      esdShowEarnings: true,
      esdShowBreaks: false,
      esdFlagSize: 2,
      showContinuousContractSwitches: true,
      showContinuousContractSwitchesBreaks: false,
      showFuturesContractExpiration: true,
      showLastNews: true,
      showCountdown: true,
      bidAsk: {
        visible: false,
        lineStyle: s.LINESTYLE_DOTTED,
        lineWidth: 1
      },
      prePostMarket: {
        visible: true,
        lineStyle: s.LINESTYLE_DOTTED,
        lineWidth: 1
      },
      highLowAvgPrice: {
        highLowPriceLinesVisible: false,
        highLowPriceLabelsVisible: false,
        averageClosePriceLineVisible: false,
        averageClosePriceLabelVisible: false,
        highLowPriceLinesWidth: 1,
        averagePriceLineWidth: 1
      },
      visible: true,
      showPriceLine: true,
      priceLineWidth: 1,
      showPrevClosePriceLine: false,
      prevClosePriceLineWidth: 1,
      minTick: "default",
      dividendsAdjustment: undefined,
      backAdjustment: false,
      settlementAsClose: true,
      sessionId: "regular",
      sessVis: false,
      statusViewStyle: {
        fontSize: 16,
        showExchange: true,
        showInterval: true,
        symbolTextSource: "description"
      },
      candleStyle: {
        drawWick: true,
        drawBorder: true,
        barColorsOnPrevClose: false,
        drawBody: true
      },
      volCandlesStyle: {
        drawWick: true,
        drawBorder: true,
        barColorsOnPrevClose: false,
        drawBody: true
      },
      hollowCandleStyle: {
        drawWick: true,
        drawBorder: true,
        drawBody: true
      },
      haStyle: {
        drawWick: true,
        drawBorder: true,
        showRealLastPrice: false,
        barColorsOnPrevClose: false,
        inputs: {},
        inputInfo: {},
        drawBody: true
      },
      barStyle: {
        barColorsOnPrevClose: false,
        dontDrawOpen: false,
        thinBars: true
      },
      hiloStyle: {
        showBorders: true,
        showLabels: true,
        drawBody: true
      },
      columnStyle: {
        barColorsOnPrevClose: true,
        priceSource: "close",
        baselinePosition: "bottom"
      },
      lineStyle: {
        linestyle: s.LINESTYLE_SOLID,
        linewidth: 2,
        priceSource: "close"
      },
      tpoStyle: {},
      svpStyle: {},
      lineWithMarkersStyle: {
        linestyle: s.LINESTYLE_SOLID,
        linewidth: 2,
        priceSource: "close"
      },
      steplineStyle: {
        linestyle: s.LINESTYLE_SOLID,
        linewidth: 2,
        priceSource: "close"
      },
      areaStyle: {
        linestyle: s.LINESTYLE_SOLID,
        linewidth: 2,
        priceSource: "close"
      },
      hlcAreaStyle: {
        highLineStyle: s.LINESTYLE_SOLID,
        highLineWidth: 2,
        lowLineStyle: s.LINESTYLE_SOLID,
        lowLineWidth: 2,
        closeLineStyle: s.LINESTYLE_SOLID,
        closeLineWidth: 2
      },
      priceAxisProperties: {
        autoScale: true,
        autoScaleDisabled: false,
        lockScale: false,
        percentage: false,
        percentageDisabled: false,
        indexedTo100: false,
        log: false,
        logDisabled: false,
        isInverted: false,
        alignLabels: true
      },
      renkoStyle: {
        inputs: {
          source: "close",
          sources: "Close",
          boxSize: 3,
          style: "ATR",
          atrLength: 14,
          percentageLTP: 1,
          wicks: true
        },
        inputInfo: {
          source: {
            name: "Source"
          },
          sources: {
            name: "Source"
          },
          boxSize: {
            name: "Box size"
          },
          style: {
            name: "Style"
          },
          atrLength: {
            name: "ATR length"
          },
          percentageLTP: {
            name: "Percentage"
          },
          wicks: {
            name: "Wicks"
          }
        }
      },
      pbStyle: {
        inputs: {
          source: "close",
          lb: 3
        },
        inputInfo: {
          source: {
            name: "Source"
          },
          lb: {
            name: "Number of line"
          }
        }
      },
      kagiStyle: {
        inputs: {
          source: "close",
          style: "ATR",
          atrLength: 14,
          percentageLTP: 1,
          reversalAmount: 1
        },
        inputInfo: {
          source: {
            name: "Source"
          },
          style: {
            name: "Style"
          },
          atrLength: {
            name: "ATR length"
          },
          percentageLTP: {
            name: "Percentage"
          },
          reversalAmount: {
            name: "Reversal amount"
          }
        }
      },
      pnfStyle: {
        inputs: {
          sources: "Close",
          reversalAmount: 3,
          boxSize: 1,
          style: "ATR",
          atrLength: 14,
          percentageLTP: 1,
          oneStepBackBuilding: false
        },
        inputInfo: {
          sources: {
            name: "Source"
          },
          boxSize: {
            name: "Box size"
          },
          reversalAmount: {
            name: "Reversal amount"
          },
          style: {
            name: "Style"
          },
          atrLength: {
            name: "ATR length"
          },
          percentageLTP: {
            name: "Percentage"
          },
          oneStepBackBuilding: {
            name: "One step back building"
          }
        }
      },
      baselineStyle: {
        topLineWidth: 2,
        bottomLineWidth: 2,
        priceSource: "close",
        transparency: 50,
        baseLevelPercentage: 50
      },
      rangeStyle: {
        barStyle: o.RangeBarStyle.Bars,
        thinBars: true,
        inputs: {
          range: 10,
          phantomBars: false
        },
        inputInfo: {
          range: {
            name: "Range"
          },
          phantomBars: {
            name: "Phantom bars"
          }
        }
      },
      volFootprintStyle: {},
      hlcBarsStyle: {
        barColorsOnPrevClose: false,
        thinBars: true
      }
    };
  },
  36897: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesSingleLinePaneView: () => d
    });
    var s = i(69708);
    var o = i(86441);
    var n = i(50151);
    var r = i(56570);
    var a = i(66540);
    var l = i(8025);
    var c = i(56468);
    var h = i(29981);
    class d {
      constructor(e, t) {
        this._items = [];
        this._invalidated = true;
        this._isMarkersEnabled = (0, r.enabled)("source_selection_markers");
        this._selectionData = null;
        this._source = e;
        this._model = t;
        this._selectionIndexer = new a.SelectionIndexes(t.timeScale());
      }
      update() {
        this._invalidated = true;
      }
      _updateImpl() {
        this._items = [];
        const e = this._model.timeScale();
        const t = this._source.priceScale();
        if (e.isEmpty() || !t || t.isEmpty()) {
          return;
        }
        const i = e.visibleBarsStrictRange();
        if (i === null) {
          return;
        }
        if (this._source.bars().size() === 0) {
          return;
        }
        const r = this._source.nearestIndex(i.firstBar() - 1, l.PlotRowSearchMode.NearestLeft) ?? i.firstBar() - 1;
        const a = this._source.nearestIndex(i.lastBar() + 1, l.PlotRowSearchMode.NearestRight) ?? i.lastBar() + 1;
        const d = this._source.barFunction();
        const u = this._model.timeScale().barSpacing();
        if (u < 0.1 && this._source.supportsConflatedChunks()) {
          const e = this._source.conflatedChunks(u, (0, n.ensureNotNull)(this._source.priceSource()));
          const t = (0, h.lowerbound)(e, r, (e, t) => e.startTime < t);
          const i = Math.min(e.length - 1, (0, h.lowerbound)(e, a, (e, t) => e.endTime < t));
          for (let s = t; s <= i; s++) {
            const t = e[s];
            [t.open, t.high, t.low, t.close].forEach(e => {
              this._items.push({
                timePointIndex: t.startTime,
                y: e,
                left: NaN,
                center: NaN,
                right: NaN
              });
            });
          }
        } else {
          for (const {
            index: e,
            value: t
          } of this._source.bars().rangeIterator(r, a)) {
            const i = d(t);
            if ((0, s.default)(i)) {
              this._items.push({
                timePointIndex: e,
                y: i,
                left: NaN,
                center: NaN,
                right: NaN
              });
            }
          }
        }
        const _ = this._source.firstValue();
        if (_ !== null) {
          t.pointsArrayToCoordinates(this._items, _);
          e.fillBarBorders(this._items);
          if (this._model.selection().isSelected(this._source)) {
            const i = this._selectionIndexer.indexes();
            this._selectionData = {
              points: [],
              bgColors: [],
              visible: true,
              barSpacing: e.barSpacing(),
              hittestResult: c.HitTarget.Regular
            };
            const s = (0, n.ensureNotNull)(this._model.paneForSource(this._source)).height();
            this._selectionData.hittestResult = c.HitTarget.Regular;
            for (let n = 0; n < i.length; n++) {
              const r = i[n];
              const a = this._source.bars().valueAt(r);
              if (a === null) {
                continue;
              }
              const l = d(a);
              const c = e.indexToCoordinate(r);
              const h = t.priceToCoordinate(l, _);
              this._selectionData.points.push({
                point: new o.Point(c, h)
              });
              this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(h / s));
            }
          } else {
            this._selectionIndexer.clear();
          }
        } else {
          this._items = [];
        }
      }
    }
  },
  20596: (e, t, i) => {
    "use strict";

    i.d(t, {
      RangeBarStyle: () => y,
      areaStylePreferencesDefault: () => c,
      barStylePreferencesDefault: () => r,
      baselineStylePreferencesDefault: () => d,
      candleStylePreferencesDefault: () => o,
      columnStylePreferencesDefault: () => S,
      haStylePreferencesDefault: () => _,
      hiloStylePreferencesDefault: () => u,
      hlcAreaStylePreferencesDefault: () => h,
      hlcBarsStylePreferencesDefault: () => a,
      hollowCandlePreferencesStyleDefault: () => n,
      kagiStylePreferencesDefault: () => g,
      lineStyleDefault: () => l,
      pbStylePreferencesDefault: () => m,
      pnfStylePreferencesDefault: () => f,
      rangeStylePreferencesDefault: () => v,
      renkoStylePreferencesDefault: () => p
    });
    var s = i(46088);
    const o = {
      upColor: "",
      downColor: "",
      drawWick: false,
      drawBorder: false,
      drawBody: true,
      borderColor: "",
      borderUpColor: "",
      borderDownColor: "",
      wickColor: "",
      wickUpColor: "",
      wickDownColor: "",
      barColorsOnPrevClose: false
    };
    const n = {
      upColor: "",
      downColor: "",
      drawWick: false,
      drawBorder: false,
      drawBody: true,
      borderColor: "",
      borderUpColor: "",
      borderDownColor: "",
      wickColor: "",
      wickUpColor: "",
      wickDownColor: ""
    };
    const r = {
      upColor: "",
      downColor: "",
      barColorsOnPrevClose: false,
      dontDrawOpen: false,
      thinBars: true
    };
    const a = {
      color: "",
      thinBars: true
    };
    const l = {
      color: "",
      linestyle: 0,
      linewidth: 0,
      colorType: s.ColorType.Gradient,
      gradientStartColor: "",
      gradientEndColor: ""
    };
    const c = {
      color1: "",
      color2: "",
      linecolor: "",
      linestyle: 0,
      linewidth: 0,
      transparency: 0
    };
    const h = {
      highLineColor: "",
      highLineStyle: 0,
      highLineWidth: 0,
      lowLineColor: "",
      lowLineStyle: 0,
      lowLineWidth: 0,
      closeLineColor: "",
      closeLineStyle: 0,
      closeLineWidth: 0,
      highCloseFillColor: "",
      closeLowFillColor: ""
    };
    const d = {
      topFillColor1: "",
      topFillColor2: "",
      bottomFillColor1: "",
      bottomFillColor2: "",
      topLineColor: "",
      bottomLineColor: "",
      baselineColor: "",
      topLineWidth: 0,
      bottomLineWidth: 0,
      transparency: 0,
      baseLevelPercentage: 0
    };
    const u = {
      color: "",
      showBorders: false,
      borderColor: "",
      showLabels: false,
      labelColor: "",
      drawBody: true
    };
    const _ = {
      upColor: "",
      downColor: "",
      drawWick: false,
      drawBorder: false,
      drawBody: true,
      borderColor: "",
      borderUpColor: "",
      borderDownColor: "",
      wickColor: "",
      wickUpColor: "",
      wickDownColor: "",
      showRealLastPrice: false,
      barColorsOnPrevClose: false,
      inputs: {}
    };
    const p = {
      upColor: "",
      downColor: "",
      borderUpColor: "",
      borderDownColor: "",
      upColorProjection: "",
      downColorProjection: "",
      borderUpColorProjection: "",
      borderDownColorProjection: "",
      wickUpColor: "",
      wickDownColor: "",
      inputs: {
        boxSize: 0,
        style: "",
        atrLength: 0,
        percentageLTP: 0,
        wicks: false,
        sources: "",
        source: ""
      }
    };
    const m = {
      upColor: "",
      downColor: "",
      borderUpColor: "",
      borderDownColor: "",
      upColorProjection: "",
      downColorProjection: "",
      borderUpColorProjection: "",
      borderDownColorProjection: "",
      inputs: {
        source: "",
        lb: 0
      }
    };
    const g = {
      upColor: "",
      downColor: "",
      upColorProjection: "",
      downColorProjection: "",
      inputs: {
        style: "",
        atrLength: 0,
        percentageLTP: 0,
        reversalAmount: 0
      }
    };
    const f = {
      upColor: "",
      downColor: "",
      upColorProjection: "",
      downColorProjection: "",
      inputs: {
        reversalAmount: 0,
        boxSize: 0,
        style: "",
        atrLength: 0,
        percentageLTP: 0,
        oneStepBackBuilding: false,
        sources: "Close"
      }
    };
    var y;
    (function (e) {
      e[e.Bars = 0] = "Bars";
      e[e.Candles = 1] = "Candles";
    })(y ||= {});
    const v = {
      barStyle: 0,
      upColor: "",
      downColor: "",
      upColorProjection: "",
      downColorProjection: "",
      thinBars: false,
      candlesUpColor: "",
      candlesDownColor: "",
      candlesBorderUpColor: "",
      candlesBorderDownColor: "",
      candlesWickUpColor: "",
      candlesWickDownColor: "",
      inputs: {
        range: 0,
        phantomBars: false
      }
    };
    const S = {
      upColor: "",
      downColor: "",
      barColorsOnPrevClose: false,
      baselinePosition: "bottom"
    };
  },
  62825: (e, t, i) => {
    "use strict";

    i.d(t, {
      getErrorFromUnsupportedResolutionState: () => c,
      getResolutionUnsupportedReason: () => h
    });
    var s = i(11542);
    var o = i(85049);
    var n = i(10074);
    const r = s.t(null, undefined, i(64818));
    const a = s.t(null, undefined, i(80254));
    const l = s.t(null, undefined, i(80185));
    function c(e, t = false) {
      const i = t ? `<b>${e.ticker}</b>` : e.ticker;
      switch (e.reason) {
        case "unsupported_resolution":
          {
            const s = t ? `<b>${e.supportedResolutions.join(", ")}</b>` : e.supportedResolutions.join(", ");
            return r.format({
              ticker: i,
              availableResolutions: s
            });
          }
        case "unsupported_ticks":
          return a.format({
            ticker: i
          });
        case "less_than_frequency":
          {
            const s = t ? `<b>${e.applicableResolution}</b>` : e.applicableResolution;
            return l.format({
              ticker: i,
              resolution: s
            });
          }
      }
    }
    function h(e, t) {
      if (e === null) {
        return null;
      }
      const i = e.data_frequency;
      if (i !== undefined) {
        if ((0, n.getApplicableIntervalForFrequency)(i, t) !== t) {
          return "less_than_frequency";
        }
      }
      if (o.Interval.isIntraday(t) && !e.has_intraday) {
        return "unsupported_resolution";
      }
      if (o.Interval.isTicks(t) && !e["is-tickbars-available"]) {
        return "unsupported_ticks";
      }
      {
        const i = o.Interval.isSeconds(t) && !e.has_seconds;
        const s = o.Interval.isDays(t) && !e.has_daily;
        if (i || s) {
          return "unsupported_resolution";
        }
      }
      return null;
    }
  },
  76748: (e, t, i) => {
    "use strict";

    i.d(t, {
      SeriesValuesProvider: () => I,
      calculateColor: () => T,
      changesData: () => x
    });
    var s = i(50151);
    var o = i(50335);
    var n = i(24377);
    var r = i(11542);
    var a = i(49483);
    var l = i(19063);
    var c = i(63273);
    var h = i(8025);
    var d = i(928);
    var u = i(74079);
    var _ = i(90799);
    function p(e, t) {
      return (t - e) * 100 / Math.abs(e || 1);
    }
    var m = i(41991);
    var g = i(15764);
    var f = i(82587);
    var y = i(23486);
    const v = y.lastDayChangeAvailable || y.alwaysShowLastPriceAndLastDayChange;
    const S = a.CheckMobile.any();
    const b = (0, u.getPercentageFormatter)();
    const w = (0, u.getVolumeFormatter)(2);
    const C = `${f.notAvailable} (${f.notAvailable}%)`;
    var P;
    function T(e, t) {
      const i = (0, n.parseRgb)(t);
      const s = (0, n.parseRgb)(e);
      if ((0, n.distanceRgb)(i, s) < 70) {
        return (0, n.rgbToHexString)((0, n.invertRgb)(i));
      } else {
        return t;
      }
    }
    function x(e, t, i, s, o) {
      let n;
      let r;
      if (t !== null) {
        const e = o[4];
        const i = t.change || 0;
        r = {
          change: i,
          currentPrice: e,
          prevPrice: e - i,
          percentChange: t.change_percent || 0
        };
      }
      const a = i[4];
      const l = e.search(s - 1, h.PlotRowSearchMode.NearestLeft, 1);
      const c = l?.value[4] ?? null;
      if (c !== null && a != null) {
        n = {
          change: a - c,
          currentPrice: a,
          prevPrice: c,
          percentChange: p(c, a)
        };
      }
      return {
        barChange: n,
        lastDayChange: r
      };
    }
    (function (e) {
      e[e.Open = 0] = "Open";
      e[e.High = 1] = "High";
      e[e.Low = 2] = "Low";
      e[e.Close = 3] = "Close";
      e[e.Source = 4] = "Source";
      e[e.LastPrice = 5] = "LastPrice";
      e[e.Change = 6] = "Change";
      e[e.Volume = 7] = "Volume";
      e[e.LastDayChange = 8] = "LastDayChange";
    })(P ||= {});
    class I {
      constructor(e, t) {
        this._series = e;
        this._model = t;
        this._emptyValues = [{
          title: r.t(null, undefined, i(16610)),
          visible: false,
          value: "",
          index: 0,
          id: ""
        }, {
          title: r.t(null, undefined, i(78254)),
          visible: false,
          value: "",
          index: 1,
          id: ""
        }, {
          title: r.t(null, undefined, i(65318)),
          visible: false,
          value: "",
          index: 2,
          id: ""
        }, {
          title: r.t(null, undefined, i(62578)),
          visible: false,
          value: "",
          index: 3,
          id: ""
        }, {
          title: "",
          visible: false,
          value: "",
          index: 4,
          id: ""
        }, {
          title: "",
          visible: false,
          value: "",
          index: 5,
          id: ""
        }, {
          title: r.t(null, undefined, i(37276)),
          visible: false,
          value: "",
          index: 6,
          id: ""
        }, {
          title: r.t(null, {
            context: "study"
          }, i(24261)),
          visible: false,
          value: "",
          index: 7,
          id: ""
        }, {
          title: r.t(null, undefined, i(63815)),
          visible: false,
          value: "",
          index: 8,
          id: ""
        }];
      }
      getItems() {
        return this._emptyValues;
      }
      getValues(e) {
        const t = this._showLastPriceAndChangeOnly();
        const i = this._emptyValues.map((e, i) => ({
          ...e,
          value: i === 6 || i === 8 ? C : f.notAvailable,
          visible: i !== 5 && i !== 4 && !t
        }));
        if (this._model.timeScale().isEmpty() || this._series.bars().size() === 0 || this._series.priceScale().isEmpty()) {
          return i;
        }
        const n = (0, s.ensureNotNull)(this._series.data().bars().last());
        if (!(0, o.isNumber)(e)) {
          e = n.index;
        }
        const r = this._series.nearestIndex(e, h.PlotRowSearchMode.NearestLeft);
        if (r === undefined) {
          return i;
        }
        const a = this._series.data().valueAt(r);
        const d = this._model.backgroundTopColor().value();
        if (a === null) {
          return i;
        }
        const u = a[1];
        const _ = a[2];
        const p = a[3];
        const g = a[4];
        const {
          barChange: y,
          lastDayChange: S
        } = x(this._series.data(), this._series.quotes(), a, r, n.value);
        const P = (0, m.getPriceValueFormatterForSource)(this._series);
        if ((0, m.shouldBeFormattedAsPercent)(this._series) || (0, m.shouldBeFormattedAsIndexedTo100)(this._series)) {
          i[6].value = "";
          i[8].value = "";
        } else {
          const e = this._series.formatter();
          const t = {
            signPositive: true
          };
          if (y !== undefined) {
            const {
              currentPrice: s,
              prevPrice: o,
              change: n,
              percentChange: r
            } = y;
            const a = e.formatChange?.(s, o, t) ?? e.format(n, t);
            i[6].value = (0, c.forceLTRStr)(`${a} (${b.format(r, t)})`);
          }
          if (S !== undefined) {
            const {
              currentPrice: s,
              prevPrice: o,
              change: n,
              percentChange: r
            } = S;
            const a = e.formatChange?.(s, o, t) ?? e.format(n, t);
            i[8].value = (0, c.forceLTRStr)(`${a} (${b.format(r, t)})`);
          }
        }
        let I = null;
        if (t) {
          i[5].value = g == null ? f.notAvailable : P(g);
          i[5].visible = true;
          I = this._getChangeColor(y?.change, r);
          i[6].visible = y !== undefined;
          i[8].visible = S !== undefined || v;
        } else {
          i[0].value = u == null ? f.notAvailable : P(u);
          i[1].value = _ == null ? f.notAvailable : P(_);
          i[2].value = p == null ? f.notAvailable : P(p);
          i[3].value = g == null ? f.notAvailable : P(g);
          i[4].value = P(this._series.barFunction()(a));
          const e = a[5];
          if ((0, o.isNumber)(e)) {
            i[7].value = w.format(e);
          } else {
            i[7].visible = false;
          }
          const t = this._series.intervalObj().is1Tick();
          const s = this._series.style() !== 21;
          i[0].visible = !t && s;
          i[1].visible = !t;
          i[2].visible = !t;
          i[8].visible = S !== undefined || v;
          i[6].visible = y !== undefined;
          const n = this._series.barColorer().barStyle(r, false);
          I = T(d, n.barBorderColor ?? n.barColor);
        }
        I = (0, l.resetTransparency)(T(d, I));
        for (const e of i) {
          e.color ||= I;
        }
        if (i[8].visible) {
          i[8].color = (0, l.resetTransparency)(T(d, this._getChangeColor(S?.change, n.index)));
        }
        return i;
      }
      _mobileNonTrackingMode() {
        return S && (this._model.crosshairSource().pane === null || (0, g.isLineToolName)(d.tool.value()) || this._model.lineBeingEdited() !== null);
      }
      _showLastPriceAndChangeOnly() {
        return y.alwaysShowLastPriceAndLastDayChange || this._mobileNonTrackingMode();
      }
      _getChangeColor(e, t) {
        const i = this._series.style();
        if (i === 2 || i === 15 || i === 14) {
          return this._series.barColorer().barStyle(t, false).barColor;
        }
        const s = e === undefined || e >= 0 ? _.SeriesBarColorer.upColor(this._series.properties()) : _.SeriesBarColorer.downColor(this._series.properties());
        return s.barBorderColor ?? s.barColor;
      }
    }
  },
  6290: (e, t, i) => {
    "use strict";

    i.d(t, {
      sessionsPreferencesDefault: () => o
    });
    var s = i(19625);
    const o = {
      sessionHighlight: {
        backgrounds: {
          preMarket: {
            color: "#FF9800",
            transparency: 92,
            visible: true
          },
          postMarket: {
            color: s.colorsPalette["color-tv-blue-500"],
            transparency: 92,
            visible: true
          },
          electronic: {
            color: s.colorsPalette["color-tv-blue-500"],
            transparency: 92,
            visible: true
          },
          outOfSession: {
            color: s.colorsPalette["color-tv-blue-500"],
            transparency: 92,
            visible: true
          }
        },
        vertlines: {
          sessBreaks: {
            color: "#4985e7",
            style: 2,
            visible: false,
            width: 1
          }
        }
      }
    };
  },
  300: (e, t, i) => {
    "use strict";

    i.d(t, {
      sourcesAffectState: () => n
    });
    var s = i(78956);
    var o = i(85719);
    function n(e) {
      return !o.lineToolsDoNotAffectChartInvalidation || e.some(e => !(0, s.isLineTool)(e));
    }
  },
  27538: (e, t, i) => {
    "use strict";

    i.d(t, {
      StatusProviderBase: () => s
    });
    class s {
      size() {
        return "13px";
      }
      bold() {
        return false;
      }
    }
  },
  27777: (e, t, i) => {
    "use strict";

    i.d(t, {
      StatusView: () => s
    });
    class s {
      constructor(e) {
        this._text = "";
        this._color = "";
        this._size = "13px";
        this._bold = false;
        this._statusProvider = e;
      }
      text() {
        return this._text;
      }
      getSplitTitle() {
        return [this._text];
      }
      bold() {
        return this._bold;
      }
      size() {
        return this._size;
      }
    }
  },
  47806: (e, t, i) => {
    "use strict";

    i.d(t, {
      AbstractFilledAreaPaneView: () => p
    });
    var s = i(50151);
    var o = i(86441);
    var n = i(5531);
    var r = i(29981);
    var a = i(94784);
    var l = i(67716);
    var c = i(62499);
    function h(e, t) {
      return Array.from({
        length: e
      }, (e, i) => ({
        timePointIndex: i + t
      }));
    }
    function d(e, t, i) {
      let s;
      let o;
      const n = e.length;
      for (let r = t; r >= 0 && r < n; r += i) {
        const t = e[r];
        if (s === undefined && t.plot1Value !== undefined) {
          s = r;
        }
        if (o === undefined && t.plot2Value !== undefined) {
          o = r;
        }
        if (s !== undefined && o !== undefined) {
          return r;
        }
      }
      return null;
    }
    function u(e) {
      if (e.type === 0) {
        return `${e.color}`;
      } else {
        return `${e.color1}:${e.color2}:${e.coordinate1}:${e.coordinate2}`;
      }
    }
    const _ = {
      type: 0,
      color: ""
    };
    class p {
      constructor(e, t, i) {
        this._isHlineFill = false;
        this._bandAKey = null;
        this._bandBKey = null;
        this._colorPlotIndex = null;
        this._areaRenderer = new l.AreaBackgroundRenderer();
        this._dataInvalidated = null;
        this._viewportInvalidated = false;
        this._plIndex1 = null;
        this._plIndex2 = null;
        this._items = [];
        this._colorAreas = new l.CachedMap();
        this._generateColor = (0, a.generateColorCached)();
        this._source = e;
        this._model = t;
        this._fillGaps = !!i?.fillgaps;
        this._fillToIntersection = !!i?.fillToIntersection;
      }
      update(e) {
        if (e.type === "global-change") {
          this._dataInvalidated = (0, c.mergeDataInvalidation)(this._dataInvalidated, {});
          this._viewportInvalidated = true;
          return;
        }
        if (e.type !== "data-source-change") {
          this._viewportInvalidated = true;
        } else if (e.sourceId === this._source.id()) {
          this._dataInvalidated = (0, c.mergeDataInvalidation)(this._dataInvalidated, {
            firstIndex: e.firstUpdatedTimePointIndex,
            clearData: e.clearData
          });
        }
      }
      renderer() {
        if (this._dataInvalidated) {
          if (this._updateImplFull(this._dataInvalidated)) {
            this._dataInvalidated = null;
            this._viewportInvalidated = false;
          }
        } else if (this._viewportInvalidated) {
          this._updateImplLight();
          this._viewportInvalidated = false;
        }
        return this._areaRenderer;
      }
      _minFirstBarIndex() {
        return -Infinity;
      }
      _priceScale() {
        return this._source.priceScale();
      }
      _firstValue() {
        return this._source.firstValue();
      }
      _plotNames() {
        return this._source.metaInfo().plots.map(e => e.id);
      }
      _plotIndex1() {
        if (this._plIndex1 === null) {
          this._plIndex1 = this._plotNames().indexOf(this._plotAId()) + 1;
        }
        return this._plIndex1;
      }
      _plotIndex2() {
        if (this._plIndex2 === null) {
          this._plIndex2 = this._plotNames().indexOf(this._plotBId()) + 1;
        }
        return this._plIndex2;
      }
      _updateImplFull(e) {
        this._areaRenderer.setData(null);
        if (this._dataInvalidated?.clearData) {
          this._items = [];
        }
        if (!this._visible()) {
          return false;
        }
        if (this._priceScale() === null) {
          return false;
        }
        if (this._firstValue() === null) {
          return false;
        }
        const t = this._source.plots().plottableRange();
        const i = t.size();
        if (i === 0) {
          return false;
        }
        const o = this._source.offset(this._plotAId());
        const n = this._source.offset(this._plotBId());
        const a = Math.min(o, n);
        const l = Math.max(o, n);
        let c = e.firstIndex;
        const d = i + (l - a) + 1;
        const u = this._plotIndex1();
        const _ = this._plotIndex2();
        if (d !== this._items.length) {
          if (c === undefined || this._items.length === 0 || c < this._items[0].timePointIndex + a) {
            c = undefined;
            this._items = h(d, 10000000000);
          } else {
            this._items = this._items.concat(h(d - this._items.length, 10000000000 + this._items.length));
          }
        }
        const p = this._colorPlotIndex;
        const m = this._transparency();
        const g = c === undefined ? t.fullRangeIterator() : t.rangeIterator(c, (0, s.ensureNotNull)(t.lastIndex()));
        let f = c !== undefined ? (0, r.lowerbound)(this._items, c + a, (e, t) => e.timePointIndex < t) - a : -a;
        for (const e of g) {
          const t = e.index + o;
          const i = e.index + n;
          const s = this._items[f + o];
          const r = this._items[f + n];
          s.timePointIndex = t;
          r.timePointIndex = i;
          if (!this._isHlineFill) {
            s.plot1Value = e.value[u] ?? undefined;
            r.plot2Value = e.value[_] ?? undefined;
          }
          if (p !== null) {
            const t = f + a - 1;
            if (t >= 0 && t < this._items.length) {
              const i = this._items[t];
              let s;
              s = p.type === 0 ? {
                type: 0,
                colorIndexOrRgba: e.value[p.colorIndexOrRgba + 1]
              } : {
                type: 1,
                colorIndexOrRgba1: p.colorIndexOrRgba1 === undefined ? undefined : e.value[p.colorIndexOrRgba1 + 1],
                colorIndexOrRgba2: p.colorIndexOrRgba2 === undefined ? undefined : e.value[p.colorIndexOrRgba2 + 1],
                value1: p.valueIndex1 === undefined ? undefined : e.value[p.valueIndex1 + 1],
                value2: p.valueIndex2 === undefined ? undefined : e.value[p.valueIndex2 + 1]
              };
              const o = i.color = this._getColorByPlotValue(s) ?? undefined;
              if (o !== undefined) {
                if (o.type === 1) {
                  o.color1 = o.color1 && this._generateColor(o.color1, m);
                  o.color2 = o.color2 && this._generateColor(o.color2, m);
                } else {
                  o.color = this._generateColor(o.color, m);
                }
              }
            }
          }
          f += 1;
        }
        this._updateImplLight();
        return true;
      }
      _updateImplLight() {
        if (!this._visible()) {
          return;
        }
        const e = this._priceScale();
        if (e === null) {
          return;
        }
        const t = this._firstValue();
        if (t === null) {
          return;
        }
        if (this._items.length === 0) {
          return;
        }
        let i;
        if (this._isHlineFill) {
          const o = this._source.properties().bands[(0, s.ensureNotNull)(this._bandAKey)];
          const n = this._source.properties().bands[(0, s.ensureNotNull)(this._bandBKey)];
          i = {
            level1: e.priceToCoordinate(o.value.value(), t),
            level2: e.priceToCoordinate(n.value.value(), t)
          };
        }
        const a = this._model.timeScale();
        const c = a.visibleBarsStrictRange();
        if (c === null) {
          return;
        }
        const h = e.priceToCoordinateFn(t);
        const p = this._transparency();
        const m = this._minFirstBarIndex();
        const g = Math.max(m, c.firstBar());
        const f = (0, r.lowerbound)(this._items, g, (e, t) => e.timePointIndex < t);
        if (f >= this._items.length) {
          return;
        }
        const y = Math.min(this._items.length - 1, (0, r.lowerbound)(this._items, c.lastBar(), (e, t) => e.timePointIndex < t));
        let v;
        let S;
        if (this._isHlineFill) {
          v = m === g ? f : Math.max(0, f - 1);
          S = Math.min(this._items.length - 1, y + 1);
        } else {
          v = m === g ? f : d(this._items, f - 1, -1) ?? f;
          S = d(this._items, y + 1, 1) ?? y;
        }
        const b = this._colorAreas;
        b.invalidateCache();
        let w;
        let C = null;
        let P = null;
        let T = null;
        const x = (e, t, i) => {
          if (this._model.timeScale().barSpacing() < 1 || !this._fillToIntersection || w === undefined || w.xCoordinate === undefined || w.plot1Coordinate === undefined || w.plot2Coordinate === undefined || P === null || C === null || C.points1.length() === 0 || e === undefined || t === undefined) {
            return;
          }
          const s = new o.Point(w.xCoordinate, w.plot1Coordinate);
          const r = new o.Point(w.xCoordinate, w.plot2Coordinate);
          const a = new o.Point(i, e);
          const l = new o.Point(i, t);
          const c = (0, n.intersectLineSegments)(s, a, r, l);
          if (c !== null) {
            const e = s.add(s.subtract(a).scaled(-c));
            P.addPoints1Point(C.points1.at(C.points1.length() - 1).x, C.points1.at(C.points1.length() - 1).y);
            P.addPoints2Point(C.points2.at(C.points1.length() - 1).x, C.points2.at(C.points1.length() - 1).y);
            P.addPoints1Point(e.x, e.y);
            P.addPoints1Point(e.x, e.y);
            C.points1.at(C.points1.length() - 1).x = e.x;
            C.points1.at(C.points1.length() - 1).y = e.y;
            C.points2.at(C.points2.length() - 1).x = e.x;
            C.points2.at(C.points2.length() - 1).y = e.y;
          }
        };
        const I = this._commonColor();
        let M;
        if (I.type === 1) {
          I.coordinate1 = h(I.value1);
          I.coordinate2 = h(I.value2);
          I.color1 = I.color1 && this._generateColor(I.color1, p);
          I.color2 = I.color2 && this._generateColor(I.color2, p);
        } else {
          I.color = this._generateColor(I.color, p);
        }
        for (let e = v; e <= S; e += 1) {
          const t = this._items[e];
          const s = t.timePointIndex;
          let o;
          let n;
          if (!this._fillGaps && M !== undefined && s - M > 1) {
            C = null;
          }
          if (i !== undefined) {
            o = i.level1;
            n = i.level2;
          } else {
            o = t.plot1Coordinate = t.plot1Value === undefined ? undefined : h(t.plot1Value);
            n = t.plot2Coordinate = t.plot2Value === undefined ? undefined : h(t.plot2Value);
          }
          const r = t.xCoordinate = a.indexToCoordinate(t.timePointIndex);
          if (t.color && t.color.type === 1) {
            t.color.coordinate1 = h(t.color.value1);
            t.color.coordinate2 = h(t.color.value2);
          }
          if (this._fillGaps ? o !== undefined || n !== undefined : o !== undefined && n !== undefined) {
            const i = this._colorPlotIndex !== null ? t.color || _ : I;
            x(o, n, r);
            L = i;
            if (!((A = T) === null || L === null ? A === L : A.type === 0 && L.type === 0 ? A.color === L.color : A.type === 1 && L.type === 1 && A.color1 === L.color1 && A.color2 === L.color2 && A.coordinate1 === L.coordinate1 && A.coordinate2 === L.coordinate2) || C === null) {
              if (C !== null) {
                if (o !== undefined) {
                  C.addPoints1Point(r, o);
                }
                if (n !== undefined) {
                  C.addPoints2Point(r, n);
                }
              }
              if (e === S) {
                continue;
              }
              T = i;
              const t = u(i);
              const s = b.get(t) ?? new l.AreaBackgroundItemsGroup(i);
              P = C;
              C = s.newItem() ?? new l.AreaBackgroundItem();
              s.push(C);
              b.set(t, s);
            }
            if (o !== undefined) {
              C.addPoints1Point(r, o);
            }
            if (n !== undefined) {
              C.addPoints2Point(r, n);
            }
          } else if (!this._fillGaps) {
            T = null;
            C = null;
            P = null;
          }
          M = s;
          w = t;
        }
        var A;
        var L;
        b.delete(u(_));
        const k = {
          barSpacing: this._model.timeScale().barSpacing(),
          colorAreas: b
        };
        this._areaRenderer.setData(k);
      }
    }
  },
  46463: (e, t, i) => {
    "use strict";

    i.d(t, {
      AreaBackgroundPaneView: () => n
    });
    var s = i(50151);
    var o = i(47806);
    class n extends o.AbstractFilledAreaPaneView {
      constructor(e, t) {
        super(e, t);
      }
      _plotAId() {
        return (0, s.ensureDefined)(this._source.metaInfo().area)[0].name;
      }
      _plotBId() {
        return (0, s.ensureDefined)(this._source.metaInfo().area)[1].name;
      }
      _commonColor() {
        return {
          type: 0,
          color: this._source.properties().areaBackground.backgroundColor.value()
        };
      }
      _transparency() {
        return this._source.properties().areaBackground.transparency?.value() ?? 0;
      }
      _visible() {
        return this._source.properties().areaBackground.fillBackground.value();
      }
      _getColorByPlotValue(e) {
        return this._commonColor();
      }
    }
  },
  17534: (e, t, i) => {
    "use strict";

    i.d(t, {
      prepareStudyProperties: () => w,
      prepareStudyPropertiesForLoadChart: () => g
    });
    var s = i(16738);
    var o = i(30551);
    var n = i(9343);
    var r = i(68159);
    var a = i(37265);
    var l = i(51056);
    var c = i(35039);
    var h = i(79303);
    var d = i(31229);
    var u = i(32679);
    var _ = i(94260);
    var p = i(94113);
    const m = (0, n.getLogger)("Chart.Study");
    function g(e, t, i, o, n, l) {
      return function (e, t, i, o, n, l, h) {
        const d = function (e, t, i, o, n) {
          if (e.version && i.version && e.version !== i.version) {
            m.logWarn("Serialized metaInfo version " + e.version + " is not equal to the saved state version " + i.version);
          }
          const l = t || e;
          const h = (0, a.clone)(l.defaults) ?? {};
          const d = r.StudyMetaInfo.getStudyPropertyRootName(l);
          const u = r.StudyMetaInfo.getStudyPropertyRootName(e);
          let _ = y();
          (0, s.default)(_, f(e));
          (0, s.default)(_, (0, a.clone)(e.defaults));
          (0, s.default)(_, h);
          (0, s.default)(_, (0, c.factoryDefaults)(d));
          (0, s.default)(_, (0, c.factoryDefaults)(u));
          (0, s.default)(_, v(l, o, d));
          (0, s.default)(_, v(e, o, u));
          (0, s.default)(_, i);
          _ = o.updateStudyState(_, e, t);
          if (n !== undefined && t) {
            _ = n(i, _, e, t);
          }
          if (r.StudyMetaInfo.versionOf(l) >= 1) {
            (0, s.default)(_, S(h, _));
          }
          return _;
        }(e, t, i, o, l);
        return P(t || e, n, d, h);
      }(e, t, i, o, r.StudyMetaInfo.getStudyPropertyRootName(e), n, l);
    }
    function f(e) {
      const t = {};
      if (e.plots) {
        for (let i = 0; i < e.plots.length; i++) {
          const s = e.plots[i];
          const o = s.id;
          if ((0, p.isColorerPlot)(s)) {
            continue;
          }
          const n = {
            display: 15,
            color: "#0496FF",
            linestyle: l.LINESTYLE_SOLID,
            linewidth: 2,
            plottype: p.LineStudyPlotStyle.Line,
            trackPrice: false
          };
          if ((0, p.isBarColorerPlot)(s)) {
            n.transparency = 0;
          }
          n.plottype = s.type;
          n.title = o;
          t[o] = n;
        }
      }
      return {
        styles: t
      };
    }
    function y() {
      const e = (0, a.clone)((0, c.defaults)("study"));
      e.intervalsVisibilities = (0, a.clone)(d.intervalsVisibilitiesDefaults);
      return e;
    }
    function v(e, t, i) {
      let s = (0, a.clone)((0, c.defaults)(i, t));
      if (e.shortId === "Overlay" || e.shortId === "Compare") {
        s.currencyId = null;
        s.unitId = null;
      }
      if (e.isTVScript && e.TVScriptSourceCode !== s.TVScriptSourceCode) {
        s = (0, a.clone)((0, c.factoryDefaults)(i));
      }
      return s;
    }
    function S(e, t) {
      const i = {};
      h.StudyVersioning.mergeInputsObjPart(i, e.inputs ?? {});
      h.StudyVersioning.mergeInputsObjPart(i, t.inputs);
      return {
        inputs: i
      };
    }
    function b(e, t, i, n) {
      if (r.StudyMetaInfo.versionOf(e) < 1) {
        throw new Error("This function cannot work with metainfo of the old format version. Required format version >= 1");
      }
      const l = r.StudyMetaInfo.getStudyPropertyRootName(e);
      const h = (0, a.clone)(e.defaults);
      const d = (0, c.factoryDefaults)(l);
      const u = y();
      (0, s.default)(u, f(e));
      (0, s.default)(u, h);
      (0, s.default)(u, d);
      (0, s.default)(u, v(e, n, l));
      (0, s.default)(u, t);
      (0, s.default)(u, S(h, u));
      if (i !== null) {
        const t = i.model().studiesColorRotatorFactory().getColorRotator(e);
        if (t !== null) {
          if (e.id === "Overlay@tv-basicstudies") {
            u.lineStyle.color = t.getColor(u.lineStyle.color, d.lineStyle.color === u.lineStyle.color);
          } else {
            (0, s.default)(u, function (e, t) {
              for (const i of Object.keys(e.styles)) {
                const s = e.styles[i];
                if ((0, o.isObject)(s) && "color" in s) {
                  const e = s.color;
                  s.color = t.getColor(e);
                }
              }
              return e;
            }(u, t));
          }
        }
      }
      n.updateStudyInputsIfNeeded(u, u.version ?? e.version, e);
      return u;
    }
    function w(e, t, i, s, o) {
      return function (e, t, i, s, o, n) {
        const l = b(e, t, i, s);
        const c = r.StudyMetaInfo.getSourceInputIds(e);
        c.forEach((e, t) => {
          const i = l.inputs[e];
          if (t < n.length) {
            l.inputs[e] = `${n[t].id()}$0`;
          } else if ((0, a.isString)(i) && i.includes("$")) {
            l.inputs[e] = "close";
          }
        });
        return P(e, o, l);
      }(e, t, i, s, r.StudyMetaInfo.getStudyPropertyRootName(e), o);
    }
    const C = ["id", "description", "description_localized", "shortDescription", "_metainfoVersion", "is_price_study", "is_hidden_study", "priceScale", "fullId", "shortId", "scriptIdPart", "packageId", "productId", "isTVScriptStub", "defaults", "symbolSource", "historyCalculationMayChange", "format", "linkedToSeries", "isTVLibrary", "docs", "exports", "exportTypes", "extra", "usesPrivateLib", "financialPeriod", "groupingKey", "pine", "isRGB", "isTVScript", "TVScriptMetaInfoExprs", "usePlotsZOrder", "isTVScriptStrategy", "TVScriptSourceCode", "lookaheadFutureData", "hasAlertFunction", "defaultStrategyAlertMessage", "tags", "canBeChild", "canNotBeChild", "_serverMetaInfoVersion", "warnings"];
    function P(e, t, i, s) {
      for (const e of C) {
        delete i[e];
      }
      const o = ["visible", "precision", "minTick", "intervalsVisibilities", "inputs.first_visible_bar_time", "inputs.last_visible_bar_time", "inputs.subscribeRealtime"];
      for (let t = 0; t < e.inputs.length; ++t) {
        const i = e.inputs[t];
        if (i.isHidden) {
          o.push(`inputs.${t}`);
          o.push(`inputs.${i.id}`);
        }
      }
      const n = new u.DefaultProperty({
        defaultName: t,
        state: i,
        excludedDefaultsKeys: o,
        excludedStateKeys: ["version"],
        theme: s
      });
      n.removeProperty("intervalsVisibilities");
      n.addChild("intervalsVisibilities", new _.IntervalsVisibilitiesProperty(i && i.intervalsVisibilities));
      if ((e.id === "PivotPointsStandard@tv-basicstudies" || e.id === "PivotPointsHighLow@tv-basicstudies") && !!n.hasChild("font")) {
        n.removeProperty("font");
      }
      const a = r.StudyMetaInfo.versionOf(e);
      if (n.hasChild("version")) {
        n.childs().version?.setValue(a);
      } else {
        n.addProperty("version", a);
      }
      return n;
    }
  },
  28490: (e, t, i) => {
    "use strict";

    i.d(t, {
      containsBackgroundTimePointIndexes: () => r,
      dematerializeBackground: () => l,
      isBackgroundInBarsRange: () => c,
      materializeBackground: () => a
    });
    var s = i(50151);
    var o = i(50503);
    var n = i(65039);
    const r = true;
    function a(e, t) {
      if (e.start >= t.length || e.stop >= t.length) {
        return null;
      }
      const i = t[e.start];
      const n = t[e.stop];
      if (n === o.INVALID_TIME_POINT_INDEX) {
        return null;
      } else {
        (0, s.assert)(i === o.INVALID_TIME_POINT_INDEX || i <= n, "start should not exceed stop");
        return {
          start: i === o.INVALID_TIME_POINT_INDEX ? null : i,
          stop: n
        };
      }
    }
    function l(e, t, i) {
      return {
        id: t,
        start: (0, n.ensureTimePointIndexIndex)(i.indexOf(e.start !== null ? e.start : o.INVALID_TIME_POINT_INDEX)),
        stop: (0, n.ensureTimePointIndexIndex)(i.indexOf(e.stop))
      };
    }
    function c(e, t) {
      if (e.start === null) {
        return t.firstBar() <= e.stop;
      }
      const i = Math.min(e.start, e.stop);
      const s = Math.max(e.start, e.stop);
      return t.contains(i) || t.contains(s) || i < t.firstBar() && s > t.lastBar();
    }
  },
  14019: (e, t, i) => {
    "use strict";

    i.d(t, {
      LiveStudyGraphics: () => r.LiveStudyGraphics,
      createGraphicsPaneViews: () => _,
      createGraphicsPriceAxisViews: () => m,
      emptyStudyGraphics: () => n.emptyStudyGraphics,
      isStudyGraphicsEmpty: () => o.isStudyGraphicsEmpty,
      loadStudyGraphics: () => n.loadStudyGraphics,
      saveStudyGraphics: () => n.saveStudyGraphics
    });
    var s = i(9343);
    var o = i(58137);
    var n = i(22837);
    var r = i(26246);
    var a = i(98558);
    var l = i(19063);
    class c extends a.PriceAxisView {
      constructor(e, t) {
        super();
        this._source = e;
        this._data = t;
      }
      _updateRendererData(e, t, i) {
        e.visible = false;
        const s = this._source.priceScale();
        const o = this._source.properties().childs();
        const n = o.visible.value();
        if (!s || s.isEmpty() || !n) {
          return;
        }
        const r = o.graphics.childs()[this._data.lineType]?.childs()[this._data.styleId]?.childs();
        if (r === undefined || !r.visible || !r.visible.value() || !r.showPrice || !r.showPrice.value() || !this._isLabelVisibleAccordinglyToProperties()) {
          return;
        }
        const a = this._source.firstValue();
        if (a === null) {
          return;
        }
        const c = this._data.line.level;
        const h = (0, l.resetTransparency)(r.color.value());
        i.background = h;
        i.textColor = this.generateTextColor(h);
        i.coordinate = s.priceToCoordinate(c, a);
        e.text = s.formatPrice(c, a, {
          signPositive: s.isPercentage()
        });
        e.visible = true;
      }
      _isLabelVisibleAccordinglyToProperties() {
        return !!this._source.model().properties().childs().scalesProperties.childs().showStudyLastValue.value() && this._source.properties().childs().showLabelsOnPriceScale.value();
      }
    }
    const h = (0, s.getLogger)("Chart.StudyGraphics");
    const d = new Set(["dwgtablecells", "tpoBlockSets", "tpoLevels", "tpoVolumeRows", "logs", "performance"]);
    async function u(e, t, s, o) {
      const n = e => ({
        regularPaneView: new e(t, s, o)
      });
      switch (e) {
        case "hhists":
          return n((await i.e(507).then(i.bind(i, 56208))).HHistPaneView);
        case "horizlines":
          return n((await i.e(507).then(i.bind(i, 95258))).HorizLinePaneView);
        case "vertlines":
          return n((await i.e(507).then(i.bind(i, 51914))).VertLinePaneView);
        case "polygons":
          return n((await i.e(507).then(i.bind(i, 38332))).PolygonPaneView);
        case "backgrounds":
          return n((await i.e(507).then(i.bind(i, 55269))).BackgroundPaneView);
      }
      return null;
    }
    async function _(e, t, i) {
      const s = [];
      const o = [];
      const n = Object.keys(e.graphicsInfo());
      n.sort((e, t) => p(e) - p(t));
      for (const r of n) {
        const n = await u(r, e, t, i);
        if (n !== null) {
          s.push(n.regularPaneView);
          if (n.forceOverlayPaneView) {
            o.push(n.forceOverlayPaneView);
          }
        } else if (!d.has(r)) {
          h.logWarn(`${r} is not supported by this build of graphics subsystem, skipping`);
        }
      }
      return {
        regularPaneViews: s,
        forceOverlayPaneViews: o
      };
    }
    function p(e) {
      return o.primitivesZOrders.get(e) ?? 0;
    }
    function m(e) {
      const t = Object.keys(e.graphicsInfo());
      const i = [];
      for (const s of t) {
        switch (s) {
          case "hlines":
            e.graphics().hlines().forEach((t, o) => {
              t.forEach(t => {
                if (t.level !== undefined) {
                  i.push(new c(e, {
                    line: {
                      level: t.level
                    },
                    styleId: o,
                    lineType: s
                  }));
                }
              });
            });
            break;
          case "horizlines":
            e.graphics().horizlines().forEach((t, o) => {
              t.forEach(t => {
                if (t.level !== undefined) {
                  i.push(new c(e, {
                    line: {
                      level: t.level
                    },
                    styleId: o,
                    lineType: s
                  }));
                }
              });
            });
        }
      }
      return i;
    }
  },
  9233: (e, t, i) => {
    "use strict";

    i.d(t, {
      HHistDirection: () => s,
      HHistLocation: () => o,
      HHistVolumeMode: () => n,
      containsHHistTimePointIndexes: () => c,
      dematerializeHHist: () => d,
      isHHistInBarsRange: () => u,
      materializeHHist: () => h
    });
    var s;
    var o;
    var n;
    var r = i(50151);
    var a = i(50503);
    var l = i(65039);
    (function (e) {
      e.LeftToRight = "left_to_right";
      e.RightToLeft = "right_to_left";
    })(s ||= {});
    (function (e) {
      e.Relative = "relative";
      e.Absolute = "absolute";
    })(o ||= {});
    (function (e) {
      e.UpDown = "Up/Down";
      e.Total = "Total";
      e.Delta = "Delta";
    })(n ||= {});
    const c = true;
    function h(e, t) {
      if (e.lastBarTime >= t.length) {
        return null;
      }
      const i = t[e.firstBarTime];
      const s = t[e.lastBarTime];
      if (s === a.INVALID_TIME_POINT_INDEX) {
        return null;
      } else {
        (0, r.assert)(i <= s, "firstBarTime should not exceed lastBarTime");
        (0, r.assert)(e.priceLow <= e.priceHigh, "priceLow should not exceed priceHigh");
        return {
          firstBarTime: i === a.INVALID_TIME_POINT_INDEX ? null : i,
          lastBarTime: s,
          rate: e.rate,
          priceHigh: e.priceHigh,
          priceLow: e.priceLow
        };
      }
    }
    function d(e, t, i) {
      const s = (0, l.ensureTimePointIndexIndex)(i.indexOf(e.firstBarTime ?? a.INVALID_TIME_POINT_INDEX));
      const o = (0, l.ensureTimePointIndexIndex)(i.indexOf(e.lastBarTime));
      return {
        id: t,
        ...e,
        firstBarTime: s,
        lastBarTime: o
      };
    }
    function u(e, t) {
      const i = Math.min(e.firstBarTime ?? a.INVALID_TIME_POINT_INDEX, e.lastBarTime);
      const s = Math.max(e.firstBarTime ?? a.INVALID_TIME_POINT_INDEX, e.lastBarTime);
      return t.contains(i) || t.contains(s) || i < t.firstBar() && s > t.lastBar();
    }
  },
  45721: (e, t, i) => {
    "use strict";

    i.d(t, {
      containsHorizLineTimePointIndexes: () => r,
      dematerializeHorizLine: () => l,
      isHorizLineInBarsRange: () => c,
      materializeHorizLine: () => a
    });
    var s = i(50151);
    var o = i(50503);
    var n = i(65039);
    const r = true;
    function a(e, t) {
      if (e.startIndex >= t.length || e.endIndex >= t.length) {
        return null;
      }
      const i = t[e.startIndex];
      const n = t[e.endIndex];
      if (n === o.INVALID_TIME_POINT_INDEX) {
        return null;
      } else {
        (0, s.assert)(i <= n, "startIndex should not exceed endIndex");
        return {
          startIndex: i === o.INVALID_TIME_POINT_INDEX ? null : i,
          endIndex: n,
          level: e.level,
          extendLeft: e.extendLeft,
          extendRight: e.extendRight
        };
      }
    }
    function l(e, t, i) {
      const s = (0, n.ensureTimePointIndexIndex)(i.indexOf(e.startIndex ?? o.INVALID_TIME_POINT_INDEX));
      const r = (0, n.ensureTimePointIndexIndex)(i.indexOf(e.endIndex));
      return {
        id: t,
        ...e,
        startIndex: s,
        endIndex: r
      };
    }
    function c(e, t) {
      if (e.startIndex === null) {
        return t.firstBar() <= e.endIndex;
      }
      const i = Math.min(e.startIndex, e.endIndex);
      const s = Math.max(e.startIndex, e.endIndex);
      if (t.contains(i) || t.contains(s) || i < t.firstBar() && s > t.lastBar()) {
        return true;
      }
      const o = e.startIndex < e.endIndex ? e.extendLeft : e.extendRight;
      const n = e.startIndex < e.endIndex ? e.extendRight : e.extendLeft;
      return s < t.firstBar() && n || i > t.lastBar() && o;
    }
  },
  26246: (e, t, i) => {
    "use strict";

    i.d(t, {
      LiveStudyGraphics: () => _
    });
    var s = i(50151);
    var o = i(29981);
    var n = i(52033);
    var r = i(9233);
    var a = i(45721);
    var l = i(28656);
    var c = i(55257);
    var h = i(28490);
    var d = i(58137);
    var u = i(22837);
    class _ {
      constructor(e = {}) {
        this._indexes = [];
        this._hhistsByTimePointIndex = new Map();
        this._primitivesCollection = function (e) {
          const t = {};
          for (const i of d.primitiveNames) {
            t[i] = new Map();
            const s = e[i];
            if (s !== undefined) {
              for (const e in s) {
                if (s.hasOwnProperty(e)) {
                  switch (i) {
                    case "horizlines":
                      t[i].set(e, v.horizlines());
                      break;
                    case "vertlines":
                      t[i].set(e, v.vertlines());
                      break;
                    case "backgrounds":
                      t[i].set(e, v.backgrounds());
                      break;
                    case "polygons":
                      t[i].set(e, v.polygons());
                      break;
                    case "hhists":
                      t[i].set(e, v.hhists());
                  }
                }
              }
            }
          }
          0;
          return t;
        }(e);
      }
      horizlines() {
        return this._primitivesCollection.horizlines;
      }
      vertlines() {
        return this._primitivesCollection.vertlines;
      }
      lines() {
        return this._primitivesCollection.lines;
      }
      hlines() {
        return this._primitivesCollection.hlines;
      }
      textmarks() {
        return this._primitivesCollection.textmarks;
      }
      shapemarks() {
        return this._primitivesCollection.shapemarks;
      }
      backgrounds() {
        return this._primitivesCollection.backgrounds;
      }
      polygons() {
        return this._primitivesCollection.polygons;
      }
      trendchannels() {
        return this._primitivesCollection.trendchannels;
      }
      hhists() {
        return this._primitivesCollection.hhists;
      }
      dwglabels() {
        return this._primitivesCollection.dwglabels;
      }
      dwglines() {
        return this._primitivesCollection.dwglines;
      }
      dwgpolylines() {
        return this._primitivesCollection.dwgpolylines;
      }
      dwgboxes() {
        return this._primitivesCollection.dwgboxes;
      }
      dwgtables() {
        return this._primitivesCollection.dwgtables;
      }
      dwgtablecells() {
        return this._primitivesCollection.dwgtablecells;
      }
      dwglinefills() {
        return this._primitivesCollection.dwglinefills;
      }
      tpos() {
        return this._primitivesCollection.tpos;
      }
      tpoBlockSets() {
        return this._primitivesCollection.tpoBlockSets;
      }
      tpoLevels() {
        return this._primitivesCollection.tpoLevels;
      }
      tpoVolumeRows() {
        return this._primitivesCollection.tpoVolumeRows;
      }
      tpoSummaryInfo() {
        return this._primitivesCollection.tpoSummaryInfo;
      }
      logs() {
        return this._primitivesCollection.logs;
      }
      observableLogs() {
        return this._primitivesCollection.logs;
      }
      performance() {
        return this._primitivesCollection.performance;
      }
      observablePerformance() {
        return this._primitivesCollection.performance;
      }
      footprints() {
        return this._primitivesCollection.footprints;
      }
      footprintLevels() {
        return this._primitivesCollection.footprintLevels;
      }
      hhistsByTimePointIndex() {
        return this._hhistsByTimePointIndex;
      }
      clear() {
        this._indexes = [];
        for (const e of d.regularPrimitiveNames) {
          this._primitivesCollection[e].forEach(e => e.clear());
        }
        for (const e of d.groupedPrimitiveNames) {
          this._primitivesCollection[e].forEach(e => {
            e.forEach(e => e.clear());
          });
        }
        this._hhistsByTimePointIndex = new Map();
      }
      extract() {
        const e = {
          indexes: this._indexes,
          horizlines: g(this._primitivesCollection.horizlines),
          vertlines: g(this._primitivesCollection.vertlines),
          lines: g(this._primitivesCollection.lines),
          hlines: g(this._primitivesCollection.hlines),
          textmarks: g(this._primitivesCollection.textmarks),
          shapemarks: g(this._primitivesCollection.shapemarks),
          backgrounds: g(this._primitivesCollection.backgrounds),
          polygons: g(this._primitivesCollection.polygons),
          trendchannels: g(this._primitivesCollection.trendchannels),
          hhists: g(this._primitivesCollection.hhists),
          dwglabels: f(this._primitivesCollection.dwglabels),
          dwglines: f(this._primitivesCollection.dwglines),
          dwgpolylines: f(this._primitivesCollection.dwgpolylines),
          dwgboxes: f(this._primitivesCollection.dwgboxes),
          dwgtables: f(this._primitivesCollection.dwgtables),
          dwgtablecells: g(this._primitivesCollection.dwgtablecells),
          dwglinefills: g(this._primitivesCollection.dwglinefills),
          tpos: g(this._primitivesCollection.tpos),
          tpoBlockSets: f(this._primitivesCollection.tpoBlockSets),
          tpoLevels: f(this._primitivesCollection.tpoLevels),
          tpoVolumeRows: f(this._primitivesCollection.tpoVolumeRows),
          tpoSummaryInfo: f(this._primitivesCollection.tpoSummaryInfo),
          logs: new Map(),
          performance: new Map(),
          footprints: g(this._primitivesCollection.footprints),
          footprintLevels: g(this._primitivesCollection.footprintLevels)
        };
        this._hhistsByTimePointIndex = new Map();
        return new u.StaticStudyGraphics("data", e);
      }
      replaceIndexesTo(e) {
        this._indexes = e;
        const t = e => e.replaceIndexesTo(this._indexes);
        for (const e of d.regularPrimitiveNames) {
          this._primitivesCollection[e].forEach(t);
        }
        for (const e of d.groupedPrimitiveNames) {
          this._primitivesCollection[e].forEach(e => {
            e.forEach(t);
          });
        }
        this._hhistsByTimePointIndex = (0, d.splitHHistsByTimePointIndex)(this._primitivesCollection.hhists);
      }
      processCommands(e) {
        if (e.erase !== undefined) {
          this._processEraseCommands(e.erase);
        }
        if (e.create !== undefined) {
          this._processCreateCommands(e.create);
        }
      }
      _processCreateCommands(e) {
        for (const t in e) {
          if (!e.hasOwnProperty(t)) {
            continue;
          }
          const i = t;
          switch (i) {
            case "hhists":
              y(this._indexes, this._primitivesCollection.hhists, e[i]);
              break;
            case "horizlines":
              y(this._indexes, this._primitivesCollection.horizlines, e[i]);
              break;
            case "vertlines":
              y(this._indexes, this._primitivesCollection.vertlines, e[i]);
              break;
            case "polygons":
              y(this._indexes, this._primitivesCollection.polygons, e[i]);
              break;
            case "backgrounds":
              y(this._indexes, this._primitivesCollection.backgrounds, e[i]);
          }
        }
        this._hhistsByTimePointIndex = (0, d.splitHHistsByTimePointIndex)(this._primitivesCollection.hhists);
      }
      _processEraseCommands(e) {
        for (const t of e) {
          if (t.action === "all") {
            for (const e of d.regularPrimitiveNames) {
              this._primitivesCollection[e].forEach(e => e.clearPrimitives());
            }
            for (const e of d.groupedPrimitiveNames) {
              this._primitivesCollection[e].forEach(e => {
                e.forEach(e => e.clearPrimitives());
              });
            }
          } else {
            const e = e => e.deleteById(t.id);
            if ((0, d.isRegularPrimiriveName)(t.type)) {
              this._primitivesCollection[t.type].forEach(e);
            } else {
              this._primitivesCollection[t.type].forEach(t => {
                t.forEach(e);
              });
            }
          }
        }
        this._hhistsByTimePointIndex = (0, d.splitHHistsByTimePointIndex)(this._primitivesCollection.hhists);
      }
    }
    class p {
      constructor(e, t) {
        this._primitivesDataById = new Map();
        this._primitiveById = new Map();
        this._changed = new n.Delegate();
        this._cleared = new n.Delegate();
        this._materializePrimitive = e;
        this._isRematerializationRequiredWithNewIndexes = t;
      }
      changed() {
        return this._changed;
      }
      cleared() {
        return this._cleared;
      }
      forEach(e, t) {
        this._primitiveById.forEach(i => {
          e.call(t, i, i, this);
        });
      }
      has(e) {
        let t = false;
        this._primitiveById.forEach(i => {
          t = t || i === e;
        });
        return t;
      }
      get size() {
        return this._primitiveById.size;
      }
      [Symbol.iterator]() {
        return this._primitiveById.values();
      }
      entries() {
        throw new Error("Not implemented");
      }
      keys() {
        throw new Error("Not implemented");
      }
      union() {
        throw new Error("Not implemented");
      }
      intersection() {
        throw new Error("Not implemented");
      }
      difference() {
        throw new Error("Not implemented");
      }
      symmetricDifference() {
        throw new Error("Not implemented");
      }
      isSubsetOf() {
        throw new Error("Not implemented");
      }
      isSupersetOf() {
        throw new Error("Not implemented");
      }
      isDisjointFrom() {
        throw new Error("Not implemented");
      }
      values() {
        return this._primitiveById.values();
      }
      hasId(e) {
        return this._primitiveById.has(e);
      }
      addData(e, t) {
        const i = [];
        e.forEach(e => {
          this._primitivesDataById.set(e.id, e);
          const s = this._tryMaterialize(t, e);
          if (s !== null) {
            i.push(s);
          }
        });
        if (i.length > 0) {
          this._changed.fire({
            created: i,
            removed: []
          });
        }
      }
      deleteById(e) {
        const t = this._primitiveById.get(e);
        if (t) {
          this._primitiveById.delete(e);
          this._primitivesDataById.delete(e);
          this._changed.fire({
            created: [],
            removed: [t]
          });
        }
      }
      clear() {
        this.clearPrimitives();
      }
      clearPrimitives() {
        this._primitivesDataById.clear();
        this._primitiveById.clear();
        this._cleared.fire();
      }
      replaceIndexesTo(e) {
        if (!this._isRematerializationRequiredWithNewIndexes) {
          return;
        }
        const t = Array.from(this._primitiveById.values());
        this._primitiveById.clear();
        this._primitivesDataById.forEach(this._tryMaterialize.bind(this, e), this);
        const i = Array.from(this._primitiveById.values());
        this._changed.fire({
          created: i,
          removed: t
        });
      }
      extract() {
        const e = new Set(this._primitivesDataById.values());
        this.clearPrimitives();
        return e;
      }
      _tryMaterialize(e, t) {
        const i = this._materializePrimitive(t, e);
        if (i !== null) {
          (0, s.assert)(!this._primitiveById.has(t.id), "primitive with specified id should not exist");
          this._primitiveById.set(t.id, i);
        }
        return i;
      }
    }
    function m(e) {
      const t = new Map();
      for (const [n, r] of e) {
        t.set(n, (i = r, (s = t.get(n)) ? (0, o.join)(s, i.extract()) : i.extract()));
      }
      var i;
      var s;
      return t;
    }
    function g(e) {
      return m((0, o.mapEntriesGenerator)(e));
    }
    function f(e) {
      return m((0, o.nestedMapGenerator)(e));
    }
    function y(e, t, i = []) {
      for (const o of i) {
        const i = o.styleId;
        const n = t.get(i);
        (0, s.assert)(n !== undefined, "Every style used by graphics primitive should be declared in study metainfo");
        n.addData(o.data, e);
      }
    }
    const v = {
      horizlines: () => new p(a.materializeHorizLine, a.containsHorizLineTimePointIndexes),
      vertlines: () => new p(l.materializeVertLine, l.containsVertLineTimePointIndexes),
      lines: () => new p(materializeLine, containsLineTimePointIndexes),
      hlines: () => new p(materializeLevel, containsLevelTimePointIndexes),
      textmarks: () => new p(materializeTextMark, containsTextMarkTimePointIndexes),
      shapemarks: () => new p(materializeShapeMark, containsShapeMarkTimePointIndexes),
      backgrounds: () => new p(h.materializeBackground, h.containsBackgroundTimePointIndexes),
      polygons: () => new p(c.materializePolygon, c.containsPolygonTimePointIndexes),
      trendchannels: () => new p(materializeTrendChannel, containsTrendChannelTimePointIndexes),
      hhists: () => new p(r.materializeHHist, r.containsHHistTimePointIndexes),
      dwglines: () => new p(materializeDwgLine, containsDwgLineTimePointIndexes),
      dwglinefills: () => new p(materializeDwgLineFill, containsDwgLineFillTimePointIndexes),
      dwglabels: () => new p(materializeDwgLabel, containsDwgLabelTimePointIndexes),
      dwgtablecells: () => new p(materializeDwgTableCell, containsDwgTableCellTimePointIndexes),
      dwgpolylines: () => new p(materializeDwgPolyline, containsDwgPolylineTimePointIndexes),
      dwgboxes: () => new p(materializeDwgBox, containsDwgBoxTimePointIndexes),
      dwgtables: () => new p(materializeDwgTable, containsDwgTableTimePointIndexes),
      tpos: () => new p(materializeTpo, containsTpoTimePointIndexes),
      tpoBlockSets: () => new p(materializeTpoBlockSet, containsTpoBlockSetTimePointIndexes),
      tpoLevels: () => new p(materializeTpoLevelGroup, containsTpoLevelGroupTimePointIndexes),
      tpoVolumeRows: () => new p(materializeTpoVolumeRow, containsTpoVolumeRowTimePointIndexes),
      tpoSummary: () => new p(materializeTpoSummary, containsTpoSummaryTimePointIndexes),
      logs: () => new p(materializeLog, containsLogTimePointIndexes),
      footprints: () => new p(materializeVolumeFootprint, containsFootprintTimePointIndexes),
      footprintLevels: () => new p(materializeVolumeFootprintPriceLevel, containsFootprintPriceLevelTimePointIndexes)
    };
  },
  55257: (e, t, i) => {
    "use strict";

    i.d(t, {
      containsPolygonTimePointIndexes: () => n,
      dematerializePolygon: () => a,
      isPolygonInBarsRange: () => l,
      materializePolygon: () => r
    });
    var s = i(50503);
    var o = i(65039);
    const n = true;
    function r(e, t) {
      for (const i of e.points) {
        if (i.index >= t.length) {
          return null;
        }
        if (t[i.index] === s.INVALID_TIME_POINT_INDEX) {
          return null;
        }
      }
      return {
        points: e.points.map(e => ({
          index: t[e.index],
          offset: e.offset,
          level: e.level
        }))
      };
    }
    function a(e, t, i) {
      return {
        id: t,
        points: e.points.map(e => ({
          ...e,
          index: (0, o.ensureTimePointIndexIndex)(i.indexOf(e.index))
        }))
      };
    }
    function l(e, t) {
      if (e.points.some(e => t.contains(e.index + (e.offset ?? 0)))) {
        return true;
      }
      let i = false;
      let s = false;
      const o = t.firstBar();
      for (const t of e.points) {
        if (t.index + (t.offset ?? 0) < o) {
          i = true;
        } else {
          s = true;
        }
      }
      return i && s;
    }
  },
  65039: (e, t, i) => {
    "use strict";

    function s(e) {
      if (e < 0) {
        throw new Error("TimePointIndexIndex should be non-negative integer");
      }
      return e;
    }
    i.d(t, {
      ensureTimePointIndexIndex: () => s
    });
  },
  22837: (e, t, i) => {
    "use strict";

    i.d(t, {
      StaticStudyGraphics: () => d,
      emptyStudyGraphics: () => g,
      loadStudyGraphics: () => f,
      saveStudyGraphics: () => y
    });
    var s = i(50503);
    var o = i(45721);
    var n = i(28656);
    var r = i(9233);
    var a = i(55257);
    var l = i(28490);
    var c = i(58137);
    var h = i(37265);
    class d {
      constructor(e, t) {
        this._indexes = [];
        this._horizlines = new Map();
        this._vertlines = new Map();
        this._lines = new Map();
        this._hlines = new Map();
        this._textmarks = new Map();
        this._shapemarks = new Map();
        this._backgrounds = new Map();
        this._polygons = new Map();
        this._trendchannels = new Map();
        this._hhists = new Map();
        this._dwglabels = new Map();
        this._dwglines = new Map();
        this._dwgpolylines = new Map();
        this._dwgboxes = new Map();
        this._dwgtables = new Map();
        this._dwgtablecells = new Map();
        this._dwglinefills = new Map();
        this._tpos = new Map();
        this._tpoBlockSets = new Map();
        this._tpoLevelGroups = new Map();
        this._tpoVolumeRows = new Map();
        this._tpoSummaryInfo = new Map();
        this._logs = new Map();
        this._performance = new Map();
        this._footprints = new Map();
        this._footprintLevels = new Map();
        if (e === "data") {
          const e = t;
          this._indexes = e.indexes;
          this._vertlines = u(e.vertlines, this._indexes, n.materializeVertLine);
          this._horizlines = u(e.horizlines, this._indexes, o.materializeHorizLine);
          this._polygons = u(e.polygons, this._indexes, a.materializePolygon);
          this._hhists = u(e.hhists, this._indexes, r.materializeHHist);
          this._backgrounds = u(e.backgrounds, this._indexes, l.materializeBackground);
        } else if (e === "state") {
          const e = t;
          this._indexes = e.indexes || [];
          this._vertlines = _(e.vertlines, this._indexes, n.materializeVertLine);
          this._horizlines = _(e.horizlines, this._indexes, o.materializeHorizLine);
          this._polygons = _(e.polygons, this._indexes, a.materializePolygon);
          this._hhists = _(e.hhists, this._indexes, r.materializeHHist);
          this._backgrounds = _(e.backgrounds, this._indexes, l.materializeBackground);
        }
        this._hhistsByTimePointIndex = (0, c.splitHHistsByTimePointIndex)(this._hhists);
      }
      horizlines() {
        return this._horizlines;
      }
      vertlines() {
        return this._vertlines;
      }
      lines() {
        return this._lines;
      }
      hlines() {
        return this._hlines;
      }
      textmarks() {
        return this._textmarks;
      }
      shapemarks() {
        return this._shapemarks;
      }
      backgrounds() {
        return this._backgrounds;
      }
      polygons() {
        return this._polygons;
      }
      trendchannels() {
        return this._trendchannels;
      }
      hhists() {
        return this._hhists;
      }
      dwglabels() {
        return this._dwglabels;
      }
      dwglines() {
        return this._dwglines;
      }
      dwgpolylines() {
        return this._dwgpolylines;
      }
      dwgboxes() {
        return this._dwgboxes;
      }
      dwgtables() {
        return this._dwgtables;
      }
      dwgtablecells() {
        return this._dwgtablecells;
      }
      dwglinefills() {
        return this._dwglinefills;
      }
      tpos() {
        return this._tpos;
      }
      tpoBlockSets() {
        return this._tpoBlockSets;
      }
      tpoLevels(e) {
        return this._tpoLevelGroups;
      }
      tpoVolumeRows(e) {
        return this._tpoVolumeRows;
      }
      tpoSummaryInfo(e) {
        return this._tpoSummaryInfo;
      }
      logs() {
        return this._logs;
      }
      performance() {
        return this._performance;
      }
      footprints() {
        return this._footprints;
      }
      footprintLevels() {
        return this._footprintLevels;
      }
      hhistsByTimePointIndex() {
        return this._hhistsByTimePointIndex;
      }
    }
    function u(e, t, i) {
      return new Map(Array.from(e.entries()).map(e => [e[0], new Set(Array.from(e[1]).map(e => i(e, t)).filter(h.notNull))]));
    }
    function _(e, t, i) {
      const s = new Map();
      if (e === undefined) {
        return s;
      }
      for (const o of e) {
        const e = o.styleId;
        const n = s.get(e) || new Set();
        o.data.forEach(e => {
          const s = i(e, t);
          if (s !== null) {
            n.add(s);
          }
        });
        s.set(e, n);
      }
      return s;
    }
    function p(e, t, i) {
      let s = null;
      for (const i of e) {
        if (i.styleId === t) {
          s = i;
        }
      }
      if (s === null) {
        s = {
          styleId: t,
          data: []
        };
        e.push(s);
      }
      s.data.push(i);
    }
    function m(e, t, i, s, o, n) {
      const r = [];
      e.forEach((e, a) => {
        e.forEach(e => {
          if (o === null || s(e, o)) {
            p(r, a, n(e, t(e), i));
          }
        });
      });
      if (r.length > 0) {
        return r;
      } else {
        return undefined;
      }
    }
    function g() {
      return new d();
    }
    function f(e) {
      return new d("state", e);
    }
    function y(e, t) {
      const i = function (e) {
        const t = new Set();
        const i = e => {
          if (e != null) {
            t.add(e);
          }
        };
        e.horizlines().forEach((e, i) => {
          e.forEach(e => {
            t.add(e.startIndex ?? s.INVALID_TIME_POINT_INDEX);
            t.add(e.endIndex);
          });
        });
        e.vertlines().forEach((e, i) => {
          e.forEach(e => {
            t.add(e.index);
          });
        });
        e.lines().forEach((e, i) => {
          e.forEach(e => {
            t.add(e.startIndex);
            t.add(e.endIndex);
          });
        });
        e.textmarks().forEach((e, i) => {
          e.forEach(e => {
            t.add(e.time);
          });
        });
        e.shapemarks().forEach((e, i) => {
          e.forEach(e => {
            t.add(e.time);
          });
        });
        e.backgrounds().forEach((e, i) => {
          e.forEach(e => {
            t.add(e.start !== null ? e.start : s.INVALID_TIME_POINT_INDEX);
            t.add(e.stop);
          });
        });
        e.polygons().forEach((e, i) => {
          e.forEach(e => {
            e.points.forEach(e => {
              t.add(e.index);
            });
          });
        });
        e.trendchannels().forEach((e, i) => {
          e.forEach(e => {
            t.add(e.startIndex);
            t.add(e.endIndex);
          });
        });
        e.hhists().forEach((e, i) => {
          e.forEach(e => {
            t.add(e.firstBarTime ?? s.INVALID_TIME_POINT_INDEX);
            t.add(e.lastBarTime);
          });
        });
        e.dwglabels().forEach(e => {
          e.forEach(e => {
            e.forEach(e => {
              t.add(e.x);
            });
          });
        });
        e.dwglines().forEach(e => {
          e.forEach(e => {
            e.forEach(e => {
              t.add(e.x1 ?? s.INVALID_TIME_POINT_INDEX);
              t.add(e.x2 ?? s.INVALID_TIME_POINT_INDEX);
            });
          });
        });
        e.dwgpolylines().forEach(e => {
          e.forEach(e => {
            e.forEach(e => {
              for (const i of e.points) {
                t.add(i.x ?? s.INVALID_TIME_POINT_INDEX);
              }
            });
          });
        });
        e.dwgboxes().forEach(e => {
          e.forEach(e => {
            e.forEach(e => {
              t.add(e.left ?? s.INVALID_TIME_POINT_INDEX);
              t.add(e.right ?? s.INVALID_TIME_POINT_INDEX);
            });
          });
        });
        e.tpos().forEach(e => {
          e.forEach(e => {
            t.add(e.firstBarTime);
            t.add(e.lastBarTime);
          });
        });
        e.tpoLevels().forEach(e => {
          e.forEach(e => {
            e.forEach(e => {
              i(e.poorHighExtendTo);
              i(e.poorLowExtendTo);
              i(e.tpoPocExtendTo);
              (e.singleprints ?? []).map(e => e.extendTo).map(i);
            });
          });
        });
        e.footprints().forEach(e => {
          e.forEach(e => {
            t.add(e.index);
          });
        });
        e.footprintLevels().forEach(e => {
          e.forEach(e => {
            t.add(e.startIndex);
            i(e.extendTo);
          });
        });
        const o = Array.from(t);
        o.sort((e, t) => e - t);
        return o;
      }(e);
      const c = {
        indexes: i
      };
      let h = 0;
      const d = () => ++h;
      c.vertlines = m(e.vertlines(), d, i, n.isVertLineInBarsRange, t, n.dematerializeVertLine);
      c.horizlines = m(e.horizlines(), d, i, o.isHorizLineInBarsRange, t, o.dematerializeHorizLine);
      c.polygons = m(e.polygons(), d, i, a.isPolygonInBarsRange, t, a.dematerializePolygon);
      c.hhists = m(e.hhists(), d, i, r.isHHistInBarsRange, t, r.dematerializeHHist);
      c.backgrounds = m(e.backgrounds(), d, i, l.isBackgroundInBarsRange, t, l.dematerializeBackground);
      return c;
    }
  },
  85904: (e, t, i) => {
    "use strict";

    var s;
    var o;
    var n;
    var r;
    i.d(t, {
      HAlign: () => o,
      LineStyle: () => r,
      MarkLocation: () => s
    });
    (function (e) {
      e.AboveBar = "AboveBar";
      e.BelowBar = "BelowBar";
      e.Top = "Top";
      e.Bottom = "Bottom";
      e.Right = "Right";
      e.Left = "Left";
      e.Absolute = "Absolute";
      e.AbsoluteUp = "AbsoluteUp";
      e.AbsoluteDown = "AbsoluteDown";
    })(s ||= {});
    (function (e) {
      e.Left = "left";
      e.Center = "center";
      e.Right = "right";
    })(o ||= {});
    (function (e) {
      e.Top = "top";
      e.Middle = "middle";
      e.Bottom = "bottom";
    })(n ||= {});
    (function (e) {
      e[e.Solid = 0] = "Solid";
      e[e.Dotted = 1] = "Dotted";
      e[e.Dashed = 2] = "Dashed";
    })(r ||= {});
  },
  58137: (e, t, i) => {
    "use strict";

    i.d(t, {
      groupedPrimitiveNames: () => n,
      hasForceOverlayPrimitives: () => d,
      isRegularPrimiriveName: () => a,
      isStudyGraphicsEmpty: () => c,
      primitiveNames: () => r,
      primitivesZOrders: () => l,
      regularPrimitiveNames: () => o,
      splitHHistsByTimePointIndex: () => h
    });
    const s = ["dwglines", "dwgboxes", "dwglabels", "dwgpolylines", "dwgtables"];
    const o = ["horizlines", "vertlines", "lines", "hlines", "textmarks", "shapemarks", "backgrounds", "polygons", "trendchannels", "hhists", "dwgtablecells", "dwglinefills", "tpos", "logs", "performance", "footprints", "footprintLevels"];
    const n = s.concat(["tpoBlockSets", "tpoLevels", "tpoVolumeRows", "tpoSummaryInfo"]);
    const r = o.concat(n);
    function a(e) {
      return o.includes(e);
    }
    const l = new Map([["logs", -4], ["performance", -4], ["polygons", -4], ["trendchannels", -3], ["textmarks", -2], ["shapemarks", -2], ["backgrounds", -1], ["footprints", 1], ["footprintLevels", 1], ["hlines", 1], ["horizlines", 1], ["hhists", 1], ["dwglinefills", 2], ["vertlines", 3], ["lines", 3], ["dwglines", 3], ["dwgpolylines", 3], ["dwgboxes", 4], ["dwglabels", 5], ["dwgtables", 6], ["dwgtablecells", 6], ["tpos", 7], ["tpoBlockSets", 7], ["tpoLevels", 7], ["tpoVolumeRows", 7], ["tpoSummaryInfo", 1]]);
    function c(e) {
      return !r.some(t => {
        const i = e[t]();
        for (const [, e] of i) {
          if (e.size > 0) {
            return true;
          }
        }
        return false;
      });
    }
    function h(e) {
      const t = new Map();
      e.forEach((e, i) => {
        e.forEach(e => {
          const s = {
            ...e,
            styleId: i
          };
          const o = e.firstBarTime;
          let n = t.get(o);
          if (n === undefined) {
            n = new Set();
            t.set(o, n);
          }
          n.add(s);
        });
      });
      return t;
    }
    function d(e) {
      return !!e.graphics.dwglines || !!e.graphics.dwgboxes || !!e.graphics.dwglabels || !!e.graphics.dwgpolylines || !!e.graphics.dwgtables;
    }
  },
  28656: (e, t, i) => {
    "use strict";

    i.d(t, {
      containsVertLineTimePointIndexes: () => n,
      dematerializeVertLine: () => a,
      isVertLineInBarsRange: () => l,
      materializeVertLine: () => r
    });
    var s = i(50503);
    var o = i(65039);
    const n = true;
    function r(e, t) {
      if (e.index >= t.length) {
        return null;
      }
      const i = t[e.index];
      if (i === s.INVALID_TIME_POINT_INDEX) {
        return null;
      } else {
        return {
          startPrice: e.startPrice,
          endPrice: e.endPrice,
          index: i,
          extendTop: e.extendTop,
          extendBottom: e.extendBottom
        };
      }
    }
    function a(e, t, i) {
      const s = (0, o.ensureTimePointIndexIndex)(i.indexOf(e.index));
      return {
        id: t,
        ...e,
        index: s
      };
    }
    function l(e, t) {
      return t.contains(e.index);
    }
  },
  64671: (e, t, i) => {
    "use strict";

    var s;
    (function (e) {
      e.BuyAndSell = "Buy and sell";
      e.Delta = "Delta";
      e.Total = "Total";
    })(s ||= {});
  },
  7015: (e, t, i) => {
    "use strict";

    i.d(t, {
      HHistBasedValuesProvider: () => m
    });
    var s = i(50335);
    var o = i(50151);
    var n = i(49483);
    var r = i(8025);
    var a = i(928);
    var l = i(74079);
    var c = i(9233);
    var h = i(15764);
    var d = i(82587);
    function u(e, t = "", i = "") {
      return {
        id: t,
        index: e,
        title: i,
        value: "",
        visible: false
      };
    }
    const _ = n.CheckMobile.any();
    const p = (0, l.getVolumeFormatter)();
    class m {
      constructor(e, t, i = false) {
        this._emptyValues = [];
        this._study = e;
        this._model = t;
        this._emptyTitles = i;
        if (this._study.metaInfo().graphics.hhists !== undefined) {
          this._emptyValues.push(u(0), u(1), u(2));
        }
      }
      getItems() {
        return this._emptyValues;
      }
      getValues(e) {
        const t = this._emptyValues.map(e => ({
          ...e
        }));
        t.forEach(e => {
          e.visible = this._study.isVisible();
          e.value = d.notAvailable;
        });
        const i = this._study.properties().childs().inputs.childs().volume.value();
        switch (i) {
          case c.HHistVolumeMode.UpDown:
            if (!this._emptyTitles) {
              t[0].title = "Up";
              t[1].title = "Down";
              t[2].title = "Total";
            }
            break;
          case c.HHistVolumeMode.Total:
            if (!this._emptyTitles) {
              t[0].title = "Total";
            }
            t[1].visible = false;
            t[2].visible = false;
            break;
          case c.HHistVolumeMode.Delta:
            if (!this._emptyTitles) {
              t[0].title = "Delta";
              t[1].title = "Max(Up, Down)";
              t[2].title = "Total";
            }
        }
        const n = this._study.priceScale();
        const a = this._model.timeScale();
        if (n === null || n.isEmpty() || a.isEmpty() || this._hideValues()) {
          return t;
        }
        if (e === null || !isFinite(e)) {
          const i = this._study.data().last();
          if (i === null) {
            return t;
          }
          e = i.index;
        }
        const l = this._model.crosshairSource();
        const h = l.price;
        if (!isFinite(l.y) && (e = function (e, t) {
          const i = e.visibleBarsStrictRange()?.lastBar();
          if (!i) {
            return null;
          }
          const s = t.data().search(i, r.PlotRowSearchMode.NearestLeft);
          if (s) {
            return s.index;
          } else {
            return null;
          }
        }(this._model.timeScale(), this._model.mainSeries())) === null) {
          return t;
        }
        const u = function (e, t, i, s) {
          if (e.size === 0) {
            return null;
          }
          if (!i) {
            const e = (0, o.ensureNotNull)(s.data().valueAt(t));
            i = s.barFunction()(e);
          }
          const n = function (e, t) {
            let i = null;
            e.forEach((e, s) => {
              if (s !== null && s <= t && (i === null || s > i)) {
                i = s;
              }
            });
            return i;
          }(e, t);
          if (n === null) {
            return null;
          }
          const r = e.get(n);
          if (!r || r.size === 0) {
            return null;
          }
          return function (e, t) {
            let i = null;
            e.forEach(e => {
              if (e.priceLow <= t && t < e.priceHigh) {
                i = e;
              }
            });
            return i;
          }(r, i);
        }(this._study.graphics().hhistsByTimePointIndex(), e, h, this._model.mainSeries());
        if (u === null) {
          t.forEach(e => {
            e.value = "0";
          });
          return t;
        }
        const _ = this._study.metaInfo().graphics.hhists;
        if (_ === undefined) {
          return t;
        }
        if (_[u.styleId] === undefined) {
          return t;
        }
        const m = this._study.properties().childs().graphics.childs().hhists?.childs()[u.styleId]?.childs();
        const g = e => (0, s.isNumber)(e) ? p.format(e) : "";
        if (i !== c.HHistVolumeMode.Delta) {
          u.rate.forEach((e, i) => {
            t[i].value = g(e);
            t[i].color = (0, o.ensureDefined)(m).colors[i].value();
          });
          if (i === c.HHistVolumeMode.UpDown) {
            const e = u.rate[0] + u.rate[1];
            t[2].value = g(e);
            t[2].color = (0, o.ensureDefined)(m).valuesColor.value();
          }
        } else {
          const e = u.rate[0] > u.rate[1] ? 0 : 1;
          const i = (0, o.ensureDefined)(m).colors[e].value();
          const s = u.rate[0] + u.rate[1];
          [u.rate[e] * 2 - s, u.rate[e], s].forEach((e, s) => {
            t[s].value = g(e);
            t[s].color = i;
          });
        }
        return t;
      }
      _hideValues() {
        return _ && (this._model.crosshairSource().pane === null || (0, h.isLineToolName)(a.tool.value()) || this._model.lineBeingEdited() !== null);
      }
    }
  },
  16685: (e, t, i) => {
    "use strict";

    var s;
    i.d(t, {
      StudyStatusType: () => s
    });
    (function (e) {
      e[e.Undefined = 0] = "Undefined";
      e[e.Loading = 1] = "Loading";
      e[e.Completed = 2] = "Completed";
      e[e.Error = 3] = "Error";
    })(s ||= {});
  },
  3462: (e, t, i) => {
    "use strict";

    i.d(t, {
      makeNextStudyId: () => r,
      makeNextSymbolId: () => o
    });
    let s = 0;
    function o() {
      s++;
      return "ss_" + s;
    }
    let n = 0;
    function r() {
      n++;
      return "st" + n;
    }
  },
  62499: (e, t, i) => {
    "use strict";

    function s(e, t) {
      if (e === null) {
        return t;
      }
      const i = e.firstIndex;
      const s = t.firstIndex;
      const o = e.clearData || t.clearData;
      return {
        firstIndex: o || i === undefined || s === undefined ? undefined : Math.min(i, s),
        clearData: o
      };
    }
    i.d(t, {
      mergeDataInvalidation: () => s
    });
  },
  72530: (e, t, i) => {
    "use strict";

    i.d(t, {
      migrateMetaInfoAndPropState: () => p
    });
    var s = i(50151);
    var o = i(68159);
    var n = i(37265);
    const r = ["Moving Average@tv-basicstudies", "Moving Average Exponential@tv-basicstudies"];
    class a {
      targetMetaInfoVersion() {
        return 53;
      }
      migrateMetaInfo(e) {
        const t = e;
        e._metainfoVersion = 53;
        r.includes(t.id);
      }
      migratePropState(e) {
        if (r.includes(e.id)) {
          e.inputs.length = e.inputs.length ?? e.inputs.in_0;
          e.inputs.source = e.inputs.source ?? e.inputs.in_1;
          e.inputs.offset = e.inputs.offset ?? e.inputs.in_2;
          delete e.inputs.in_0;
          delete e.inputs.in_1;
          delete e.inputs.in_2;
          e.plots[1] = {
            id: "smoothedMA",
            type: "line"
          };
          e.styles.smoothedMA = {
            display: 0,
            linestyle: 0,
            linewidth: 1,
            plottype: 0,
            trackPrice: false,
            transparency: 0,
            color: "#0496ff",
            histogramBase: 0,
            joinPoints: false,
            title: "Smoothed MA"
          };
        }
      }
    }
    const l = ["Volume@tv-basicstudies"];
    class c {
      targetMetaInfoVersion() {
        return 53;
      }
      migrateMetaInfo(e) {
        const t = e;
        e._metainfoVersion = 53;
        l.includes(t.id);
      }
      migratePropState(e) {
        if (l.includes(e.id)) {
          e.inputs.maLength = e.inputs.length ?? e.inputs.maLength;
          delete e.inputs.length;
          delete e.inputs.offset;
          delete e.inputs.source;
          e.plots[1] = {
            id: "smoothedMA",
            type: "line"
          };
          e.styles.smoothedMA = {
            display: 0,
            linestyle: 0,
            linewidth: 1,
            plottype: 0,
            trackPrice: false,
            transparency: 0,
            color: "#0496ff",
            histogramBase: 0,
            joinPoints: false,
            title: "Smoothed MA"
          };
        }
      }
    }
    const h = ["Relative Strength Index@tv-basicstudies", "Commodity Channel Index@tv-basicstudies", "On Balance Volume@tv-basicstudies"];
    class d {
      targetMetaInfoVersion() {
        return 53;
      }
      migrateMetaInfo(e) {
        const t = e;
        const i = e;
        i._metainfoVersion = 53;
        if (h.includes(t.id)) {
          i.styles[t.id] = {
            title: "Smoothed MA",
            histogramBase: 0,
            joinPoints: false
          };
        }
      }
      migratePropState(e) {
        if (h.includes(e.id)) {
          e.plots[1] = {
            id: "smoothedMA",
            type: "line"
          };
          e.styles.smoothedMA = {
            display: 0,
            linestyle: 0,
            linewidth: 1,
            plottype: 0,
            trackPrice: false,
            transparency: 0,
            color: "#0496ff"
          };
        }
      }
    }
    var u;
    (function (e) {
      e[e.InMetaInfoVersion = 52] = "InMetaInfoVersion";
      e[e.OutMetaInfoVersion = 53] = "OutMetaInfoVersion";
    })(u ||= {});
    const _ = [new class {
      targetMetaInfoVersion() {
        return 47;
      }
      migrateMetaInfo(e) {
        const t = e;
        const i = e;
        i._metainfoVersion = 47;
        if (!t.defaults || t.defaults.precision === undefined) {
          i.format = {
            type: "inherit"
          };
          return;
        }
        const s = t.defaults && t.defaults.precision;
        const o = (0, n.isNumber)(s) ? s : parseInt(s);
        if (o === 0) {
          i.format = {
            type: "volume"
          };
        } else if (isFinite(o)) {
          i.format = {
            type: "price",
            precision: o
          };
        } else {
          i.format = {
            type: "inherit"
          };
        }
        delete t.defaults.precision;
      }
      migratePropState(e) { }
    }(), new class {
      targetMetaInfoVersion() {
        return 50;
      }
      migrateMetaInfo(e) {
        const t = e;
        const i = e;
        i._metainfoVersion = 50;
        if (t.defaults === undefined || t.defaults.ohlcPlots === undefined || t.ohlcPlots === undefined) {
          return;
        }
        const o = t.ohlcPlots;
        const n = t.defaults.ohlcPlots;
        const r = (0, s.ensureDefined)((0, s.ensureDefined)(i.defaults).ohlcPlots);
        for (const e of Object.keys(n)) {
          const t = n[e];
          if (t.plottype === "ohlc_candles") {
            let i = false;
            const s = o[e];
            if (s !== undefined) {
              i = !!s.drawBorder;
              delete s.drawBorder;
            }
            r[e] = {
              borderColor: "#000000",
              drawBorder: i,
              ...t
            };
          }
        }
      }
      migratePropState(e) { }
    }(), new class {
      targetMetaInfoVersion() {
        return 53;
      }
      migrateMetaInfo(e) {
        const t = e;
        const i = e;
        i._metainfoVersion = 53;
        if (t.defaults !== undefined) {
          if (t.defaults.ohlcPlots !== undefined && t.ohlcPlots !== undefined) {
            const e = Object.keys(t.ohlcPlots);
            const o = t.defaults.ohlcPlots;
            const n = (0, s.ensureDefined)((0, s.ensureDefined)(i.defaults).ohlcPlots);
            for (const t of e) {
              const e = o[t];
              if (e === undefined || e.visible === undefined) {
                continue;
              }
              const i = e.visible ? 15 : 0;
              delete e.visible;
              n[t] = {
                display: i,
                ...e
              };
            }
          }
          if (t.defaults.styles !== undefined && t.plots !== undefined) {
            const e = t.plots.map(e => e.id);
            const o = t.defaults.styles;
            const n = (0, s.ensureDefined)((0, s.ensureDefined)(i.defaults).styles);
            for (const t of e) {
              const e = o[t];
              if (e === undefined || e.visible === undefined) {
                continue;
              }
              const i = e.visible ? 15 : 0;
              delete e.visible;
              n[t] = {
                display: i,
                ...e
              };
            }
          }
        }
      }
      migratePropState(e) {
        if (e.ohlcPlots) {
          for (const t of Object.keys(e.ohlcPlots)) {
            const i = (0, s.ensureDefined)(e.ohlcPlots[t]);
            if (i.visible !== undefined) {
              i.display = i.visible ? 15 : 0;
              delete i.visible;
            }
          }
        }
        if (e.styles) {
          for (const t of Object.keys(e.styles)) {
            const i = (0, s.ensureDefined)(e.styles[t]);
            if (i.visible !== undefined) {
              i.display = i.visible ? 15 : 0;
              delete i.visible;
            }
          }
        }
      }
    }()];
    function p(e, t) {
      const i = o.StudyMetaInfo.versionOf(e);
      const n = e;
      if (n._serverMetaInfoVersion === undefined) {
        n._serverMetaInfoVersion = i;
      }
      const r = ["PennantCP@tv-basicstudies", "WedgeCP@tv-basicstudies"].includes(e.id);
      _.forEach(o => {
        if (!(i < 0) && !(i >= o.targetMetaInfoVersion()) || !!r) {
          o.migrateMetaInfo(e);
          if (t !== undefined) {
            o.migratePropState(t);
          }
          (0, s.assert)(e._metainfoVersion === o.targetMetaInfoVersion());
        }
      });
    }
    _.push(new a());
    _.push(new c());
    _.push(new d());
    _.sort(function (e, t) {
      return e.targetMetaInfoVersion() - t.targetMetaInfoVersion();
    });
  },
  25149: (e, t, i) => {
    "use strict";

    i.d(t, {
      NonSeriesStudy: () => r,
      isNonSeriesStudy: () => n
    });
    var s = i(50151);
    var o = i(46806);
    function n(e) {
      return e instanceof r;
    }
    class r extends o.Study {
      clearData() {
        this._customData = null;
        this._indexes = null;
      }
      restoreData(e, t, i) {
        super.restoreData(e);
        this._customData = t;
        this._indexes = i;
      }
      state(e) {
        const t = super.state(e);
        if (e) {
          t.nonSeriesData = this._customData;
          t.indexes = this._indexes;
        }
        return t;
      }
      customData() {
        return this._customData;
      }
      _setPaneViews(e) {
        this._paneViews = e;
        this.model().lightUpdate();
      }
      _onDataUpdated(e, t, i) {
        if (t !== null) {
          if (t.indexes_replace) {
            (0, s.assert)(i !== "nochange");
            this._indexes = i;
          } else {
            this._customData = t.data;
            if (i !== "nochange") {
              this._indexes = i;
            }
          }
        }
        super._onDataUpdated(e, t, i);
      }
    }
  },
  13380: (e, t, i) => {
    "use strict";

    var s;
    function o(e) {
      e.lineWidth = undefined;
      e.lineStyle = undefined;
      for (let t = 0; t < e.colors.length; t++) {
        e.colors[t] = undefined;
      }
      return e;
    }
    function n() {
      return {
        colors: [undefined, undefined, undefined, undefined, undefined, undefined, undefined],
        lineWidth: undefined,
        lineStyle: undefined
      };
    }
    i.d(t, {
      clearStyle: () => o,
      createEmptyStyle: () => n
    });
    (function (e) {
      e[e.Main = 0] = "Main";
      e[e.Background = 1] = "Background";
      e[e.Text = 2] = "Text";
      e[e.Border = 3] = "Border";
      e[e.Wick = 4] = "Wick";
      e[e.Up = 5] = "Up";
      e[e.Down = 6] = "Down";
    })(s ||= {});
  },
  81368: (e, t, i) => {
    "use strict";

    i.d(t, {
      PaneRendererColumns: () => n
    });
    var s = i(30125);
    var o = i(56468);
    class n extends s.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = null;
        this._precalculatedCache = [];
        this.setData(e);
      }
      setData(e) {
        this._data = e;
        this._precalculatedCache = [];
      }
      hitTest(e) {
        if (this._data === null) {
          return null;
        }
        const t = this._data.visibleItemsRange?.startItemIndex ?? 0;
        const i = (this._data.visibleItemsRange?.endItemIndex ?? this._data.items.length) - 1;
        for (let s = t; s <= i; s++) {
          const t = this._data.items[s];
          if (e.x >= t.left && e.x <= t.right) {
            const i = t.y;
            if (e.y >= Math.min(i, this._data.histogramBase) && e.y <= Math.max(i, this._data.histogramBase)) {
              return new o.HitTestResult(o.HitTarget.Regular);
            }
          }
        }
        return null;
      }
      _drawImpl(e) {
        if (this._data === null || this._data.items.length === 0) {
          return;
        }
        const {
          context: t,
          horizontalPixelRatio: i,
          verticalPixelRatio: s
        } = e;
        if (!this._precalculatedCache.length) {
          this._fillPrecalculatedCache(i);
        }
        const o = Math.max(1, Math.floor(i));
        const n = Math.max(1, Math.floor(s));
        const r = Math.round(this._data.histogramBase * s) - Math.floor(o / 2);
        const a = r + o;
        const l = this._data.lineColor;
        const c = this._data.visibleItemsRange?.startItemIndex ?? 0;
        const h = (this._data.visibleItemsRange?.endItemIndex ?? this._data.items.length) - 1;
        for (let e = c; e <= h; e++) {
          const i = this._data.items[e];
          const o = this._precalculatedCache[e - c];
          const h = Math.round(i.y * s);
          let d;
          let u;
          t.fillStyle = i.style ? i.style.color : l;
          if (h <= r) {
            d = h;
            u = a;
          } else {
            d = r;
            u = h - Math.floor(n / 2) + n;
          }
          t.fillRect(o.left, d, o.right - o.left + 1, u - d);
        }
      }
      _fillPrecalculatedCache(e) {
        if (this._data === null || this._data.items.length === 0) {
          this._precalculatedCache = [];
          return;
        }
        const {
          barSpacing: t,
          visibleItemsRange: i,
          items: s
        } = this._data;
        const o = Math.ceil(t * e) <= 1 ? 0 : Math.max(1, Math.floor(e));
        const n = i?.startItemIndex ?? 0;
        const r = (i?.endItemIndex ?? s.length) - 1;
        const a = r - n + 1;
        if (a <= 0) {
          this._precalculatedCache = [];
          return;
        }
        this._precalculatedCache = new Array(a);
        for (let t = n; t <= r; t++) {
          const i = s[t];
          const r = Math.round(i.center * e);
          let a;
          let l;
          const c = Math.round((i.right - i.left) * e) - o;
          if (c % 2) {
            const e = (c - 1) / 2;
            a = r - e;
            l = r + e;
          } else {
            const e = c / 2;
            a = r - e;
            l = r + e - 1;
          }
          this._precalculatedCache[t - n] = {
            left: a,
            right: l,
            roundedCenter: r,
            center: i.center * e,
            time: i.timePointIndex
          };
        }
        for (let e = n + 1; e <= r; e++) {
          const t = this._precalculatedCache[e - n];
          const i = this._precalculatedCache[e - n - 1];
          if (t.time === i.time + 1) {
            if (t.left - i.right !== o + 1) {
              if (i.roundedCenter > i.center) {
                i.right = t.left - o - 1;
              } else {
                t.left = i.right + o + 1;
              }
            }
          }
        }
        let l = Math.ceil(t * e);
        for (let e = n + 1; e <= r; e++) {
          const t = this._precalculatedCache[e - n];
          if (t.right < t.left) {
            t.right = t.left;
          }
          const i = t.right - t.left + 1;
          l = Math.min(i, l);
        }
        if (o > 0 && l < 4) {
          for (let e = n + 1; e <= r; e++) {
            const t = this._precalculatedCache[e - n];
            if (t.right - t.left + 1 > l) {
              if (t.roundedCenter > t.center) {
                t.right -= 1;
              } else {
                t.left += 1;
              }
            }
          }
        }
      }
    }
  },
  78198: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyPlotPaneView: () => V
    });
    var s = i(50151);
    var o = i(24377);
    var n = i(56570);
    var r = i(9859);
    var a = i(37265);
    var l = i(19063);
    var c = i(18832);
    function h(e, t) {
      const i = new Map();
      return function (...s) {
        const o = "" + (t ? t.apply(null, s) : s[0]);
        if (!i.has(o)) {
          const t = e.apply(this, s);
          i.set(o, t);
          return t;
        }
        return i.get(o);
      };
    }
    var d = i(2271);
    var u = i(95201);
    var _ = i(74010);
    var p = i(3385);
    var m = i(11064);
    var g = i(13380);
    var f = i(86441);
    var y = i(61993);
    var v = i(56468);
    var S = i(30125);
    var b = i(49483);
    class w extends S.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = e;
      }
      hitTest(e) {
        const t = this._data;
        const i = t.lineWidth;
        const s = t.vertOffset || 0;
        const o = (0, y.interactionTolerance)().series + i;
        const n = t.visibleItemsRange?.startItemIndex ?? 0;
        const r = t.visibleItemsRange?.endItemIndex ?? t.items.length;
        for (let a = n; a < r; a++) {
          const n = t.items[a];
          if (new f.Point(n.center, n.y + s).subtract(e).length() + i <= o) {
            return new v.HitTestResult(v.HitTarget.Regular);
          }
        }
        return null;
      }
      _drawImpl(e) {
        const t = this._data;
        const {
          horizontalPixelRatio: i,
          verticalPixelRatio: s,
          context: o
        } = e;
        const n = Math.max(1, Math.floor(i)) % 2 ? 0.5 : 0;
        const r = t.vertOffset || 0;
        const l = t.lineColor;
        const c = t.lineWidth;
        let h = "";
        let d = false;
        const u = t.visibleItemsRange?.startItemIndex ?? 0;
        const _ = t.visibleItemsRange?.endItemIndex ?? t.items.length;
        for (let e = u; e < _; e++) {
          const u = t.items[e];
          const _ = u.center;
          const p = u.y + r;
          if ((0, a.isNaN)(_) || (0, a.isNaN)(p)) {
            continue;
          }
          let m;
          let g;
          if (u.style != null) {
            m = u.style.color;
            g = u.style.width;
          } else {
            m = l;
            g = c;
          }
          if (m !== h || b.isSafari) {
            h = m;
            if (d) {
              o.fill();
            }
            o.beginPath();
            o.fillStyle = m;
          }
          const f = Math.round(_ * i) + n;
          const y = Math.round(p * s) + n;
          const v = Math.round(g * i) + n;
          o.moveTo(f + v, y);
          o.arc(f, y, v, 0, Math.PI * 2, false);
          d = true;
        }
        if (d) {
          o.fill();
        }
      }
    }
    var C = i(81368);
    var P = i(4652);
    class T extends S.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = e;
      }
      hitTest(e) {
        const t = (0, y.interactionTolerance)().series + this._data.lineWidth / 2;
        let i;
        let s;
        let o;
        let n;
        for (let r = 1; r < this._data.items.length; ++r) {
          i = this._data.items[r - 1];
          s = this._data.items[r];
          o = i.center;
          n = s.center;
          if ((0, P.distanceToSegment)(new f.Point(o, i.y), new f.Point(n, s.y), new f.Point(e.x, e.y)).distance <= t) {
            return new v.HitTestResult(v.HitTarget.Regular);
          }
        }
        return null;
      }
      _drawImpl(e) {
        const {
          context: t,
          horizontalPixelRatio: i,
          verticalPixelRatio: s
        } = e;
        let o = "";
        let n = false;
        const r = this._data.visibleItemsRange?.startItemIndex ?? 0;
        const l = (this._data.visibleItemsRange?.endItemIndex ?? this._data.items.length) - 1;
        for (let e = r; e <= l; e++) {
          const r = this._data.items[e];
          if ((0, a.isNaN)(r.center) || (0, a.isNaN)(r.y)) {
            continue;
          }
          const l = r.style?.color ?? this._data.lineColor;
          const c = r.style?.width ?? this._data.lineWidth;
          const h = Math.max(1, Math.floor(c * i));
          const d = Math.max(1, Math.floor(c * s));
          if (l !== o || b.isSafari) {
            o = l;
            if (n) {
              t.fill();
            }
            t.beginPath();
            t.fillStyle = l;
          }
          let u = h * 3;
          if (u % 2 != h % 2) {
            u += 1;
          }
          let _ = d * 3;
          if (_ % 2 != d % 2) {
            _ += 1;
          }
          const p = Math.round(Math.round(r.center * i) - u / 2);
          const m = Math.round(Math.round(r.y * s) - _ / 2);
          const g = p + Math.floor(u / 2 - h / 2);
          const f = m + Math.floor(_ / 2 - d / 2);
          t.rect(p, f, u, d);
          t.rect(g, m, h, _);
          n = true;
        }
        if (n) {
          t.fill();
        }
      }
    }
    class x extends S.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = e;
      }
      hitTest(e) {
        const t = (0, y.interactionTolerance)().series + this._data.lineWidth / 2;
        const i = new Map();
        for (const o of this._data.items) {
          const n = o.center;
          const r = o.y;
          let a = t;
          if (o.style) {
            if (i.has(o.style.width)) {
              a = (0, s.ensureDefined)(i.get(o.style.width));
            } else {
              i.set(this._data.lineWidth, a);
            }
          }
          if ((0, P.distanceToSegment)(new f.Point(n, r), new f.Point(n, this._data.histogramBase), new f.Point(e.x, e.y)).distance <= a) {
            return new v.HitTestResult(v.HitTarget.Regular);
          }
        }
        return null;
      }
      _drawImpl(e) {
        if (this._data.items.length === 0) {
          return;
        }
        const {
          context: t,
          horizontalPixelRatio: i,
          verticalPixelRatio: s
        } = e;
        t.fillStyle = this._data.lineColor;
        const o = Math.max(1, Math.floor(this._data.lineWidth * i));
        const n = o / 2;
        const r = Math.max(1, Math.floor(i));
        const a = Math.round(this._data.histogramBase * s) - Math.floor(r / 2);
        const l = a + r;
        const c = this._data.visibleItemsRange?.startItemIndex ?? 0;
        const h = (this._data.visibleItemsRange?.endItemIndex ?? this._data.items.length) - 1;
        for (let e = c; e <= h; e++) {
          const c = this._data.items[e];
          let h = o;
          let d = n;
          if (c.style) {
            t.fillStyle = c.style.color;
            h = Math.max(1, Math.floor(c.style.width * i));
            d = h / 2;
          } else {
            t.fillStyle = this._data.lineColor;
          }
          const u = h % 2 ? 0.5 : 0;
          const _ = Math.round(c.center * i) + u;
          const p = Math.round(c.y * s);
          let m;
          let g;
          if (p <= a) {
            m = p;
            g = l;
          } else {
            m = a;
            g = p - Math.floor(r / 2) + r;
          }
          t.fillRect(Math.floor(_ - d), m, h, g - m);
        }
      }
    }
    var I = i(94113);
    var M = i(83085);
    var A = i(29981);
    var L = i(35864);
    var k = i(46088);
    const D = e => {
      const t = (0, o.rgbToHsl)((0, o.parseRgb)(e));
      const i = t[0] + 0.05;
      t[0] = i - Math.floor(i);
      return (0, o.rgbToHexString)((0, o.hslToRgb)(t));
    };
    const E = h(D);
    const B = new Set([I.LineStudyPlotStyle.Line, I.LineStudyPlotStyle.Area, I.LineStudyPlotStyle.Circles, I.LineStudyPlotStyle.Cross, I.LineStudyPlotStyle.StepLine, I.LineStudyPlotStyle.StepLineWithDiamonds]);
    class V extends L.StudyPaneViewInplaceUpdatable {
      constructor(e, t, i, s, o = false) {
        super(t, i, s);
        this._histogramBase = null;
        this._lineColor = "";
        this._lineWidth = 1;
        this._color1 = "";
        this._color2 = "";
        this._renderer = new u.CompositeRenderer();
        this._isMarkersEnabled = n.enabled("source_selection_markers");
        this._study = e;
        this._plotIndex = e.metaInfo().plots.findIndex(e => e.id === s);
        this._colorProvider = (0, M.createStudyPlotColorProvider)(e.metaInfo(), e.properties(), s);
        this._extendStepLineToBarsEndings = o;
        this._isFundamental = false;
        const r = this._study.properties().styles[this._plotName].plottype.value();
        this._isStepLinePlot = r === I.LineStudyPlotStyle.StepLine || r === I.LineStudyPlotStyle.StepLineWithBreaks || r === I.LineStudyPlotStyle.StepLineWithDiamonds;
      }
      items() {
        return this._items;
      }
      renderer() {
        this._makeSureRendererIsValid();
        return this._renderer;
      }
      _getTranspValue() {
        const e = this._study.properties();
        const t = e.styles[this._plotName];
        let i = 0;
        const s = this._study.metaInfo();
        if (s.id === "Volume@tv-basicstudies" && s.version <= 46 && "transparency" in e) {
          i = e.transparency.value();
          i = (0, a.isNumber)(i) ? i : 0;
          return i;
        } else {
          if (t.transparency) {
            i = t.transparency.value();
            i = (0, a.isNumber)(i) ? i : 0;
          }
          return i;
        }
      }
      _updateImplFull(e) {
        this._renderer.clear();
        if (this._dataInvalidated?.clearData) {
          this._items = [];
        }
        if (!this._study.isPlotVisibleAt(this._plotName, 1)) {
          return false;
        }
        const t = this._priceScale();
        if (!t || t.isEmpty()) {
          return false;
        }
        if (this._study.firstValue(undefined, this.isForceOverlay()) === null) {
          return false;
        }
        this._histogramBase = null;
        const i = this._study.properties().styles[this._plotName];
        const o = i.plottype.value();
        const n = this._isFundamental && this._isStepLinePlot;
        const a = this._study.plots().plottableRange(n);
        if (a.size() === 0) {
          return false;
        }
        const c = this._study.offset(this._plotName);
        const h = B.has(o);
        const d = this._preallocateItems(a, (e, t) => ({
          y: NaN,
          left: NaN,
          center: NaN,
          right: NaN,
          origPrices: {
            price: t ?? NaN,
            timePointIndex: e + c
          },
          timePointIndex: e + c
        }));
        let u = NaN;
        let _ = NaN;
        const p = new Map();
        const m = (e, t) => {
          let i = p.get(e);
          if (i === undefined) {
            i = new Map();
            p.set(e, i);
          }
          let s = i.get(t);
          if (s === undefined) {
            const o = !this._plotName || this._plotName !== "vol";
            s = (0, l.generateColor)(e, t, o);
            i.set(t, s);
          }
          return s;
        };
        const f = (0, g.createEmptyStyle)();
        const y = (0, r.clamp)(this._getTranspValue(), 0, 100);
        const v = this._model.timeScale().visibleBarsStrictRange();
        if (v === null) {
          return false;
        }
        const {
          startBar: S,
          endBar: b
        } = this._calculateStartEnd(v);
        if (S === null || b === null || this._items.length === 0) {
          return false;
        }
        const w = d ?? (0, s.ensureNotNull)(a.firstIndex());
        const C = (0, s.ensureNotNull)(a.lastIndex()) + 1;
        const P = a.rangeIterator(w, C);
        let T;
        let x = (0, A.lowerbound)(this._items, w + c, (e, t) => e.timePointIndex < t);
        for (const e of P) {
          let t = e.index;
          const s = e.value;
          t += c;
          t = Math.floor(t);
          let o = s[this._plotIndex + 1];
          const n = o == null;
          o = n ? NaN : o;
          if (h && n) {
            _ = o;
            u = t;
            x++;
            continue;
          }
          const r = this._items[x];
          r.valIsNotSameAsPrev = o !== _ || t - 1 !== u;
          if (this._colorProvider.isColorDefined() && (r.style = {
            color: m(i.color.value(), 100),
            width: i.linewidth.value(),
            style: i.linestyle.value()
          }, o != null)) {
            const e = this._colorProvider.getPlotPointStyle(s, f);
            const t = e.colors[0];
            if (t !== undefined) {
              r.style.color = (0, l.isHexColor)(t) ? m(t, y) : t;
            }
            r.style.width = e.lineWidth ?? r.style.width;
            r.style.style = e.lineStyle ?? r.style.style;
          }
          if (!h && !isNaN(u) && u !== t - 1 && x > 0) {
            this._items[x].breakBefore = true;
          }
          _ = o;
          u = t;
          x++;
          T = r;
        }
        this._updateImplLight();
        return true;
      }
      _correctVisibleItemIndexes(e, t) {
        return super._correctVisibleItemIndexes(e, t);
      }
      _updateRenderer(e, t) {
        this._renderer.clear();
        const i = this._study.properties().styles.childs()[this._plotName].childs();
        const o = this._study.metaInfo().styles?.[this._plotName];
        const n = (0, r.clamp)(this._getTranspValue(), 0, 100);
        this._lineColor = (0, l.generateColor)(i.color.value(), n);
        this._lineWidth = i.linewidth.value();
        let h = i.color.value();
        const u = this._colorProvider.getDefaultPlotPointStyle();
        if (u) {
          h = u.colors[0] || h;
          this._lineWidth = u.lineWidth ?? this._lineWidth;
          this._lineColor = h ? (0, l.generateColor)(h, n) : this._lineColor;
        }
        this._color2 = (0, l.generateColor)(h, n);
        const g = this._study.metaInfo().isRGB ? D(h) : E(h);
        this._color1 = (0, l.generateColor)(g, n);
        const f = this._histogramBase ? this._histogramBase : (0, s.ensureNotNull)(this._priceScale()).height();
        const y = i.plottype.value();
        const v = {
          barSpacing: this._model.timeScale().barSpacing(),
          items: this._items,
          histogramBase: f,
          lineIndex: 0,
          lineStyle: i.linestyle.value(),
          lineColor: this._lineColor,
          lineWidth: (0, a.isNumber)(this._lineWidth) ? this._lineWidth : 1,
          color1: this._color1,
          color2: this._color2,
          bottom: f,
          visibleItemsRange: {
            startItemIndex: e,
            endItemIndex: t
          },
          simpleMode: this._colorProvider.singleColor(),
          skipHoles: [I.LineStudyPlotStyle.Line, I.LineStudyPlotStyle.Area, I.LineStudyPlotStyle.Cross, I.LineStudyPlotStyle.Circles, I.LineStudyPlotStyle.StepLine, I.LineStudyPlotStyle.StepLineWithDiamonds].includes(y)
        };
        const S = this._renderer;
        const b = Boolean(o?.joinPoints);
        switch (y) {
          case I.LineStudyPlotStyle.Line:
          case I.LineStudyPlotStyle.LineWithBreaks:
            S.append(new _.PaneRendererLine({
              ...v,
              lineColor: {
                type: k.ColorType.Solid,
                color: this._lineColor
              }
            }));
            break;
          case I.LineStudyPlotStyle.Area:
          case I.LineStudyPlotStyle.AreaWithBreaks:
            S.append(new d.PaneRendererArea({
              ...v,
              lineColor: {
                type: k.ColorType.Solid,
                color: this._lineColor
              }
            }));
            break;
          case I.LineStudyPlotStyle.Histogram:
            S.append(new x(v));
            break;
          case I.LineStudyPlotStyle.Columns:
            S.append(new C.PaneRendererColumns(v));
            break;
          case I.LineStudyPlotStyle.Cross:
            S.append(new T(v));
            if (b) {
              S.append(new _.PaneRendererLine({
                ...(0, c.deepCopy)(v),
                lineWidth: 1,
                lineColor: {
                  type: k.ColorType.Solid,
                  color: this._lineColor
                },
                forceLineWidth: true
              }));
            }
            break;
          case I.LineStudyPlotStyle.Circles:
            S.append(new w(v));
            if (b) {
              S.append(new _.PaneRendererLine({
                ...(0, c.deepCopy)(v),
                lineWidth: 1,
                lineColor: {
                  type: k.ColorType.Solid,
                  color: this._lineColor
                },
                ignorePaletteLineWidth: true
              }));
            }
            break;
          case I.LineStudyPlotStyle.StepLine:
          case I.LineStudyPlotStyle.StepLineWithBreaks:
          case I.LineStudyPlotStyle.StepLineWithDiamonds:
            {
              const e = new p.PaneRendererStepLine();
              e.setData({
                ...v,
                lineColor: {
                  type: k.ColorType.Solid,
                  color: this._lineColor
                },
                decoration: i.plottype.value() === I.LineStudyPlotStyle.StepLineWithDiamonds ? p.StepLineDecoration.Diamonds : p.StepLineDecoration.None,
                extendToBarsEndings: this._extendStepLineToBarsEndings
              });
              S.append(e);
              break;
            }
          default:
            S.append(new _.PaneRendererLine({
              ...v,
              lineColor: {
                type: k.ColorType.Solid,
                color: this._lineColor
              }
            }));
        }
        if (this._model.selection().isSelected(this._study) && this._isMarkersEnabled && this._selectionData) {
          S.append(new m.SelectionRenderer(this._selectionData));
        }
      }
      _updateAdditionalPrices(e, t) {
        const i = this._study.metaInfo().styles?.[this._plotName];
        if (i?.histogramBase !== undefined) {
          this._histogramBase = e.priceToCoordinate(i.histogramBase, t);
        }
      }
    }
  },
  64559: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyForceOverlayPlotView: () => s
    });
    class s {
      constructor(e, t, i) {
        this._series = e;
        this._model = t;
        this._plotName = i;
      }
      isForceOverlay() {
        return !!this._study.metaInfo().isPlotForceOverlay(this._plotName);
      }
      _priceScale() {
        if (this.isForceOverlay()) {
          return this._model.mainSeries().priceScale();
        } else {
          return this._study.priceScale();
        }
      }
    }
  },
  35864: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyPaneViewInplaceUpdatable: () => u
    });
    var s = i(50151);
    var o = i(86441);
    var n = i(37265);
    var r = i(62499);
    var a = i(8025);
    var l = i(29981);
    var c = i(66540);
    var h = i(56468);
    var d = i(64559);
    class u extends d.StudyForceOverlayPlotView {
      constructor(e, t, i) {
        super(e, t, i);
        this._selectionData = null;
        this._dataInvalidated = null;
        this._viewportInvalidated = false;
        this._items = [];
        this._selectionIndexer = new c.SelectionIndexes(t.timeScale());
      }
      update(e) {
        if (e.type !== "hover-change") {
          if (e.type === "global-change") {
            this._dataInvalidated = (0, r.mergeDataInvalidation)(this._dataInvalidated, {});
            this._viewportInvalidated = true;
            return;
          }
          if (e.type !== "data-source-change") {
            this._viewportInvalidated = true;
          } else if ((e.sourceId === this._study.id() || this._dependsOnSeriesData() && e.sourceId === this._model.mainSeries().id()) && !e.nonSeriesOnly) {
            const t = (0, r.mergeDataInvalidation)(this._dataInvalidated, {
              firstIndex: e.firstUpdatedTimePointIndex,
              clearData: e.clearData
            });
            this._dataInvalidated = t;
          }
        }
      }
      _dependsOnSeriesData() {
        return false;
      }
      _makeSureRendererIsValid() {
        if (this._dataInvalidated) {
          if (this._updateImplFull(this._viewportInvalidated)) {
            this._dataInvalidated = null;
          }
        } else if (this._viewportInvalidated) {
          this._updateImplLight();
        }
        this._viewportInvalidated = false;
      }
      _preallocateItems(e, t) {
        const i = e.size();
        let o = this._dataInvalidated?.firstIndex;
        if (i === 0) {
          return o;
        }
        const n = this._study.offset(this._plotName);
        if (i !== this._items.length) {
          const i = o !== undefined ? o + n : undefined;
          if (i === undefined || this._items.length === 0 || i < (0, s.ensureDefined)(this._items[0].timePointIndex)) {
            this._items = [];
            e.each((e, i) => {
              const s = i[this._plotIndex + 1];
              this._items.push(t(e, s));
              return false;
            });
            if (this._items.length) {
              return (0, s.ensureDefined)(this._items[0].timePointIndex) - n;
            } else {
              return undefined;
            }
          }
          {
            const i = (0, s.ensureDefined)(o);
            const r = n >= 0 ? 0 : n;
            const a = n >= 0 ? n : 0;
            let c = (0, l.lowerbound)(this._items, i + r, (e, t) => e.timePointIndex < t);
            const h = (0, s.ensureNotNull)(e.lastIndex());
            const d = e.rangeIterator(i - a, h);
            for (const e of d) {
              if (c !== undefined && this._items[c]?.timePointIndex === e.index + n) {
                c = this._updateItem(e, c);
              } else {
                const i = e.value[this._plotIndex + 1];
                this._items.push(t(e.index, i));
              }
            }
          }
        } else {
          o = o ?? e.firstIndex() ?? undefined;
          if (o !== undefined) {
            const t = n >= 0 ? 0 : n;
            const i = n >= 0 ? n : 0;
            let r = (0, l.lowerbound)(this._items, o + t, (e, t) => e.timePointIndex < t);
            const a = (0, s.ensureNotNull)(e.lastIndex()) + 1;
            const c = e.rangeIterator(o - i, a);
            for (const e of c) {
              r = this._updateItem(e, r);
            }
          }
        }
        return o;
      }
      _updateItem(e, t) {
        const i = this._getValueForUpdating(e);
        this._items[t].origPrices.price = i ?? NaN;
        return t + 1;
      }
      _getValueForUpdating(e) {
        return e.value[this._plotIndex + 1];
      }
      _calculateStartEnd(e) {
        const t = this._study.offset(this._plotName);
        let i = e.firstBar() - Math.abs(t) - 1;
        let o = e.lastBar() + Math.abs(t) + 1;
        const n = this._study.getMinFirstBarIndexForPlot(this._plotName) + t;
        if (n > o + 1) {
          return {
            startBar: null,
            endBar: null
          };
        }
        let r = this._study.plots();
        r = r.range(n, (0, s.ensureNotNull)(r.lastIndex()));
        i = Math.max(i, n);
        o = Math.max(o, n);
        const l = r.search(i, a.PlotRowSearchMode.NearestLeft, this._plotIndex + 1);
        const c = r.search(o, a.PlotRowSearchMode.NearestRight, this._plotIndex + 1);
        if (l !== null) {
          i = l.index;
        }
        if (c !== null) {
          o = c.index;
        }
        i = Math.max(n, i);
        return {
          startBar: i,
          endBar: o
        };
      }
      _updateImplLight() {
        const e = this._study.firstValue(undefined, this.isForceOverlay());
        if (e === null) {
          this._selectionData = null;
          this._updateRenderer(0, -1);
          return;
        }
        const t = this._priceScale();
        if (t === null || t.isEmpty()) {
          this._selectionData = null;
          this._updateRenderer(0, -1);
          return;
        }
        const i = this._model.timeScale().visibleBarsStrictRange();
        if (i === null) {
          this._selectionData = null;
          this._updateRenderer(0, -1);
          return;
        }
        const {
          startBar: s,
          endBar: o
        } = this._calculateStartEnd(i);
        if (s === null || o === null || this._items.length === 0) {
          this._selectionData = null;
          this._updateRenderer(0, -1);
          return;
        }
        const {
          startItemIndex: n,
          endItemIndex: r
        } = this._correctVisibleItemIndexes(Math.max(0, (0, l.lowerbound)(this._items, s, (e, t) => e.timePointIndex < t)), Math.min(this._items.length, (0, l.upperbound)(this._items, o, (e, t) => e < t.timePointIndex)));
        if (n >= r) {
          this._selectionData = null;
          this._updateRenderer(0, -1);
          return;
        }
        this._convertItemsToCoordinates(t, e, n, r);
        this._createSelection(e);
        this._updateRenderer(n, r);
      }
      _correctVisibleItemIndexes(e, t) {
        return {
          startItemIndex: e,
          endItemIndex: t
        };
      }
      _convertItemsToCoordinates(e, t, i, s) {
        this._convertItemsToCoordinatesImpl(e, t, i, s);
      }
      _convertItemsToCoordinatesImpl(e, t, i, s) {
        for (let e = i; e < s; e++) {
          const t = this._items[e];
          t.y = t.origPrices.price;
        }
        e.pointsArrayToCoordinates(this._items, t, {
          startItemIndex: i,
          endItemIndex: s
        });
        this._model.timeScale().fillBarBorders(this._items, {
          startItemIndex: i,
          endItemIndex: s
        }, true);
        this._updateAdditionalPrices(e, t);
      }
      _updateAdditionalPrices(e, t) { }
      _createSelection(e) {
        const t = this._priceScale();
        if (t !== null) {
          if (this._model.selection().isSelected(this._study)) {
            const i = (0, s.ensureNotNull)(this._model.paneForSource(this._study)).height();
            this._selectionData = {
              points: [],
              bgColors: [],
              visible: true,
              hittestResult: h.HitTarget.Regular,
              barSpacing: this._model.timeScale().barSpacing()
            };
            const o = this._study.offset(this._plotName);
            for (const s of this._selectionIndexer.indexes()) {
              const r = this._study.plots().valueAt(s);
              if ((0, n.isAbsent)(r)) {
                continue;
              }
              const a = r[this._plotIndex + 1];
              if ((0, n.isAbsent)(a)) {
                continue;
              }
              const l = this._createSelectionDataPoint(t, Math.floor(s + o), a, e);
              this._selectionData.points.push(l);
              this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(l.point.y / i));
            }
          } else {
            this._selectionIndexer.clear();
          }
        }
      }
      _createSelectionDataPoint(e, t, i, s) {
        const n = this._model.timeScale().indexToCoordinate(t);
        const r = e.priceToCoordinate(i, s);
        return {
          point: (0, o.point)(n, r)
        };
      }
    }
  },
  83085: (e, t, i) => {
    "use strict";

    i.d(t, {
      createStudyPlotColorProvider: () => _
    });
    var s = i(94113);
    var o = i(50151);
    var n = i(13380);
    const r = new Map([[0, "color"], [2, "textColor"], [3, "borderColor"], [4, "wickColor"], [5, "colorup"], [6, "colordown"]]);
    class a {
      constructor(e) {
        this._plotStyle = e;
      }
      getPlotPointStyle(e, t) {
        const i = t ? (0, n.clearStyle)(t) : (0, n.createEmptyStyle)();
        r.forEach((e, t) => {
          if (this._plotStyle[e]) {
            i.colors[t] = this._plotStyle[e].value();
          }
        });
        i.lineWidth = this._plotStyle.linewidth ? this._plotStyle.linewidth.value() : undefined;
        i.lineStyle = this._plotStyle.linestyle ? this._plotStyle.linestyle.value() : undefined;
        return i;
      }
      isColorDefined() {
        return true;
      }
      singleColor() {
        return true;
      }
      getDefaultPlotPointStyle() {
        return null;
      }
    }
    const l = [0, 1, 2, 3, 4, 5, 6];
    class c {
      constructor(e, t, i, s) {
        this._palettesColors = new Map();
        this._defaultPlotColors = new Map();
        this._indexes = s;
        const n = t.styles[i];
        if (n) {
          for (const [e, t] of r) {
            this._defaultPlotColors.set(e, n[t]);
          }
        }
        const a = (0, o.ensureDefined)(e.palettes);
        const l = e.plots;
        s.forEach((e, i) => {
          const s = l[e];
          if (s && "palette" in s) {
            const e = a[s.palette];
            const o = t.palettes[s.palette];
            if (e && o) {
              const {
                valToIndex: t
              } = e;
              const {
                colors: s
              } = o;
              const n = {
                ...s
              };
              if (t) {
                Object.keys(t).forEach(e => {
                  const i = t[e];
                  if (i !== undefined) {
                    n[e] = s[i];
                  }
                });
              }
              this._palettesColors.set(i, n);
            }
          }
        });
      }
      getPlotPointStyle(e, t) {
        const i = t ? (0, n.clearStyle)(t) : (0, n.createEmptyStyle)();
        l.forEach(t => {
          if (this._palettesColors.has(t)) {
            const s = e[(0, o.ensureDefined)(this._indexes.get(t)) + 1];
            if (typeof s == "number") {
              const e = this._palettesColors.get(t)?.[s];
              if (t === 0 && e) {
                i.lineWidth = e.width.value();
                i.lineStyle = e.style.value();
              }
              i.colors[t] = e?.color.value();
            } else {
              i.colors[t] = "transparent";
            }
          } else {
            i.colors[t] = this._defaultPlotColors.get(t)?.value();
          }
        });
        return i;
      }
      getDefaultPlotPointStyle() {
        const e = this._palettesColors.get(0)?.[0];
        if (e !== undefined) {
          return {
            colors: [e.color.value(), undefined, undefined, undefined, undefined, undefined, undefined],
            lineStyle: undefined,
            lineWidth: e.width.value()
          };
        }
        return null;
      }
      isColorDefined() {
        return !!this._palettesColors.size;
      }
      singleColor() {
        return false;
      }
    }
    var h = i(31599);
    class d {
      constructor(e) {
        this._rgbaFromInteger = (0, h.rgbaFromIntegerCached)();
        this._indexes = e;
      }
      getPlotPointStyle(e, t) {
        const i = t ? (0, n.clearStyle)(t) : (0, n.createEmptyStyle)();
        this._indexes.forEach((t, s) => {
          const o = e[t + 1];
          if (o != null) {
            const e = this._rgbaFromInteger(o);
            i.colors[s] = e;
          } else {
            i.colors[s] = "transparent";
          }
        });
        return i;
      }
      isColorDefined() {
        return true;
      }
      singleColor() {
        return false;
      }
      getDefaultPlotPointStyle() {
        return null;
      }
    }
    const u = new Map([[0, function (e, t) {
      const i = (0, s.isColorerPlot)(t) || (0, s.isOhlcColorerPlot)(t);
      return "target" in t && t.target === e && i;
    }], [2, function (e, t) {
      const i = (0, s.isTextColorerPlot)(t);
      return "target" in t && t.target === e && i;
    }], [1, function (e, t) {
      return (0, s.isBgColorerPlot)(t) && t.id === e;
    }], [3, function (e, t) {
      const i = (0, s.isCandleBorderColorerPlot)(t);
      return "target" in t && t.target === e && i;
    }], [4, function (e, t) {
      const i = (0, s.isCandleWickColorerPlot)(t);
      return "target" in t && t.target === e && i;
    }], [5, function (e, t) {
      const i = (0, s.isUpColorerPlot)(t);
      return "target" in t && t.target === e && i;
    }], [6, function (e, t) {
      const i = (0, s.isDownColorerPlot)(t);
      return "target" in t && t.target === e && i;
    }]]);
    function _(e, t, i) {
      const {
        colorers: s
      } = function (e, t) {
        const i = e.plots;
        const s = i.findIndex(e => e.id === t);
        const o = new Map();
        i.forEach((e, i) => {
          u.forEach((s, n) => {
            if (s(t, e)) {
              o.set(n, i);
            }
          });
        });
        return {
          plotIndex: s === -1 ? null : s,
          colorers: o
        };
      }(e, i);
      if (s.size) {
        if (e.isRGB) {
          return new d(s);
        } else {
          return new c(e, t, i, s);
        }
      }
      {
        const e = t.ohlcPlots;
        if (e && e[i]) {
          return new a(e[i]);
        }
        const s = t.styles[i];
        return new a(s);
      }
    }
  },
  94113: (e, t, i) => {
    "use strict";

    var s;
    var o;
    var n;
    var r;
    var a;
    var l;
    var c;
    function h(e) {
      return e.type === "line";
    }
    function d(e) {
      return e.type === "shapes";
    }
    function u(e) {
      return e.type === "chars";
    }
    function _(e) {
      return e.type === "arrows";
    }
    function p(e) {
      return e.type === "data";
    }
    function m(e) {
      return e.type === "dataoffset";
    }
    function g(e) {
      return e.type === "ohlc_open";
    }
    function f(e) {
      return e.type === "ohlc_high";
    }
    function y(e) {
      return e.type === "ohlc_low";
    }
    function v(e) {
      return e.type === "ohlc_close";
    }
    function S(e) {
      return g(e) || f(e) || y(e) || v(e);
    }
    function b(e) {
      return e.type === "colorer" && "palette" in e;
    }
    function w(e) {
      return e.type === "colorer" && !("palette" in e);
    }
    function C(e) {
      return e.type === "colorer";
    }
    function P(e) {
      return e.type === "bar_colorer";
    }
    function T(e) {
      return e.type === "bg_colorer";
    }
    function x(e) {
      return e.type === "text_colorer";
    }
    function I(e) {
      return e.type === "ohlc_colorer";
    }
    function M(e) {
      return e.type === "wick_colorer";
    }
    function A(e) {
      return e.type === "border_colorer";
    }
    function L(e) {
      return e.type === "up_colorer";
    }
    function k(e) {
      return e.type === "down_colorer";
    }
    function D(e) {
      return e.type === "alertcondition";
    }
    function E(e) {
      return h(e) || d(e) || u(e) || _(e);
    }
    function B(e) {
      return e !== "Plot";
    }
    function V(e) {
      return e.plottype === "ohlc_bars";
    }
    function R(e) {
      return e.plottype === "ohlc_candles";
    }
    function N(e) {
      return C(e) || P(e) || T(e) || p(e) || m(e) || I(e) || D(e) || L(e) || k(e) || A(e) || M(e) || x(e);
    }
    function O(e) {
      return C(e) || x(e) || P(e) || p(e) || m(e) || I(e) || M(e) || A(e) || L(e) || k(e) || D(e);
    }
    i.r(t);
    i.d(t, {
      InternalStudyPlotType: () => n,
      LineStudyPlotStyle: () => s,
      OhlcStudyPlotStyle: () => l,
      PlotSymbolSize: () => c,
      STUDYPLOTDISPLAYTARGET: () => a,
      StudyPlotDisplayTarget: () => r,
      StudyPlotType: () => o,
      isAlertConditionPlot: () => D,
      isArrowsPlot: () => _,
      isBarColorerPlot: () => P,
      isBgColorerPlot: () => T,
      isCandleBorderColorerPlot: () => A,
      isCandleWickColorerPlot: () => M,
      isCharsPlot: () => u,
      isColorerPlot: () => C,
      isDataOffsetPlot: () => m,
      isDataPlot: () => p,
      isDownColorerPlot: () => k,
      isLinePlot: () => h,
      isNonVisualPlot: () => O,
      isOhlcClosePlot: () => v,
      isOhlcColorerPlot: () => I,
      isOhlcHighPlot: () => f,
      isOhlcLowPlot: () => y,
      isOhlcOpenPlot: () => g,
      isOhlcPlot: () => S,
      isOhlcPlotStyleBars: () => V,
      isOhlcPlotStyleCandles: () => R,
      isPaletteColorerPlot: () => b,
      isPlotSupportDisplay: () => E,
      isPlotTitleDefined: () => B,
      isPlotWithTechnicalValues: () => N,
      isRgbaColorerPlot: () => w,
      isShapesPlot: () => d,
      isTextColorerPlot: () => x,
      isUpColorerPlot: () => L
    });
    (function (e) {
      e[e.Line = 0] = "Line";
      e[e.Histogram = 1] = "Histogram";
      e[e.Cross = 3] = "Cross";
      e[e.Area = 4] = "Area";
      e[e.Columns = 5] = "Columns";
      e[e.Circles = 6] = "Circles";
      e[e.LineWithBreaks = 7] = "LineWithBreaks";
      e[e.AreaWithBreaks = 8] = "AreaWithBreaks";
      e[e.StepLine = 9] = "StepLine";
      e[e.StepLineWithDiamonds = 10] = "StepLineWithDiamonds";
      e[e.StepLineWithBreaks = 11] = "StepLineWithBreaks";
    })(s ||= {});
    (function (e) {
      e.Line = "line";
      e.Colorer = "colorer";
      e.BarColorer = "bar_colorer";
      e.BgColorer = "bg_colorer";
      e.TextColorer = "text_colorer";
      e.OhlcColorer = "ohlc_colorer";
      e.CandleWickColorer = "wick_colorer";
      e.CandleBorderColorer = "border_colorer";
      e.UpColorer = "up_colorer";
      e.DownColorer = "down_colorer";
      e.Shapes = "shapes";
      e.Chars = "chars";
      e.Arrows = "arrows";
      e.Data = "data";
      e.DataOffset = "dataoffset";
      e.OhlcOpen = "ohlc_open";
      e.OhlcHigh = "ohlc_high";
      e.OhlcLow = "ohlc_low";
      e.OhlcClose = "ohlc_close";
    })(o ||= {});
    (function (e) {
      e.AlertCondition = "alertcondition";
    })(n ||= {});
    (function (e) {
      e[e.None = 0] = "None";
      e[e.Pane = 1] = "Pane";
      e[e.DataWindow = 2] = "DataWindow";
      e[e.PriceScale = 4] = "PriceScale";
      e[e.StatusLine = 8] = "StatusLine";
      e[e.All = 15] = "All";
    })(r ||= {});
    (function (e) {
      e[e.None = 0] = "None";
      e[e.Pane = 1] = "Pane";
      e[e.DataWindow = 2] = "DataWindow";
      e[e.PriceScale = 4] = "PriceScale";
      e[e.StatusLine = 8] = "StatusLine";
      e[e.All = 15] = "All";
    })(a ||= {});
    (function (e) {
      e.OhlcBars = "ohlc_bars";
      e.OhlcCandles = "ohlc_candles";
    })(l ||= {});
    (function (e) {
      e.Auto = "auto";
      e.Tiny = "tiny";
      e.Small = "small";
      e.Normal = "normal";
      e.Large = "large";
      e.Huge = "huge";
    })(c ||= {});
  },
  49822: (e, t, i) => {
    "use strict";

    function s(e, t = "shift", i) {
      return {
        studyConstructorAsyncGetter: e,
        colorRotationMode: t,
        colorRotationComparator: i
      };
    }
    i.d(t, {
      addStudyInfoToMap: () => n,
      createStudyInfo: () => s,
      getStudyClassName: () => a,
      getStudyInfoByName: () => r
    });
    const o = new Map();
    function n(e, t) {
      o.set(e, t);
    }
    function r(e) {
      return o.get(e);
    }
    function a(e) {
      for (const [t, i] of o.entries()) {
        if (i.studyConstructor === e) {
          return t;
        }
      }
      return null;
    }
  },
  79036: (e, t, i) => {
    "use strict";

    i.d(t, {
      createStudy: () => S,
      hasConfirmInputs: () => P,
      hasPendingStudiesModuleLoading: () => v,
      isCompareOrOverlayStudy: () => f,
      isFundamentalStudy: () => m,
      isOverlayStudy: () => g,
      isStudy: () => u,
      isStudyStrategy: () => _,
      isStudyStub: () => p,
      isSymbolicStudy: () => x,
      studyColorRotationMode: () => b,
      useSameColorRotationComparator: () => C
    });
    var s = i(50151);
    var o = i(56570);
    var n = i(68159);
    var r = i(21239);
    const a = "study_Internal$STD;Fund_";
    function l(e) {
      const t = "study_" + (e.classId || e.shortId);
      if (t.startsWith(a)) {
        return a;
      } else {
        return t;
      }
    }
    var c = i(49822);
    i(29137);
    const h = (0, c.createStudyInfo)(() => Promise.all([i.e(4821), i.e(7539)]).then(i.bind(i, 46806)).then(e => e.Study));
    (0, c.addStudyInfoToMap)("Study", h);
    (0, c.addStudyInfoToMap)("study_PivotPointsStandard", (0, c.createStudyInfo)(() => Promise.all([i.e(4821), i.e(7539)]).then(i.bind(i, 93378)).then(e => e.study_PivotPointsStandard)));
    (0, c.addStudyInfoToMap)("study_Overlay", (0, c.createStudyInfo)(() => Promise.all([i.e(4821), i.e(7539)]).then(i.bind(i, 38496)).then(e => e.study_Overlay), "sexyColors"));
    (0, c.addStudyInfoToMap)("study_Compare", (0, c.createStudyInfo)(() => Promise.all([i.e(4821), i.e(7539)]).then(i.bind(i, 85604)).then(e => e.StudyCompare), "sexyColors"));
    (0, c.addStudyInfoToMap)("study_Volume", (0, c.createStudyInfo)(() => Promise.all([i.e(4821), i.e(7539)]).then(i.bind(i, 7021)).then(e => e.VolumeStudy)));
    (0, c.addStudyInfoToMap)("study_VbPVisible", (0, c.createStudyInfo)(() => Promise.all([i.e(4821), i.e(7539)]).then(i.bind(i, 34425)).then(e => e.VbPVisibleWrapper), "noRotations"));
    (0, c.addStudyInfoToMap)("study_VbPFixed", (0, c.createStudyInfo)(() => Promise.all([i.e(4821), i.e(7539)]).then(i.bind(i, 34425)).then(e => e.VolumeProfileStudyWithThemedColors), "noRotations"));
    (0, c.addStudyInfoToMap)("study_ScriptWithDataOffset", (0, c.createStudyInfo)(() => Promise.all([i.e(4821), i.e(7539)]).then(i.bind(i, 31257)).then(e => e.study_ScriptWithDataOffset)));
    if (o.enabled("moving_average_study_changable_currency_unit")) {
      (0, c.addStudyInfoToMap)("study_Moving Average", (0, c.createStudyInfo)(() => i.e(5248).then(i.bind(i, 55288)).then(e => e.study_MovingAverage)));
    }
    const d = ["getStudyName", "guiPlotName", "isLinkedToSeries"];
    function u(e) {
      return d.every(t => t in e);
    }
    function _(e) {
      return false;
    }
    function p(e) {
      return e instanceof r.StudyStub;
    }
    function m(e) {
      return false;
    }
    function g(e) {
      return u(e) && e.metaInfo().id === "Overlay@tv-basicstudies";
    }
    function f(e) {
      return g(e) || u(e) && e.metaInfo().id === "Compare@tv-basicstudies";
    }
    let y = 0;
    function v() {
      return y > 0;
    }
    async function S(e, t, i, o, n, r) {
      let a;
      const d = r === 2;
      if (!a) {
        const e = l(o);
        a = (0, c.getStudyInfoByName)(e ?? "Study") ?? h;
      }
      if (!a.studyConstructor) {
        y += 1;
        a.studyConstructor = await (0, s.ensureDefined)(a.studyConstructorAsyncGetter)();
        y -= 1;
      }
      const u = new ((0, s.ensureDefined)(a?.studyConstructor))(e, t, i, o, d);
      if (n !== undefined) {
        u.setId(n);
      }
      return u;
    }
    function b(e) {
      const t = l(e);
      const i = (0, c.getStudyInfoByName)(t);
      if (i) {
        return i.colorRotationMode;
      } else if (e.pine === undefined || n.StudyMetaInfo.isStandardPine(e.id)) {
        if (e.plots.length !== 1) {
          return "shift";
        } else {
          return "loop";
        }
      } else {
        return null;
      }
    }
    function w(e, t) {
      return e.id === t.id && (s = t, ((i = e).pine ? i.pine.version : undefined) === (s.pine ? s.pine.version : undefined));
      var i;
      var s;
    }
    function C(e) {
      const t = l(e);
      const i = (0, c.getStudyInfoByName)(t);
      if (i) {
        const e = i.colorRotationComparator;
        if (e !== undefined) {
          return e;
        }
      }
      return w;
    }
    function P(e) {
      return (e ?? []).some(e => e.confirm);
    }
    const T = ["Overlay@tv-basicstudies", "CorrelationCoefficient@tv-basicstudies", "Correlation Coeff@tv-basicstudies", "Spread@tv-basicstudies", "Ratio@tv-basicstudies"];
    function x(e) {
      return T.includes(e.id);
    }
  },
  14878: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyBaseWindowView: () => n
    });
    var s = i(7576);
    var o = i(19466);
    class n extends s.DataWindowView {
      constructor(e, t) {
        super();
        this._invalidated = true;
        this._study = e;
        this._model = t;
        this._valueProvider = this._createValuesProvider(e, t);
        this._items = this._valueProvider.getItems().map(e => new s.DataWindowItem(e.id, e.title, ""));
      }
      update(e) {
        if (e.type !== "hover-change") {
          this._invalidated = true;
        }
      }
      items() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        return this._items;
      }
      study() {
        return this._study;
      }
      _updateImpl() {
        this._header = this._study.title(o.TitleDisplayTarget.DataWindow, true);
        this._title = this._study.title(o.TitleDisplayTarget.DataWindow);
        const e = this._valueProvider.getValues(this._currentIndex());
        for (let t = 0; t < e.length; ++t) {
          const i = e[t];
          const s = this._items[t];
          s.setValue(i.value);
          s.setVisible(i.visible);
          s.setColor(i.color);
          s.setTitle(i.title);
        }
      }
      _currentIndex() {
        const e = this._model.crosshairSource().appliedIndex();
        if (isNaN(e)) {
          return null;
        } else {
          return e;
        }
      }
    }
  },
  71838: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyDataSource: () => _
    });
    var s = i(50151);
    var o = i(52033);
    var n = i(64755);
    var r = i(18172);
    var a = i(3462);
    var l = i(82349);
    var c = i(26246);
    var h = i(16685);
    const d = (0, i(9343).getLogger)("Chart.StudyDataSource");
    var u;
    (function (e) {
      e[e.Idle = 0] = "Idle";
      e[e.AwaitingConnection = 1] = "AwaitingConnection";
      e[e.AwaitingParent = 2] = "AwaitingParent";
      e[e.AwaitingFirstDataUpdate = 3] = "AwaitingFirstDataUpdate";
      e[e.Active = 4] = "Active";
    })(u ||= {});
    class _ {
      constructor(e, t, i, s) {
        this._inputs = null;
        this._status = u.Idle;
        this._studyId = null;
        this._turnaroundCounter = 1;
        this._studyStatus = {
          type: h.StudyStatusType.Undefined
        };
        this._studyStatusChanged = new o.Delegate();
        this._dataCleared = new o.Delegate();
        this._dataUpdated = new o.Delegate();
        this._boundOnGatewayIsConnectedChanged = this._onGatewayIsConnectedChanged.bind(this);
        this._ongoingDataUpdate = Promise.resolve();
        this._gateway = e;
        this._metaInfo = s;
        this._seriesSource = t;
        this._turnaroundPrefix = i;
        this._plots = new n.PlotList((0, l.studyPlotFunctionMap)(s), l.studyEmptyPlotValuePredicate);
        this._gateway.isConnected().subscribe(this._boundOnGatewayIsConnectedChanged);
        this._graphics = new c.LiveStudyGraphics(s.graphics);
      }
      destroy() {
        this.stop();
        this._gateway.isConnected().unsubscribe(this._boundOnGatewayIsConnectedChanged);
        this._seriesSource.dataEvents().created().unsubscribeAll(this);
      }
      metaInfo() {
        return this._metaInfo;
      }
      inputs() {
        return this._inputs;
      }
      setInputs(e) {
        this._inputs = e;
        if (this._studyId !== null) {
          this._turnaroundCounter++;
          this._onStudyStatusChangedTo({
            type: h.StudyStatusType.Undefined
          });
          this._gateway.modifyStudy(this._studyId, this._turnaround(), e, this._onMessage.bind(this));
          if (this._status === u.Active) {
            this._changeStatusTo(u.AwaitingFirstDataUpdate);
          }
        }
      }
      isStarted() {
        return this._status !== u.Idle;
      }
      isActive() {
        return this._status === u.Active;
      }
      start() {
        if (this.isStarted()) {
          d.logNormal("start: data source is already started, nothing to do");
        } else {
          (0, s.assert)(this._inputs !== null, "Inputs should be defined when starting a study data source");
          if (this._gateway.isConnected().value()) {
            this._createStudy();
          } else {
            this._changeStatusTo(u.AwaitingConnection);
          }
        }
      }
      stop() {
        if (this.isStarted()) {
          if (this._studyId !== null) {
            if (this._gateway.isConnected().value()) {
              this._gateway.removeStudy(this._studyId);
            }
            this._studyId = null;
            this._onStudyStatusChangedTo({
              type: h.StudyStatusType.Undefined
            });
          }
          this._changeStatusTo(u.Idle);
        } else {
          d.logNormal("stop: data source is already stopped, nothing to do");
        }
      }
      studyId() {
        return this._studyId;
      }
      studyStatus() {
        return this._studyStatus;
      }
      studyStatusChanged() {
        return this._studyStatusChanged;
      }
      plots() {
        return this._plots;
      }
      graphics() {
        return this._graphics;
      }
      clearData() {
        this._plots.clear();
        this._graphics.clear();
        this._dataCleared.fire();
      }
      stopAndStealData() {
        (0, s.assert)(this._status === u.Active, "Couldn't steal data from non-active data source");
        this.stop();
        const e = this._plots;
        const t = this._graphics.extract();
        this._plots = new n.PlotList((0, l.studyPlotFunctionMap)(this._metaInfo), l.studyEmptyPlotValuePredicate);
        return {
          plots: e,
          graphics: t
        };
      }
      dataCleared() {
        return this._dataCleared;
      }
      dataUpdated() {
        return this._dataUpdated;
      }
      moveData(e) {
        this._ongoingDataUpdate = this._ongoingDataUpdate.then(() => {
          this._plots.move(e);
        });
      }
      pendingUpdatesReady() {
        return this._ongoingDataUpdate;
      }
      _createStudyError(e) {
        return {
          type: h.StudyStatusType.Error,
          errorDescription: this._getStudyErrorDescription(e)
        };
      }
      _getStudyErrorDescription(e) {
        if (typeof e == "string") {
          return {
            error: e.split(":", 2)[0]
          };
        } else {
          return e;
        }
      }
      _changeStatusTo(e) {
        (0, s.assert)(this._status !== e, "Source and destination status should be distinct");
        d.logNormal(`Status changed from ${u[this._status]} to ${u[e]}`);
        this._status = e;
      }
      _createStudy() {
        const e = this._seriesSource.instanceId();
        if (e !== null) {
          this._createStudyUsingParentId(e);
        } else {
          this._changeStatusTo(u.AwaitingParent);
          this._seriesSource.dataEvents().created().subscribe(this, this._onSeriesCreated, true);
        }
      }
      _createStudyUsingParentId(e) {
        (0, s.assert)(this._status !== u.Active, "Status should not be \"Active\" when creating a study");
        (0, s.assert)(this._studyStatus.type === h.StudyStatusType.Undefined, "Study status should be \"Undefined\" when creating a study");
        (0, s.assert)(this._studyId === null, "Study id should be empty when creating a study");
        this._studyId = (0, a.makeNextStudyId)();
        this._gateway.createStudy(this._studyId, this._turnaround(), e, this._metaInfo.fullId + (this._metaInfo.packageId === "tv-basicstudies" ? "" : "!"), (0, s.ensureNotNull)(this._inputs), this._onMessage.bind(this), {
          id: this._metaInfo.id
        });
        this._changeStatusTo(u.AwaitingFirstDataUpdate);
      }
      _onGatewayIsConnectedChanged(e) {
        if (e) {
          this._onGatewayConnected();
        } else {
          this._onGatewayDisconnected();
        }
      }
      _onGatewayConnected() {
        if (this._status === u.AwaitingConnection) {
          this._createStudy();
        }
      }
      _onGatewayDisconnected() {
        if (this._status !== u.Idle && this._status !== u.AwaitingConnection) {
          this._studyId = null;
          this._changeStatusTo(u.AwaitingConnection);
          if (this._studyStatus.type !== h.StudyStatusType.Undefined) {
            this._onStudyStatusChangedTo({
              type: h.StudyStatusType.Undefined
            });
          }
        }
        this._turnaroundCounter = 1;
      }
      _onSeriesCreated() {
        if (this._status === u.AwaitingParent) {
          this._createStudyUsingParentId((0, s.ensure)(this._seriesSource.instanceId()));
        }
      }
      _onStudyStatusChangedTo(e) {
        const t = this._studyStatus;
        this._studyStatus = e;
        d.logNormal(`Study status type changed from ${h.StudyStatusType[t.type]} to ${h.StudyStatusType[e.type]}`);
        this._studyStatusChanged.fire(t, e);
      }
      _onMessage(e) {
        if (e.method === "data_update") {
          const {
            customId: t,
            turnaround: i,
            plots: o,
            nonseries: n
          } = e.params;
          if (t === this._studyId && this._checkTurnaround(i)) {
            this._onDataUpdate(o, (0, s.ensureDefined)(n));
          }
        } else if (e.method === "study_loading") {
          const [t, i] = e.params;
          if (t === this._studyId && this._checkTurnaround(i)) {
            this._onStudyLoading(e.time);
          }
        } else if (e.method === "study_completed") {
          const [t, i] = e.params;
          if (t === this._studyId && this._checkTurnaround(i)) {
            this._onStudyCompleted(e.time);
          }
        } else if (e.method === "study_error") {
          const [t, i, s, o] = e.params;
          if (t === this._studyId && this._checkTurnaround(i)) {
            this._onStudyError(s, o, e.time);
          }
        } else if (e.method === "clear_data" && this._checkTurnaround(e.params.turnaround)) {
          this.clearData();
        }
      }
      _onDataUpdate(e, t) {
        const i = (0, r.unpackNonSeriesData)(t.d);
        this._ongoingDataUpdate = this._ongoingDataUpdate.then(() => i, () => i).then(this._onDataUnpacked.bind(this, e, t.indexes));
        return this._ongoingDataUpdate;
      }
      _onDataUnpacked(e, t, i) {
        if (this._status !== u.Idle) {
          if (this._status === u.AwaitingFirstDataUpdate) {
            this._changeStatusTo(u.Active);
            this.clearData();
          }
          this._mergePlots(e);
          if (i !== null) {
            if (i.indexes_replace) {
              (0, s.assert)(t !== "nochange");
              this._graphics.replaceIndexesTo(t);
            } else {
              if (t !== "nochange") {
                this._graphics.replaceIndexesTo(t);
              }
              if (i.graphicsCmds !== undefined) {
                this._graphics.processCommands(i.graphicsCmds);
              }
            }
          }
          this._dataUpdated.fire(e, i, t);
        }
      }
      _onStudyLoading(e) {
        this._onStudyStatusChangedTo({
          type: h.StudyStatusType.Loading,
          startTime: Date.now()
        });
      }
      _onStudyError(e, t, i) {
        this.clearData();
        this._onStudyStatusChangedTo(this._createStudyError(e));
      }
      _onStudyCompleted(e) {
        this._onStudyStatusChangedTo({
          type: h.StudyStatusType.Completed
        });
      }
      _mergePlots(e) {
        this._plots.merge(e);
      }
      _turnaround() {
        return `${this._turnaroundPrefix}${this._turnaroundCounter}`;
      }
      _checkTurnaround(e) {
        const t = this._turnaround();
        return e === t || e === this._seriesSource.turnaround() || e === `${this._seriesSource.turnaround()}_${t}`;
      }
    }
  },
  22839: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyDataWindowView: () => a
    });
    var s = i(14878);
    var o = i(22739);
    var n = i(7015);
    class r {
      constructor(e, t) {
        this._study = e;
        this._model = t;
        this._hhistBasedStudy = e.metaInfo().graphics.hhists !== undefined;
        this._valuesProvider = this._createValuesProvider(e, t);
      }
      getItems() {
        return this._valuesProvider.getItems();
      }
      getValues(e) {
        const t = this._valuesProvider.getValues(e);
        const i = e => !!this._hhistBasedStudy || this._study.isPlotVisibleAt(e, 2);
        for (const e of t) {
          e.visible = e.visible && i(e.id);
        }
        return t;
      }
      _createValuesProvider(e, t) {
        if (this._hhistBasedStudy) {
          return new n.HHistBasedValuesProvider(e, t);
        } else {
          return new o.StudyValuesProvider(e, t);
        }
      }
    }
    class a extends s.StudyBaseWindowView {
      canShowItems() {
        const e = this._model.paneForSource(this._study);
        return !!e?.maximized().value() || this._model.panes().every(e => !e.maximized().value());
      }
      _createValuesProvider(e, t) {
        return new r(e, t);
      }
    }
  },
  82349: (e, t, i) => {
    "use strict";

    function s(e) {
      const t = new Map();
      e.plots.forEach((e, i) => {
        t.set(e.id, e => e[i + 1]);
      });
      return t;
    }
    function o(e, t) {
      return e[t] == null;
    }
    i.d(t, {
      studyEmptyPlotValuePredicate: () => o,
      studyPlotFunctionMap: () => s
    });
  },
  65383: (e, t, i) => {
    "use strict";

    i.d(t, {
      ChartColorDependentStudyInputNames: () => p,
      InputDisplayFlags: () => o,
      RangeDependentStudyInputNames: () => _,
      areStudyInputsEqual: () => m,
      editableStudyInputs: () => f,
      getInputValue: () => l,
      isExtendedInput: () => r,
      isExtendedInputSource: () => a,
      isStudyInputDependsOnChartColors: () => y,
      isStudyInputOptionsInfo: () => c,
      isTimeOrPriceNotHiddenInput: () => g
    });
    var s;
    var o;
    var n = i(82433);
    function r(e) {
      return (0, n.default)(e);
    }
    function a(e) {
      return e.t === "source";
    }
    function l(e) {
      if (r(e)) {
        return e.v;
      } else {
        return e;
      }
    }
    (function (e) {
      e.Integer = "integer";
      e.Float = "float";
      e.Price = "price";
      e.Bool = "bool";
      e.Text = "text";
      e.Symbol = "symbol";
      e.Session = "session";
      e.Source = "source";
      e.Resolution = "resolution";
      e.Time = "time";
      e.BarTime = "bar_time";
      e.Color = "color";
      e.Textarea = "text_area";
    })(s ||= {});
    (function (e) {
      e[e.None = 0] = "None";
      e[e.DataWindow = 2] = "DataWindow";
      e[e.StatusLine = 8] = "StatusLine";
      e[e.All = 15] = "All";
    })(o ||= {});
    function c(e) {
      return ["text", "integer", "float", "price", "session", "resolution"].includes(e.type) && e.hasOwnProperty("options");
    }
    var h;
    var d;
    var u;
    var _;
    var p;
    function m(e, t, i) {
      for (const s of e) {
        if (t[s.id] !== i[s.id]) {
          return false;
        }
      }
      return true;
    }
    function g(e) {
      return (e.type === "time" || e.type === "price") && e.isHidden !== true;
    }
    function f(e) {
      return [];
    }
    function y(e) {
      return Object.values(p).map(e => e).includes(e.id);
    }
    (function (e) {
      e.InitialCapital = "initial_capital";
      e.Currency = "currency";
      e.DefaultQTYValue = "default_qty_value";
      e.DefaultQTYType = "default_qty_type";
      e.Pyramiding = "pyramiding";
      e.ComissionValue = "commission_value";
      e.ComissionType = "commission_type";
      e.BacktestFillLimitsAssumtion = "backtest_fill_limits_assumption";
      e.Slippage = "slippage";
      e.CalcOnOrderFills = "calc_on_order_fills";
      e.CalcOnEveryTick = "calc_on_every_tick";
      e.MarginLong = "margin_long";
      e.MarginShort = "margin_short";
      e.UseBarMagnifier = "use_bar_magnifier";
      e.ProcessOrdersOnClose = "process_orders_on_close";
      e.FillOrdersOnStandardOHLC = "fill_orders_on_standard_ohlc";
    })(h ||= {});
    (function (e) {
      e.Fixed = "fixed";
      e.CashPerOrder = "cash_per_order";
      e.PercentOfEquity = "percent_of_equity";
    })(d ||= {});
    (function (e) {
      e.Percent = "percent";
      e.CashPerContract = "cash_per_contract";
      e.CashPerOrder = "cash_per_order";
    })(u ||= {});
    (function (e) {
      e.FirstBar = "first_visible_bar_time";
      e.LastBar = "last_visible_bar_time";
      e.Realtime = "subscribeRealtime";
    })(_ ||= {});
    (function (e) {
      e.FgColor = "__chart_fgcolor";
      e.BgColor = "__chart_bgcolor";
    })(p ||= {});
  },
  16638: (e, t, i) => {
    "use strict";

    i.d(t, {
      isStudyDescriptor: () => u,
      studyMetaInfoRepository: () => g
    });
    var s = i(81251);
    var o = i(11542);
    var n = i(50151);
    var r = i(68159);
    var a = i(72530);
    var l = i(1640);
    var c = i(79303);
    var h = i(9343);
    var d = i(14426);
    (0, h.getLogger)("Chart.Studies.StudyMetaInfoRepository", {
      color: "#606"
    });
    function u(e) {
      return typeof e == "object" && e !== null && "type" in e && (e.type === "java" && "studyId" in e || e.type === "pine" && "pineId" in e);
    }
    class _ {
      constructor(e) {
        this._isReady = false;
        this._studyVersioning = null;
        this._rawStudiesMetaInfo = [];
        this._rawStudiesMetaInfoDeferredPromise = null;
        this._javaStudiesMetaInfo = [];
        this._pineMetaInfoCache = [];
        this._compileErrors = new WeakMap();
        this._studiesMigrations = [];
        this._chartApi = e;
      }
      async requestMetaInfo() {
        if (this._rawStudiesMetaInfoDeferredPromise === null) {
          this._rawStudiesMetaInfoDeferredPromise = (0, d.createDeferredPromise)();
          const e = (await this._chartApi.requestMetadata()).params[1].metainfo.slice();
          this._processLibraryMetaInfo(e);
          this._studyVersioning = new c.StudyVersioning(this._javaStudiesMetaInfo, this._studiesMigrations);
          this._requestFinished();
          this._rawStudiesMetaInfoDeferredPromise.resolve(this._rawStudiesMetaInfo);
        }
        return this._rawStudiesMetaInfoDeferredPromise.promise;
      }
      async findById(e) {
        if (!this._isReady) {
          await this.requestMetaInfo();
        }
        const t = this._findStudyMetaInfo(e);
        if (t !== null) {
          const e = this._compileErrors.get(t);
          if (e) {
            return Promise.reject(e);
          } else {
            return Promise.resolve(t);
          }
        }
        if (e.type === "pine") {
          return this._compilePine(e);
        } else {
          return Promise.reject(`unexpected study id=${e.studyId} with type=${e.type}`);
        }
      }
      findByIdSync(e) {
        return this._findStudyMetaInfo(e);
      }
      isReady() {
        return this._isReady;
      }
      async findAllJavaStudies() {
        if (!this._isReady) {
          await this.requestMetaInfo();
        }
        return this._javaStudiesMetaInfo;
      }
      studyVersioning() {
        return (0, n.ensureNotNull)(this._studyVersioning);
      }
      getInternalMetaInfoArray() {
        return this._javaStudiesMetaInfo;
      }
      addPineMetaInfo(e, t) {
        const i = m(this._pineMetaInfoCache, e);
        if (t && (!Array.isArray(t) || t.length > 0)) {
          t = Array.isArray(t) ? new PineCompileFailErrorImpl({
            warnings: [],
            errors: t
          }, e) : t;
          this._compileErrors.set(i, t);
        }
        return i;
      }
      async getLatestMetaInfoForPineStudy(e, t) {
        return null;
      }
      _processMigrations(e) {
        throw new Error("not implemented");
      }
      _processSiteMetaInfo(e, t) {
        throw new Error("not implemented");
      }
      _processLibraryMetaInfo(e) {
        for (const t of e) {
          p(t);
          m(this._javaStudiesMetaInfo, t);
        }
        this._javaStudiesMetaInfo = this._javaStudiesMetaInfo.sort((e, t) => {
          const i = e.description_localized || e.description;
          const s = t.description_localized || t.description;
          if (i > s) {
            return 1;
          } else if (i < s) {
            return -1;
          } else {
            return 0;
          }
        });
        r.StudyMetaInfo.overrideDefaults(this._javaStudiesMetaInfo);
      }
      _requestFinished() {
        this._isReady = true;
      }
      _findStudyMetaInfo(e) {
        if (e.type === "java") {
          (0, n.assert)(this._javaStudiesMetaInfo.length !== 0, "Java studies metainfo should be define here");
          return this._javaStudiesMetaInfo.find(t => t.id === e.studyId) || null;
        } else {
          return this._pineMetaInfoCache.find(t => t.scriptIdPart === e.pineId && (e.pineVersion === undefined || (0, n.ensureDefined)(t.pine).version === e.pineVersion)) || null;
        }
      }
      _compilePine(e) {
        throw new Error("unsupported");
      }
    }
    function p(e) {
      e.description_localized = o.t(e.description, {
        context: "study"
      }, i(83477));
    }
    function m(e, t) {
      const i = new r.StudyMetaInfo(t).state();
      (0, a.migrateMetaInfoAndPropState)(i);
      const s = new r.StudyMetaInfo(i);
      let o = true;
      const n = e.findIndex(e => e.id === s.id);
      if (n === -1) {
        e.push(s);
      } else {
        const t = e[n];
        const i = t.pine !== undefined ? l.Version.parse(t.pine.version) : null;
        const r = s.pine !== undefined ? l.Version.parse(s.pine.version) : null;
        if (r === null || i === null || r.isGreaterOrEqual(i)) {
          t.removeDefaults();
          e[n] = s;
        } else {
          o = false;
        }
      }
      if (o) {
        s.createDefaults();
      }
      return s;
    }
    const g = (0, s.default)(() => new _(window.ChartApiInstance));
  },
  70294: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyStatusProviderBase: () => l
    });
    var s = i(27538);
    var o = i(678);
    var n = i(19466);
    const r = {
      NONE: "Default"
    };
    const a = false;
    class l extends s.StatusProviderBase {
      constructor(e) {
        super();
        this._source = e;
      }
      getSplitTitle() {
        return this._source.titleInParts(n.TitleDisplayTarget.StatusLine, true, r, undefined, a);
      }
      text() {
        if (this._source.isActualInterval()) {
          if (this._source.isFailed()) {
            return `${this._source.title(n.TitleDisplayTarget.StatusLine, true, r, undefined, a)}: ${this.sourceStatusText()}`;
          } else {
            return `${this._source.title(n.TitleDisplayTarget.StatusLine, true, r, undefined, a)} ${this.sourceStatusText()}`;
          }
        } else {
          return this._source.title(n.TitleDisplayTarget.StatusLine, true, r, undefined, a);
        }
      }
      sourceStatusText() {
        return (0, o.convertStudyStatusToString)(this._source.status(), true);
      }
      errorStatus() {
        if (!this._source.isActualInterval() || this._source.isSymbolInvalid()) {
          return null;
        }
        const e = this._source.status();
        if (e.type === o.StudyStatusType.Error) {
          return {
            showReportItButton: e.errorDescription.showReportItButton,
            error: this.sourceStatusText(),
            solutionId: (0, o.studyStatusSolutionId)(e),
            title: (0, o.studyStatusTitle)(e),
            studyFeature: (0, o.studyStatusFeature)(e),
            stackTrace: (0, o.studyErrorStatusStackTrace)(e.errorDescription.stack_trace),
            editorError: e.errorDescription.editorError
          };
        } else {
          return null;
        }
      }
    }
  },
  44158: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyStatusProvider: () => n
    });
    var s = i(11542);
    i(678);
    var o = i(70294);
    s.t(null, undefined, i(24077));
    class n extends o.StudyStatusProviderBase {
      sourceStatusText() {
        this._source.status();
        return super.sourceStatusText();
      }
    }
  },
  49936: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyStatusView: () => o
    });
    var s = i(27777);
    class o extends s.StatusView {
      constructor(e) {
        super(e.statusProvider());
      }
      getSplitTitle() {
        return this._statusProvider.getSplitTitle();
      }
      update(e) {
        this._text = this._statusProvider.text();
      }
    }
  },
  678: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyStatusType: () => h,
      convertStudyStatusToString: () => d,
      createStudyError: () => g,
      studyErrorStatusStackTrace: () => m,
      studyStatusFeature: () => p,
      studyStatusSolutionId: () => u,
      studyStatusTitle: () => _
    });
    var s = i(11542);
    var o = i(82236);
    const n = s.t(null, undefined, i(50910));
    const r = new Map();
    const a = new Map();
    const l = "loading...";
    const c = s.t(null, undefined, i(62011));
    var h;
    function d(e, t) {
      if (e.type === h.Loading) {
        if (t) {
          return c;
        } else {
          return l;
        }
      }
      if (e.type === h.Error) {
        const i = e.errorDescription;
        const s = t ? (0, o.triesTranslateError)(i.error) : i.error;
        if (i.ctx) {
          const e = {};
          Object.entries(i.ctx).forEach(([t, i]) => {
            e[t] = i.toString();
          });
          return s.format(e);
        }
        return s;
      }
      return "";
    }
    function u(e) {
      if (e.type === h.Error) {
        if (e.errorDescription.solution_id) {
          return e.errorDescription.solution_id;
        } else {
          return function (e) {
            for (const t of Array.from(r.keys())) {
              if (e.includes(t)) {
                return r.get(t);
              }
            }
          }(e.errorDescription.error);
        }
      }
    }
    function _(e) {
      if (e.type === h.Error) {
        if (function (e) {
          const t = e.toLowerCase();
          return t.includes("the data vendor doesn't provide volume data for this symbol.") || t.includes("no volume is provided by the data vendor");
        }(e.errorDescription.error)) {
          return n;
        } else {
          return (0, o.triesTranslateError)(e.errorDescription.title ?? "Runtime error");
        }
      }
    }
    function p(e) {
      const {
        errorDescription: {
          error: t
        }
      } = e;
      for (const [e, i] of a) {
        if (t.startsWith(e)) {
          return i;
        }
      }
    }
    function m(e) {
      if (e === undefined) {
        return;
      }
      const t = [];
      for (const i of e) {
        const e = {
          functionOrScopeName: i.n,
          lineNumber: i.p
        };
        if ("id" in i) {
          e.id = i.id;
        }
        if ("v" in i) {
          e.versionScript = i.v;
        }
        t.push(e);
      }
      return t;
    }
    function g(e, t) {
      const i = e.error === "check study unexpected error";
      return {
        type: h.Error,
        errorDescription: {
          ...e,
          showReportItButton: i
        }
      };
    }
    (function (e) {
      e[e.Undefined = 0] = "Undefined";
      e[e.Loading = 1] = "Loading";
      e[e.Completed = 2] = "Completed";
      e[e.Error = 3] = "Error";
    })(h ||= {});
  },
  21239: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyStub: () => b,
      isStudyStubDescriptor: () => w
    });
    var s = i(50279);
    var o = i(30551);
    var n = i(50151);
    var r = i(64147);
    i(88960);
    var a = i(62288);
    var l = i(49936);
    var c = i(45579);
    var h = i(725);
    var d = i(52033);
    var u = i(12988);
    var _ = i(70294);
    var p = i(19466);
    class m extends _.StudyStatusProviderBase {
      text() {
        if (this._source.isActualInterval()) {
          return `${this._source.title(p.TitleDisplayTarget.StatusLine)} ${this.sourceStatusText()}`;
        } else {
          return this._source.title(p.TitleDisplayTarget.StatusLine);
        }
      }
    }
    var g = i(678);
    var f = i(36915);
    var y = i(16638);
    class v {
      getItems() {
        return [];
      }
      getValues(e) {
        return [];
      }
    }
    const S = new d.Delegate();
    class b extends c.PriceDataSource {
      constructor(e, t, i, s, o = null) {
        super(e);
        this._priceStep = 0.01;
        this._origState = null;
        this._descriptor = null;
        this._status = {
          type: g.StudyStatusType.Undefined
        };
        this._statusChanged = new d.Delegate();
        this._descriptorChanged = new d.Delegate();
        this._formatter = new h.PriceFormatter({
          priceScale: 100
        });
        this._showPineVersionInStatusLine = new r.WatchedValue(false).spawn();
        this._pineSourceCodeModel = null;
        if ((0, y.isStudyDescriptor)(t)) {
          this._descriptor = t;
        } else {
          this._origState = t;
        }
        this._title = i;
        this._alwaysShowInLegend = s !== undefined;
        this._isOverlay = s;
        this._studyMetaInfo = o;
        this._properties = new u.Property({
          visible: true
        });
        this._statusView = new l.StudyStatusView(this);
      }
      destroy() {
        this._pineSourceCodeModel?.get()?.destroy();
        this._pineSourceCodeModel?.destroy();
        this._showPineVersionInStatusLine.destroy();
        super.destroy();
      }
      barColorer() {
        return null;
      }
      properties() {
        return this._properties;
      }
      statusView() {
        return this._statusView;
      }
      legendView() {
        return null;
      }
      state(e) {
        return this._origState;
      }
      getDescriptor() {
        if (this._descriptor === null) {
          return null;
        } else {
          return {
            descriptor: this._descriptor,
            title: this._title,
            isOverlay: this._isOverlay,
            id: this.id(),
            status: this._status
          };
        }
      }
      updateDescriptor(e) {
        if (!(0, s.default)(this._descriptor, e)) {
          this._descriptor = e;
          this._descriptorChanged.fire();
        }
      }
      onDescriptorChanged() {
        return this._descriptorChanged;
      }
      metaInfo() {
        return this._studyMetaInfo;
      }
      setMetaInfo(e) {
        this._studyMetaInfo = e;
      }
      setStatus(e) {
        const t = this.isDisplayedInLegend();
        this._status = e;
        this._statusChanged.fire();
        if (this.isDisplayedInLegend() !== t) {
          const e = this._model.paneForSource(this);
          if (e) {
            const t = this._model.panes().indexOf(e);
            const i = a.InvalidationMask.invalidateLegendWidgetLayout(t);
            this.model().invalidate(i);
          }
        }
      }
      formatter() {
        return this._formatter;
      }
      name() {
        return this._title;
      }
      title() {
        return this.titleInParts().join(" ");
      }
      titleInParts() {
        const e = [this._title];
        if (this._showPineVersionInStatusLine.value()) {
          e.push((0, n.ensureDefined)(this._studyMetaInfo?.pine).version);
        }
        return e;
      }
      isFailed() {
        return this._status.type === g.StudyStatusType.Error;
      }
      isLoading() {
        return this._status.type === g.StudyStatusType.Loading;
      }
      isDisplayedInLegend() {
        return this._alwaysShowInLegend || this.isFailed();
      }
      setFailed(e) {
        this.setStatus({
          type: g.StudyStatusType.Error,
          errorDescription: {
            error: e
          }
        });
        this._model.updateSource(this);
      }
      isSymbolInvalid() {
        return false;
      }
      isActualInterval() {
        return true;
      }
      onIsActualIntervalChange() {
        return S;
      }
      start() { }
      status() {
        return this._status;
      }
      onStatusChanged() {
        return this._statusChanged;
      }
      firstValue() {
        return null;
      }
      currency() {
        return null;
      }
      sessionId() {
        return this._model.mainSeries().sessionId();
      }
      sessionIdChanged() {
        return this._model.mainSeries().sessionIdChanged();
      }
      unit() {
        return null;
      }
      symbolSource() {
        return this._model.mainSeries();
      }
      barsProvider() {
        return this._model.mainSeries();
      }
      legendValuesProvider() {
        return new v();
      }
      statusProvider(e) {
        return new m(this);
      }
      isRemovedByStudyTemplates() {
        return this._origState !== null && (0, f.isStudyState)(this._origState);
      }
      pineSourceCodeModel() {
        return Promise.resolve(null);
      }
    }
    function w(e) {
      return (0, o.isObject)(e) && "descriptor" in e && (0, y.isStudyDescriptor)(e.descriptor);
    }
  },
  22739: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyValuesProvider: () => v
    });
    var s = i(50335);
    var o = i(49483);
    var n = i(19063);
    var r = i(56570);
    var a = i(8025);
    var l = i(15764);
    var c = i(928);
    var h = i(94113);
    var d = i(83085);
    var u = i(41991);
    var _ = i(50151);
    var p = i(82587);
    var m = i(19466);
    const g = o.CheckMobile.any();
    const f = r.enabled("hide_last_na_study_output");
    const y = r.enabled("always_show_legend_values_on_mobile");
    class v {
      constructor(e, t, i) {
        this._emptyValues = [];
        this._colorProviders = new Map();
        this._study = e;
        this._model = t;
        this._studyMetaInfo = this._study.metaInfo();
        this._studyProperties = this._study.properties().childs();
        this._isFundamental = false;
        const s = this._studyMetaInfo.plots;
        if (s) {
          s.forEach((e, t) => {
            if ((0, h.isPlotWithTechnicalValues)(e)) {
              return;
            }
            const s = e.id;
            this._emptyValues.push(function (e, t = "", i = "") {
              return {
                id: t,
                index: e,
                title: i,
                value: "",
                visible: false
              };
            }(t, s, i ? "" : this._study.guiPlotName(m.TitleDisplayTarget.StatusLine, s)));
            const o = (0, h.isOhlcPlot)(e) ? e.target : s;
            this._colorProviders.set(o, (0, d.createStudyPlotColorProvider)(this._studyMetaInfo, this._study.properties(), o));
          });
        }
      }
      getItems() {
        return this._emptyValues;
      }
      getPlotColor(e, t) {
        const i = t[e + 1];
        if (!(0, s.isNumber)(i)) {
          return "";
        }
        const o = i > 0;
        let n;
        const r = this._studyMetaInfo.plots[e];
        let a = r.id;
        const l = this._studyProperties;
        if ((0, h.isOhlcPlot)(r)) {
          a = r.target || a;
          n = (0, _.ensureDefined)(l.ohlcPlots.childs()[a].childs().color).value();
        } else if ((0, h.isArrowsPlot)(r)) {
          const e = (0, _.ensureDefined)(l.styles.childs()[a]);
          n = o ? e.childs().colorup.value() : e.childs().colordown.value();
        } else {
          n = (0, _.ensureDefined)(l.styles.childs()[a]?.child("color")).value();
        }
        let c = n;
        const d = this._colorProviders.get(a);
        const u = d && d.getPlotPointStyle(t);
        if (u) {
          if ((0, h.isArrowsPlot)(r)) {
            if (o && u.colors[5] !== undefined) {
              c = u.colors[5];
            }
            if (!o && u.colors[6] !== undefined) {
              c = u.colors[6];
            }
          } else if (u.colors[0] !== undefined) {
            c = u.colors[0];
          }
        }
        if (c === "transparent") {
          c = n;
        }
        return c;
      }
      getValues(e) {
        const t = this._emptyValues.map(e => ({
          ...e
        }));
        let i = null;
        const o = this._study.data().lastIndex();
        const r = this._studyProperties;
        if (o !== null) {
          for (const e of t) {
            const t = r.styles.childs()[e.id]?.childs().display.value();
            if (t === 0) {
              continue;
            }
            const s = this._study.nearestIndex(o, a.PlotRowSearchMode.NearestLeft, e.index + 1);
            if (s === undefined) {
              continue;
            }
            const n = s + this._study.offset(e.id);
            i = i !== null ? Math.max(n, i) : n;
          }
        }
        if (e === null || i !== null && e > i) {
          e = i;
        }
        const l = this._hideValues();
        const c = this._study.isVisible() && !l ? p.notAvailable : "";
        for (const e of t) {
          e.value = c;
        }
        if (l) {
          return t;
        }
        if (f && t.length) {
          t[t.length - 1].value = "";
        }
        const d = this._study.priceScale();
        if (!this._study.isVisible() || e === null || d === null || d.isEmpty() || this._model.timeScale().isEmpty()) {
          return t;
        }
        const m = {};
        for (const i of t) {
          const t = i.id;
          const l = (0, u.getPriceValueFormatterForStudy)(this._study, t);
          const c = (0, _.ensureDefined)(r.styles.childs()[t]);
          const d = c.childs().display.value();
          i.visible = d !== 0;
          if (!i.visible) {
            continue;
          }
          const p = c.hasChild("plottype") ? c.child("plottype")?.value() : null;
          const g = this._isFundamental && (p === h.LineStudyPlotStyle.StepLine || p === h.LineStudyPlotStyle.StepLineWithDiamonds);
          const f = i.index;
          const y = e - this._study.offset(t);
          const v = g || o !== null && y > o ? a.PlotRowSearchMode.NearestLeft : a.PlotRowSearchMode.Exact;
          const S = this._study.nearestIndex(y, v);
          if (S === undefined) {
            continue;
          }
          let b = m[t];
          if (b === undefined) {
            b = this._study.getMinFirstBarIndexForPlot(t);
            if (Number.isFinite(b)) {
              m[t] = b;
            }
          }
          if (b > S) {
            continue;
          }
          const w = this._study.data().last();
          const C = this._study.data().valueAt(S) || (w !== null ? w.value : null);
          if (C === null) {
            continue;
          }
          const P = C[f + 1];
          if ((0, s.isNumber)(P)) {
            i.value = l(P);
            i.color = (0, n.resetTransparency)(this.getPlotColor(f, C));
          }
        }
        return t;
      }
      _hideValues() {
        if (y) {
          return (0, l.isLineToolName)(c.tool.value()) || this._model.lineBeingEdited() !== null;
        } else {
          return g && (this._model.crosshairSource().pane === null || (0, l.isLineToolName)(c.tool.value()) || this._model.lineBeingEdited() !== null);
        }
      }
    }
  },
  85604: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      StudyCompare: () => H
    });
    var s = i(50151);
    var o = i(50788);
    var n = i(46806);
    var r = i(68805);
    var a = i(12988);
    var l = i(73698);
    var c = i(56570);
    var h = i(94164);
    var d = i(98558);
    var u = i(49256);
    var _ = i(19063);
    const p = c.enabled("force_exchange_as_title");
    class m extends d.PriceAxisView {
      constructor(e, t) {
        super();
        this._studyCompare = e;
        this._data = t;
      }
      _updateRendererData(e, t, i) {
        e.visible = false;
        t.visible = false;
        const o = this._studyCompare.priceScale();
        const n = this._studyCompare.lastValueData(this._data.plotIndex, false);
        if (n.noData || o === null || o.isEmpty()) {
          return;
        }
        const r = this._studyCompare.model();
        const a = r.timeScale().visibleBarsStrictRange();
        const l = r.mainSeries().bars().lastIndex();
        if (a === null || l === null) {
          return;
        }
        if (l <= a.lastBar()) {
          i.background = (0, _.resetTransparency)(n.color);
          i.textColor = this.generateTextColor(i.background);
          i.borderColor = undefined;
          e.borderVisible = false;
          t.borderVisible = false;
        } else {
          const o = r.backgroundColorAtYPercentFromTop(n.coordinate / (0, s.ensureNotNull)(r.paneForSource(this._studyCompare)).height());
          i.background = o;
          i.textColor = (0, _.resetTransparency)(n.color);
          i.borderColor = i.textColor;
          e.borderVisible = true;
          t.borderVisible = true;
        }
        i.coordinate = n.coordinate;
        i.floatCoordinate = n.floatCoordinate;
        const c = r.properties().childs().scalesProperties.childs();
        if (c.showSeriesLastValue.value()) {
          e.text = (0, u.getCurrentModePriceText)(o, n);
          if (c.seriesLastValueMode.value() !== h.PriceAxisLastValueMode.LastPriceAndPercentageValue) {
            e.secondLine = "";
          } else {
            e.secondLine = (0, u.getOppositeModePriceText)(o, n);
          }
          e.visible = true;
        }
        t.text = "";
        if (c.showSymbolLabels.value()) {
          t.text = this._paneText();
          t.visible = t.text.length > 0;
        }
      }
      _paneText() {
        let e = "";
        const t = this._studyCompare.symbolInfo();
        if (p) {
          e = (0, r.displayedSymbolExchange)(t);
        } else if (this._studyCompare.model().properties().childs().scalesProperties.childs().showSymbolLabels.value()) {
          e = (0, r.displayedSymbolName)(t);
        }
        return e;
      }
    }
    i(11542);
    var g = i(22839);
    var f = i(22739);
    var y = i(928);
    var v = i(49483);
    var S = i(15764);
    var b = i(37265);
    var w = i(19466);
    const C = v.CheckMobile.any();
    class P extends f.StudyValuesProvider {
      constructor(e, t) {
        super(e, t);
        this._emptyValues[0].title = e.guiPlotName(w.TitleDisplayTarget.StatusLine, "");
      }
      getValues(e) {
        if (!(0, b.isNumber)(e)) {
          if (this._showLastPriceAndChangeOnly()) {
            e = this._study.data().lastIndex();
          } else {
            e = this._model.crosshairSource().appliedIndex();
            if (!(0, b.isNumber)(e)) {
              e = this._study.data().lastIndex();
            }
          }
        }
        return super.getValues(e);
      }
      _hideValues() {
        return false;
      }
      _showLastPriceAndChangeOnly() {
        return C && (this._model.crosshairSource().pane === null || (0, S.isLineToolName)(y.tool.value()) || this._model.lineBeingEdited() !== null);
      }
    }
    class T extends g.StudyDataWindowView {
      constructor(e, t) {
        super(e, t);
        this._studyCompare = e;
      }
      _hideValues() {
        return false;
      }
      _createValuesProvider(e, t) {
        return new P(e, t);
      }
    }
    var x = i(44672);
    class I extends T {
      constructor(e, t) {
        super(e, t);
        this._additional = null;
        this._showSeriesOHLC = t.properties().childs().paneProperties.childs().legendProperties.childs().showSeriesOHLC;
        this._showSeriesOHLC.subscribe(this, () => this.update((0, x.sourceChangeEvent)(e.id())));
      }
      areValuesVisible() {
        return this._showSeriesOHLC.value();
      }
      destroy() {
        this._showSeriesOHLC.unsubscribeAll(this);
      }
      additional() {
        return this._additional;
      }
      _updateImpl() {
        super._updateImpl();
      }
    }
    var M = i(49936);
    var A = i(24526);
    var L = i(44158);
    class k extends L.StudyStatusProvider {
      getSplitTitle() {
        return this._source.titleInParts(w.TitleDisplayTarget.StatusLine, true, undefined, false, false);
      }
      text() {
        if (this._source.isActualInterval()) {
          if (this._source.isFailed()) {
            return `${this._source.title(w.TitleDisplayTarget.StatusLine, true, undefined, false, false)}: ${this.sourceStatusText()}`;
          } else {
            return `${this._source.title(w.TitleDisplayTarget.StatusLine, true, undefined, false, false)} ${this.sourceStatusText()}`;
          }
        } else {
          return this._source.title(w.TitleDisplayTarget.StatusLine, true, undefined, false, false);
        }
      }
    }
    var D = i(76350);
    var E = i(52270);
    var B = i(64147);
    const V = c.enabled("study_overlay_compare_legend_option");
    const R = c.enabled("force_exchange_as_title");
    const N = !c.enabled("hide_study_compare_legend_item");
    const O = c.enabled("hide_unresolved_symbols_in_legend");
    const F = c.enabled("symbol_info_price_source");
    var W;
    (function (e) {
      e.SnapShotSymbolInfoKey = "___snapshot";
    })(W ||= {});
    class H extends n.Study {
      constructor(e, t, i, s, o) {
        super(e, function (e) {
          if (!e.hasChild("currencyId")) {
            e.addChild("currencyId", new a.Property(null));
          }
          if (!e.hasChild("unitId")) {
            e.addChild("unitId", new a.Property(null));
          }
          e.addExcludedKey("currencyId", 1);
          e.addExcludedKey("unitId", 1);
          return e;
        }(t), i, s, o);
        this._isActingAsSymbolSource = new B.WatchedValue(true);
        this._realignToolsLastParams = null;
        this._lastResolvedSymbolSource = "";
        this.properties().childs().minTick.subscribe(null, () => this._recreatePriceFormattingDependencies());
        this.properties().childs().minTick.subscribe(null, () => this._model.fullUpdate());
        this.properties().childs().currencyId.subscribe(this, this._onCurrencyChanged);
        this.properties().childs().unitId.subscribe(this, this._onUnitChanged);
        this._symbolResolvingActive = new B.WatchedValue(false);
        this._symbolHibernated = new B.WatchedValue(false);
        e.mainSeries().onIntervalChanged().subscribe(this, () => e.realignLineTools(this));
      }
      destroy() {
        this._model.mainSeries().onIntervalChanged().unsubscribeAll(this);
        super.destroy();
      }
      properties() {
        return this._properties;
      }
      isActingAsSymbolSource() {
        return this._isActingAsSymbolSource.readonly();
      }
      symbolParams() {
        return (0, D.symbolParams)(this);
      }
      compareSymbolParams(e) {
        return (0, D.compareSymbolParams)(this, e, this._model.unitConversionEnabled());
      }
      async setSymbolParams(e) {
        this._setSymbolCurrencyUnitInternal(e);
      }
      symbol() {
        return this.properties().childs().inputs.childs().symbol.value();
      }
      symbolChanged() {
        return this.properties().childs().inputs.childs().symbol;
      }
      setSymbol(e) {
        this.setSymbolParams({
          symbol: e
        });
      }
      symbolInfo() {
        if (!this._resolvedSymbols) {
          return null;
        }
        const e = this.symbol();
        if (!e) {
          return null;
        }
        let t;
        t = this._resolvedSymbols[this._getSymbolForResolve(e)] || null;
        return t;
      }
      symbolResolved() {
        return this.symbolsResolved();
      }
      symbolResolvingActive() {
        return this._symbolResolvingActive;
      }
      symbolHibernated() {
        return this._symbolHibernated;
      }
      isVisible() {
        const e = super.isVisible();
        this._symbolHibernated.setValue(!e);
        return e;
      }
      symbolSameAsCurrent(e) {
        return (0, D.symbolSameAsCurrent)(e, this.symbolInfo());
      }
      symbolSameAsResolved(e) {
        return (0, E.symbolSameAsResolved)(e, this._lastResolvedSymbolSource, this.symbol());
      }
      currency() {
        return this.properties().childs().currencyId.value() || null;
      }
      setCurrency(e) {
        this.setSymbolParams({
          currency: e
        });
      }
      isConvertedToOtherCurrency() {
        return (0, r.isConvertedToOtherCurrency)(this.symbolInfo());
      }
      unit() {
        return this.properties().childs().unitId.value() || null;
      }
      setUnit(e) {
        this.setSymbolParams({
          unit: e
        });
      }
      isConvertedToOtherUnit() {
        return (0, r.isConvertedToOtherUnit)(this.symbolInfo(), this._model.unitConversionEnabled());
      }
      style() {
        return 2;
      }
      setStyle(e) { }
      interval() {
        return this._model.mainSeries().interval();
      }
      setInterval(e) { }
      symbolSource() {
        return this;
      }
      valueAt(e, t) {
        return this.data().search(e)?.value[1] ?? null;
      }
      state(e, t) {
        const i = super.state(e, t);
        if (!this._model.unitConversionEnabled()) {
          delete i.state.unitId;
        }
        const o = this.symbol();
        i.state.inputs.symbol = (0, r.symbolToSaveInState)(this.symbolInfo() ?? this._model.chartApi().lastSymbolResolveInfo(o), o);
        if (e) {
          (0, s.ensureDefined)(i.data).symbols = {
            ___snapshot: this.symbolInfo() || undefined
          };
        }
        return i;
      }
      symbolTitle(e, t, i) {
        return this.title(e, true, {}, false, t);
      }
      titleInParts(e, t, i, s, o) {
        const n = this._titleInParts(e, t, i, s, o);
        return [[n[0], ...(n[1] ?? [])].join(", ")];
      }
      tags() {
        const e = this.symbol();
        if (e) {
          return [e];
        } else {
          return [];
        }
      }
      statusView() {
        if (N) {
          return super.statusView();
        } else {
          return null;
        }
      }
      guiPlotName(e, t) {
        return this.properties().childs().inputs.childs().symbol.value();
      }
      canOverrideMinTick() {
        return true;
      }
      canBeHiddenByGlobalFlag() {
        return false;
      }
      legendValuesProvider() {
        return new P(this, this.model());
      }
      statusProvider(e) {
        return new k(this);
      }
      measureUnitId() {
        return (0, r.measureUnitId)(this.symbolInfo());
      }
      getSymbolString(e = this._getSymbolForApi(this.symbol())) {
        return (0, l.encodeExtendedSymbolOrGetSimpleSymbolString)(this._getSymbolObject(e));
      }
      _createPriceAxisView(e) {
        return new m(this, {
          plotIndex: "compare"
        });
      }
      _createViews() {
        this._legendView ||= new I(this, this._model);
        this._dataWindowView ||= new T(this, this._model);
        this._statusView ||= new M.StudyStatusView(this);
        super._createViews();
      }
      _onUnitChanged() {
        if ((0, o.currencyUnitVisibilityProperty)().value() !== "alwaysOff") {
          this._model.fullUpdate();
        }
        if (this._model.unitConversionEnabled() && this.isStarted()) {
          this._tryChangeInputs();
        }
        this._unitChanged.fire();
      }
      _getSymbolObject(e) {
        const t = super._getSymbolObject(e);
        const i = this.currency();
        if (i !== null) {
          t["currency-id"] = i;
        }
        const s = this.unit();
        if (this._model.unitConversionEnabled() && s !== null) {
          t["unit-id"] = s;
        }
        return t;
      }
      _onSymbolResolvingStart(e, t) {
        this._lastResolvedSymbolSource = t;
        super._onSymbolResolvingStart(e, t);
        this._symbolResolvingActive.setValue(true);
      }
      _onSymbolError() {
        super._onSymbolError();
        this._symbolResolvingActive.setValue(false);
      }
      _onSymbolResolved(e, t, i) {
        super._onSymbolResolved(e, t, i);
        this._recreatePriceFormattingDependencies();
        const s = t === this.symbol() ? (0, r.extractSymbolNameFromSymbolInfo)(i, this.symbol()) : null;
        const o = (0, r.symbolCurrency)(i);
        const n = (0, r.symbolUnit)(i, this._model.unitConversionEnabled());
        this._setSymbolCurrencyUnitInternal({
          symbol: s ?? undefined,
          currency: o,
          unit: n
        }, i);
        this._symbolResolvingActive.setValue(false);
      }
      async _changeInputsImpl(e, t) {
        await super._changeInputsImpl(e, t);
        this._realignLineToolsIfParamsChanged();
      }
      _createStudyOnServer() {
        const e = super._createStudyOnServer();
        this._realignLineToolsIfParamsChanged();
        return e;
      }
      _tryCreateFormatter() {
        const e = A.customFormatters?.priceFormatterFactory?.(this.symbolInfo(), this.properties().childs().minTick.value()) ?? null;
        if (e !== null) {
          return e;
        } else {
          return (0, r.createSeriesFormatter)(this.symbolInfo(), this.properties().childs().minTick.value());
        }
      }
      _tryCreateDefaultFormatter() {
        return (0, r.createSeriesFormatter)(this.symbolInfo(), "default");
      }
      _titleInParts(e, t, i, s, o) {
        const n = this.symbolInfo();
        return [this._getSymbolTitlePart(n), [this._getExchangeTitlePart(n, o), this._getPriceSourceTitlePart(n)].filter(e => e !== null)];
      }
      _skipHistogramBaseOnAutoScale() {
        return true;
      }
      _getSymbolTitlePart(e) {
        if (e === null) {
          if (O) {
            return "";
          } else {
            return this.properties().childs().inputs.childs().symbol.value();
          }
        }
        const t = (0, r.getSymbolExchange)(e);
        if (R && t !== undefined) {
          return t;
        }
        if (V) {
          switch (this._model.mainSeries().symbolTextSourceProxyProperty().value()) {
            case "description":
              return e.description;
            case "ticker-and-description":
              return `${e.name}, ${e.description}`;
            case "long-description":
              return e.long_description ?? e.description;
          }
        }
        return e.name;
      }
      _getExchangeTitlePart(e, t) {
        if (e === null || t) {
          return null;
        } else {
          return (0, r.getSymbolExchange)(e);
        }
      }
      _getPriceSourceTitlePart(e) {
        if (F && this._model.properties().childs().paneProperties.childs().legendProperties.childs().showPriceSource.value() !== false && e?.price_source_id !== undefined) {
          return this._model.availablePriceSources(this.getSymbolString(this._getSymbolForApi(this.symbol()))).name(e.price_source_id) ?? null;
        } else {
          return null;
        }
      }
      _setSymbolCurrencyUnitInternal(e, t) {
        const {
          symbol: i,
          currency: s,
          unit: o
        } = e;
        const n = this.properties().childs();
        const a = n.inputs.childs().symbol.value();
        const l = n.currencyId.value();
        const c = n.unitId.value();
        if (i !== undefined) {
          n.inputs.childs().symbol.setValueSilently(i);
        }
        if (s !== undefined) {
          n.currencyId.setValueSilently(s);
        }
        if (o !== undefined) {
          n.unitId.setValueSilently(o);
        }
        if (t) {
          this._resolvedSymbolsByInput[this.symbol()] = t;
          this._resolvedSymbols[this._getSymbolForResolve(this.symbol())] = t;
          this._realignToolsLastParams = null;
        } else {
          const e = this.symbolInfo();
          if (e !== null) {
            n.currencyId.setValueSilently((0, r.symbolCurrency)(e));
            n.unitId.setValueSilently((0, r.symbolUnit)(e, this._model.unitConversionEnabled()));
          }
        }
        if (n.inputs.childs().symbol.value() !== a) {
          n.inputs.childs().symbol.fireChanged();
        }
        if (n.currencyId.value() !== l) {
          n.currencyId.fireChanged();
        }
        if (n.unitId.value() !== c) {
          n.unitId.fireChanged();
        }
        this._realignLineToolsIfParamsChanged();
      }
      _realignLineToolsIfParamsChanged() {
        let e = this._realignToolsLastParams === null;
        if (this._realignToolsLastParams !== null) {
          const t = this.compareSymbolParams(this._realignToolsLastParams);
          e = t.symbolChanged || t.intervalChanged || t.currencyChanged || t.unitChanged;
        }
        if (e) {
          this._model.realignLineTools(this);
          this._realignToolsLastParams = this.symbolParams();
        }
      }
    }
  },
  16227: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyPriceAxisView: () => r
    });
    var s = i(50151);
    var o = i(98558);
    var n = i(19063);
    class r extends o.PriceAxisView {
      constructor(e, t) {
        super();
        this._model = e.model();
        this._source = e;
        this._data = t;
        this._isForceOverlay = !!this._source.metaInfo().isPlotForceOverlay(this._data.plotIndex);
      }
      update(e) {
        if (e.type !== "hover-change") {
          super.update(e);
        }
      }
      _updateRendererData(e, t, i) {
        e.visible = false;
        t.visible = false;
        const o = this._source.model();
        const r = this._isForceOverlay ? o.mainSeries().priceScale() : this._source.priceScale();
        if (r === null) {
          return;
        }
        if (!o.isPriceScaleVisible(r)) {
          return;
        }
        const a = this._source.lastValueData(this._data.plotIndex, false);
        if (a.noData) {
          return;
        }
        const l = o.timeScale().visibleBarsStrictRange();
        const c = o.mainSeries().bars().lastIndex();
        if (l !== null && c !== null) {
          if (c <= l.lastBar()) {
            i.background = (0, n.resetTransparency)(a.color);
            let s = a.color;
            if (s === "transparent") {
              s = this._model.properties().childs().scalesProperties.childs().backgroundColor.value();
            }
            i.textColor = this.generateTextColor(s);
            i.borderColor = undefined;
            e.borderVisible = false;
            t.borderVisible = false;
          } else {
            const r = o.backgroundColorAtYPercentFromTop(a.coordinate / (0, s.ensureNotNull)(o.paneForSource(this._source)).height());
            i.background = r;
            i.textColor = (0, n.resetTransparency)(a.color);
            i.borderColor = (0, n.resetTransparency)(i.textColor);
            e.borderVisible = true;
            t.borderVisible = true;
          }
          i.coordinate = a.coordinate;
          i.floatCoordinate = a.floatCoordinate;
          if (this._showAxisLabel()) {
            e.text = a.text;
            e.visible = true;
          }
          this._updatePaneRendererData(t);
        }
      }
      _showPaneLabel() {
        return !!this._model.properties().childs().scalesProperties.childs().showStudyPlotLabels.value() && this._source.properties().childs().showLabelsOnPriceScale.value() && this._source.isPlotVisibleAt(this._data.plotIndex, 4);
      }
      _showAxisLabel() {
        return !!this._model.properties().childs().scalesProperties.childs().showStudyLastValue.value() && this._source.properties().childs().showLabelsOnPriceScale.value() && this._source.isPlotVisibleAt(this._data.plotIndex, 4);
      }
      _updatePaneRendererData(e) {
        e.text = "";
        if (this._showPaneLabel()) {
          e.text = this._source.priceLabelText(this._data.plotIndex);
          e.visible = true;
        }
      }
    }
  },
  78749: (e, t, i) => {
    "use strict";

    i.d(t, {
      applyOverridesToStudy: () => d,
      applyOverridesToStudyDefaults: () => u
    });
    var s = i(50151);
    var o = i(94113);
    var n = i(9343);
    const r = {
      line: o.LineStudyPlotStyle.Line,
      histogram: o.LineStudyPlotStyle.Histogram,
      cross: o.LineStudyPlotStyle.Cross,
      area: o.LineStudyPlotStyle.Area,
      columns: o.LineStudyPlotStyle.Columns,
      circles: o.LineStudyPlotStyle.Circles,
      line_with_breaks: o.LineStudyPlotStyle.LineWithBreaks,
      area_with_breaks: o.LineStudyPlotStyle.AreaWithBreaks,
      step_line: o.LineStudyPlotStyle.StepLine,
      step_line_with_breaks: o.LineStudyPlotStyle.StepLineWithBreaks,
      step_line_with_diamonds: o.LineStudyPlotStyle.StepLineWithDiamonds
    };
    const a = (0, n.getLogger)("Chart.Model.StudyPropertiesOverrider");
    var l;
    var c;
    function h(e, t, i, s) {
      const o = i.split(".");
      if (o.length === 0 || o[0].length === 0) {
        return;
      }
      const n = function (e) {
        const t = e.split(":");
        return {
          name: t[0],
          type: t.length === 2 ? t[1] : null
        };
      }(o[0]);
      const r = n.name;
      const h = n.type;
      const d = h !== null;
      const u = !d || h === "band";
      const _ = !d || h === "area";
      const p = !d || h === "input";
      const m = !d || h === "plot" ? c.getPlotIdByTitle(e, r) : null;
      const g = u ? c.getBandIndexByName(e, r) : null;
      const f = _ ? c.getFilledAreaIdByTitle(e, r) : null;
      const y = p ? c.getInputByName(e, r) : null;
      const v = t.hasOwnProperty(r);
      if ((m !== null ? 1 : 0) + (g !== null ? 1 : 0) + (f !== null ? 1 : 0) + (y !== null ? 1 : 0) + (v ? 1 : 0) > 1) {
        a.logWarn(`Study '${e.description}' has ambiguous identifier '${r}'`);
        return;
      }
      const S = o[1];
      if (m !== null) {
        if (o.length === 1) {
          a.logWarn(`Path of sub-property of '${r}' plot for study '${e.description}' must be not empty`);
          return;
        }
        const i = o.slice(1);
        l.applyPlotProperty(e, t, m, i, s);
      } else if (y !== null) {
        l.applyInputValue(t, y, s);
      } else if (g !== null) {
        if (S === undefined) {
          a.logWarn(`Property name of '${r}' band for study '${e.description}' must be set`);
          return;
        }
        l.applyBandProperty(t, g, S, s);
      } else if (f !== null) {
        if (S === undefined) {
          a.logWarn(`Property name of '${r}' area for study '${e.description}' must be set`);
          return;
        }
        l.applyFilledAreaProperty(t, f, S, s);
      } else if (v) {
        l.setRootProperty(t, o, s);
      } else {
        a.logWarn(`Study '${e.description}' has no plot or input '${r}'`);
      }
    }
    function d(e, t) {
      const i = e.properties();
      const s = i.state();
      for (const i in t) {
        if (t.hasOwnProperty(i)) {
          h(e.metaInfo(), s, i, t[i]);
        }
      }
      i.mergeAndFire(s);
    }
    function u(e, t, i) {
      for (const s in e) {
        if (!e.hasOwnProperty(s)) {
          continue;
        }
        const o = s.indexOf(".");
        if (o === -1) {
          continue;
        }
        const n = s.substring(0, o);
        const r = c.getMetaInfoByDescription(t, n);
        if (r === null) {
          a.logWarn(`There is no such study ${n}`);
          continue;
        }
        const l = i(r);
        if (l !== null) {
          h(r, l, s.substring(o + 1), e[s]);
        } else {
          a.logWarn(`Cannot apply overrides for study ${n}`);
        }
      }
    }
    (function (e) {
      e.applyPlotProperty = function (e, t, i, n, l) {
        if (t.styles === undefined) {
          a.logWarn("Study does not have styles");
          return;
        }
        const c = n[0];
        if (c === "color") {
          const r = function (e, t, i) {
            if (e.plots === undefined) {
              return null;
            }
            for (const s of e.plots) {
              if (!(0, o.isPaletteColorerPlot)(s) || t.palettes === undefined) {
                continue;
              }
              const e = t.palettes[s.palette];
              if (s.target === i && e !== undefined) {
                return e;
              }
            }
            return null;
          }(e, t, i);
          (function (e, t, i, o, n) {
            if (e.styles !== undefined) {
              if (t === null && !isNaN(o) && o > 0) {
                a.logWarn(`Study plot does not have color #${o}`);
              } else {
                if (o === 0 || isNaN(o)) {
                  (0, s.ensureDefined)(e.styles[i]).color = String(n);
                  o = 0;
                }
                if (t !== null) {
                  (0, s.ensureDefined)(t.colors?.[o]).color = String(n);
                }
              }
            } else {
              a.logWarn("Study does not have styles");
            }
          })(t, r, i, n.length > 1 ? parseInt(n[1]) : NaN, l);
          return;
        }
        const h = t.styles[i];
        if (h !== undefined && h.hasOwnProperty(c)) {
          if (c === "plottype") {
            const e = r[String(l)];
            if (e === undefined) {
              a.logWarn(`Unsupported plot type for plot: ${l}`);
              return;
            }
            l = e;
          }
          h[c] = l;
        } else {
          a.logWarn(`Study plot does not have property '${c}'`);
        }
      };
      e.applyBandProperty = function (e, t, i, s) {
        if (e.bands === undefined) {
          a.logWarn("Study does not have bands");
          return;
        }
        const o = e.bands[t];
        if (o !== undefined && o.hasOwnProperty(i)) {
          if (i === "plottype") {
            const e = r[String(s)];
            if (e === undefined) {
              a.logWarn(`Unsupported plot type for band: ${s}`);
              return;
            }
            s = e;
          }
          o[i] = s;
        } else {
          a.logWarn(`Study band does not have property '${i}'`);
        }
      };
      e.applyFilledAreaProperty = function (e, t, i, s) {
        if (e.filledAreasStyle === undefined) {
          a.logWarn("Study does not have areas");
          return;
        }
        const o = e.filledAreasStyle[t];
        if (o !== undefined && o.hasOwnProperty(i)) {
          o[i] = s;
        } else {
          a.logWarn(`Study area does not have property '${i}'`);
        }
      };
      e.applyInputValue = function (e, t, i) {
        if (e.inputs !== undefined && e.inputs.hasOwnProperty(t)) {
          e.inputs[t] = i;
        } else {
          a.logWarn(`Study does not have input '${t}'`);
        }
      };
      e.setRootProperty = function (e, t, i) {
        if (t.length === 0) {
          return;
        }
        let s = e;
        for (const e of t.slice(0, -1)) {
          if (s == null || !s.hasOwnProperty(e)) {
            break;
          }
          s = s[e];
        }
        const o = t[t.length - 1];
        if (s != null && s.hasOwnProperty(o)) {
          s[o] = i;
        } else {
          a.logWarn(`Study does not have property ${t.join(".")}`);
        }
      };
    })(l ||= {});
    (function (e) {
      e.getInputByName = function (e, t) {
        if (e.inputs === undefined) {
          return null;
        }
        t = t.toLowerCase();
        for (const i of e.inputs) {
          if (i.name.toLowerCase() === t) {
            return i.id;
          }
        }
        return null;
      };
      e.getPlotIdByTitle = function (e, t) {
        if (e.styles === undefined) {
          return null;
        }
        t = t.toLowerCase();
        for (const i in e.styles) {
          const s = e.styles[i];
          if ((s !== undefined && s.title !== undefined ? s.title : i).toLowerCase() === t) {
            return i;
          }
        }
        return null;
      };
      e.getFilledAreaIdByTitle = function (e, t) {
        if (e.filledAreas === undefined) {
          return null;
        }
        t = t.toLowerCase();
        for (const i of e.filledAreas) {
          if (i.title.toLowerCase() === t) {
            return i.id;
          }
        }
        return null;
      };
      e.getBandIndexByName = function (e, t) {
        if (e.bands === undefined) {
          return null;
        }
        t = t.toLowerCase();
        for (let i = 0; i < e.bands.length; ++i) {
          if (e.bands[i].name.toLowerCase() === t) {
            return i;
          }
        }
        return null;
      };
      e.getMetaInfoByDescription = function (e, t) {
        t = t.toLowerCase();
        for (const i of e) {
          if (i.description.toLowerCase() === t || i.shortDescription.toLowerCase() === t) {
            return i;
          }
        }
        return null;
      };
    })(c ||= {});
  },
  46806: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      StudiesChunkName: () => Et,
      Study: () => Kt,
      studyFormatter: () => qt
    });
    var s = i(50279);
    var o = i(90054);
    var n = i(16738);
    var r = i(50151);
    var a = i(11542);
    var l = i(9343);
    var c = i(49822);
    function h(e) {
      const {
        name: t,
        group: i
      } = e;
      if (t.length > 0) {
        return `${i ? `${i}.` : ""}${t}`;
      } else {
        return undefined;
      }
    }
    var d = i(71885);
    var u = i(52033);
    var _ = i(19063);
    var p = i(58137);
    var m = i(18172);
    var g = i(45579);
    var f = i(93280);
    var y = i(64755);
    var v = i(68159);
    var S = i(14019);
    var b = i(8025);
    var w = i(85904);
    var C = i(14878);
    var P = i(44672);
    var T = i(22739);
    var x = i(7015);
    class I {
      constructor(e, t, i, s) {
        this._study = e;
        this._model = t;
        this._showStudyValues = s ?? t.properties().childs().paneProperties.childs().legendProperties.childs().showStudyValues;
        this._hhistBasedStudy = e.metaInfo().graphics.hhists !== undefined;
        this._valuesProvider = this._createValuesProvider(e, t, i);
      }
      getItems() {
        return this._valuesProvider.getItems();
      }
      getValues(e) {
        const t = this._valuesProvider.getValues(e);
        const i = this._study.properties();
        const s = this._showStudyValues.value() && i.childs().showLegendValues.value();
        const o = e => !!this._hhistBasedStudy || this._study.isPlotVisibleAt(e, 8);
        for (const e of t) {
          e.visible = e.visible && s && o(e.id);
        }
        return t;
      }
      _createValuesProvider(e, t, i) {
        if (this._hhistBasedStudy) {
          return new x.HHistBasedValuesProvider(e, t, i);
        } else {
          return new T.StudyValuesProvider(e, t, i);
        }
      }
    }
    var M = i(94113);
    class A extends C.StudyBaseWindowView {
      constructor(e, t) {
        super(e, t);
        this._showStudyValues = t.properties().childs().paneProperties.childs().legendProperties.childs().showStudyValues;
        this._showStudyValues.subscribe(this, () => this.update((0, P.sourceChangeEvent)(e.id())));
        const i = this._study.properties();
        i.childs().showLegendValues.subscribe(this, () => this.update((0, P.sourceChangeEvent)(e.id())));
        const s = this._study.metaInfo().plots;
        const o = new Set();
        s.forEach(t => {
          if ((0, M.isOhlcPlot)(t)) {
            const s = t.target;
            if (o.has(s)) {
              return;
            }
            o.add(s);
            i.childs().ohlcPlots.childs()[s].childs().display.subscribe(this, () => this.update((0, P.sourceChangeEvent)(e.id())));
          } else if ((0, M.isPlotSupportDisplay)(t)) {
            i.childs().styles.childs()[t.id]?.childs().display.subscribe(this, () => this.update((0, P.sourceChangeEvent)(e.id())));
          }
        });
      }
      areValuesVisible() {
        return this._showStudyValues.value();
      }
      additional() {
        return null;
      }
      destroy() {
        this._showStudyValues.unsubscribeAll(this);
        const e = this._study.properties();
        e.childs().showLegendValues.unsubscribeAll(this);
        const t = this._study.metaInfo().plots;
        const i = new Set();
        t.forEach(t => {
          if ((0, M.isOhlcPlot)(t)) {
            const s = t.target;
            if (i.has(s)) {
              return;
            }
            i.add(s);
            e.childs().ohlcPlots.childs()[s].childs().display.unsubscribeAll(this);
          } else if ((0, M.isPlotSupportDisplay)(t)) {
            e.childs().styles.childs()[t.id]?.childs().display.unsubscribeAll(this);
          }
        });
      }
      _createValuesProvider(e, t) {
        return new I(e, t);
      }
    }
    var L = i(928);
    var k = i(49936);
    var D = i(73698);
    var E = i(3462);
    var B = i(4340);
    var V = i(44158);
    var R = i(37265);
    i(19466);
    i(84425);
    function N(e, t) {
      return e.studyId.localeCompare(t.studyId);
    }
    function O(e) {
      const t = new Set();
      const i = [];
      e.forEach(e => {
        if (!t.has(e.studyId)) {
          t.add(e.studyId);
          i.push(e);
        }
      });
      return i;
    }
    function F(e) {
      const t = e.model().mainSeries();
      return {
        studyId: (0, r.ensureNotNull)(e.sourceId()),
        turnaround: e.turnaround(),
        sourceStudies: e.parentSources().filter(e => e !== t).map(e => F(e))
      };
    }
    var W = i(65383);
    var H = i(56570);
    var z = i(95201);
    var U = i(30125);
    class j extends U.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = e;
      }
      hitTest(e) {
        return null;
      }
      _drawImpl(e) { }
      _drawBackgroundImpl(e) {
        const {
          context: t,
          horizontalPixelRatio: i,
          bitmapSize: s
        } = e;
        const o = this._data;
        for (let e = 0; e < o.items.length; ++e) {
          const n = o.items[e];
          if (n.color == null) {
            continue;
          }
          t.fillStyle = n.color;
          const r = Math.round(n.left * i) + 1;
          const a = Math.round(n.right * i);
          t.fillRect(r, 0, a - r + 1, s.height);
        }
      }
    }
    var G = i(83085);
    var q = i(64559);
    class $ extends q.StudyForceOverlayPlotView {
      constructor(e, t, i, s) {
        super(t, i, s);
        this._items = [];
        this._invalidated = true;
        this._isMarkersEnabled = H.enabled("source_selection_markers");
        this._study = e;
        const o = this._study.metaInfo().plots;
        for (let e = 0; e < o.length; e++) {
          const t = o[e];
          if (t.id === this._plotName) {
            this._plotIndex = e;
            (0, r.assert)((0, M.isBgColorerPlot)(t), "Plot '" + this._plotName + "' is not a background colorer!");
          }
        }
        this._colorProvider = (0, G.createStudyPlotColorProvider)(e.metaInfo(), e.properties(), s);
      }
      items() {
        return this._items;
      }
      update(e) {
        if (e.type !== "hover-change") {
          this._invalidated = true;
        }
      }
      renderer() {
        if (~(0, r.ensureDefined)(this._study.properties().childs().styles.childs()[this._plotName]).childs().display.value() & 1) {
          return null;
        }
        if (!this._scalesReady()) {
          return null;
        }
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        const e = {
          items: this._items
        };
        const t = new z.CompositeRenderer();
        t.append(new j(e));
        return t;
      }
      _scalesReady() {
        const e = this._model.timeScale();
        const t = this._priceScale();
        return e && !e.isEmpty() && t !== null && !t.isEmpty();
      }
      _getTranspValue() {
        const e = (0, r.ensureDefined)(this._study.properties().childs().styles.childs()[this._plotName]).childs();
        let t = 0;
        if (e.transparency) {
          t = e.transparency.value();
          t = (0, R.isNumber)(t) ? t : 40;
        }
        return t;
      }
      _updateImpl() {
        this._items = [];
        (0, r.assert)(this._scalesReady(), "Scales must be ready!");
        const e = this._model.timeScale().visibleBarsStrictRange();
        if (e === null) {
          return;
        }
        const t = this._getTranspValue();
        let i = (0, r.ensureDefined)(this._series.nearestIndex(e.firstBar(), b.PlotRowSearchMode.NearestRight));
        let s = (0, r.ensureDefined)(this._series.nearestIndex(e.lastBar(), b.PlotRowSearchMode.NearestLeft));
        const o = this._study.offset(this._plotName);
        if (o > 0) {
          i -= o;
          s += o;
        } else {
          i += o;
          s -= o;
        }
        const n = this._study.getMinFirstBarIndexForPlot(this._plotName);
        if (n > s) {
          return;
        }
        i = Math.max(n, i);
        const a = this._study.data();
        for (const e of a.rangeIterator(i, s)) {
          let i = e.index;
          const s = e.value;
          i += o;
          const n = {
            timePointIndex: Math.floor(i),
            left: NaN,
            center: NaN,
            right: NaN
          };
          let a = (0, R.isNumber)(t) ? t : 50;
          a = Math.min(a, 100);
          a = Math.max(a, 0);
          const l = this._colorProvider.getPlotPointStyle(s);
          if (l.colors[1] !== undefined) {
            n.color = (0, _.generateColor)((0, r.ensureDefined)(l.colors[1]), a);
          }
          this._items.push(n);
        }
        this._model.timeScale().fillBarBorders(this._items);
      }
    }
    var K;
    var Y = i(86129);
    var Z = i(11064);
    var X = i(31785);
    var J = i(9859);
    var Q = i(66540);
    var ee = i(3070);
    var te = i(13380);
    var ie = i(86441);
    var se = i(34026);
    var oe = i(50335);
    var ne = i(30699);
    var re = i(56468);
    var ae = i(63812);
    var le = i(68979);
    var ce = i(27714);
    var he = i(7114);
    (function (e) {
      e.Left = "left";
      e.Center = "center";
      e.Right = "right";
    })(K ||= {});
    const de = (0, he.createDisconnectedCanvas)(document, (0, ce.size)({
      width: 0,
      height: 0
    }), 1);
    class ue {
      constructor(e, t, i, s, o, n = "center", a = 0) {
        this._lines = e.split(/[^\S\r\n]*(?:\r\n|\r|\n)/);
        this._font = function (e, t, i, s) {
          return (0, le.makeFont)(s, i, `${e ? "bold " : ""}${t ? "italic " : ""}`);
        }(t, i, s, o);
        this._fontSize = o;
        this._verticalPadding = ~~(o / 6);
        this._textAlign = n;
        this._lineSpacing = a;
        const l = (0, r.ensureNotNull)(de.getContext("2d"));
        l.font = this._font;
        l.textBaseline = "top";
        let c = 0;
        for (let e = 0; e < this._lines.length; ++e) {
          const t = this._lines[e];
          const i = l.measureText(t).width;
          c = Math.max(c, i);
        }
        this.textImageWidth = c + 1;
        this.textImageHeight = this._lines.length * o + (this._lines.length - 1) * this._lineSpacing + this._verticalPadding;
      }
      paintTo(e, t) {
        const {
          context: i,
          horizontalPixelRatio: s,
          verticalPixelRatio: o
        } = e;
        i.save();
        const n = t.location;
        i.translate(Math.round(function (e, t, i) {
          let s = e;
          switch (t) {
            case "left":
              break;
            case "right":
              s -= i;
              break;
            case "center":
              s -= i / 2;
          }
          return Math.round(s);
        }(n.x, n.horzAlign, this.textImageWidth) * s), Math.round(function (e, t, i) {
          let s = e;
          switch (t) {
            case "top":
              break;
            case "bottom":
              s -= i;
              break;
            case "middle":
              s -= i / 2;
          }
          return Math.round(s);
        }(n.y, n.vertAlign, this.textImageHeight) * o));
        const r = t.style;
        let a;
        i.textBaseline = "top";
        i.font = this._font;
        i.lineJoin = "round";
        i.fillStyle = r.fillStyle;
        if (r.strokeStyle) {
          i.strokeStyle = r.strokeStyle;
        }
        if (r.lineWidth) {
          i.lineWidth = r.lineWidth;
        }
        switch (this._textAlign) {
          case "left":
            a = 0;
            i.textAlign = "left";
            break;
          case "right":
            a = this.textImageWidth - 1;
            i.textAlign = "right";
            break;
          default:
            a = this.textImageWidth / 2;
            i.textAlign = "center";
        }
        let l = this._verticalPadding;
        (0, he.drawScaled)(i, s, o, () => {
          for (const e of this._lines) {
            if (r.strokeStyle) {
              i.strokeText(e, a, l);
            }
            i.fillText(e, a, l);
            l += this._fontSize;
            l += this._lineSpacing;
          }
        });
        i.restore();
      }
    }
    class _e extends ae.AbstractMapContainer {
      constructor(e) {
        super();
        this._maxSize = e;
        this._keysQueue = [];
      }
      get(e) {
        const {
          fontSize: t,
          text: i,
          align: s,
          font: o,
          bold: n,
          italic: r,
          lineSpacing: a = 0
        } = e;
        if (!i || !t || !s) {
          return null;
        }
        const l = (0, le.makeFont)(t, o, r ? "italic" : "", n ? "bold" : "");
        const c = (0, ae.getDefault3)(this._map, a, s, l, new Map());
        let h = c.get(i);
        if (h === undefined) {
          if (this._size >= this._maxSize) {
            this._deleteFirstKey();
          } else {
            ++this._size;
          }
          this._keysQueue.push([l, s, a, i]);
          h = new ue(i, n, r, o, t, s, a);
          c.set(i, h);
        }
        return h;
      }
      _deleteFirstKey() {
        const e = this._keysQueue.shift();
        const [t, i, s, o] = e;
        const n = (0, r.ensureDefined)(this._map.get(s));
        const a = (0, r.ensureDefined)(n.get(i));
        const l = (0, r.ensureDefined)(a.get(t));
        l.delete(o);
        if (l.size === 0) {
          a.delete(t);
        }
        if (a.size === 0) {
          n.delete(i);
        }
        if (n.size === 0) {
          this._map.delete(s);
        }
      }
    }
    var pe;
    var me = i(15938);
    var ge = i(49483);
    (function (e) {
      e.Transparent = "rgba(0, 0, 0, 0)";
    })(pe ||= {});
    class fe extends U.BitmapCoordinatesPaneRenderer {
      constructor(e, t = {
        skipRenderingOptimizations: false
      }) {
        super();
        this._items = [];
        this._barSpacing = 0;
        this._vertOffset = 0;
        this._textCache = t.textCache || new _e(5000);
        this._drawOperation = t.skipRenderingOptimizations ? this._drawWithoutOptimizations.bind(this) : this._drawWithOptimizations.bind(this);
        if (e !== null) {
          this.setData(e);
        }
      }
      hitTest(e) {
        const t = re.HitTarget.Regular;
        let i = null;
        for (const s of this._items) {
          if (!s) {
            continue;
          }
          const o = this._calcBoundingBox(s);
          if (o && (0, se.pointInBox)(e, o)) {
            const e = {
              tooltip: this._getTooltip(s, o)
            };
            i = new re.HitTestResult(t, e);
          }
        }
        return i;
      }
      setData(e) {
        this._height = e.height !== undefined ? e.height : e.width;
        this._width = e.width !== undefined ? e.width : e.height;
        this._color = e.color;
        this._borderColor = e.borderColor;
        this._vertOffset = e.vertOffset || 0;
        if (e.text) {
          this._text = e.text;
          this._fontSize = e.fontSize;
          this._lineSpacing = e.lineSpacing;
          this._textColor = e.textColor;
          this._textAlign = e.textAlign || "center";
        }
        if (e.items !== undefined && e.barSpacing !== undefined) {
          const t = e.visibleItemsRange?.startItemIndex ?? 0;
          const i = e.visibleItemsRange?.endItemIndex ?? e.items.length;
          this.setItems(i > t ? e.items.slice(t, i) : [], e.barSpacing);
        }
      }
      setItems(e, t) {
        this._setBaseData(e, t);
      }
      _drawImpl(e) {
        this._preDrawInit();
        this._drawOperation(e);
      }
      _calcBoundingBox(e) {
        const t = e.vertOffset;
        const i = this._getTextCache(e);
        if (!i) {
          return;
        }
        const s = i.textImageWidth;
        const o = i.textImageHeight;
        const n = s / 2;
        const r = e.y + t + e.textVertOffset;
        const a = t > 0 ? 0 : -o;
        const l = t > 0 ? o : 0;
        const c = new ie.Point(e.center - n, r + a);
        const h = new ie.Point(e.center + n, r + l);
        return (0, ie.box)(c, h);
      }
      _unionBox(e, t) {
        const i = Math.min(e.min.x, t.min.x);
        const s = Math.max(e.max.x, t.max.x);
        const o = Math.min(e.min.y, t.min.y);
        const n = Math.max(e.max.y, t.max.y);
        const r = new ie.Point(i, o);
        const a = new ie.Point(s, n);
        return (0, ie.box)(r, a);
      }
      _getTooltip(e, t) {
        if (e.tooltip) {
          return {
            content: {
              type: "text",
              data: e.tooltip
            },
            tooltipDelay: 200,
            extendMargin: true,
            rect: {
              x: t.min.x,
              y: t.min.y,
              w: Math.abs(t.max.x - t.min.x),
              h: Math.abs(t.max.y - t.min.y)
            }
          };
        }
      }
      _setBaseData(e, t) {
        this._items.length = 0;
        this._barSpacing = t;
        for (const t of e) {
          if ((0, oe.isNaN)(t.y)) {
            continue;
          }
          const e = t.width === undefined ? (0, r.ensureDefined)(this._width) : t.width;
          const i = t.height === undefined ? (0, r.ensureDefined)(this._height) : t.height;
          const s = t.vertOffset === undefined ? this._vertOffset : t.vertOffset;
          const o = s > 0 ? i : -i;
          this._items.push({
            width: e,
            height: i,
            vertOffset: s,
            textVertOffset: o,
            shapeWidth: 0,
            shapeHeight: 0,
            stepX: 0,
            stepY: 0,
            ...t
          });
        }
      }
      _drawItemText(e, t) {
        const i = this._getTextCache(t);
        if (i === null) {
          return;
        }
        const s = t.center;
        const o = t.vertOffset;
        const n = t.y + o + t.textVertOffset;
        let r;
        r = t.style && t.style.textColor !== undefined ? t.style.textColor : this._textColor;
        const a = {
          style: {
            fillStyle: r
          },
          location: {
            x: s,
            y: n,
            horzAlign: ne.HorizontalAlign.Center,
            vertAlign: o > 0 ? ne.VerticalAlign.Top : ne.VerticalAlign.Bottom
          }
        };
        i.paintTo(e, a);
      }
      _drawWithOptimizations(e) {
        let t;
        let i;
        let s = null;
        let o = false;
        for (const n of this._items) {
          if (!(0, oe.isNaN)(n.y)) {
            if (n.style && n.style.color !== undefined) {
              t = n.style.color || "rgba(0, 0, 0, 0)";
              i = n.style.borderColor || "rgba(0, 0, 0, 0)";
            } else {
              t = this._color;
              i = this._borderColor;
            }
            if (s !== t || ge.isSafari) {
              s = t;
              if (o) {
                this._endPath(e);
              }
              this._startPath(e, t, i);
            }
            this._drawItemShape(e, n);
            o = true;
          }
        }
        if (o) {
          this._endPath(e);
        }
        for (const t of this._items) {
          if (!(0, oe.isNaN)(t.y)) {
            this._drawItemText(e, t);
          }
        }
      }
      _drawWithoutOptimizations(e) {
        let t;
        let i;
        for (const s of this._items) {
          if ((0, oe.isNaN)(s.y)) {
            continue;
          }
          const o = (0, r.ensureDefined)(s.style);
          t = o.color || "rgba(0, 0, 0, 0)";
          i = o.borderColor || "rgba(0, 0, 0, 0)";
          this._startPath(e, t, i);
          this._drawItemShape(e, s);
          this._endPath(e);
          this._drawItemText(e, s);
        }
      }
      _drawItemShape(e, t) {
        const {
          context: i,
          horizontalPixelRatio: s,
          verticalPixelRatio: o
        } = e;
        (0, he.drawScaled)(i, s, o, () => this._drawItemShapeUsingCSSPixels(i, t));
      }
      _drawItemShapeUsingCSSPixels(e, t) { }
      _preDrawInit() { }
      _startPath(e, t, i) { }
      _endPath(e) { }
      _getTextCache(e) {
        const t = e.text || this._text;
        const i = e.fontSize || this._fontSize;
        const s = e.lineSpacing ?? this._lineSpacing;
        const o = e.textAlign || this._textAlign;
        const n = e.font ?? me.CHART_FONT_FAMILY;
        const r = e.bold ?? false;
        const a = e.italic ?? false;
        return this._textCache.get({
          text: t,
          bold: r,
          italic: a,
          font: n,
          fontSize: i,
          lineSpacing: s,
          align: o
        });
      }
    }
    class ye extends fe {
      _startPath(e, t, i) {
        const s = e.context;
        s.beginPath();
        s.lineWidth = this._lineWidth(e);
        s.lineCap = "butt";
        s.strokeStyle = t;
      }
      _endPath(e) {
        e.context.stroke();
      }
      _lineWidth(e) {
        return Math.max(1, Math.floor(e.horizontalPixelRatio * 2));
      }
    }
    class ve extends fe {
      _startPath(e, t, i) {
        const s = e.context;
        s.beginPath();
        s.lineWidth = this._lineWidth(e);
        s.lineCap = "butt";
        s.fillStyle = t;
        s.strokeStyle = i;
      }
      _endPath(e) {
        const t = e.context;
        t.fill();
        t.stroke();
      }
      _lineWidth(e) {
        return Math.max(1, Math.floor(e.horizontalPixelRatio));
      }
    }
    class Se extends ve {
      constructor() {
        super(...arguments);
        this._sign = 0;
        this._thinArrow = false;
        this._thinArrowLineWidth = 0;
        this._headHeight = 0;
        this._arrowWidth = 0;
      }
      setItems(e, t) {
        this._setBaseData(e, t);
      }
      _drawItemShape(e, t) {
        const {
          context: i,
          horizontalPixelRatio: s,
          verticalPixelRatio: o
        } = e;
        const n = this._lineWidth(e) % 2 ? 0.5 : 0;
        const r = this._sign;
        const a = this._arrowWidth;
        const l = this._headHeight;
        const c = Math.abs(t.height);
        const h = Math.round(t.center * s) + n;
        const d = t.vertOffset;
        const u = Math.round((t.y + d + r * c / 2) * o) + n;
        const _ = (0, J.ceiledEven)(a * s);
        const p = _ / 2;
        const m = Math.round(c * o);
        const g = Math.round(l * o);
        i.translate(h, u);
        if (this._thinArrow) {
          i.moveTo(0, 0);
          i.lineTo(-p, -p * r);
          i.moveTo(0, 0);
          i.lineTo(p, -p * r);
          i.moveTo(0, 0);
          i.lineTo(0, -m * r);
          i.moveTo(-p, -m * r);
          i.lineTo(p, -m * r);
        } else {
          i.moveTo(0, 0);
          if (m < g) {
            i.lineTo(_, -m * r);
            i.lineTo(-_, -m * r);
          } else {
            i.lineTo(_, -g * r);
            i.lineTo(p, -g * r);
            i.lineTo(p, -m * r);
            i.lineTo(-p, -m * r);
            i.lineTo(-p, -g * r);
            i.lineTo(-_, -g * r);
          }
          i.lineTo(0, 0);
        }
        i.translate(-h, -u);
      }
      _preDrawInit() {
        const e = this._calculateWidth();
        this._arrowWidth = e;
        this._sign = this._isUp() ? -1 : 1;
        this._thinArrow = e < 4;
        this._thinArrowLineWidth = Math.max(e / 2, 1);
        this._headHeight = Math.round(e);
      }
      _startPath(e, t, i) {
        const s = e.context;
        s.beginPath();
        s.fillStyle = t;
        s.strokeStyle = i;
        s.lineWidth = this._lineWidth(e);
      }
      _lineWidth(e) {
        if (this._thinArrow) {
          return this._thinArrowLineWidth;
        } else {
          return super._lineWidth(e);
        }
      }
      _calcBoundingBox(e) {
        const t = e.vertOffset;
        const i = this._sign;
        const s = this._arrowWidth;
        const o = this._headHeight;
        const n = Math.abs(e.height);
        const r = e.center - s;
        const a = r + s * 2;
        const l = e.y + t + i * Math.round(n / 2);
        const c = l + (-n - o) * i;
        const h = new ie.Point(r, l);
        const d = new ie.Point(a, c);
        let u = (0, ie.box)(h, d);
        const _ = super._calcBoundingBox(e);
        if (_) {
          u = this._unionBox(u, _);
        }
        return u;
      }
      _calculateWidth() {
        return Math.round(this._barSpacing / 4);
      }
    }
    const be = Math.PI * 2;
    class we extends ve {
      setItems(e, t) {
        this._setBaseData(e, t);
        for (const e of this._items) {
          if (e.fontSize) {
            const t = e.fontSize;
            e.stepX = Math.round(t / 1.5);
            e.stepY = Math.round(t / 2) - 1;
          } else {
            const t = e.height;
            e.stepX = Math.round(t / 2 * 0.65) + 0.5;
            e.stepY = e.stepX;
          }
          e.vertOffset = this._calcVertOffset(e);
          const t = this._getTextCache(e);
          if (t === null) {
            e.shapeWidth = e.stepX * 2;
            e.shapeHeight = e.stepY * 2.5;
            continue;
          }
          const i = t.textImageWidth;
          const s = t.textImageHeight;
          e.shapeWidth = i + e.stepX * 2;
          e.shapeHeight = s + e.stepY * 2;
          e.vertOffset = this._calcVertOffset(e);
          e.textHorizOffset = this._getHorizontalTextOffset(e);
          e.textVertOffset = this._getVerticalTextOffset(e);
        }
      }
      _calcVertOffset(e) {
        return e.vertOffset;
      }
      _drawCorner(e, t, i, s) {
        const {
          context: o,
          horizontalPixelRatio: n
        } = e;
        const r = Math.max(1, Math.floor(n * 2));
        o.lineTo(t - r * s.prevPointSignX, i - r * s.prevPointSignY);
        o.arcTo(t, i, t + r * s.nextPointSignX, i + r * s.nextPointSignY, r);
      }
      _getArrowSize(e) {
        return e.stepX;
      }
      _getHorizontalTextOffset(e) {
        return 0;
      }
      _getVerticalTextOffset(e) {
        return 0;
      }
      _hasText(e) {
        return Boolean(e.text) || Boolean(this._text);
      }
      _drawItemText(e, t) {
        const i = this._getTextCache(t);
        if (i === null) {
          return;
        }
        const s = t.textHorizOffset || 0;
        const o = t.center + s;
        const n = t.vertOffset;
        const a = t.y + n + t.textVertOffset;
        const l = t.style?.textColor || this._textColor;
        const c = {
          style: {
            fillStyle: (0, r.ensureDefined)(l)
          },
          location: {
            x: o,
            y: Math.floor(a),
            horzAlign: ne.HorizontalAlign.Center,
            vertAlign: ne.VerticalAlign.Middle
          }
        };
        i.paintTo(e, c);
      }
    }
    class Ce {
      constructor(e, t, i, s) {
        this.prevPointSignX = e;
        this.prevPointSignY = t;
        this.nextPointSignX = i;
        this.nextPointSignY = s;
      }
    }
    var Pe;
    (function (e) {
      e.rightUp = new Ce(1, 0, 0, 1);
      e.rightDown = new Ce(0, 1, -1, 0);
      e.leftDown = new Ce(-1, 0, 0, -1);
      e.leftUp = new Ce(0, -1, 1, 0);
    })(Pe ||= {});
    class Te extends ve {
      _calcBoundingBox(e) {
        const t = e.width;
        const i = e.height;
        const s = t / 2;
        const o = Math.round(i / 3);
        const n = e.center;
        const r = e.vertOffset - o * 2;
        const a = e.y + r;
        const l = n - s;
        const c = n + s;
        const h = a;
        const d = a + i;
        const u = new ie.Point(l, h);
        const _ = new ie.Point(c, d);
        let p = (0, ie.box)(u, _);
        const m = super._calcBoundingBox(e);
        if (m) {
          p = this._unionBox(p, m);
        }
        return p;
      }
    }
    var xe = i(29981);
    var Ie = i(35864);
    const Me = new Map();
    Me.set("PaneRendererArrowUp", class extends Se {
      _isUp() {
        return true;
      }
    });
    Me.set("PaneRendererArrowDown", class extends Se {
      _isUp() {
        return false;
      }
    });
    Me.set("PaneRendererCircleShape", class extends ve {
      _drawItemShapeUsingCSSPixels(e, t) {
        const i = Math.max(t.width, t.height) / 2;
        const s = t.center;
        const o = t.vertOffset;
        const n = t.y + o;
        e.moveTo(s + i, n);
        e.arc(s, n, i, 0, be, false);
      }
      _calcBoundingBox(e) {
        const t = Math.max(e.width, e.height) / 2;
        const i = e.center;
        const s = e.vertOffset;
        const o = e.y + s;
        const n = i - t;
        const r = i + t;
        const a = o - t;
        const l = o + t;
        const c = new ie.Point(n, a);
        const h = new ie.Point(r, l);
        let d = (0, ie.box)(c, h);
        const u = super._calcBoundingBox(e);
        if (u) {
          d = this._unionBox(d, u);
        }
        return d;
      }
    });
    Me.set("PaneRendererCrossShape", class extends ye {
      _drawItemShape(e, t) {
        const {
          context: i,
          horizontalPixelRatio: s,
          verticalPixelRatio: o
        } = e;
        const n = t.width;
        const r = t.height;
        const a = t.center - n / 2;
        const l = t.vertOffset;
        const c = t.y - r / 2 + l;
        const h = this._lineWidth(e);
        const d = h % 2 ? 0.5 : 0;
        const u = Math.round(a * s);
        let _ = Math.round((a + n) * s);
        if ((_ - u) % 2 != h % 2) {
          _ += 1;
        }
        const p = Math.floor((u + _) / 2) + d;
        const m = Math.round(c * o);
        let g = Math.round((c + r) * o);
        if ((g - m) % 2 != h % 2) {
          g += 1;
        }
        const f = Math.floor((m + g) / 2) + d;
        i.moveTo(p, m);
        i.lineTo(p, g);
        i.moveTo(u, f);
        i.lineTo(_, f);
      }
      _calcBoundingBox(e) {
        const t = e.width;
        const i = e.height;
        const s = e.center - t / 2;
        const o = e.vertOffset;
        const n = e.y - i / 2 + o;
        const r = s;
        const a = s + t;
        const l = n;
        const c = n + i;
        const h = new ie.Point(r, l);
        const d = new ie.Point(a, c);
        let u = (0, ie.box)(h, d);
        const _ = super._calcBoundingBox(e);
        if (_) {
          u = this._unionBox(u, _);
        }
        return u;
      }
    });
    Me.set("PaneRendererDiamond", class extends ve {
      _drawItemShapeUsingCSSPixels(e, t) {
        const i = Math.round(t.height / 2);
        const s = t.center;
        const o = t.vertOffset;
        const n = t.y + o;
        e.moveTo(s, n - i);
        e.lineTo(s + i, n);
        e.lineTo(s, n + i);
        e.lineTo(s - i, n);
        e.lineTo(s, n - i);
      }
      _calcBoundingBox(e) {
        const t = Math.round(e.height / 2);
        const i = e.center;
        const s = e.vertOffset;
        const o = e.y + s;
        const n = i - t;
        const r = i + t;
        const a = o - t;
        const l = o + t;
        const c = new ie.Point(n, a);
        const h = new ie.Point(r, l);
        let d = (0, ie.box)(c, h);
        const u = super._calcBoundingBox(e);
        if (u) {
          d = this._unionBox(d, u);
        }
        return d;
      }
    });
    Me.set("PaneRendererFlagShape", class extends ve {
      _drawItemShapeUsingCSSPixels(e, t) {
        const i = t.width;
        const s = t.height;
        const o = s / 2;
        const n = (i - 3) / 3;
        const r = t.center - i / 2;
        const a = t.vertOffset;
        const l = t.y - o + a;
        e.moveTo(r, l);
        e.lineTo(r + 3, l);
        e.bezierCurveTo(r + n, l - n, r + n * 2, l + n, r + i, l);
        e.lineTo(r + i, l + o);
        e.bezierCurveTo(r + i - n, l + o + n, r + i - n * 2, l + o - n, r + 3, l + o);
        e.lineTo(r + 3, l + s);
        e.lineTo(r, l + s);
        e.lineTo(r, l);
      }
      _calcBoundingBox(e) {
        const t = e.width;
        const i = e.height;
        const s = i / 2;
        const o = e.center - t / 2;
        const n = e.vertOffset;
        const r = e.y - s + n;
        const a = o;
        const l = o + t;
        const c = r;
        const h = r + i;
        const d = new ie.Point(a, c);
        const u = new ie.Point(l, h);
        let _ = (0, ie.box)(d, u);
        const p = super._calcBoundingBox(e);
        if (p) {
          _ = this._unionBox(_, p);
        }
        return _;
      }
    });
    Me.set("PaneRendererLabelUp", class extends we {
      _calcBoundingBox(e) {
        const t = e.center - e.shapeWidth / 2;
        const i = e.center + e.shapeWidth / 2;
        const s = e.y + e.vertOffset;
        const o = e.y + e.shapeHeight + e.vertOffset;
        const n = new ie.Point(t, s);
        const r = new ie.Point(i, o);
        return (0, ie.box)(n, r);
      }
      _drawItemShape(e, t) {
        const {
          context: i,
          horizontalPixelRatio: s,
          verticalPixelRatio: o
        } = e;
        const n = this._lineWidth(e) % 2 ? 0.5 : 0;
        const r = Math.max(1, Math.floor(s)) % 2 ? 0.5 : 0;
        const a = this._getArrowSize(t);
        let l = Math.round(a * s);
        if ((r + l) % 1 != n % 1) {
          l += 0.5;
        }
        let c = Math.round(t.shapeWidth / 2 * s);
        if ((r + c) % 1 != n % 1) {
          c += 0.5;
        }
        const h = Math.round(t.center * s) + r;
        const d = Math.round((t.y + t.vertOffset) * o) + n;
        const u = h - l;
        const _ = Math.round((t.y + t.vertOffset + a) * o) + n;
        const p = h + l;
        const m = h + c;
        const g = Math.round((t.y + t.vertOffset + a + t.shapeHeight) * o) + n;
        const f = h - c;
        i.moveTo(u, _);
        i.lineTo(h, d);
        i.lineTo(p, _);
        if (t.shapeWidth <= a * 2) {
          i.lineTo(m, _);
          this._drawCorner(e, m, g, Pe.rightDown);
          this._drawCorner(e, f, g, Pe.leftDown);
          i.lineTo(f, _);
        } else {
          this._drawCorner(e, m, _, Pe.rightUp);
          this._drawCorner(e, m, g, Pe.rightDown);
          this._drawCorner(e, f, g, Pe.leftDown);
          this._drawCorner(e, f, _, Pe.leftUp);
        }
        i.lineTo(u, _);
      }
      _getVerticalTextOffset(e) {
        return e.shapeHeight / 2 + this._getArrowSize(e);
      }
      _calcVertOffset(e) {
        if (Math.sign(e.vertOffset) >= 0) {
          return e.vertOffset;
        } else {
          return e.vertOffset - e.shapeHeight;
        }
      }
    });
    Me.set("PaneRendererLabelDown", class extends we {
      _calcBoundingBox(e) {
        const t = e.center - e.shapeWidth / 2;
        const i = e.center + e.shapeWidth / 2;
        const s = e.y - e.shapeHeight + e.vertOffset;
        const o = e.y + e.vertOffset;
        const n = new ie.Point(t, s);
        const r = new ie.Point(i, o);
        return (0, ie.box)(n, r);
      }
      _drawItemShape(e, t) {
        const {
          context: i,
          horizontalPixelRatio: s,
          verticalPixelRatio: o
        } = e;
        const n = this._lineWidth(e) % 2 ? 0.5 : 0;
        const r = Math.max(1, Math.floor(s)) % 2 ? 0.5 : 0;
        const a = this._getArrowSize(t);
        let l = Math.round(a * s);
        if ((r + l) % 1 != n % 1) {
          l += 0.5;
        }
        let c = Math.round(t.shapeWidth / 2 * s);
        if ((r + c) % 1 != n % 1) {
          c += 0.5;
        }
        const h = Math.round(t.center * s) + r;
        const d = Math.round((t.y + t.vertOffset) * o) + n;
        const u = h + l;
        const _ = Math.round((t.y + t.vertOffset - a) * o) + n;
        const p = h - l;
        const m = h + c;
        const g = Math.round((t.y + t.vertOffset - t.shapeHeight - a) * o) + n;
        const f = h - c;
        i.moveTo(u, _);
        i.lineTo(h, d);
        i.lineTo(p, _);
        if (t.shapeWidth <= a * 2) {
          i.lineTo(f, _);
          this._drawCorner(e, f, g, Pe.leftUp);
          this._drawCorner(e, m, g, Pe.rightUp);
          i.lineTo(m, _);
        } else {
          this._drawCorner(e, f, _, Pe.leftDown);
          this._drawCorner(e, f, g, Pe.leftUp);
          this._drawCorner(e, m, g, Pe.rightUp);
          this._drawCorner(e, m, _, Pe.rightDown);
        }
        i.lineTo(u, _);
      }
      _getVerticalTextOffset(e) {
        return -e.shapeHeight / 2 - this._getArrowSize(e);
      }
      _calcVertOffset(e) {
        if (Math.sign(e.vertOffset) <= 0) {
          return e.vertOffset;
        } else {
          return e.vertOffset + e.shapeHeight;
        }
      }
    });
    Me.set("PaneRendererSquare", class extends ve {
      _drawItemShape(e, t) {
        const {
          context: i,
          horizontalPixelRatio: s,
          verticalPixelRatio: o
        } = e;
        const n = Math.max(1, Math.floor(s)) % 2 ? 0.5 : 0;
        const r = this._lineWidth(e) % 2 ? 0.5 : 0;
        let a = Math.round(t.height / 2 * o);
        if ((n + a) % 1 != r % 1) {
          a += 0.5;
        }
        const l = Math.round(t.center * s) + n;
        const c = Math.round((t.y + t.vertOffset) * o) + n;
        const h = l - a;
        const d = c - a;
        const u = l + a;
        const _ = c + a;
        i.rect(h, d, u - h, _ - d);
      }
      _calcBoundingBox(e) {
        const t = e.height;
        const i = Math.round(t / 2);
        const s = e.center - i;
        const o = e.vertOffset;
        const n = e.y + o - i;
        const r = s;
        const a = s + t;
        const l = n;
        const c = n + t;
        const h = new ie.Point(r, l);
        const d = new ie.Point(a, c);
        let u = (0, ie.box)(h, d);
        const _ = super._calcBoundingBox(e);
        if (_) {
          u = this._unionBox(u, _);
        }
        return u;
      }
    });
    Me.set("PaneRendererTriangleApexUp", class extends Te {
      _drawItemShape(e, t) {
        const {
          context: i,
          horizontalPixelRatio: s,
          verticalPixelRatio: o
        } = e;
        const n = t.width;
        const r = t.height;
        const a = Math.round(r / 3);
        const l = t.vertOffset - a * 2;
        const c = this._lineWidth(e) % 2 ? 0.5 : 0;
        const h = Math.max(1, Math.floor(s));
        const d = h % 2 ? 0.5 : 0;
        let u = Math.round(n * s);
        if (u % 2 != h % 2) {
          u += 1;
        }
        const _ = Math.round(t.center * s) + d;
        const p = Math.round((t.y + l) * o);
        const m = _ + u / 2;
        const g = Math.round((t.y + l + r) * o) + c;
        const f = _ - u / 2;
        i.moveTo(_, p);
        i.lineTo(m, g);
        i.lineTo(f, g);
        i.lineTo(_, p);
      }
    });
    Me.set("PaneRendererTriangleApexDown", class extends Te {
      _drawItemShape(e, t) {
        const {
          context: i,
          horizontalPixelRatio: s,
          verticalPixelRatio: o
        } = e;
        const n = t.width;
        const r = t.height;
        const a = Math.round(r / 3);
        const l = t.vertOffset - a;
        const c = this._lineWidth(e) % 2 ? 0.5 : 0;
        const h = Math.max(1, Math.floor(s));
        const d = h % 2 ? 0.5 : 0;
        let u = Math.round(n * s);
        if (u % 2 != h % 2) {
          u += 1;
        }
        const _ = Math.round(t.center * s) + d;
        const p = Math.round((t.y + l) * o) + c;
        const m = _ + u / 2;
        const g = Math.round((t.y + l + r) * o);
        const f = _ - u / 2;
        i.moveTo(f, p);
        i.lineTo(m, p);
        i.lineTo(_, g);
        i.lineTo(f, p);
      }
    });
    Me.set("PaneRendererXCross", class extends ye {
      _drawItemShapeUsingCSSPixels(e, t) {
        const i = t.width;
        const s = t.height;
        const o = t.center - i / 2;
        const n = t.vertOffset;
        const r = t.y - s / 2 + n;
        e.moveTo(o, r);
        e.lineTo(o + i, r + s);
        e.moveTo(o, r + s);
        e.lineTo(o + i, r);
      }
      _calcBoundingBox(e) {
        const t = e.width;
        const i = e.height;
        const s = e.center - t / 2;
        const o = e.vertOffset;
        const n = e.y - i / 2 + o;
        const r = s;
        const a = s + t;
        const l = n;
        const c = n + i;
        const h = new ie.Point(r, l);
        const d = new ie.Point(a, c);
        let u = (0, ie.box)(h, d);
        const _ = super._calcBoundingBox(e);
        if (_) {
          u = this._unionBox(u, _);
        }
        return u;
      }
    });
    class Ae extends Ie.StudyPaneViewInplaceUpdatable {
      constructor(e, t, i, s) {
        super(t, i, s);
        this._renderer = null;
        this._shapesRenderer = null;
        this._selectionRenderer = null;
        this._isMarkersEnabled = H.enabled("source_selection_markers");
        this._study = e;
        const o = e.metaInfo().plots;
        for (let e = 0; e < o.length; e++) {
          if (o[e].id === this._plotName) {
            this._plotIndex = e;
            break;
          }
        }
        this._plotStyleInfo = (0, r.ensureDefined)(e.metaInfo().styles?.[this._plotName]);
        this._colorProvider = (0, G.createStudyPlotColorProvider)(e.metaInfo(), e.properties(), s);
        this._selectionIndexer = new Q.SelectionIndexes(i.timeScale());
      }
      items() {
        return this._items;
      }
      renderer() {
        if (this._isPlotVisible() && this._scalesReady()) {
          this._makeSureRendererIsValid();
          return this._renderer;
        } else {
          return null;
        }
      }
      _isPlotVisible() {
        return this._study.isPlotVisibleAt(this._plotName, 1);
      }
      _scalesReady() {
        const e = this._model.timeScale();
        const t = this._priceScale();
        return e && t !== null && !e.isEmpty() && !t.isEmpty();
      }
      _updateImplFull(e) {
        if (this._dataInvalidated?.clearData) {
          this._items = [];
          this._renderer = null;
        }
        if (!this._scalesReady()) {
          return false;
        }
        const t = this._model.timeScale();
        const i = this._priceScale();
        const s = t.visibleBarsStrictRange();
        if (s === null || i === null) {
          return false;
        }
        const o = this._study.plots().plottableRange(false);
        if (o.size() === 0) {
          return false;
        }
        const n = this._study.offset(this._plotName);
        const a = this._study.firstValue(undefined, this.isForceOverlay());
        if (a === null) {
          return false;
        }
        this._updateAdditionalPrices(i, a);
        const {
          hiPlot: l,
          loPlot: c
        } = this._hiLoPlots();
        const h = this._preallocateItems(o, (e, t) => this._createItem(e, t ?? null, l, c, n));
        let d = this._series.nearestIndex(s.firstBar(), b.PlotRowSearchMode.NearestRight);
        let u = this._series.nearestIndex(s.lastBar(), b.PlotRowSearchMode.NearestLeft);
        if (d === undefined || u === undefined) {
          return false;
        }
        if (n > 0) {
          d -= n;
          u += n;
        } else {
          d += n;
          u -= n;
        }
        const _ = this._study.getMinFirstBarIndexForPlot(this._plotName);
        if (_ > u) {
          return true;
        }
        d = Math.max(_, d);
        const p = this._getTranspValue();
        const m = this._study.properties().childs().styles.childs()[this._plotName].childs();
        const g = m.color.value();
        const f = m.textColor ? m.textColor.value() : undefined;
        const y = g;
        const v = g;
        const S = f === undefined ? undefined : f;
        const w = (0, r.ensureNotNull)(this._plotIndex);
        const C = (0, te.createEmptyStyle)();
        const P = h ?? (0, r.ensureNotNull)(o.firstIndex());
        const T = o.rangeIterator(P, (0, r.ensureNotNull)(o.lastIndex()) + 1);
        let x = (0, xe.lowerbound)(this._items, P + n, (e, t) => e.timePointIndex < t);
        for (const e of T) {
          const t = e.value;
          const i = t[w + 1];
          if (i == null) {
            x++;
            continue;
          }
          const s = this._items[x];
          if (!isNaN(s.origPrices.price)) {
            if (this._colorProvider.isColorDefined()) {
              s.style = {
                color: y,
                borderColor: v,
                textColor: S
              };
              const e = this._colorProvider.getPlotPointStyle(t, C);
              this._fillItemWithPointStyle(s, e, p);
            }
          }
          x++;
        }
        this._updateImplLight();
        return true;
      }
      _fillItemWithPointStyle(e, t, i) {
        const s = (0, r.ensureDefined)(e.style);
        if (t.colors[0] !== undefined) {
          s.color = (0, _.generateColor)((0, r.ensureDefined)(t.colors[0]), i);
          const e = i > 9 ? i - 10 : 0;
          s.borderColor = (0, _.generateColor)(s.color, e);
        }
        if (t.colors[2] !== undefined) {
          s.textColor = (0, _.generateColor)((0, r.ensureDefined)(t.colors[2]), i);
        }
      }
      _updateRenderer(e, t) {
        this._makeSureRendererIsValid();
        const i = this._model.timeScale();
        const s = {};
        const o = this._getTranspValue();
        const n = i.barSpacing();
        const r = this._calculateShapeHeight(n);
        const a = this._study.properties().childs().styles.childs()[this._plotName].childs();
        const l = a.location.value();
        const c = this._calculateVerticalOffset(l, r + r / 2);
        s.barSpacing = n;
        s.items = this._items;
        s.color = (0, _.generateColor)(a.color.value(), o);
        s.height = r;
        s.vertOffset = c;
        s.visibleItemsRange = {
          startItemIndex: e,
          endItemIndex: t
        };
        const h = a.plottype.value();
        const d = X.plotShapesData[h];
        const u = new z.CompositeRenderer();
        if (d) {
          if (this._shapesRenderer) {
            this._shapesRenderer.setData(s);
          } else {
            this._shapesRenderer = this._createRenderer(d.paneRendererClass, s);
            u.append(this._shapesRenderer);
          }
        }
        if (this._model.selection().isSelected(this._study) && this._isMarkersEnabled && this._selectionData !== null) {
          this._selectionData.vertOffset = c;
          u.append(new Z.SelectionRenderer(this._selectionData));
        }
        this._renderer = u;
      }
      _createRenderer(e, t) {
        const i = Me.get(e);
        return new ((0, r.ensureDefined)(i))(t);
      }
      _getSeriesVal(e, t) {
        const i = (0, ee.barFunction)(e);
        const s = this._series.data().valueAt(t);
        if (s === null) {
          return null;
        } else {
          return i(s);
        }
      }
      _getTranspValue() {
        let e = 0;
        const t = this._study.properties().childs();
        if (t.transparency) {
          e = t.transparency.value();
          e = (0, R.isNumber)(e) ? e : 50;
        }
        const i = t.styles.childs()[this._plotName].childs();
        if (i.transparency) {
          e = i.transparency.value();
          e = (0, R.isNumber)(e) ? e : 50;
        }
        return (0, J.clamp)(e, 0, 100);
      }
      _createItem(e, t, i, s, o) {
        const n = this._study.properties().childs().styles.childs()[this._plotName].childs().location.value();
        const a = {
          origPrices: {
            price: NaN
          },
          timePointIndex: e + o
        };
        if ((t === null || t === 0) && n !== w.MarkLocation.Absolute) {
          return a;
        }
        if (t == null) {
          return a;
        }
        let l = NaN;
        switch (n) {
          case w.MarkLocation.AboveBar:
            {
              const t = this._getLocationPrice(e, i, o);
              if (t === null) {
                return a;
              }
              l = t;
              break;
            }
          case w.MarkLocation.BelowBar:
            {
              const t = this._getLocationPrice(e, s, o);
              if (t === null) {
                return a;
              }
              l = t;
              break;
            }
          case w.MarkLocation.Absolute:
            l = (0, r.ensureNotNull)(t);
            break;
          case w.MarkLocation.Top:
          case w.MarkLocation.Bottom:
            l = 0;
            break;
          default:
            throw new Error("Bad value: " + n);
        }
        return {
          y: NaN,
          origPrices: {
            price: l
          },
          timePointIndex: e + o
        };
      }
      _dependsOnSeriesData() {
        const e = this._study.properties().childs().styles.childs()[this._plotName].childs().location.value();
        return e === w.MarkLocation.AboveBar || e === w.MarkLocation.BelowBar;
      }
      _getValueForUpdating(e) {
        const t = e.value[this._plotIndex + 1];
        if (t == null) {
          return null;
        }
        const i = this._study.properties().childs().styles.childs()[this._plotName].childs().location.value();
        if (t === 0 && i !== w.MarkLocation.Absolute) {
          return null;
        }
        const s = this._study.offset(this._plotName);
        const {
          hiPlot: o,
          loPlot: n
        } = this._hiLoPlots();
        switch (i) {
          case w.MarkLocation.AboveBar:
            return this._getLocationPrice(e.index, o, s);
          case w.MarkLocation.BelowBar:
            return this._getLocationPrice(e.index, n, s);
        }
        return super._getValueForUpdating(e);
      }
      _convertItemsToCoordinates(e, t, i, s) {
        for (let e = i; e < s; e++) {
          const t = this._items[e];
          t.y = t.origPrices.price;
        }
        this._model.timeScale().fillBarBorders(this._items);
        const o = this._study.properties().childs().styles.childs()[this._plotName].childs().location.value();
        const n = e.height() * e.topMargin();
        const r = e.height() * (1 - e.bottomMargin());
        const a = e.isInverted();
        const l = a ? r : n;
        const c = a ? n : r;
        const h = e => {
          for (let t = i; t < s; t++) {
            if (!isNaN(this._items[t].y)) {
              this._items[t].y = e;
            }
          }
        };
        switch (o) {
          case w.MarkLocation.Top:
            h(l);
            break;
          case w.MarkLocation.Bottom:
            h(c);
            break;
          default:
            e.pointsArrayToCoordinates(this._items, t, {
              startItemIndex: i,
              endItemIndex: s
            });
        }
      }
      _calculateVerticalOffset(e, t) {
        let i = 0;
        switch (e) {
          case w.MarkLocation.AboveBar:
          case w.MarkLocation.Bottom:
            i = -t;
            break;
          case w.MarkLocation.BelowBar:
          case w.MarkLocation.Top:
            i = t;
        }
        if ((0, r.ensureNotNull)(this._priceScale()).isInverted()) {
          i *= -1;
        }
        return i;
      }
      _calculateShapeHeight(e, t) {
        let i = e;
        switch (t) {
          case M.PlotSymbolSize.Tiny:
            i = e * 0.3;
            break;
          case M.PlotSymbolSize.Small:
            i = e * 0.6;
            break;
          case M.PlotSymbolSize.Normal:
            i = e;
            break;
          case M.PlotSymbolSize.Large:
            i = e * 1.5;
            break;
          case M.PlotSymbolSize.Huge:
            i = e * 2;
        }
        if (typeof t == "number" && t > 0) {
          i = t;
        }
        return i;
      }
      _hiLoPlots() {
        let e;
        let t;
        let i = null;
        switch (this._series.properties().childs().style.value()) {
          case 2:
            i = "lineStyle";
            break;
          case 14:
            i = "lineWithMarkersStyle";
            break;
          case 15:
            i = "steplineStyle";
            break;
          case 3:
            i = "areaStyle";
        }
        if (i) {
          e = this._series.properties().childs()[i].childs().priceSource.value();
          t = e;
        } else {
          e = "high";
          t = "low";
        }
        return {
          hiPlot: e,
          loPlot: t
        };
      }
      _getLocationPrice(e, t, i) {
        const s = Math.min(e + i, (0, r.ensureNotNull)(this._series.data().last()).index);
        return this._getSeriesVal(t, s);
      }
    }
    class Le extends Ae {
      _updateRenderer(e, t) {
        const i = this._study.properties().childs().styles.childs()[this._plotName].childs();
        const s = this._model.timeScale();
        const o = {};
        const n = this._getTranspValue();
        const r = s.barSpacing();
        let a;
        a = this._plotStyleInfo.size ? this._calculateShapeHeight(25, this._plotStyleInfo.size) : Math.round(r / 2);
        a = Math.max(a, 1);
        const l = i.location.value();
        const c = (0, _.generateColor)(i.color.value(), n);
        const h = n > 19 ? n - 10 : 0;
        const d = this._calculateVerticalOffset(l, Math.round(a * 1.5));
        o.barSpacing = r;
        o.items = this.items();
        o.color = c;
        o.borderColor = (0, _.generateColor)(i.color.value(), h);
        o.height = a;
        o.vertOffset = d;
        o.visibleItemsRange = {
          startItemIndex: e,
          endItemIndex: t
        };
        const u = i.plottype.value();
        const p = X.plotShapesData[u];
        const m = this._plotStyleInfo.text;
        if (m !== undefined && m.trim() !== "") {
          let e = m.replace(/\\n/gm, "\n");
          e = (0, Y.cleanButAmpersand)(e, true);
          o.text = e;
          o.fontSize = 12;
          const t = i.textColor ? i.textColor.value() : undefined;
          o.textColor = t ? (0, _.generateColor)(t, n) : c;
        }
        if (this._renderer && this._shapesRenderer && this._selectionRenderer) {
          this._shapesRenderer.setData(o);
          if (this._model.selection().isSelected(this._study) && this._isMarkersEnabled && this._selectionData !== null) {
            this._selectionData.vertOffset = d;
            this._selectionRenderer.setData(this._selectionData);
          } else {
            this._selectionRenderer.setData(null);
          }
        } else {
          const e = new z.CompositeRenderer();
          this._shapesRenderer = super._createRenderer(p.paneRendererClass, o);
          e.append(this._shapesRenderer);
          this._selectionRenderer = new Z.SelectionRenderer(this._selectionData ?? undefined);
          if (this._model.selection().isSelected(this._study) && this._isMarkersEnabled && this._selectionData !== null) {
            this._selectionData.vertOffset = d;
          } else {
            this._selectionRenderer.setData(null);
          }
          e.append(this._selectionRenderer);
          this._renderer = e;
        }
      }
    }
    var ke;
    var De = i(87795);
    var Ee = i.n(De);
    var Be = i(61993);
    var Ve = i(2844);
    (function (e) {
      e[e.SimplifiedPaintingMaxFontSize = 4] = "SimplifiedPaintingMaxFontSize";
    })(ke ||= {});
    class Re extends fe {
      constructor(e, t) {
        super(null, t);
        this._textWidthCache = new Ve.TextWidthCache();
        this._fontSizeEnsured = 0;
        this._font = "";
        this._ch = "";
        if (e !== null) {
          this.setData(e);
        }
      }
      setData(e) {
        super.setData(e);
        this._fontSizeEnsured = (0, r.ensureDefined)(this._height);
        this._font = (0, le.makeFont)(this._fontSizeEnsured, e.fontFamily || me.CHART_FONT_FAMILY);
        const t = e.char.slice(0, 40);
        this._ch = Ee()(t)[0] || " ";
      }
      hitTest(e) {
        const t = (0, Be.interactionTolerance)().series + this._fontSizeEnsured / 2;
        for (const i of this._items) {
          if (new ie.Point(i.center, i.y + i.vertOffset).subtract(e).length() <= t) {
            return new re.HitTestResult(re.HitTarget.Regular);
          }
        }
        return null;
      }
      _drawItemShape(e, t) {
        const i = t.center;
        const s = t.vertOffset > 0 ? 1 : -1;
        const o = Math.trunc(this._fontSizeEnsured / 6);
        const n = t.y + t.vertOffset - s * Math.round(this._fontSizeEnsured / 2) + (s > 0 ? o : -this._fontSizeEnsured);
        let r;
        r = t.style && t.style.color !== undefined ? t.style.color : this._color;
        const {
          context: a,
          horizontalPixelRatio: l,
          verticalPixelRatio: c
        } = e;
        if (a.font !== this._font) {
          a.font = this._font;
        }
        const h = this._textWidthCache.measureText(a, this._ch);
        if (this._fontSizeEnsured <= 4 / l) {
          a.save();
          const e = Math.max(1, Math.floor(l));
          let s = Math.max(1, Math.floor(h * l));
          if (s % 2 != e % 2) {
            s += s > 1 ? -1 : 1;
          }
          const o = Math.round(n * c) + (t.vertOffset >= 0 ? 0 : -s);
          a.fillStyle = r;
          a.fillRect(Math.round(i * l) + (l % 2 ? 0.5 : 0) - s / 2, o, s, s);
          a.restore();
          return;
        }
        (0, he.drawScaled)(a, l, c, () => {
          a.fillStyle = r;
          a.textAlign = "center";
          a.textBaseline = "top";

          a.fillText(this._ch, i, n);
        });
      }
      _startPath(e, t, i) { }
      _endPath(e) { }
    }
    class Ne extends Ae {
      constructor() {
        super(...arguments);
        this._charRenderer = new Re(null);
      }
      _updateRenderer(e, t) {
        const i = this._getTranspValue();
        const s = this._model.timeScale().barSpacing();
        let o;
        const n = this._study.properties().childs().styles.childs()[this._plotName].childs();
        o = this._plotStyleInfo.size ? this._calculateShapeHeight(50, this._plotStyleInfo.size) : Math.round(s);
        const a = n.location.value();
        const l = (0, _.generateColor)(n.color.value(), i);
        const c = this._calculateVerticalOffset(a, o);
        const h = {
          items: this.items(),
          barSpacing: s,
          char: (0, r.ensureDefined)(n.char?.value() ?? this._plotStyleInfo.char),
          height: o,
          vertOffset: c,
          color: l,
          visibleItemsRange: {
            startItemIndex: e,
            endItemIndex: t
          }
        };
        const d = this._plotStyleInfo.text;
        if (d !== undefined && d.trim() !== "") {
          let e = d.replace(/\\n/gm, "\n");
          e = (0, Y.cleanButAmpersand)(e, true);
          h.text = e;
          h.fontSize = 12;
          const t = n.textColor ? n.textColor.value() : undefined;
          h.textColor = t ? (0, _.generateColor)(t, i) : l;
        }
        this._charRenderer.setData(h);
        const u = new z.CompositeRenderer();
        u.append(this._charRenderer);
        if (this._model.selection().isSelected(this._study) && this._isMarkersEnabled && this._selectionData !== null) {
          this._selectionData.vertOffset = c;
          u.append(new Z.SelectionRenderer(this._selectionData));
        }
        this._renderer = u;
      }
    }
    var Oe = i(24377);
    class Fe {
      constructor(e, t, i, s, o) {
        this.left = NaN;
        this.right = NaN;
        this.height = NaN;
        this.center = e;
        this.y = t;
        this.origHeight = i;
        this.isUp = s;
        this.origPrices = o;
        this.timePointIndex = e;
        this.style = {};
      }
    }
    function We(e) {
      return Math.round(e / 4);
    }
    function He(e) {
      return Math.round(e / 2);
    }
    class ze extends U.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = e;
      }
      hitTest(e) {
        const t = this._data;
        const i = He(t.barSpacing);
        const s = Math.round(i / 2);
        const o = Math.round(i);
        const n = We(t.barSpacing);
        const r = t.visibleItemsRange?.startItemIndex ?? 0;
        const a = t.visibleItemsRange?.endItemIndex ?? t.items.length;
        if (r >= a) {
          return null;
        }
        for (const i of t.items.slice(r, a)) {
          if (!i) {
            continue;
          }
          if (!Number.isFinite(i.center) || !Number.isFinite(i.y)) {
            continue;
          }
          const t = Math.abs(i.height);
          const r = i.isUp ? -1 : 1;
          const a = t + o;
          const l = i.y - r * n;
          const c = l - r * a;
          const h = i.center - s;
          const d = i.center + s;
          if (h < e.x && e.x < d && (i.isUp ? l < e.y && e.y < c : c < e.y && e.y < l)) {
            return new re.HitTestResult(re.HitTarget.Regular);
          }
        }
        return null;
      }
      _drawImpl(e) {
        const {
          horizontalPixelRatio: t,
          verticalPixelRatio: i,
          context: s
        } = e;
        const o = this._data;
        const n = He(o.barSpacing);
        const r = We(o.barSpacing);
        const a = n < 4;
        const l = Math.max(n / 2, 1);
        const c = (0, J.ceiledEven)(n * t);
        const h = c / 2;
        const d = Math.round(n * i);
        s.lineCap = "butt";
        s.lineWidth = Math.max(1, Math.floor(t));
        const u = s.lineWidth % 2 ? 0.5 : 0;
        const _ = o.visibleItemsRange?.startItemIndex ?? 0;
        const p = o.visibleItemsRange?.endItemIndex ?? o.items.length;
        if (!(_ >= p)) {
          for (const e of o.items.slice(_, p)) {
            if (!Number.isFinite(e.center) || !Number.isFinite(e.y)) {
              continue;
            }
            const n = e.isUp ? -1 : 1;
            const _ = Math.round(Math.abs(e.height) * i);
            const p = Math.round(e.center * t) + u;
            const m = Math.round((e.y - n * r) * i) + u;
            s.beginPath();
            s.translate(p, m);
            const g = (e.style && e.style.color) ?? (e.isUp ? o.colorup : o.colordown);
            if (a) {
              s.moveTo(0, 0);
              s.lineTo(-h, -h * n);
              s.moveTo(0, 0);
              s.lineTo(h, -h * n);
              s.moveTo(0, 0);
              s.lineTo(0, -_ * n);
              s.moveTo(-h, -_ * n);
              s.lineTo(h, -_ * n);
              s.lineWidth = l;
              s.strokeStyle = g;
              s.stroke();
            } else {
              s.moveTo(0, 0);
              if (_ < d) {
                s.lineTo(c, -_ * n);
                s.lineTo(-c, -_ * n);
              } else {
                s.lineTo(c, -d * n);
                s.lineTo(h, -d * n);
                s.lineTo(h, -_ * n);
                s.lineTo(-h, -_ * n);
                s.lineTo(-h, -d * n);
                s.lineTo(-c, -d * n);
              }
              s.lineTo(0, 0);
              s.strokeStyle = e.isUp ? o.colorBorderUp : o.colorBorderDown;
              s.stroke();
              s.fillStyle = g;
              s.fill();
            }
            s.translate(-p, -m);
          }
        }
      }
    }
    class Ue extends Ae {
      _updateRenderer(e, t) {
        const i = this._study.properties().childs().styles.childs()[this._plotName].childs();
        const s = (0, J.clamp)(this._getTranspValue(), 0, 100);
        const o = this._model.timeScale().barSpacing();
        const n = (0, _.generateColor)(i.colorup.value(), s);
        const r = (0, _.generateColor)(i.colordown.value(), s);
        const a = (0, Oe.parseRgba)(n);
        const l = a ? (1 - a[3]) * 100 : 0;
        const c = (0, Oe.parseRgba)(r);
        const h = c ? (1 - c[3]) * 100 : 0;
        const d = {
          items: this._items,
          barSpacing: o,
          colorup: n,
          colordown: r,
          colorBorderUp: (0, _.generateColor)("#000000", l),
          colorBorderDown: (0, _.generateColor)("#000000", h),
          minHeight: this._plotStyleInfo.minHeight,
          visibleItemsRange: {
            startItemIndex: e,
            endItemIndex: t
          }
        };
        this._updateItemsHeights(d);
        const u = new z.CompositeRenderer();
        u.append(new ze(d));
        if (this._model.selection().isSelected(this._study) && this._selectionData !== null) {
          u.append(new Z.SelectionRenderer({
            ...this._selectionData,
            barSpacing: o,
            withOutline: false
          }));
        }
        this._renderer = u;
      }
      _fillItemWithPointStyle(e, t, i) {
        const s = (0, r.ensureDefined)(e.style);
        if (e.isUp) {
          if (t.colors[5] !== undefined) {
            s.color = (0, _.generateColor)((0, r.ensureDefined)(t.colors[5]), i);
          } else {
            s.color = (0, _.generateColor)(this._study.properties().childs().styles.childs()[this._plotName].childs().colorup.value(), i);
          }
        } else if (t.colors[6] !== undefined) {
          s.color = (0, _.generateColor)((0, r.ensureDefined)(t.colors[6]), i);
        } else {
          s.color = (0, _.generateColor)(this._study.properties().childs().styles.childs()[this._plotName].childs().colordown.value(), i);
        }
      }
      _getValueForUpdating(e) {
        const t = e.value[this._plotIndex + 1];
        if (!t) {
          return null;
        }
        const i = e.index;
        const s = t > 0;
        const {
          hiPlot: o,
          loPlot: n
        } = this._hiLoPlots();
        const a = this._study.offset(this._plotName);
        const l = Math.min(i + a, (0, r.ensureNotNull)(this._series.data().last()).index);
        if (s) {
          const e = this._getSeriesVal(n, l);
          if (e !== null) {
            return e;
          }
        } else {
          const e = this._getSeriesVal(o, l);
          if (e !== null) {
            return e;
          }
        }
        return null;
      }
      _updateItem(e, t) {
        const i = this._getValueForUpdating(e);
        const s = e.value[this._plotIndex + 1] > 0;
        this._items[t].origPrices.price = i ?? NaN;
        this._items[t].isUp = s;
        return t + 1;
      }
      _createItem(e, t, i, s, o) {
        const n = {
          center: NaN,
          y: NaN,
          origPrices: {
            price: NaN,
            timePointIndex: NaN
          },
          origHeight: NaN,
          timePointIndex: e + o
        };
        if (!t) {
          return n;
        }
        const a = Math.min(e + o, (0, r.ensureNotNull)(this._series.data().last()).index);
        const l = t > 0;
        let c;
        if (l) {
          const e = this._getSeriesVal(s, a);
          if (e === null) {
            return n;
          }
          c = e;
        } else {
          const e = this._getSeriesVal(i, a);
          if (e === null) {
            return n;
          }
          c = e;
        }
        return new Fe(e + o, c, t, l, {
          price: c,
          timePointIndex: e + o
        });
      }
      _dependsOnSeriesData() {
        return true;
      }
      _convertItemsToCoordinates(e, t, i, s) {
        this._convertItemsToCoordinatesImpl(e, t, i, s);
      }
      _createSelectionDataPoint(e, t, i, s) {
        const o = this._model.timeScale().barSpacing();
        const n = We(o);
        const r = function (e) {
          return He(e);
        }(o);
        const a = super._createSelectionDataPoint(e, t, i, s);
        const l = this._items[(0, xe.lowerbound)(this._items, t, (e, t) => e.timePointIndex < t)];
        if (!l) {
          return a;
        }
        const c = l.isUp ? 1 : -1;
        return {
          ...a,
          point: a.point.add((0, ie.point)(0, c * (n + r)))
        };
      }
      _updateItemsHeights(e) {
        const t = this._study.properties().childs().styles.childs();
        let i = Math.abs((0, r.ensureDefined)(t[this._plotName].childs().minHeight?.value() ?? this._plotStyleInfo.minHeight));
        let s = Math.abs((0, r.ensureDefined)(t[this._plotName].childs().maxHeight?.value() ?? this._plotStyleInfo.maxHeight));
        if (i > s) {
          const e = i;
          i = s;
          s = e;
        }
        const o = this._items;
        const n = e.visibleItemsRange?.startItemIndex ?? 0;
        const a = (e.visibleItemsRange?.endItemIndex ?? o.length) - 1;
        let l = 0;
        for (let e = n; e <= a; e++) {
          const t = o[e];
          const i = Math.abs(t.origHeight);
          if (i > l) {
            l = i;
          }
        }
        const c = (s - i) / l;
        for (let e = n; e <= a; e++) {
          const t = o[e];
          const s = Math.abs(t.origHeight);
          t.height = s * c + i;
        }
      }
    }
    var je = i(59432);
    class Ge extends q.StudyForceOverlayPlotView {
      constructor(e, t, i, s) {
        super(t, i, s);
        this._bars = [];
        this._invalidated = false;
        this._isMarkersEnabled = H.enabled("source_selection_markers");
        this._selectionData = null;
        this._ohlcPlotIndexes = new Map();
        this._study = e;
        this._isMarkersEnabled = H.enabled("source_selection_markers");
        this._colorProvider = (0, G.createStudyPlotColorProvider)(e.metaInfo(), e.properties(), s);
        this._selectionIndexer = new Q.SelectionIndexes(i.timeScale());
        const o = this._study.metaInfo().plots;
        for (let e = 0; e < o.length; e++) {
          const t = o[e];
          if ("target" in t) {
            if (t.target === this._plotName) {
              if ((0, M.isOhlcOpenPlot)(t)) {
                this._ohlcPlotIndexes.set(1, e);
              }
              if ((0, M.isOhlcHighPlot)(t)) {
                this._ohlcPlotIndexes.set(2, e);
              }
              if ((0, M.isOhlcLowPlot)(t)) {
                this._ohlcPlotIndexes.set(3, e);
              }
              if ((0, M.isOhlcClosePlot)(t)) {
                this._ohlcPlotIndexes.set(4, e);
              }
            }
          }
        }
      }
      update(e) {
        if (e.type !== "hover-change") {
          this._invalidated = true;
        }
      }
      items() {
        return this._bars;
      }
      _updateImpl() {
        this._bars.length = 0;
        const e = this._priceScale();
        if (this._model.timeScale().isEmpty() || e === null || e.isEmpty()) {
          return;
        }
        const t = this._model.timeScale().visibleBarsStrictRange();
        if (t === null) {
          return;
        }
        let i = this._series.nearestIndex(t.firstBar(), b.PlotRowSearchMode.NearestRight);
        const s = this._series.nearestIndex(t.lastBar(), b.PlotRowSearchMode.NearestLeft);
        if (i === undefined || s === undefined) {
          return;
        }
        const o = this._study.getMinFirstBarIndexForPlot(this._plotName);
        if (o > s) {
          return;
        }
        i = Math.max(o, i);
        const n = this._study.data();
        const a = this._study.firstValue(undefined, this.isForceOverlay());
        if (a === null) {
          return;
        }
        const l = n.rangeIterator(i, s);
        const c = (0, r.ensureDefined)(this._study.properties().childs().ohlcPlots).childs()[this._plotName].childs();
        const h = new Map();
        const d = (e, t) => {
          const i = e + "@" + t;
          if (!h.has(i)) {
            const s = (0, _.generateColor)(e, t);
            h.set(i, s);
            return s;
          }
          return h.get(i);
        };
        const u = (0, te.createEmptyStyle)();
        for (const e of l) {
          let t = e.index;
          const i = e.value;
          t = Math.floor(t);
          let s = true;
          const o = new Map();
          for (let e = 1; e <= 4; ++e) {
            const t = this._ohlcPlotIndexes.get(e);
            if (t === undefined) {
              s = false;
              break;
            }
            const n = i[t + 1];
            if (n == null) {
              s = false;
              break;
            }
            o.set(e, n);
          }
          if (!s) {
            continue;
          }
          const n = (0, r.ensureDefined)(o.get(1));
          const a = (0, r.ensureDefined)(o.get(4));
          const l = (0, r.ensureDefined)(o.get(2));
          const h = (0, r.ensureDefined)(o.get(3));
          const _ = Math.max(n, l, h, a);
          const p = Math.min(n, l, h, a);
          let m = (0, r.ensureDefined)(d(c.color.value(), 0));
          const g = this._colorProvider.getPlotPointStyle(i, u);
          if (g.colors[0] !== undefined) {
            m = (0, r.ensureDefined)(g.colors[0]);
          }
          const f = {
            open: n,
            high: _,
            low: p,
            close: a,
            color: m,
            wickColor: g.colors[4],
            borderColor: g.colors[3],
            hollow: null,
            center: NaN,
            left: NaN,
            right: NaN,
            timePointIndex: Math.round(t)
          };
          this._bars.push(f);
        }
        e.barPricesToCoordinates(this._bars, a);
        this._model.timeScale().fillBarBorders(this._bars);
        if (this._model.selection().isSelected(this._study)) {
          const t = this._selectionIndexer.indexes();
          this._selectionData = {
            points: [],
            hittestResult: re.HitTarget.Regular,
            bgColors: [],
            visible: true,
            barSpacing: this._model.timeScale().barSpacing()
          };
          const i = (0, r.ensureNotNull)(this._model.paneForSource(this._study)).height();
          const s = (0, r.ensureDefined)(this._ohlcPlotIndexes.get(4));
          for (let o = 0; o < t.length; o++) {
            const n = t[o];
            const r = this._study.data().valueAt(n);
            if (r === null) {
              continue;
            }
            const l = r[s + 1];
            if (l == null) {
              continue;
            }
            const c = this._model.timeScale().indexToCoordinate(Math.floor(n));
            const h = e.priceToCoordinate(l, a);
            this._selectionData.points.push({
              point: new ie.Point(c, h)
            });
            this._selectionData.bgColors.push(this._model.backgroundColorAtYPercentFromTop(h / i));
          }
        } else {
          this._selectionIndexer.clear();
        }
      }
      _isOHLCPlotVisible() {
        return this._study.isPlotVisibleAt(this._plotName, 1);
      }
    }
    class qe extends Ge {
      renderer() {
        if (!this._isOHLCPlotVisible()) {
          return null;
        }
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        const e = {
          bars: this._bars,
          dontDrawOpen: this._series.properties().childs().barStyle.childs().dontDrawOpen.value(),
          thinBars: this._series.properties().childs().barStyle.childs().thinBars.value()
        };
        const t = new z.CompositeRenderer();
        t.append(new je.PaneRendererBars(e));
        if (this._model.selection().isSelected(this._study) && this._isMarkersEnabled && this._selectionData) {
          t.append(new Z.SelectionRenderer(this._selectionData));
        }
        return t;
      }
    }
    var $e = i(25201);
    class Ke extends Ge {
      renderer() {
        if (!this._isOHLCPlotVisible()) {
          return null;
        }
        const e = this._priceScale();
        if (!e || e.isEmpty()) {
          return null;
        }
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        const t = (0, r.ensureDefined)(this._study.properties().childs().ohlcPlots).childs()[this._plotName].childs();
        const i = this._model.timeScale().barSpacing();
        const s = {
          bars: this._bars,
          barSpacing: i,
          wickVisible: t.drawWick.value(),
          bodyVisible: true,
          borderVisible: t.drawBorder.value(),
          barWidth: (0, Be.optimalBarWidth)(i),
          borderColor: t.borderColor.value(),
          wickColor: t.wickColor.value(),
          isPriceScaleInverted: e.isInverted()
        };
        const o = new z.CompositeRenderer();
        o.append(new $e.PaneRendererCandles(s));
        if (this._model.selection().isSelected(this._study) && this._isMarkersEnabled && this._selectionData) {
          o.append(new Z.SelectionRenderer(this._selectionData));
        }
        return o;
      }
    }
    var Ye = i(65458);
    var Ze = i(78198);
    var Xe = i(52397);
    var Je = i(51056);
    class Qe extends Xe.HorizontalLinePaneView {
      constructor(e, t) {
        super();
        this._lineRendererData.linestyle = Je.LINESTYLE_DOTTED;
        this._study = e;
        this._plotName = t;
      }
      _updateImpl() {
        this._lineRendererData.visible = false;
        const e = this._study.properties().childs().styles.childs()[this._plotName].childs();
        if (!e.trackPrice.value() || !this._study.isPlotVisibleAt(this._plotName, 1)) {
          return;
        }
        const t = this._study.lastValueData(this._plotName, true);
        if (!t.noData) {
          this._lineRendererData.visible = true;
          this._lineRendererData.y = t.coordinate;
          this._lineRendererData.color = t.color;
          this._lineRendererData.linewidth = e.linewidth.value();
        }
      }
    }
    var et = i(46463);
    var tt = i(31599);
    var it = i(47806);
    const st = {
      type: 0,
      color: "transparent"
    };
    class ot extends it.AbstractFilledAreaPaneView {
      constructor(e, t, i, s) {
        super(e, t, i);
        this._palettesInfo = {};
        this._gradientPropsStateCache = null;
        this._rgbaFromInteger = (0, tt.rgbaFromIntegerCached)();
        const o = this._source.metaInfo();
        this._isRGB = Boolean(o.isRGB);
        this._isHlineFill = i.type === "hline_hline";
        (0, r.assert)(this._isHlineFill || i.type === "plot_plot", "Wrong filledArea type: " + i.type);
        if (this._isHlineFill) {
          this._initBandIndexes(i.objAId, i.objBId);
        }
        this._fillMetaInfo = i;
        this._fillStyleProps = s;
        this._gradientFillType = s.hasChild("fillType") && s.childs().fillType?.value() === "gradient";
        this._gradientStaticState = {
          color1: i.topColor,
          color2: i.bottomColor,
          value1: i.topValue,
          value2: i.bottomValue
        };
        this._hasAllGradientRequiredProps = this._gradientFillType && (this._gradientStaticState.color1 !== undefined || s.hasChild("topColor") || this._gradientStaticState.color2 !== undefined || s.hasChild("bottomColor")) && (this._gradientStaticState.value1 !== undefined || s.hasChild("topValue")) && (this._gradientStaticState.value2 !== undefined || s.hasChild("bottomValue"));
        const n = () => this._colorPlotIndex = this._colorPlotIndex ?? {
          type: 1
        };
        for (let t = 0; t < o.plots.length; ++t) {
          const s = o.plots[t];
          if (((0, M.isColorerPlot)(s) || (0, M.isDataPlot)(s)) && s.target === i.id) {
            if ((0, M.isColorerPlot)(s)) {
              let i;
              if (s.targetField !== undefined) {
                if (s.targetField === "topColor") {
                  n().colorIndexOrRgba1 = t;
                  i = "color1";
                } else if (s.targetField === "bottomColor") {
                  n().colorIndexOrRgba2 = t;
                  i = "color2";
                }
              } else {
                this._colorPlotIndex = {
                  type: 0,
                  colorIndexOrRgba: t
                };
              }
              if ((0, M.isPaletteColorerPlot)(s)) {
                this._palettesInfo[i ?? "color"] = {
                  map: (0, r.ensureDefined)((0, r.ensureDefined)(o.palettes)[s.palette]?.valToIndex),
                  values: e.properties().palettes[s.palette].colors
                };
              }
            } else if ((0, M.isDataPlot)(s)) {
              if (s.targetField === "topValue") {
                n().valueIndex1 = t;
              } else if (s.targetField === "bottomValue") {
                n().valueIndex2 = t;
              }
            }
            if (this._colorPlotIndex?.type === 0) {
              break;
            }
          }
        }
      }
      update(e) {
        super.update(e);
        this._gradientPropsStateCache = null;
      }
      isForceOverlay() {
        return !!this._source.metaInfo().isPlotForceOverlay(this._plotAId());
      }
      _firstValue() {
        const e = this.isForceOverlay();
        return this._source.firstValue(undefined, e);
      }
      _minFirstBarIndex() {
        return this._source.getMinFirstBarIndexForPlot(this._fillMetaInfo.id);
      }
      _getColorByPlotValue(e) {
        if (e.type === 0) {
          let t;
          if (e.colorIndexOrRgba == null) {
            return null;
          }
          if (this._isRGB) {
            t = this._rgbaFromInteger(e.colorIndexOrRgba);
          } else {
            const i = (0, r.ensureDefined)(this._palettesInfo.color);
            const s = (0, r.ensureDefined)(i.map[e.colorIndexOrRgba]);
            t = i.values[s]?.childs().color.value();
          }
          return {
            type: 0,
            color: t
          };
        }
        const t = this._gradientColorPropsState();
        let i;
        let s;
        if (this._isRGB) {
          if (e.colorIndexOrRgba1 != null) {
            i = this._rgbaFromInteger(e.colorIndexOrRgba1);
          }
          if (e.colorIndexOrRgba2 != null) {
            s = this._rgbaFromInteger(e.colorIndexOrRgba2);
          }
        } else {
          if (e.colorIndexOrRgba1 != null) {
            const t = (0, r.ensureDefined)(this._palettesInfo.color1);
            i = t.values[(0, r.ensureDefined)(t.map[e.colorIndexOrRgba1])].childs().color.value();
          }
          if (e.colorIndexOrRgba2 != null) {
            const t = (0, r.ensureDefined)(this._palettesInfo.color2);
            s = t.values[(0, r.ensureDefined)(t.map[e.colorIndexOrRgba2])].childs().color.value();
          }
        }
        const o = e.value1 ?? t.value1;
        const n = e.value2 ?? t.value2;
        i = i ?? t.color1;
        s = s ?? t.color2;
        if (o === undefined || n === undefined || i === undefined && s === undefined) {
          return null;
        } else {
          return {
            type: 1,
            color1: i,
            color2: s,
            value1: o,
            value2: n,
            coordinate1: NaN,
            coordinate2: NaN
          };
        }
      }
      _plotAId() {
        return this._fillMetaInfo.objAId;
      }
      _plotBId() {
        return this._fillMetaInfo.objBId;
      }
      _commonColor() {
        const e = this._fillStyleProps.childs();
        if (this._gradientFillType) {
          if (!this._hasAllGradientRequiredProps) {
            return st;
          }
          const e = this._gradientColorPropsState();
          return {
            type: 1,
            color1: e.color1,
            color2: e.color2,
            value1: e.value1,
            value2: e.value2,
            coordinate1: NaN,
            coordinate2: NaN
          };
        }
        return {
          type: 0,
          color: e.color.value()
        };
      }
      _transparency() {
        return this._fillStyleProps.childs().transparency?.value() ?? 0;
      }
      _visible() {
        return this._fillStyleProps.childs().visible.value();
      }
      _priceScale() {
        if (this.isForceOverlay()) {
          return this._model.mainSeries().priceScale();
        } else {
          return this._source.priceScale();
        }
      }
      _initBandIndexes(e, t) {
        this._bandAKey = null;
        this._bandBKey = null;
        const i = this._source.metaInfo().bands;
        if (i !== undefined) {
          for (let s = 0; s < i.length; ++s) {
            const o = i[s];
            if (this._bandAKey !== null || o.id !== e) {
              if (this._bandBKey === null && o.id === t) {
                this._bandBKey = s;
              }
            } else {
              this._bandAKey = s;
            }
          }
        }
      }
      _gradientColorPropsState() {
        if (this._gradientPropsStateCache === null) {
          const e = this._fillStyleProps.state();
          this._gradientPropsStateCache = {
            color1: this._gradientStaticState.color1 ?? e.topColor,
            color2: this._gradientStaticState.color2 ?? e.bottomColor,
            value1: this._gradientStaticState.value1 ?? e.topValue,
            value2: this._gradientStaticState.value2 ?? e.bottomValue
          };
        }
        return this._gradientPropsStateCache;
      }
    }
    var nt = i(22839);
    var rt = i(50600);
    class at {
      constructor(e, t) {
        this._invalidated = true;
        this._lineRenderer = new rt.HorizontalLineRenderer();
        this._source = t;
        this._points = [new ie.Point(-1, -1)];
        this._invalidated = true;
        this._properties = e;
      }
      update(e) {
        if (e.type !== "hover-change") {
          this._invalidated = true;
        }
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        const e = {
          y: this._points[0].y,
          color: this._properties.childs().color.value(),
          linewidth: this._properties.childs().linewidth.value(),
          linestyle: this._properties.childs().linestyle.value()
        };
        this._lineRenderer.setData(e);
        return this._lineRenderer;
      }
      _updateImpl() {
        const e = this._source.priceScale();
        if (!e || e.isEmpty()) {
          this._points[0] = new ie.Point(-1, -1);
          return;
        }
        const t = this._properties.childs().value.value();
        const i = this._source.firstValue();
        const s = (0, R.isNumber)(t) && i !== null ? e.priceToCoordinate(t, i) : NaN;
        this._points[0] = new ie.Point(-1, s);
      }
    }
    var lt = i(75919);
    class ct extends lt.MediaCoordinatesPaneRenderer {
      constructor() {
        super();
        this._data = null;
        this._data = null;
      }
      setData(e = null) {
        this._data = e;
      }
      hitTest() {
        return null;
      }
      _drawImpl(e) {
        if (this._data === null || this._data.points.length === 0) {
          return;
        }
        const t = e.context;
        const i = e.mediaSize.width;
        if (this._data.gradient) {
          const e = t.createLinearGradient(0, this._data.coordinate1, 0, this._data.coordinate2);
          e.addColorStop(0, this._data.backColor1 ?? "transparent");
          e.addColorStop(1, this._data.backColor2 ?? "transparent");
          t.fillStyle = e;
        } else {
          t.fillStyle = this._data.backcolor;
        }
        const s = Math.min(this._data.points[0], this._data.points[1]);
        const o = Math.max(this._data.points[0], this._data.points[1]);
        t.fillRect(0, s, i, o - s);
      }
    }
    class ht {
      constructor(e) {
        this._bandBgRenderer = new ct();
        this._invalidated = true;
        this._source = e;
      }
      update(e) {
        if (e.type !== "hover-change") {
          this._invalidated = true;
        }
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        return this._bandBgRenderer;
      }
      _updateImpl() {
        this._bandBgRenderer.setData(null);
        const e = this._source.properties().childs();
        const t = e.bands;
        if (t.childCount() < 2) {
          return;
        }
        const i = e.bandsBackground;
        if (!i?.childs().fillBackground.value()) {
          return;
        }
        const s = t[0].childs();
        const o = t[1].childs();
        const n = this._source.priceScale();
        const a = this._source.firstValue();
        if (!n || n.isEmpty() || a === null) {
          return;
        }
        const l = [n.priceToCoordinate(s.value.value(), a), n.priceToCoordinate(o.value.value(), a)];
        const c = (0, r.ensureDefined)(e.bandsBackground).childs();
        const h = (0, J.clamp)(c.transparency?.value() ?? 0, 0, 100);
        this._bandBgRenderer.setData({
          gradient: false,
          points: l,
          backcolor: (0, _.generateColor)(c.backgroundColor.value(), h)
        });
      }
    }
    class dt {
      constructor(e, t, i) {
        this._bandBgRenderer = new ct();
        this._bandAKey = null;
        this._bandBKey = null;
        this._invalidated = true;
        this._source = e;
        (0, r.assert)(t.type === "hline_hline", "Wrong filledArea type: " + t.type);
        this._initBandIndexes(t.objAId, t.objBId);
        this._fillStyleProps = i;
        this._bandBgRenderer = new ct();
        this._gradientFillType = i.hasChild("fillType") && i.childs().fillType?.value() === "gradient";
        this._gradientStaticState = {
          color1: t.topColor,
          color2: t.bottomColor,
          value1: t.topValue,
          value2: t.bottomValue
        };
      }
      update() {
        this._invalidated = true;
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        return this._bandBgRenderer;
      }
      _updateImpl() {
        this._bandBgRenderer.setData(null);
        if (!this._fillStyleProps.childs().visible.value()) {
          return;
        }
        if (this._bandAKey === null || this._bandBKey === null) {
          return;
        }
        const e = (0, r.ensureDefined)(this._source.properties().childs().bands);
        const t = e.childs()[this._bandAKey].childs();
        const i = e.childs()[this._bandBKey].childs();
        const s = this._source.priceScale();
        const o = this._source.firstValue();
        if (!s || s.isEmpty() || o === null) {
          return;
        }
        const n = [s.priceToCoordinate(t.value.value(), o), s.priceToCoordinate(i.value.value(), o)];
        const a = (0, J.clamp)(this._fillStyleProps.childs().transparency?.value() ?? 0, 0, 100);
        let l;
        const c = this._fillStyleProps.childs();
        if (this._gradientFillType) {
          const e = this._gradientStaticState;
          const t = c;
          const i = e.value1 ?? t.topValue?.value();
          const r = e.value2 ?? t.bottomValue?.value();
          if (i === undefined || r === undefined) {
            return;
          }
          const h = e.color1 ?? t.topColor?.value();
          const d = e.color2 ?? t.bottomColor?.value();
          if (h === undefined && d === undefined) {
            return;
          }
          l = {
            gradient: true,
            points: n,
            backColor1: h && (0, _.generateColor)(h, a),
            backColor2: d && (0, _.generateColor)(d, a),
            coordinate1: s.priceToCoordinate(i, o),
            coordinate2: s.priceToCoordinate(r, o)
          };
        } else {
          l = {
            gradient: false,
            points: n,
            backcolor: (0, _.generateColor)(c.color.value(), a)
          };
        }
        this._bandBgRenderer.setData(l);
      }
      _initBandIndexes(e, t) {
        this._bandAKey = null;
        this._bandBKey = null;
        (0, r.ensureDefined)(this._source.metaInfo().bands).forEach((i, s) => {
          if (this._bandAKey === null && i.id === e) {
            this._bandAKey = s;
          }
          if (this._bandBKey === null && i.id === t) {
            this._bandBKey = s;
          }
        });
      }
    }
    var ut = i(678);
    var _t = i(10892);
    var pt = i(62288);
    var mt = i(64147);
    i(88960);
    var gt = i(68805);
    var ft = i(50788);
    var yt = i(16227);
    var vt = i(37626);
    var St = i(96000);
    class bt extends St.AbstractBarColorer {
      constructor(e, t) {
        super();
        this._rgbaFromInteger = (0, tt.rgbaFromIntegerCached)();
        this._study = e;
        this._plotIndex = t;
      }
      applyBarStyle(e, t, i, s) {
        if (t) {
          return i;
        }
        const o = this._study.properties().childs();
        if (!o.visible.value()) {
          return i;
        }
        const n = this._study.metaInfo();
        const a = this._study.data();
        if (!a || a.size() === 0) {
          return i;
        }
        const l = n.plots[this._plotIndex];
        const c = this._getOffset();
        if (this._study.getMinFirstBarIndexForPlot(l.id) > e + c) {
          return i;
        }
        if (o.styles.childs()[l.id].childs().display.value() === 0) {
          return i;
        }
        const h = a.valueAt(e - c);
        if (h === null) {
          return i;
        }
        let d = h[this._plotIndex + 1];
        if (d == null) {
          return i;
        }
        d = Math.round(d);
        if (n.isRGB) {
          i.barColor = this._rgbaFromInteger(d);
          i.upColor = i.barColor;
          i.downColor = i.barColor;
        } else {
          const e = n.plots[this._plotIndex];
          if ("palette" in e) {
            const t = e.palette;
            const s = o.palettes.childs()[t];
            const a = (0, r.ensureDefined)(n.palettes?.[t]);
            const l = a.valToIndex ? (0, r.ensureDefined)(a.valToIndex[d]) : d;
            const c = s.childs().colors.childs()[l].childs().color.value();
            i.barColor = c;
            i.upColor = c;
            i.downColor = c;
          }
        }
        return i;
      }
      firstColoredBar(e) {
        let t = e;
        for (const i of this._backColorers) {
          t = Math.min(t, i.firstColoredBar(e) ?? Infinity);
        }
        const i = this._getOffset();
        t = Math.min(t, e + i);
        const s = this._getBars().firstIndex();
        const o = Math.max(t, s ?? -Infinity);
        const n = this._study.metaInfo().plots[this._plotIndex];
        return Math.max(this._study.getMinFirstBarIndexForPlot(n.id), o);
      }
      _getBars() {
        return this._study.series().bars();
      }
      _getOffset() {
        const e = this._study.metaInfo().plots[this._plotIndex];
        return this._study.offset(e.id);
      }
    }
    var wt = i(76422);
    var Ct = i(725);
    var Pt = i(82349);
    class Tt extends Ye.PanePriceAxisView {
      constructor(e, t, i, s) {
        super(e, t, i);
        this._dataSource = t;
        this._isForceOverlay = t.metaInfo().isPlotForceOverlay(s);
      }
      _position() {
        const e = this._isForceOverlay ? this._chartModel.mainPane() : this._chartModel.paneForSource(this._dataSource);
        if (e === null) {
          return null;
        }
        const t = this._isForceOverlay ? this._chartModel.mainSeries().priceScale() : this._dataSource.priceScale();
        if (t === null) {
          return null;
        }
        let i = e.priceScalePosition(t);
        if (i === "overlay") {
          i = e.priceScalePosition(e.defaultPriceScale());
        }
        if (i === "overlay") {
          return null;
        } else {
          return i;
        }
      }
    }
    var xt = i(74079);
    var It = i(7927);
    var Mt = i(29137);
    var At = i(24526);
    const Lt = (0, l.getLogger)("Chart.Study");
    const kt = a.t(null, undefined, i(14285));
    const Dt = false;
    var Et;
    var Bt;
    (function (e) {
      e.PaneViews = "study-pane-views";
    })(Et ||= {});
    (function (e) {
      e[e.DefaultPriceScale = 100] = "DefaultPriceScale";
    })(Bt ||= {});
    const Vt = {
      symbolsForDisplay: false,
      symbolsForChartApi: true,
      skipHiddenInputs: false,
      skipFakeInputs: false,
      skipBooleanInputs: H.enabled("dont_show_boolean_study_arguments"),
      asObject: true,
      skippedGroups: [],
      skippedInputs: [],
      noExchanges: false,
      noResolution: false,
      keepOptionalSymbolsEmpty: false,
      skipColorInputs: false,
      skipTimeInputs: false,
      skipOptionalEmptySymbolInputs: false,
      skipTextareaInputs: false,
      priceInputsForDisplay: false
    };
    const Rt = H.enabled("study_symbol_ticker_description");
    const Nt = H.enabled("hide_main_series_symbol_from_indicator_legend");
    const Ot = H.enabled("datasource_copypaste");
    const Ft = H.enabled("hide_unresolved_symbols_in_legend");
    function Wt(e, t) {
      const i = e.plots[t];
      if (!i || !(0, M.isOhlcPlot)(i)) {
        return false;
      }
      const s = i.target;
      const o = e.defaults.styles && e.defaults.styles[s];
      const n = e.defaults.ohlcPlots && e.defaults.ohlcPlots[s];
      const r = e.ohlcPlots && e.ohlcPlots[s];
      return o && (0, M.isOhlcPlotStyleBars)(o) || n && (0, M.isOhlcPlotStyleBars)(n) || !!r && (0, M.isOhlcPlotStyleBars)(r);
    }
    function Ht(e, t) {
      const i = e.plots[t];
      if (!i || !(0, M.isOhlcPlot)(i)) {
        return false;
      }
      const s = i.target;
      const o = e.defaults.styles && e.defaults.styles[s];
      const n = e.defaults.ohlcPlots && e.defaults.ohlcPlots[s];
      const r = e.ohlcPlots && e.ohlcPlots[s];
      return o && (0, M.isOhlcPlotStyleCandles)(o) || n && (0, M.isOhlcPlotStyleCandles)(n) || !!r && (0, M.isOhlcPlotStyleCandles)(r);
    }
    function zt(e, t) {
      (0, r.assert)(e !== undefined, "zOrder must be defined");
      (0, r.assert)(!t.has(e), "zOrder must be unique");
    }
    function Ut(e, t) {
      return e.plots.some(e => ((0, M.isColorerPlot)(e) || (0, M.isDataPlot)(e)) && e.target === t);
    }
    function jt(e, t, i) {
      let s = 0;
      let o = 0;
      return Math.sign(o) - Math.sign(s);
    }
    function Gt(e) {
      if (e.type === "inherit") {
        e.type = "price";
      }
      return e;
    }
    function qt(e, t, i, s) {
      {
        const t = (0, R.isNumber)(s) ? s : undefined;
        const o = At.customFormatters?.studyFormatterFactory?.(e, i, t) ?? null;
        if (o !== null) {
          return o;
        }
      }
      if (t !== null) {
        switch (e.type) {
          case "inherit":
          case "price":
            return new Ct.PriceFormatter({
              priceScale: t
            });
          case "volume":
            return (0, xt.getVolumeFormatter)(Math.log10(t));
          case "percent":
            return (0, xt.getPercentageFormatter)(Math.log10(t));
        }
      }
      if (e.type === "inherit") {
        return null;
      }
      const o = (0, R.isNumber)(e.precision) ? Math.pow(10, e.precision) : undefined;
      switch (e.type) {
        case "price":
          return new Ct.PriceFormatter({
            priceScale: o
          });
        case "volume":
          {
            let t = e.precision;
            if (t === undefined) {
              t = i && (0, R.isNumber)(i.volume_precision) ? i.volume_precision : 0;
            }
            return (0, xt.getVolumeFormatter)(t);
          }
        case "percent":
          return (0, xt.getPercentageFormatter)(o === undefined ? undefined : Math.log10(o));
        default:
          Lt.logWarn(`Unsupported format type: ${e.type}`);
          return null;
      }
    }
    const $t = new Set(["first_visible_bar_time", "last_visible_bar_time", "subscribeRealtime"]);
    class Kt extends g.PriceDataSource {
      constructor(e, t, i, s, o) {
        super(e);
        this._onStart = new u.Delegate();
        this._restarting = false;
        this._paneViews = [];
        this._forceOverlaysPaneViews = [];
        this._legendView = null;
        this._priceAxisViews = [];
        this._forceOverlayPriceAxisViews = [];
        this._priceAxisViewsBase = [];
        this._resolvedSymbols = {};
        this._resolvedSymbolsByInput = {};
        this._priceLinesAxisViews = [];
        this._labelPaneViews = [];
        this._forceOverlayLabelPaneViews = [];
        this._ownFirstValue = null;
        this._formatter = null;
        this._defaultFormatter = null;
        this._dataUpdated = new u.Delegate();
        this._currencySourceSymbolInputProperty = null;
        this._onHibernationStateChange = new u.Delegate();
        this._symbolsResolved = new u.Delegate();
        this._statusChanged = new u.Delegate();
        this._inputsAnchorsPaneView = null;
        this._inputsLinesPaneView = null;
        this._inputsTimeAxisPaneViews = [];
        this._inputsPriceAxisPaneViews = [];
        this._sources = [];
        this._status = {
          type: ut.StudyStatusType.Undefined
        };
        this._compileActiveStatus = null;
        this._compileErrorStatus = null;
        this._wasCompletedBefore = false;
        this._studyId = null;
        this._isSubscribedToSessionId = false;
        this._titleStrCache = {};
        this._titleInPartsCache = {};
        this._children = [];
        this._graphicsPriceAxisViews = [];
        this._plotOffsets = {};
        this._ongoingDataUpdate = Promise.resolve();
        this._studyModified = false;
        this._tagsChanged = new u.Delegate();
        this._studyName = "";
        this._turnaround = "st0";
        this._pendingResolveSymbols = new Map();
        this._onIsActualIntervalChange = new u.Delegate();
        this._childStudyByRebind = new u.Delegate();
        this._lastNonEmptyPlotRowCache = {};
        this._startMovingPoint = null;
        this._processHibernateBound = this.processHibernate.bind(this, 1);
        this._maxOffset = new mt.WatchedValue(0);
        this._currencySourceSymbolInfo = null;
        this._graphicsPriceRangeGroups = null;
        this._graphicsViewsReady = false;
        this._visibleTimeRangeInputs = null;
        this._turnaroundCounter = 0;
        this._deferredPinePatchProps = false;
        this._propertiesPatched = Promise.resolve();
        this._aboutToBeDestroyed = new u.Delegate();
        this._definitionsViewModel = null;
        this._plotFormatters = new Map();
        this._showPineVersionInStatusLine = new mt.WatchedValue(false).spawn();
        this._pineSourceCodeModel = null;
        this._onParentSourcesChanges = new u.Delegate();
        this._statusChangesSubscriber = {};
        this._calculationTime = new mt.WatchedValue(0);
        this._chartApi = e.chartApi();
        this._properties = t;
        this._metaInfo = s;
        this._hideMatches = s.inputs.filter(e => e.hideWhenPlotsHidden).map(e => ({
          id: e.id,
          plotIds: e.hideWhenPlotsHidden || []
        }));
        this._series = this._model.mainSeries();
        this._series.onIntervalChanged().subscribe(this, this._calcIsActualInterval);
        this._series.alertCreationAvailable().subscribe(this._updateAlertCreationAvailable.bind(this));
        this._showStudyArgumentsProperty = e.properties().childs().paneProperties.childs().legendProperties.childs().showStudyArguments;
        e.collapsed().subscribe(this._processHibernateBound);
        this._sources = i;
        v.StudyMetaInfo.setChildStudyMetaInfoPropertiesSourceId(s, this._sources[0]?.id(), t);
        i.forEach(e => {
          e.setChild(this);
        });
        [this._series, ...i].forEach(e => {
          e.currencyChanged().subscribe(this, this._onSourceCurrencyChanged);
          e.unitChanged().subscribe(this, this._onSourceUnitChanged);
          e.priceRangeReadyChanged().subscribe(this, this._onSourcePriceRangeReadyChanged);
          e.formatterChanged().subscribe(this, this._onSourceFormatterChanged);
          e.priceStepChanged().subscribe(this, this._onSourcePriceStepChanged);
        });
        if (Rt) {
          this._model.mainSeries().properties().childs().statusViewStyle.childs().symbolTextSource.subscribe(this, () => {
            this.invalidateTitleCache(true);
          });
        }
        const n = this._properties.childs();
        for (const e of v.StudyMetaInfo.getSourceInputIds(s)) {
          n.inputs.childs()[e]?.subscribe(this, this._onSourceInputChanged);
        }
        this._properties.subscribe(this, this._onPropertiesChanged);
        n.visible.subscribe(this, this._visibleChanged);
        n.visible.subscribe(this, () => this.processHibernate());
        n.intervalsVisibilities.subscribe(this, this._calcIsActualInterval);
        n.inputs.subscribe(this, this._updateMaxOffsetValue);
        if (n.offsets !== undefined) {
          n.offsets.subscribe(this, this._updateMaxOffsetValue);
        }
        if (n.offset !== undefined) {
          n.offset.subscribe(this, this._updateMaxOffsetValue);
        }
        this._initializeCurrencySource();
        L.hideAllIndicators().subscribe(this, this._visibleChanged);
        for (let e = 0; e < this._metaInfo.plots.length; e++) {
          const t = this._metaInfo.plots[e].id;
          const i = n.styles.childs()[t];
          i?.childs().display.subscribe(this, () => {
            this.processHibernate();
            this.invalidateTitleCache();
          });
        }
        for (const e of Object.keys(this._metaInfo.graphics)) {
          for (const t of Object.keys(this._metaInfo.graphics[e])) {
            const i = n.graphics.childs()[e]?.childs()[t];
            if (i && i.childs().visible) {
              (0, r.ensureDefined)(i.childs().visible).subscribe(this, () => this.processHibernate());
            }
          }
        }
        this._isActualInterval = (0, _t.isActualInterval)(this._series.intervalObj(), n.intervalsVisibilities);
        this._initializeStudyInputsPaneViews();
        this._handler = e => this._onData(e);
        this._valuesProvider = new T.StudyValuesProvider(this, e);
        this._graphics = new S.LiveStudyGraphics(s.graphics);
        this._chartApi = e.chartApi();
        this._invalidateLastNonEmptyPlotRowCache();
        this._data = new y.PlotList((0, Pt.studyPlotFunctionMap)(this._metaInfo), Pt.studyEmptyPlotValuePredicate);
        this._createViews();
        this._recreatePriceFormattingDependencies(this._series.symbolInfo());
        n.precision.subscribe(this, this._onFormatterPropsChanged);
        this._showStudyArgumentsProperty.subscribe(this, () => this.invalidateTitleCache(true));
        n.inputs.subscribe(this, () => this.invalidateTitleCache(true));
        if (H.enabled("update_study_formatter_on_symbol_resolve")) {
          e.mainSeries().dataEvents().symbolResolved().subscribe(this, this._recreatePriceFormattingDependencies);
        }
        e.mainSeries().dataEvents().symbolResolved().subscribe(this, () => this.invalidateTitleCache(true));
        const a = new Set();
        this._simplePlotsCount = s.plots.filter((e, t) => {
          if ((0, M.isLinePlot)(e)) {
            return true;
          }
          if ((0, M.isOhlcPlot)(e)) {
            const t = e.target;
            return !a.has(t) && (a.add(t), true);
          }
          return false;
        }).length;
        if (this.hasBarColorer()) {
          n.visible.subscribe(this, () => e.mainSeries().invalidateBarStylesCache);
        }
        this._definitionsViewModel = null;
        this._updateMaxOffsetValue();
        if (s.inputs.some(e => $t.has(e.id))) {
          this._visibleTimeRangeInputs = e.visibleRangeStudiesInputs().spawn();
          const t = this._visibleTimeRangeInputs.value();
          let i = t !== null;
          this._visibleTimeRangeInputs.subscribe(e => {
            const t = () => {
              this._onVisibleTimeRangeInputsChanged(e);
              if (i !== (e !== null)) {
                i = e !== null;
                if (!!i && !this._restarting && !this.isStarted()) {
                  this.start(true);
                }
              }
            };
            this._statusChanged.unsubscribeAll(this._statusChangesSubscriber);
            if (this._status.type === ut.StudyStatusType.Loading) {
              this._statusChanged.subscribe(this._statusChangesSubscriber, t, true);
            } else {
              t();
            }
          });
          if (t) {
            this._updateVisibleTimeRangeInputs(t, false);
          }
        }
        this._properties.setNameInOwner((0, It.propertyPathForSource)(this));
      }
      destroy() {
        this._signlePerformanceValue?.destroy();
        this._aboutToBeDestroyed.fire();
        if (this._definitionsViewModel !== null) {
          this._definitionsViewModel.destroy();
          this._definitionsViewModel = null;
        }
        this._showStudyArgumentsProperty.unsubscribeAll(this);
        this._model.mainSeries().dataEvents().symbolResolved().unsubscribeAll(this);
        this.parentSources().forEach(e => {
          e.currencyChanged().unsubscribeAll(this);
          e.unitChanged().unsubscribeAll(this);
          e.priceRangeReadyChanged().unsubscribeAll(this);
          e.formatterChanged().unsubscribeAll(this);
          e.priceStepChanged().unsubscribeAll(this);
        });
        this._series.properties().childs().statusViewStyle.childs().symbolTextSource.unsubscribeAll(this);
        this._series.onIntervalChanged().unsubscribeAll(this);
        this._series.alertCreationAvailable().unsubscribe(this._updateAlertCreationAvailable);
        this.formatterChanged().unsubscribe(this, this.invalidateTitleCache);
        L.hideAllIndicators().unsubscribe(this, this._visibleChanged);
        this._model.collapsed().unsubscribe(this._processHibernateBound);
        if (this._currencySourceSymbolInputProperty !== null) {
          this._currencySourceSymbolInputProperty.unsubscribeAll(this);
        }
        this._legendView?.destroy();
        this._pineSourceCodeModel?.get()?.destroy();
        this._pineSourceCodeModel?.destroy();
        this._visibleTimeRangeInputs?.destroy();
        this._showPineVersionInStatusLine.destroy();
        super.destroy();
      }
      setId(e) {
        super.setId(e);
        this._properties.setNameInOwner((0, It.propertyPathForSource)(this));
      }
      properties() {
        return this._properties;
      }
      propertiesPatched() {
        return this._propertiesPatched;
      }
      isDraggable() {
        return !this._metaInfo.linkedToSeries;
      }
      logs() {
        return null;
      }
      logLevelMask() {
        const e = this._properties.childs().inputs.childs().__log_level.value();
        if (!(0, R.isNumber)(e) || e < 0 || e > 7) {
          throw new Error(`Value of log level is unexpected, current value is ${e}, but expected values from 0 to 7`);
        }
        return {
          error: Boolean(e & 1),
          warning: Boolean(e & 2),
          info: Boolean(e & 4)
        };
      }
      setLogLevelMask(e) {
        const t = (Number(e.error) && 1) | (Number(e.warning) && 2) | (Number(e.info) && 4);
        this._properties.childs().inputs.childs().__log_level.setValue(t);
      }
      performance() {
        return new mt.WatchedValue(null);
      }
      profilingEnabled() {
        return !!this._properties.childs().inputs.childs().__profile?.value();
      }
      enableProfiling(e) {
        this._properties.childs().inputs.childs().__profile?.setValue(e);
      }
      onAboutToBeDestroyed() {
        return this._aboutToBeDestroyed;
      }
      priceScale(e) {
        if (e) {
          return this._model.mainSeries().priceScale();
        } else {
          return super.priceScale();
        }
      }
      lastValueData(e, t, i) {
        const s = {
          noData: true
        };
        const o = this.metaInfo().isPlotForceOverlay(e);
        const n = o ? this._model.mainSeries().priceScale() : this.priceScale();
        if (this._model.timeScale().isEmpty() || n === null || n.isEmpty() || this.data().isEmpty()) {
          return s;
        }
        const r = this._model.timeScale().visibleBarsStrictRange();
        const a = this.firstValue(true, o);
        if (r === null || a === null) {
          return s;
        }
        if (!this._properties.childs().visible.value()) {
          return s;
        }
        const l = this._properties.childs().styles;
        const c = this._properties.childs().ohlcPlots;
        let h;
        let d;
        if (l && l.childs()[e]) {
          h = l.childs()[e];
        }
        if (c && c.childs()[e]) {
          h = c.childs()[e];
        }
        if (!h || h.childs().display.value() === 0) {
          return s;
        }
        const u = this.metaInfo().plots;
        for (d = 0; d < u.length; d++) {
          const t = u[d];
          if (t.id === e || (0, M.isOhlcClosePlot)(t) && t.target === e) {
            break;
          }
        }
        const _ = d + 1;
        const p = this.offset(e);
        const m = this.nearestIndex(r.lastBar() - p, b.PlotRowSearchMode.NearestLeft, _);
        if (m === undefined) {
          return s;
        }
        const g = this._lastNonEmptyPlotRow(_);
        const f = g !== null && r.contains(g.index);
        const y = g !== null ? g.value : null;
        const v = t || f ? y : this.data().valueAt(m);
        if (!v || !(0, R.isNumber)(v[_])) {
          return s;
        }
        const S = v[_];
        const w = this._valuesProvider.getPlotColor(d, v);
        const C = n.priceToCoordinate(S, a);
        const P = this.plotFormatter(e).format(S);
        const T = {
          ...n.getFormattedValues(S, a, undefined, P),
          noData: false,
          color: w,
          floatCoordinate: C,
          coordinate: C
        };
        if (i) {
          T.price = S;
        }
        return T;
      }
      isFailed() {
        return this.status().type === ut.StudyStatusType.Error;
      }
      isLoading() {
        return this.status().type === ut.StudyStatusType.Loading;
      }
      isCompleted() {
        return this.status().type === ut.StudyStatusType.Completed;
      }
      isSymbolInvalid() {
        return this._status.type === ut.StudyStatusType.Error && this._status.errorDescription.error === kt;
      }
      series() {
        return this._series;
      }
      model() {
        return this._model;
      }
      state(e, t) {
        const i = (0, r.ensureNotNull)((0, c.getStudyClassName)(this.constructor));
        const s = this.metaInfo();
        const o = {
          type: i,
          id: this.id(),
          state: this.properties().state(),
          zorder: this.zorder(),
          ownFirstValue: this.isVisible() ? null : this._ownFirstValue,
          metaInfo: s.state()
        };
        const n = this._sources.map(e => e.id());
        if (n.length) {
          o.parentSources = n;
        }
        if (e) {
          let e = this.data();
          const t = this._model.timeScale();
          const i = this._seriesDataRangeToSave(e);
          if (i !== null) {
            e = e.range(i.firstBar(), i.lastBar());
          }
          o.data = e.state();
          o.data.symbols = this._resolvedSymbols;
          o.data.graphics = (0, S.saveStudyGraphics)(this.graphics(), t.visibleBarsStrictRange());
          o.data.plotOffsets = this._plotOffsets;
        }
        if (this.ownerSource()) {
          o.ownerSource = this.ownerSource()?.id();
        }
        for (let e = 0; e < s.inputs.length; e++) {
          if (s.inputs[e].type === "bar_time") {
            const t = s.inputs[e].id;
            const i = o.state.inputs[t];
            if (i < 0) {
              const e = this._rightOffsetToUnixTime(-i);
              o.state.inputs[t] = e && e >= 0 ? e : 0;
            }
          }
        }
        if (o.state?.inputs) {
          const e = o.metaInfo.inputs.find(e => e.name === "ILScript");
          if (e) {
            delete o.state.inputs[e.id];
          }
          delete o.state.inputs.__log_level;
          delete o.state.inputs.__profile;
        }
        const a = this.stateCustomFields();
        if (a) {
          o.customFields = a;
        }
        return o;
      }
      stateCustomFields() {
        if (this._compileErrorStatus) {
          return {
            compileErrorDescription: this._compileErrorStatus.errorDescription
          };
        }
      }
      restoreStateCustomFields(e) {
        const t = e.compileErrorDescription;
        if (t) {
          this.setErrorCompilation([(0, r.ensureDefined)(t.editorError)]);
        }
      }
      restoreData(e) {
        this._invalidateLastNonEmptyPlotRowCache();
        this.data().restoreState(e);
        this._resolvedSymbols = e.symbols ?? {};
        this._graphics = e.graphics ? (0, S.loadStudyGraphics)(e.graphics) : (0, S.emptyStudyGraphics)();
        this._postProcessGraphics();
        this._plotOffsets = e.plotOffsets ?? {};
        this._setStatus({
          type: ut.StudyStatusType.Completed
        }, true);
      }
      hasStateForAlert() {
        return false;
      }
      stateForAlert() {
        throw new Error("Not implemented");
      }
      idForAlert() {
        return super.idForAlert();
      }
      hasBarColorer() {
        return (0, r.ensureNotNull)(this._metaInfo).plots.some(M.isBarColorerPlot);
      }
      barColorer() {
        const e = this._metaInfo.plots;
        let t = null;
        for (let i = 0; i < e.length; ++i) {
          if ((0, M.isBarColorerPlot)(e[i])) {
            const e = new bt(this, i);
            if (t === null) {
              t = e;
            } else {
              t.pushBackBarColorer(e);
            }
          }
        }
        return t;
      }
      isSavedInStudyTemplates() {
        return this._metaInfo.inputs.every(e => e.type !== "bar_time");
      }
      restart(e) {
        this._restarting = true;
        this.clearData();
        if (e || H.enabled("stop_study_on_restart")) {
          this.stop();
        }
        setTimeout(this.start.bind(this), 0);
      }
      stop(e, t) {
        if (e === true && this._children) {
          for (const e of this._children) {
            e.stop(true);
          }
        }
        this._stopStudyOnServer();
        this.clearData();
        this._unsubscribeToSessionId();
        this.recalculate();
      }
      disconnect() {
        this._studyId = null;
        if (!this._model.isSnapshot()) {
          this._resolvedSymbols = {};
          this._resolvedSymbolsByInput = {};
        }
      }
      sourceId() {
        return this._studyId;
      }
      parentSources() {
        return this._sources;
      }
      symbolSource() {
        return this._firstSourceOrSeries().symbolSource();
      }
      valueAt(e, t) {
        return this.symbolSource().valueAt(e, t);
      }
      barsProvider() {
        return this._firstSourceOrSeries().barsProvider();
      }
      ownerSource() {
        if (this.isChildStudy()) {
          return this._sources[0];
        } else {
          return super.ownerSource();
        }
      }
      isChildStudy() {
        return this._sources.length > 0;
      }
      hasChildren() {
        return this._children.length > 0;
      }
      isStarted() {
        return Boolean(this._studyId);
      }
      isRestarting() {
        return this._restarting;
      }
      isActualInterval() {
        return this._isActualInterval;
      }
      onIsActualIntervalChange() {
        return this._onIsActualIntervalChange;
      }
      isVisible() {
        const e = this._properties.childs();
        if (this._model.collapsed().value() || !e.visible.value() || !this.isActualInterval()) {
          return false;
        }
        const t = this.metaInfo();
        if (t.plots.length > 0) {
          for (let i = 0; i < t.plots.length; i++) {
            const s = t.plots[i].id;
            const o = e.styles.childs()[s];
            if (o === undefined) {
              continue;
            }
            if (o.childs().display.value() !== 0) {
              return true;
            }
          }
        }
        if (t.bands) {
          for (let i = 0; i < t.bands.length; i++) {
            if (e.bands.childs()[i].childs().visible.value()) {
              return true;
            }
          }
        }
        for (const i of Object.keys(t.graphics)) {
          for (const s of Object.keys(t.graphics[i])) {
            const t = e.graphics.childs()[i]?.childs()[s];
            if (t !== undefined && (t.child("visible")?.value() ?? 1)) {
              return true;
            }
          }
        }
        if (t.filledAreas) {
          for (let i = 0; i < t.filledAreas.length; i++) {
            if (e.filledAreasStyle.childs()[t.filledAreas[i].id].childs().visible.value()) {
              return true;
            }
          }
        }
        return false;
      }
      async start(e, t, i) {
        const s = this._model.mainSeries();
        await s.seriesCreated();
        await Promise.all(this._sources.filter(e => e.isHibernated()).map(e => e.start()));
        const o = !this.isHibernationAllowed() || !!this.isVisible() || t === true;
        if (this._chartApi && this._chartApi.isConnected().value() && o) {
          try {
            await this._allSymbolsAreResolved();
            await this._startAfterSymbolsResolved(e, t);
          } catch (e) {
            const t = `ERROR: ${this._debugId()} start failed, ${e}`;
            Lt.logError(t);
            this._restarting = false;
            if (e?.cause === "TooManyStudies") {
              (0, d.showTooManyStudiesNotice)(this._chartApi.getStudyCounter());
            }
          }
        }
      }
      replaceData(e, t, i) {
        this._invalidateLastNonEmptyPlotRowCache();
        this.data().remove(e + 1);
        this.data().addTail(i, t);
      }
      inputs(e) {
        const t = (0, n.default)((0, R.clone)(Vt), e || {});
        if (t.skipOptionalEmptySymbolInputs) {
          t.keepOptionalSymbolsEmpty = true;
        }
        const i = (0, o.default)(this._buildInputs(t));
        if (t.patchSosInputs) {
          v.StudyMetaInfo.patchSoSInputs(i, e => this._sources.find(t => t.id() === e)?.sourceId() ?? null);
        }
        return i;
      }
      data() {
        return this._data;
      }
      moveData(e) {
        this._ongoingDataUpdate = this._ongoingDataUpdate.then(() => {
          this._invalidateLastNonEmptyPlotRowCache();
          this._moveData(e);
        });
      }
      plots() {
        return this.data();
      }
      metaInfo() {
        return this._metaInfo;
      }
      status() {
        return this._compileActiveStatus ?? this._compileErrorStatus ?? this._status;
      }
      name(e) {
        if (e) {
          return this.metaInfo().shortDescription || "Study";
        } else {
          return this.metaInfo().description || "Study";
        }
      }
      title(e, t, i, s, o, n) {
        s = s === undefined ? !this._showStudyArgumentsProperty.value() : s;
        const r = JSON.stringify([e, t, i, s, o, n]);
        if (this._titleStrCache[r]) {
          return this._titleStrCache[r];
        }
        if (this._titleInPartsCache[r]) {
          return this._joinTitlesParts(this._titleInPartsCache[r]);
        }
        const a = this._title(e, t, i, s, o, n);
        this._titleStrCache[r] = a;
        return a;
      }
      titleInParts(e, t, i, s, o) {
        s = s === undefined ? !this._showStudyArgumentsProperty.value() : s;
        const n = JSON.stringify([e, t, i, s, o]);
        if (this._titleInPartsCache[n]) {
          return this._titleInPartsCache[n];
        }
        const r = this._titleInParts(e, t, i, s, o);
        this._titleInPartsCache[n] = r;
        return r;
      }
      invalidateTitleCache(e) {
        this._titleStrCache = {};
        this._titleInPartsCache = {};
        if (e === true && this._children) {
          for (let t = 0; t < this._children.length; ++t) {
            this._children[t].invalidateTitleCache(e);
          }
        }
      }
      graphics() {
        return this._graphics;
      }
      graphicsInfo() {
        return this._metaInfo.graphics;
      }
      priceLabelText(e) {
        const t = this._metaInfo.styles;
        const i = this._metaInfo.ohlcPlots;
        let s;
        if (t && t[e]) {
          s = t[e];
        }
        if (i && i[e]) {
          s = i[e];
        }
        const o = (0, r.ensureDefined)(s).title;
        if (this._simplePlotsCount !== 1 || (0, M.isPlotTitleDefined)(o)) {
          if (this._metaInfo.is_price_study && o !== this._metaInfo.shortDescription) {
            if (o === "") {
              return this._metaInfo.shortDescription;
            } else {
              return this._metaInfo.shortDescription + ":" + o;
            }
          } else {
            return o;
          }
        } else {
          return this._metaInfo.shortDescription;
        }
      }
      setOwnFirstValue(e) {
        this._ownFirstValue = e;
      }
      firstValue(e, t) {
        if (t) {
          return this._series.firstValue();
        }
        if (!this.isChildStudy() && this._metaInfo.id === "Compare@tv-basicstudies" || !this._metaInfo.is_price_study) {
          const t = this._model.timeScale().visibleBarsStrictRange();
          if (t === null) {
            return null;
          }
          const i = this.properties().childs();
          if (!i.visible.value() || !this.isActualInterval() || this._startMovingPoint !== null) {
            return this._ownFirstValue;
          }
          const s = t.firstBar();
          const o = t.lastBar();
          let n = null;
          const a = (this._metaInfo.plots || []).filter(e => !this._metaInfo.isPlotForceOverlay(e.id));
          if (n === null) {
            const t = new Set();
            const l = this._metaInfo.filledAreas || [];
            for (let e = 0; e < l.length; e++) {
              const s = l[e];
              if (i.filledAreasStyle.childs()[s.id].childs().visible.value()) {
                t.add(s.objAId);
                t.add(s.objBId);
              }
            }
            for (const l of this.data().rangeIterator(s, o)) {
              const s = l.value;
              for (let o = 0; o < a.length; ++o) {
                if ((0, M.isColorerPlot)(a[o])) {
                  continue;
                }
                const l = s[o + 1];
                if (l == null) {
                  continue;
                }
                const c = a[o].id;
                if (((0, r.ensureDefined)(i.styles.childs()[c]).childs().display.value() !== 0 || t.has(c)) && (!e || !(Math.abs(l) < 1e-10))) {
                  n = l;
                  break;
                }
              }
              if (n !== null) {
                break;
              }
            }
          }
          this._ownFirstValue = n;
          if (n !== null) {
            return n;
          } else {
            return this._bandsFirstValue(e);
          }
        }
        if (this.isChildStudy()) {
          const e = this._getNonPriceParent();
          if (e && this.priceScale() === e.priceScale()) {
            if (e._ownFirstValue !== null) {
              return e._ownFirstValue;
            } else {
              return e.firstValue();
            }
          }
        }
        return this._series.firstValue();
      }
      desiredPriceScalePosition() {
        if (this.metaInfo().isTVScriptStub) {
          return "overlay";
        }
        if (this.metaInfo().linkedToSeries) {
          return "as-series";
        }
        switch (this.metaInfo().priceScale) {
          case 1:
            return "left";
          case 0:
            return "right";
          case 2:
            return "overlay";
          default:
            return null;
        }
      }
      offset(e) {
        let t = 0;
        if (this._plotOffsets && this._plotOffsets[e] !== undefined) {
          t += this._plotOffsets[e];
        }
        const i = this.properties().childs();
        const s = i.offsets?.childs()[e];
        if (s) {
          t += s.childs().val.value();
        }
        if (i.offset) {
          t += i.offset.childs().val.value();
        }
        return t;
      }
      tags() {
        if (!this._metaInfo || !this._metaInfo.description || this._metaInfo.isTVScriptStub || this._metaInfo.is_hidden_study || this._metaInfo.isTVScript && this._metaInfo.productId === "tv-scripting") {
          return [];
        } else {
          return [this._metaInfo.description];
        }
      }
      copiable() {
        return Ot && !this.isChildStudy();
      }
      setPriceScale(e) {
        super.setPriceScale(e);
        (0, wt.emit)("study_event", this.id(), "price_scale_changed");
      }
      priceRange(e, t, i) {
        let s = null;
        const o = this._metaInfo;
        const n = this._fillPrecalculatedAutoscaleInfo(e, t, i);
        let a = this.data().minMaxOnRangeCached(e, t, n.fields);
        a = (0, y.mergeMinMax)(n.baseValueMinMax, a);
        if (n.useMainSeriesRange) {
          const i = [{
            name: "low",
            offset: 0
          }, {
            name: "high",
            offset: 0
          }];
          const s = this.series().data().bars().minMaxOnRangeCached(e, t, i);
          a = (0, y.mergeMinMax)(a, s);
        }
        if (a !== null) {
          s = new f.PriceRange(a.min, a.max);
        }
        if (o.bands && i.targetPriceScale === this.priceScale()) {
          for (let e = 0; e < o.bands.length; e++) {
            const t = (0, r.ensureDefined)(this._properties.childs().bands.childs()[e]).childs();
            if (t.visible.value()) {
              const e = t.value.value();
              if (!(0, R.isNumber)(e)) {
                continue;
              }
              if (s) {
                s.apply(e, e);
              } else {
                s = new f.PriceRange(e, e);
              }
            }
          }
        }
        return this._postProcessPriceRange(s, i);
      }
      autoScaleInfo(e, t, i) {
        const s = this.priceRange(e, t, i);
        if (this.priceScale() !== this._series.priceScale()) {
          this.priceScale();
          i.targetPriceScale;
        }
        const o = {
          topPixelMargin: 0,
          bottomPixelMargin: 0
        };
        return {
          range: s,
          topPixelMargin: o.topPixelMargin,
          bottomPixelMargin: o.bottomPixelMargin
        };
      }
      formatter(e) {
        return this._formatter ?? this._firstSourceOrSeries().formatter(false);
      }
      defaultFormatter() {
        const e = this._firstSourceOrSeries();
        return this._defaultFormatter ?? e.defaultFormatter?.() ?? e.formatter();
      }
      plotFormatter(e) {
        return this._plotFormatters.get(e) ?? this.formatter();
      }
      isMultiPaneAvailable() {
        return this._metaInfo.hasForceOverlayPlots() || (0, p.hasForceOverlayPrimitives)(this._metaInfo);
      }
      isMultiPaneEnabled() {
        return this._metaInfo.hasForceOverlayPlots();
      }
      updateAllViews(e) {
        const t = this._model.paneForSource(this);
        const i = this._model.mainPane();
        const s = e.type === "viewport-change" && e.pane && e.pane !== i;
        if (e.type !== "viewport-change" || !e.pane || e.pane === t) {
          this._paneViews.forEach(t => t.update(e));
          this._labelPaneViews.forEach(t => t.update(e));
          this._dataWindowView?.update(e);
          this._legendView?.update(e);
          this._statusView?.update(e);
          this._priceAxisViews.forEach(t => t.update(e));
          this._priceLinesAxisViews.forEach(t => t.update(e));
          this._inputsLinesPaneView?.update(e);
          this._inputsAnchorsPaneView?.update(e);
          this._inputsTimeAxisPaneViews.forEach(t => t.update(e));
          this._inputsPriceAxisPaneViews.forEach(t => t.update(e));
        }
        if (!s) {
          this._forceOverlaysPaneViews.forEach(t => t.update(e));
          this._forceOverlayLabelPaneViews.forEach(t => t.update(e));
          this._forceOverlayPriceAxisViews.forEach(t => t.update(e));
        }
        if (e.type === "data-source-change" && e.sourceId === this.id() && e.clearData) {
          this._children.forEach(e => e.updateAllViews({
            type: "data-source-change",
            sourceId: e.id(),
            clearData: true
          }));
        }
      }
      removeByRemoveAllStudies() {
        return true;
      }
      getStudyName() {
        return this._studyName;
      }
      nearestIndex(e, t, i) {
        return this.data().search(e, t, i)?.index;
      }
      getMinFirstBarIndexForPlot(e) {
        const t = this._properties.childs();
        const i = this._metaInfo;
        const s = t.styles.childs()[e]?.child("showLast")?.value() ?? t.filledAreasStyle.childs()[e]?.child("showLast")?.value() ?? i.styles?.[e]?.showLast ?? t.ohlcPlots.childs()[e]?.child("showLast")?.value() ?? i.ohlcPlots?.[e]?.showLast ?? null;
        if (s === null) {
          return -Infinity;
        }
        const o = this.data().lastIndex();
        if (o === null) {
          return -Infinity;
        } else {
          return o - s + 1;
        }
      }
      guiPlotName(e, t) {
        return this._metaInfo.styles?.[t]?.title ?? this.title(e);
      }
      childStudyByRebind() {
        return this._childStudyByRebind;
      }
      isPine() {
        return this._metaInfo.pine !== undefined;
      }
      isStandardPine() {
        return this.isPine() && v.StudyMetaInfo.isStandardPine(this._metaInfo.id);
      }
      isLinkedToSeries() {
        return this._metaInfo.linkedToSeries === true;
      }
      preferredZOrder() {
        if (this._metaInfo.behind_chart === false) {
          return 0;
        } else {
          return null;
        }
      }
      defaultPlotIdForAlert() {
        if (this._metaInfo.plots.length) {
          return this._metaInfo.plots[0].id;
        } else {
          return null;
        }
      }
      resolvedSymbolInfoBySymbol(e) {
        return this._resolvedSymbols && e && this._resolvedSymbols[this._getSymbolForResolve(e)] || null;
      }
      hasPendingUnresolvedSymbols() {
        return this._pendingResolveSymbols.size > 0;
      }
      hasSymbolInputs() {
        return this._metaInfo.inputs.some(e => e.type === "symbol");
      }
      currency() {
        if (this._currencySourceSymbolInfo !== null) {
          return (0, gt.symbolCurrency)(this._currencySourceSymbolInfo);
        }
        const e = this.metaInfo();
        if (Boolean(e) && e.is_price_study) {
          return this._firstSourceOrSeries().currency();
        } else {
          return null;
        }
      }
      currencySourceSymbolInfo() {
        return this._currencySourceSymbolInfo ?? this.symbolSource()?.symbolInfo() ?? null;
      }
      unit() {
        const e = this.metaInfo();
        if (Boolean(e) && e.is_price_study) {
          return this._firstSourceOrSeries().unit();
        } else {
          return null;
        }
      }
      canOverrideMinTick() {
        return false;
      }
      dataWindowView() {
        return this._dataWindowView;
      }
      statusView() {
        return this._statusView;
      }
      legendView() {
        return this._legendView;
      }
      pineSourceCodeModel() {
        return Promise.resolve(null);
      }
      inputsForAlertState() {
        return this.inputs();
      }
      sessionId() {
        return this._firstSourceOrSeries().sessionId();
      }
      sessionIdChanged() {
        return this._firstSourceOrSeries().sessionIdChanged();
      }
      getSymbolString(e) {
        if (e === "") {
          return "";
        } else {
          return (0, D.encodeExtendedSymbolOrGetSimpleSymbolString)(this._getSymbolObject(e));
        }
      }
      onStatusChanged() {
        return this._statusChanged;
      }
      symbolsResolved() {
        return this._symbolsResolved;
      }
      onHibernationStateChange() {
        return this._onHibernationStateChange;
      }
      legendValuesProvider() {
        return new I(this, this.model());
      }
      statusProvider(e) {
        return new V.StudyStatusProvider(this);
      }
      correctScaleMargins(e) {
        if (this.metaInfo().shortId === "Volume") {
          const t = this.model().paneForSource(this);
          if (t !== null && t.isOverlay(this) && t.containsMainSeries()) {
            return {
              top: 0.75,
              bottom: 0
            };
          } else {
            return {
              top: e.top,
              bottom: 0
            };
          }
        }
        return e;
      }
      canBeHiddenByGlobalFlag() {
        return true;
      }
      isSourceHidden() {
        return !this.isVisible() || this.canBeHiddenByGlobalFlag() && L.hideAllIndicators().value();
      }
      wasCompletedBefore() {
        return this._wasCompletedBefore;
      }
      paneViews(e) {
        const t = this._model.mainPane();
        if (this.isSourceHidden()) {
          return null;
        }
        if (!e.hasPriceDataSource(this)) {
          if (e !== t) {
            return null;
          } else {
            return this._forceOverlaysPaneViews;
          }
        }
        const i = [];
        if (!this._startMovingPoint && this._wasCompletedBefore) {
          i.push(...this._paneViews.filter(e => !e.isForceOverlay?.()));
        }
        if (this._inputsLinesPaneView && (this._startMovingPoint || this._model.selection().isSelected(this))) {
          i.push(this._inputsLinesPaneView);
        }
        if (this._inputsAnchorsPaneView) {
          i.push(this._inputsAnchorsPaneView);
        }
        if (e === t) {
          i.push(...this._forceOverlaysPaneViews);
        }
        return i;
      }
      labelPaneViews(e) {
        const t = this._model.mainPane();
        if (this.isSourceHidden() || !e.hasPriceDataSource(this)) {
          if (this._metaInfo.hasForceOverlayPlots()) {
            if (e !== t) {
              return null;
            } else {
              return this._forceOverlayLabelPaneViews;
            }
          } else {
            return null;
          }
        }
        const i = [...this._labelPaneViews];
        if (e === t) {
          i.push(...this._forceOverlayLabelPaneViews);
        }
        return i;
      }
      timeAxisViews() {
        if (this._model.selection().isSelected(this)) {
          return this._inputsTimeAxisPaneViews;
        } else {
          return null;
        }
      }
      priceAxisViews(e, t) {
        if (t !== this.priceScale() && t === this._model.mainSeries().priceScale() && !e.hasDataSource(this)) {
          return this._forceOverlayPriceAxisViews;
        }
        const i = this._properties.childs().oldShowLastValue;
        if (i && !i.value()) {
          return null;
        }
        let s = this._priceAxisViews.slice();
        if (this._model.selection().isSelected(this)) {
          s = s.concat(this._inputsPriceAxisPaneViews);
        }
        if (t === this._model.mainSeries().priceScale()) {
          s = s.concat(this._forceOverlayPriceAxisViews);
        }
        return e.findTargetPriceAxisViews(this, t, s, this._priceLinesAxisViews);
      }
      movable() {
        return this._inputsAnchorsPaneView !== null;
      }
      startMoving(e, t, i, s) {
        this._startMovingPoint = e;
      }
      move(e, t, i, s) {
        if (e.logical !== undefined && this._startMovingPoint !== null) {
          if (Array.isArray(t)) {
            const i = t;
            this._updateInputValue(e.logical, i[0]);
            this._updateInputValue(e.logical, i[1]);
          } else {
            this._updateInputValue(e.logical, t);
          }
          this.updateAllViews((0, P.sourceChangeEvent)(this.id()));
        }
      }
      endMoving(e, t) {
        this._startMovingPoint = null;
        return {
          indexesChanged: false,
          pricesChanged: false
        };
      }
      clearData() {
        this._invalidateLastNonEmptyPlotRowCache();
        this._ongoingDataUpdate = this._ongoingDataUpdate.then(() => {
          this._clearData();
          if (this._graphics instanceof S.LiveStudyGraphics) {
            this._graphics?.clear();
          }
        });
        if (this.hasBarColorer()) {
          this._model.mainSeries().invalidateBarStylesCache();
        }
        this.updateAllViews((0, P.sourceChangeEvent)({
          sourceId: this.id(),
          clearData: true
        }));
      }
      convertYCoordinateToPriceForMoving(e, t) {
        const i = this.priceScale();
        if (!t || !i || i.isEmpty()) {
          return null;
        }
        const s = t.firstValue();
        if (s === null) {
          return null;
        } else {
          return i.coordinateToPrice(e, s);
        }
      }
      processHibernate(e) {
        const t = this.isVisible();
        if (!this.isStarted() && t) {
          this._sources.forEach(e => {
            e.processHibernate();
          });
          this.start(undefined, undefined, e);
          this._onHibernationStateChange.fire(false);
        }
        if (this.isHibernationAllowed() && this.isStarted() && !t) {
          for (const e of this._children) {
            e.processHibernate();
          }
          this.stop(undefined, e);
          this._onHibernationStateChange.fire(true);
        }
      }
      isHibernationAllowed() {
        return !this.metaInfo().historyCalculationMayChange && (!this.hasChildren() || !!this._model.collapsed().value() && this._children.every(e => e.isHibernationAllowed()));
      }
      isPlotVisibleAt(e, t) {
        let i;
        const s = this.metaInfo().plots.find(t => t.id === e);
        i = s !== undefined ? (0, M.isOhlcPlot)(s) ? this._properties.childs().ohlcPlots.childs()[s.target] : this._properties.childs().styles.childs()[e] : this._properties.childs().ohlcPlots.childs()[e];
        if (i === undefined) {
          throw new Error(`Study does not contain ${e} plot`);
        }
        const o = i.childs().display.value();
        return o !== null && (o & t) === t;
      }
      recalculate() {
        const e = this._model.paneForSource(this);
        this._model.recalculatePane(e, (0, P.sourceChangeEvent)(this.id()));
        this._model.updateSource(this);
      }
      maxOffset() {
        return this._maxOffset;
      }
      onStart() {
        return this._onStart;
      }
      onParentSourcesChanges() {
        return this._onParentSourcesChanges;
      }
      isHibernated() {
        return !this.isVisible() && !this.isStarted();
      }
      graphicsViewsReady() {
        return this._graphicsViewsReady;
      }
      setLoadingCompilationActive(e) {
        0;
      }
      setErrorCompilation(e) {
        0;
      }
      hasCompileError() {
        return this._compileErrorStatus !== null;
      }
      turnaround(e) {
        if (!e) {
          return this._turnaround;
        }
        return function (e, t) {
          let i = t.turnaround;
          let s = [t];
          while (s.length > 0) {
            let e = [];
            const t = [];
            s.forEach(i => {
              const s = O(i.sourceStudies).sort(N);
              if (s.length > 0) {
                e = e.concat(s);
                const i = s.map(e => e.turnaround).join("_");
                t.push(i);
              }
            });
            if (t.length) {
              i = t.join("_") + "_" + i;
            }
            s = e;
          }
          return e + "_" + i;
        }(this._series.seriesSource().turnaround(), F(this));
      }
      canHaveChildren() {
        this._canHaveChildren = this._canHaveChildren ?? v.StudyMetaInfo.canHaveChildren(this._metaInfo);
        return this._canHaveChildren;
      }
      setChild(e) {
        if (this._children.indexOf(e) === -1) {
          this._children.push(e);
        }
      }
      unsetChild(e) {
        const t = this._children.indexOf(e);
        if (~t) {
          this._children.splice(t, 1);
        }
      }
      getAllChildren() {
        const e = this._children.slice();
        for (let t = 0; t < e.length; ++t) {
          const i = e[t].getAllChildren();
          for (let t = 0; t < i.length; ++t) {
            if (!~e.indexOf(i[t])) {
              e.push(i[t]);
            }
          }
        }
        return e;
      }
      parentSourceForInput(e) {
        if (e.includes("$")) {
          const t = e.split("$")[0];
          return this._sources.find(e => e.id() === t) ?? null;
        }
        return this._series;
      }
      priceStep() {
        return this._priceStep || this._firstSourceOrSeries().priceStep(false);
      }
      recreatePriceFormatter() {
        this._recreatePriceFormattingDependencies();
      }
      setOwnerSource(e) {
        super.setOwnerSource(e);
        this._recreatePriceFormattingDependencies();
      }
      onTagsChanged() {
        return this._tagsChanged;
      }
      getPropertyDefinitionsViewModel() {
        if (this._definitionsViewModel === null) {
          return this._getPropertyDefinitionsViewModelClass().then(e => e === null || this._isDestroyed ? null : (this._definitionsViewModel === null && (this._definitionsViewModel = new e(this._model.undoModel(), this)), this._definitionsViewModel));
        } else {
          return Promise.resolve(this._definitionsViewModel);
        }
      }
      calculationTime() {
        return this._calculationTime.readonly();
      }
      _getPropertyDefinitionsViewModelClass() {
        return Promise.resolve(null);
      }
      _alertMetaInfo() {
        return this.metaInfo();
      }
      _createStudyOnServer() {
        if (this._isDestroyed) {
          return false;
        }
        const e = this._metaInfo.useVersionFromMetaInfo ? (0, v.getStudyIdWithVersion)(this._metaInfo) : this._getStudyIdWithLatestVersion();
        this._studyId = (0, E.makeNextStudyId)();
        this._incrementTurnaround();
        this._studyName = e;
        const t = (0, R.clone)((0, r.ensureDefined)(this._inputs));
        let i;
        v.StudyMetaInfo.patchSoSInputs(t, e => this._sources.find(t => t.id() === e)?.sourceId() ?? null);
        i = this._chartApi.createStudy(this._studyId, this._turnaround, this.isChildStudy() ? (0, r.ensureNotNull)(this._sources[0].sourceId()) : (0, r.ensureNotNull)(this._series.seriesSource().instanceId()), this._studyName, t, this._handler, this._studySpec());
        if (i) {
          performance.mark(`calculate_study_${this._studyId}`);
          return true;
        } else {
          this._studyId = null;
          return i;
        }
      }
      _stopStudyOnServer() {
        if (this._chartApi && this._chartApi.isConnected().value() && this.isStarted()) {
          this._chartApi.removeStudy((0, r.ensureNotNull)(this._studyId));
          this._setStatus({
            type: ut.StudyStatusType.Undefined
          });
        }
        performance.clearMarks(`calculate_study_${this._studyId}`);
        this._studyId = null;
      }
      _modifyStudyOnServer(e, t) {
        const i = (0, R.clone)((0, r.ensureDefined)(e));
        v.StudyMetaInfo.patchSoSInputs(i, e => this._sources.find(t => t.id() === e)?.sourceId() ?? null);
        this._chartApi.modifyStudy((0, r.ensureNotNull)(this._studyId), this._turnaround, i, this._handler, t);
        performance.mark(`calculate_study_${this._studyId}`);
      }
      _sendNotifyCommand(e, t) {
        this._chartApi.notifyStudy((0, r.ensureNotNull)(this._studyId), e, t);
      }
      _transformData(e) { }
      _invalidateLastNonEmptyPlotRowCache() {
        this._lastNonEmptyPlotRowCache = {};
      }
      _collectDepsForAlert() {
        throw new Error("Not implemented");
      }
      _allInputsAreValid() {
        if (this._visibleTimeRangeInputs?.value() === null) {
          return false;
        }
        for (const e of this._metaInfo.inputs) {
          if (e.type === "bar_time") {
            const t = e.id;
            if (this._properties.childs().inputs.childs()[t].value() == null) {
              return false;
            }
          }
        }
        return true;
      }
      async _startAfterSymbolsResolved(e, t) {
        await Promise.all(this._sources.map(e => !e.isStarted() || e.isRestarting() ? new Promise(t => {
          e.onStart().subscribe(this, t, true);
        }) : Promise.resolve()));
        if (!this.isStarted() || !!this._restarting) {
          this._restarting = false;
          if (this._allInputsAreValid() && !this.metaInfo().isTVScriptStub) {
            this._inputs = this._apiInputs();
            if (this._createStudyOnServer()) {
              this._subscribeToSessionId();
              this._onStart.fire();
              if (e === true && this._children) {
                await this._children.map(e => e.start(true, t));
              }
            }
          }
        }
      }
      async _changeInputsImpl(e, t) {
        const s = this._calcSources();
        const o = jt(this._metaInfo);
        const n = () => {
          for (const i of this._metaInfo.inputs) {
            if (i.type !== "source") {
              continue;
            }
            const s = e[i.id].v;
            const o = t[i.id].v;
            if (s !== o) {
              (0, r.ensureDefined)(this._properties.childs().inputs.child(i.id)).setValue(o);
            }
          }
        };
        if (this.isStarted() && this._chartApi.isConnected().value() && o > 0 && !this._chartApi.canCreateStudy(this._studySpec(true), true).success) {
          const e = window.user.pro_plan;
          createGoProDialog({
            feature: "studyOnStudy",
            actions: e && e === "pro_premium_expert" ? [{
              text: a.t(null, undefined, i(15462)),
              action: PredefinedAction.Close
            }] : undefined
          });
          n();
          return;
        }
        this._inputs = e;
        let l = false;
        const c = Object.values(W.RangeDependentStudyInputNames);
        for (const i of Object.keys(e)) {
          if (JSON.stringify(e[i]) !== JSON.stringify(t[i]) && !c.includes(i)) {
            l = true;
            break;
          }
        }
        this._incrementTurnaround();
        if (l) {
          this.disablePriceRangeReady();
        }
        try {
          await this._updateParentSources(s, o, true);
          this._modifyStudyOnServer(e, o);
          this._studyModified = true;
        } catch (e) {
          Lt.logError(`Error applying parent sources: ${e}`);
          n();
        }
        this.invalidateTitleCache();
      }
      _createPriceAxisView(e) {
        return new yt.StudyPriceAxisView(this, {
          plotIndex: e
        });
      }
      _createPriceLineAxisView(e) {
        return new vt.StudyPriceLineAxisView(this, e);
      }
      _createStudyPlotPaneView(e) {
        return new Ze.StudyPlotPaneView(this, this._series, this._model, e);
      }
      _createViews() {
        this._priceAxisViewsBase = [];
        this._forceOverlayPriceAxisViews = [];
        this._priceLinesAxisViews = [];
        this._paneViews = [];
        this._forceOverlaysPaneViews = [];
        this._labelPaneViews = [];
        this._forceOverlayLabelPaneViews = [];
        const e = new Set();
        const t = this.metaInfo();
        const i = Boolean(t.usePlotsZOrder);
        const s = new Map();
        const o = this._properties.childs();
        if (o.filledAreasStyle && t.filledAreas) {
          for (let e = 0; e < t.filledAreas.length; ++e) {
            const n = t.filledAreas[e];
            const a = (0, r.ensureDefined)(o.filledAreasStyle.childs()[n.id]);
            const l = Ut(t, n.id);
            let c;
            if (n.type === "plot_plot" || l) {
              c = new ot(this, this.model(), n, a);
            } else if (n.type === "hline_hline") {
              c = new dt(this, n, a);
            } else {
              Lt.logWarn("Unsupported filledArea type: " + n.type);
            }
            if (c !== undefined) {
              let e = false;
              if (n.type === "plot_plot") {
                e = t.isPlotForceOverlay(n.objAId);
              }
              if (e) {
                this._forceOverlaysPaneViews.push(c);
              } else {
                const e = i ? (0, r.ensureDefined)(n.zorder) : s.size;
                zt(e, s);
                s.set(e, {
                  paneViews: [c]
                });
              }
            }
          }
        }
        {
          let o = -100000;
          for (let n = 0; n < t.plots.length; n++) {
            const a = t.plots[n];
            let l;
            let c;
            let h;
            let d;
            let u;
            let _ = t.isPlotForceOverlay(a.id);
            if ((0, M.isNonVisualPlot)(a)) {
              continue;
            }
            let p = a.id;
            let m = t.styles;
            const g = (0, M.isBgColorerPlot)(a);
            if (g) {
              l = new $(this, this._series, this._model, p);
            } else if ((0, M.isShapesPlot)(a)) {
              l = new Le(this, this._series, this._model, p);
            } else if ((0, M.isCharsPlot)(a)) {
              l = new Ne(this, this._series, this._model, p);
            } else if ((0, M.isArrowsPlot)(a)) {
              l = new Ue(this, this._series, this._model, p);
            } else if ((0, M.isOhlcPlot)(a)) {
              const i = a.target;
              if (e.has(i)) {
                continue;
              }
              _ = t.isPlotForceOverlay(i);
              e.add(i);
              if (Wt(t, n)) {
                l = new qe(this, this._series, this._model, i);
              } else {
                if (!Ht(t, n)) {
                  Lt.logError(`plot ${a.id} looks to be invalid`);
                  continue;
                }
                l = new Ke(this, this._series, this._model, i);
              }
              d = this._createPriceAxisView(i);
              h = new Ye.PanePriceAxisView(d, this, this._model);
              p = i;
              m = t.ohlcPlots;
            } else if (!(0, M.isDataPlot)(a)) {
              d = this._createPriceAxisView(p);
              u = this._createPriceLineAxisView(p);
              l = this._createStudyPlotPaneView(p);
              if (this._properties.childs().styles.childs()[p]?.child("trackPrice")?.value()) {
                c = new Qe(this, p);
              }
              h = new Tt(d, this, this._model, p);
            }
            const f = i ? g ? o++ : (0, r.ensureDefined)(m?.[p]?.zorder) : s.size;
            zt(f, s);
            if (_) {
              if (d) {
                this._forceOverlayPriceAxisViews.push(d);
              }
              if (l) {
                this._forceOverlaysPaneViews.push(l);
              }
              if (h) {
                this._forceOverlayLabelPaneViews.push(h);
              }
            } else {
              const e = {
                paneViews: l !== undefined ? [l] : [],
                labelView: h,
                priceAxisView: d,
                priceLineAxisView: u
              };
              if (c !== undefined) {
                e.paneViews.push(c);
              }
              s.set(f, e);
            }
          }
        }
        (this._metaInfo.bands ?? []).forEach((e, t) => {
          const n = o.bands.childs()[t];
          if (n && n.childs().visible.value()) {
            const t = new at(n, this);
            const o = i ? (0, r.ensureDefined)(e.zorder) : s.size;
            zt(o, s);
            s.set(o, {
              paneViews: [t]
            });
          }
        });
        if (o.bandsBackground) {
          (0, r.assert)(!i, "'usePlotsZOrder' flag does not supported");
          s.set(s.size, {
            paneViews: [new ht(this)]
          });
        }
        const n = this._paneViews;
        const a = this._forceOverlaysPaneViews;
        this._createGraphicsPaneViews().then(e => {
          for (let t = 0; t < e.regularPaneViews.length; t++) {
            n.push(e.regularPaneViews[t]);
          }
          for (let t = 0; t < e.forceOverlayPaneViews.length; t++) {
            a.push(e.forceOverlayPaneViews[t]);
          }
          this._model.lightUpdate();
          this._graphicsViewsReady = true;
        });
        if (o.areaBackground) {
          (0, r.assert)(!i, "'usePlotsZOrder' flag does not supported");
          s.set(s.size, {
            paneViews: [new et.AreaBackgroundPaneView(this, this.model())]
          });
        }
        const l = Array.from(s.keys()).sort((e, t) => e - t);
        for (let e = 0; e < l.length; e++) {
          const t = (0, r.ensureDefined)(s.get(l[e]));
          this._paneViews.push(...t.paneViews);
          if (t.labelView) {
            this._labelPaneViews.push(t.labelView);
          }
          if (t.priceAxisView) {
            this._priceAxisViewsBase.push(t.priceAxisView);
          }
          if (t.priceLineAxisView) {
            this._priceLinesAxisViews.push(t.priceLineAxisView);
          }
        }
        this._dataWindowView ||= new nt.StudyDataWindowView(this, this._model);
        this._legendView ||= new A(this, this._model);
        this._statusView ||= new k.StudyStatusView(this);
        this._concatPriceAxisViews();
      }
      _onData(e) {
        switch (e.method) {
          case "study_loading":
            this._onStudyLoading(e.time);
            break;
          case "study_error":
            this._onStudyError(e.params[2]);
            break;
          case "study_completed":
            if (!this._checkTurnaround(e.params[1])) {
              return;
            }
            this._onStudyCompleted(e.time);
            break;
          case "data_update":
            if (e.params.customId !== this.sourceId() || !this._checkTurnaround(e.params.turnaround)) {
              return;
            }
            (0, r.assert)(!!e.params.nonseries, "data.params.nonseries is missing");
            this._onDataUpdate(e.params.plots, (0, r.ensureDefined)(e.params.nonseries), e.params.lastBar);
            break;
          case "clear_data":
            if (this._checkTurnaround(e.params.turnaround)) {
              this.clearData();
            }
        }
      }
      _getTelemetryObjectName() {
        return "study";
      }
      _onDataUpdated(e, t, i, s) {
        if (this.hasBarColorer() && e.length > 0) {
          const t = (0, r.ensureNotNull)(this.barColorer()).firstColoredBar(e[0].index);
          if (t !== null) {
            this._model.mainSeries().invalidateBarStylesCache(t);
          }
        }
        if (t !== null) {
          this._postProcessGraphics();
        }
        const o = this._model.paneForSource(this);
        this._model.recalculatePane(o, (0, P.sourceChangeEvent)({
          sourceId: this.id(),
          firstUpdatedTimePointIndex: s ?? undefined,
          nonSeriesOnly: e.length === 0
        }));
        this._updateSources();
      }
      _titleInputs(e, t, i) {
        return this.inputs(this._titleInputsOptions(e, t, i));
      }
      _titleInputsOptions(e, t, i) {
        return {
          symbolsForDisplay: true,
          skipHiddenInputs: true,
          skipFakeInputs: false,
          fakeInputsForDisplay: true,
          asObject: true,
          skippedGroups: [],
          skippedInputs: this._skippedTitleInputs(),
          noExchanges: t,
          noResolution: i,
          priceInputsForDisplay: true,
          skipOptionalEmptySymbolInputs: Nt,
          displayMask: e
        };
      }
      _postProcessGraphics() {
        this._graphicsPriceAxisViews = this._createGraphicsPriceAxisViews();
        this._concatPriceAxisViews();
      }
      async _createGraphicsPaneViews() {
        return (0, S.createGraphicsPaneViews)(this, this.model());
      }
      _createGraphicsPriceAxisViews() {
        return (0, S.createGraphicsPriceAxisViews)(this);
      }
      _subscribeToSessionId() {
        if (!this._isSubscribedToSessionId && this.hasSymbolInputs()) {
          this.sessionIdChanged().subscribe(this, this._onSessionIdChanged);
          this._isSubscribedToSessionId = true;
        }
      }
      _recreateFormatter(e) {
        this._recreatePlotsFormatters(e);
        this._formatter = this._tryCreateFormatter(e);
        this._defaultFormatter = this._tryCreateDefaultFormatter(e);
        this._formatterChanged.fire();
        const t = this.priceScale();
        if (t !== null) {
          t.updateFormatter();
        }
        this.getAllChildren().forEach(e => {
          e.recreatePriceFormatter();
        });
        this._model.fullUpdate();
      }
      _recreatePriceFormattingDependencies(e) {
        this._recreateFormatter(e);
        this._recreatePriceStep();
      }
      _title(e, t, i, s, o, n) {
        const r = this._titleInParts(e, t, i, s, o, n);
        return this._joinTitlesParts(r);
      }
      _postProcessPriceRange(e, t) {
        if (e && e.minValue() === e.maxValue() && !this.metaInfo().is_price_study) {
          const t = e.minValue() * 0.005;
          e = new f.PriceRange(e.minValue() - t, e.maxValue() + t);
        }
        const i = t.targetPriceScale;
        if (i && i.isLog() && e) {
          return new f.PriceRange(i.priceToLogical(e.minValue()), i.priceToLogical(e.maxValue()));
        } else {
          return e;
        }
      }
      _titleInParts(e, t, s, o, n, l) {
        const c = this.name(t);
        s = s || {};
        const h = [a.t(c, {
          context: "study"
        }, i(83477))];
        let d = [];
        if (!o) {
          const i = this._getMTFResolutionInputTitle();
          if (i !== null && i.length > 0) {
            h.push(i);
          }
          const o = this.metaInfo();
          const a = this._titleInputs((0, Mt.toInputDisplayFlags)(e), n, true);
          const c = o.inputs.filter(e => a.hasOwnProperty(e.id)).map(e => ({
            meta: e,
            value: a[e.id]
          }));
          if (c.length > 0) {
            const i = {};
            if (this.isChildStudy()) {
              for (let s = 0; s < o.inputs.length; ++s) {
                const a = o.inputs[s];
                if (!v.StudyMetaInfo.isSourceInput(a)) {
                  continue;
                }
                const c = a.id;
                const h = (0, r.ensureDefined)(this._properties.childs().inputs.child(c)).value();
                if (h.indexOf("$") >= 0) {
                  const s = this.parentSourceForInput(h);
                  if (s instanceof Kt) {
                    const o = s.metaInfo();
                    const r = s.title(e, t, {}, true, n, l);
                    if (o.plots.length === 1) {
                      i[h] = r;
                    } else {
                      const e = h.split("$")[1];
                      const t = o.plots[parseInt(e)]?.id;
                      const s = o.styles && o.styles[t];
                      const n = s && s.title || t;
                      i[h] = r + ":\u2009" + n;
                    }
                  }
                }
              }
            }
            d = c.map(({
              meta: e,
              value: t
            }) => {
              if (e.type === "time") {
                return new Date(t).toISOString();
              }
              let o = (0, R.isNumber)(t) ? (0, xt.getNumericFormatter)().format(t) : i && i[t.toString()] || t.toString();
              if (s && s[o.toString()]) {
                o = s[o.toString()];
              }
              return o;
            });
          }
        }
        return [h.join(" · "), d];
      }
      _seriesDataRangeToSave(e) {
        return this._model.timeScale().visibleExtendedDataRange(e, 0);
      }
      _getSymbolForResolve(e) {
        return this.getSymbolString(this._getSymbolForApi(e));
      }
      _getSymbolForApi(e) {
        return e;
      }
      _getSymbolObject(e) {
        const t = {
          symbol: e
        };
        const i = this.currency();
        if (this._currencySourceSymbolInputProperty !== null && this._currencySourceSymbolInfo !== null && this._getSymbolForApi(this._currencySourceSymbolInputProperty.value()) === e) {
          t["currency-id"] = i;
        }
        t.session = this.sessionId();
        return t;
      }
      _onSymbolResolved(e, t, i) {
        this._onCurrencyMayChange();
      }
      _onSymbolResolvingStart(e, t) { }
      _onSymbolError() { }
      _setStatus(e, t) {
        const i = this.isFailed();
        this._status = e;
        if (e.type === ut.StudyStatusType.Completed) {
          this._wasCompletedBefore = true;
        } else if (e.type === ut.StudyStatusType.Error || e.type === ut.StudyStatusType.Undefined) {
          this._wasCompletedBefore = false;
        }
        if (!t) {
          this._statusView?.update((0, P.sourceChangeEvent)(this.id()));
          this._model.updateSource(this);
          this._statusChanged.fire(this.status());
        }
        if (i !== this.isFailed()) {
          this._updateAlertCreationAvailable();
        }
      }
      _onPropertiesChanged() {
        if (!this._restarting) {
          if (this._inputs) {
            this._tryChangeInputs();
          } else if (this._chartApi && this._chartApi.isConnected().value()) {
            this.restart();
          }
        }
        this._recreatePaneViews();
        (0, wt.emit)("study_properties_changed", this._id.value());
      }
      _lastNonEmptyPlotRow(e) {
        if (!(0, R.isInteger)(e)) {
          Lt.logDebug("_lastNonEmptyPlotRow: incorrect plotIndex");
          return null;
        }
        let t = this._lastNonEmptyPlotRowCache[e] ?? null;
        if (t !== null) {
          return t;
        }
        t = this.data().findLast((t, i) => i[e] !== undefined, 1000);
        if (t === null) {
          return null;
        } else {
          this._lastNonEmptyPlotRowCache[e] = t;
          return t;
        }
      }
      _onCurrencyChanged() {
        if ((0, ft.currencyUnitVisibilityProperty)().value() !== "alwaysOff") {
          this._model.fullUpdate();
        }
        if (this.isStarted()) {
          this._tryChangeInputs();
        }
        this._currencyChanged.fire();
      }
      _apiInputs() {
        return this.inputs({
          keepOptionalSymbolsEmpty: true
        });
      }
      async _tryChangeInputs() {
        const e = this.isStarted() && this._chartApi.isConnected().value();
        const t = this._allInputsAreValid();
        (0, r.ensureDefined)((0, R.clone)(this._inputs));
        const i = this._apiInputs();
        const s = JSON.stringify(i);
        const o = s !== JSON.stringify(this._inputs);
        if (e && t) {
          try {
            await this._allSymbolsAreResolved();
            if (s !== JSON.stringify(this._apiInputs())) {
              return this._tryChangeInputs();
            }
            if (this._isStopped()) {
              if (o) {
                this.disablePriceRangeReady();
              }
              return;
            }
            if (o) {
              await this._changeInputsImpl(i, (0, r.ensureDefined)((0, R.clone)(this._inputs)));
            }
          } catch (e) {
            Lt.logError(`ERROR: ${this._debugId()} _tryChangeInputs: cannot modify study, ${e}`);
          }
        } else {
          if (e && !t) {
            this.stop(true);
          }
          if (!e && t) {
            this.start(true);
          }
          if (o) {
            const e = this._calcSources();
            const t = jt(this._metaInfo);
            this._updateParentSources(e, t, true);
            this._inputs = i;
          }
        }
        this._tagsChanged.fire();
      }
      _onCurrencyMayChange() {
        if (this._currencySourceSymbolInputProperty !== null) {
          const e = this.currency();
          this._updateCurrencySourceSymbolInfo();
          if (e !== this.currency()) {
            this._onCurrencyChanged();
          }
        }
      }
      _fillPrecalculatedAutoscaleInfo(e, t, i) {
        const s = this._metaInfo;
        const o = this.properties().childs();
        const n = new Set();
        const r = this._metaInfo.filledAreas || [];
        for (let e = 0; e < r.length; e++) {
          const t = r[e];
          if (o.filledAreasStyle.childs()[t.id].childs().visible.value()) {
            n.add(t.objAId);
            n.add(t.objBId);
          }
        }
        return s.plots.filter(e => !(0, M.isPlotWithTechnicalValues)(e)).filter(e => this._metaInfo.isPlotForceOverlay(e.id) ? i.targetPriceScale === this._model.mainSeries().priceScale() : i.targetPriceScale === this.priceScale() && !i.forceOverlayOnly).filter(e => n.has(e.id) || this.isPlotVisibleAt(e.id, 1)).reduce((i, s) => this._applyPlotToPrecalculatedAutoscaleInfo(e, t, i, s), {
          fields: [],
          useMainSeriesRange: false,
          baseValueMinMax: null
        });
      }
      _firstSourceOrSeries() {
        return this._sources[0] ?? this._series;
      }
      _skipHistogramBaseOnAutoScale() {
        return false;
      }
      _tryCreateFormatter(e) {
        const t = e === undefined ? this.symbolSource().symbolInfo() : e;
        return qt(this._metaInfo.format, this._priceScaleByProperties(), t, this.properties().childs().precision.value());
      }
      _tryCreateDefaultFormatter(e) {
        return this._tryCreateFormatter(e);
      }
      _mergeData(e) {
        this._invalidateLastNonEmptyPlotRowCache();
        return this.data().merge(e);
      }
      _skippedTitleInputs() {
        return this._hideMatches.filter(e => e.plotIds.every(e => this._getPlotDisplayValue(e) === 0)).map(e => e.id);
      }
      _getPlotDisplayValue(e) {
        return this.properties()?.childs()?.styles?.childs()?.[e]?.childs()?.display?.value();
      }
      _onStudyError(e) {
        performance.clearMarks(`calculate_study_${this._studyId}`);
        this._handleStudyError(this._createStudyError(e));
        this._enablePriceRangeReady();
      }
      _onStudyCompleted(e) {
        if (performance.getEntriesByName(`calculate_study_${this._studyId}`).length) {
          try {
            const e = performance.measure(`measure_study_${this._studyId}`, `calculate_study_${this._studyId}`);
            this._calculationTime.setValue(e.duration);
          } catch (e) {
            Lt.logError("Error during measuring study calculation time");
          }
          performance.clearMarks(`calculate_study_${this._studyId}`);
          performance.clearMeasures(`measure_study_${this._studyId}`);
        }
        if (this._studyModified) {
          this.clearData();
          this._studyModified = false;
        }
        this._setStatus({
          type: ut.StudyStatusType.Completed
        });
        this._statusView?.update((0, P.sourceChangeEvent)(this.id()));
        const t = this._model.paneForSource(this);
        this._model.recalculatePane(t, (0, P.sourceChangeEvent)(this.id()));
        this._updateSources();
        const i = pt.InvalidationMask.full();
        if (this._model.appliedTimeFrame().value() !== null) {
          i.lockVisibleTimeRangeOnResize();
        }
        this._model.invalidate(i);
      }
      _clearData() {
        this._data.clear();
      }
      _moveData(e) {
        this.data().move(e);
      }
      _incrementTurnaround() {
        this._turnaround = "st" + ++this._turnaroundCounter;
      }
      _checkTurnaround(e) {
        return e === this._turnaround || e === this._model.mainSeries().seriesSource().turnaround() || e === this.turnaround(true);
      }
      _updateMaxOffsetValue() {
        let e = -Infinity;
        for (const t of this._metaInfo.plots) {
          e = Math.max(this.offset(t.id), e);
        }
        this._maxOffset.setValue(e);
      }
      _rightOffsetToUnixTime(e) {
        if (this._series.bars().size() >= e) {
          const t = (0, r.ensureNotNull)(this._series.bars().lastIndex()) - e;
          return (0, r.ensureNotNull)(this._series.bars().valueAt(t))[0];
        }
        return null;
      }
      _concatPriceAxisViews() {
        this._priceAxisViews = [...this._priceAxisViewsBase, ...this._graphicsPriceAxisViews];
      }
      _onStudyLoading(e) {
        this._setStatus({
          type: ut.StudyStatusType.Loading,
          startTime: Date.now()
        });
        this._statusView?.update((0, P.sourceChangeEvent)(this.id()));
        this._model.updateSource(this);
      }
      _handleStudyError(e) {
        this.clearData();
        this._setStatus(e);
        this._statusView?.update((0, P.sourceChangeEvent)(this.id()));
        this._model.updateSource(this);
      }
      _createStudyError(e) {
        let t;
        t = (0, R.isString)(e) ? {
          error: this._getStudyErrorText(e),
          title: e.includes("study_not_auth") ? "Access error" : "Runtime error"
        } : {
          ...e,
          title: e.title ?? "Runtime error"
        };
        return (0, ut.createStudyError)(t, this.symbolSource().symbolInfo()?.exchange);
      }
      _updateSources() {
        this._model.updateSource(this);
        if (this.hasBarColorer()) {
          this._model.updateSource(this._model.mainSeries());
        }
      }
      _unsubscribeToSessionId() {
        if (this._isSubscribedToSessionId) {
          this.sessionIdChanged().unsubscribe(this, this._onSessionIdChanged);
          this._isSubscribedToSessionId = false;
        }
      }
      _onSessionIdChanged() {
        this.restart(true);
      }
      _recreatePriceStep() {
        let e = null;
        const t = this._priceScaleByProperties() ?? this._priceScaleByMetaInfo();
        if (t !== null) {
          e = 1 / t;
        }
        if (this._priceStep !== e) {
          this._priceStep = e;
          this._priceStepChanged.fire();
        }
      }
      _recreatePlotsFormatters(e) {
        this._plotFormatters.clear();
        const t = this._metaInfo.format;
        const i = this._priceScaleByProperties();
        const s = e === undefined ? this.symbolSource().symbolInfo() : e;
        for (const [e, o] of Object.entries(this._metaInfo.ohlcPlots ?? {})) {
          if (o?.format) {
            const n = qt(Gt({
              ...t,
              ...o?.format
            }), i, s, this.properties().childs().precision.value());
            if (n) {
              this._plotFormatters.set(e, n);
            }
          }
        }
        for (const [e, o] of Object.entries(this._metaInfo.styles ?? {})) {
          if (o?.format) {
            const n = qt(Gt({
              ...t,
              ...o?.format
            }), i, s, this.properties().childs().precision.value());
            if (n) {
              this._plotFormatters.set(e, n);
            }
          }
        }
        for (const e of this._metaInfo.plots) {
          if ((0, M.isOhlcPlot)(e)) {
            const t = this._plotFormatters.get(e.target);
            if (t) {
              this._plotFormatters.set(e.id, t);
            }
          }
        }
      }
      _joinTitlesParts(e) {
        const t = e[1] ? e[1].join(", ") : "";
        return e[0] + (t.length > 0 ? " (" + t + ")" : "");
      }
      _getMTFResolutionInputTitle() {
        const e = this.metaInfo();
        for (let t = 0; t < e.inputs.length; t++) {
          const i = e.inputs[t];
          if (i.type === "resolution" && i.isMTFResolution) {
            return (0, r.ensureDefined)(this._properties.childs().inputs.child(i.id)).value();
          }
        }
        return null;
      }
      _onDataUpdate(e, t, i) {
        if (this._studyModified) {
          this.clearData();
          this._studyModified = false;
        }
        const s = (0, m.unpackNonSeriesData)(t.d);
        this._ongoingDataUpdate = this._ongoingDataUpdate.then(() => s, () => s).then(this._onDataUnpacked.bind(this, e, t.indexes, i));
        return this._ongoingDataUpdate;
      }
      _allSymbolsAreResolved() {
        const e = this._inputSymbols();
        const t = [];
        let i = false;
        for (const s of e) {
          const e = this._getSymbolForResolve(s);
          if (e !== "") {
            if (this._resolvedSymbols[e]) {
              i = true;
            } else {
              const i = this._resolveSymbol(e, s);
              t.push(i);
            }
          }
        }
        if (t.length === 0) {
          const e = Promise.resolve();
          if (i) {
            return e.then(() => this._symbolsResolved.fire());
          } else {
            return e;
          }
        }
        return Promise.all(t).catch(e => {
          if (this._inputSymbols().includes(e)) {
            this.stop(true);
          }
          this._setStatus({
            type: ut.StudyStatusType.Error,
            errorDescription: {
              error: kt
            }
          });
          this._model.updateSource(this);
          return Promise.reject("Invalid symbol, " + e);
        }).then(() => {
          this._symbolsResolved.fire();
          this._recheckLineToolsActuality();
        });
      }
      _resolveSymbol(e, t) {
        if (e === "") {
          return Promise.resolve();
        }
        let i = this._pendingResolveSymbols.get(e);
        if (i === undefined) {
          i = new Promise((i, s) => {
            this._onSymbolResolvingStart(e, t);
            this._chartApi.resolveSymbol((0, E.makeNextSymbolId)(), e, o => {
              this._pendingResolveSymbols.delete(e);
              switch (o.method) {
                case "symbol_resolved":
                  {
                    this._setStatus({
                      type: ut.StudyStatusType.Undefined
                    });
                    const s = o.params[1];
                    this._resolvedSymbols[e] = s;
                    this._resolvedSymbolsByInput[t] = s;
                    this._onSymbolResolved(e, t, s);
                    this.invalidateTitleCache(true);
                    i();
                    break;
                  }
                case "symbol_error":
                  this._setStatus({
                    type: ut.StudyStatusType.Error,
                    errorDescription: {
                      error: o.params[1]
                    }
                  });
                  this._onSymbolError();
                  if (o.params[1] === B.permissionDenied && o.params[2]) {
                    if (o.params[2] !== B.SymbolErrorPermissionDeniedReason.Symbol) {
                      this._resolveSymbol(o.params[2], t).then(i);
                      return;
                    }
                    if (o.params[3]) {
                      this._resolveSymbol(o.params[3], t).then(i);
                      return;
                    }
                  }
                  0;
                  s(t);
              }
            });
          });
          this._pendingResolveSymbols.set(e, i);
        }
        return i;
      }
      _recheckLineToolsActuality() {
        const e = this._model.paneForSource(this);
        if (e !== null) {
          e.sourcesByGroup().lineSourcesForAllSymbols().forEach(e => {
            if (e.ownerSource() === this) {
              e.calcIsActualSymbol();
            }
          });
        }
      }
      _sendTelemetryCounter(e, t = this._getTelemetryAdditionalData()) {
        const i = {
          count: 1,
          additional: t
        };
        telemetry.sendChartReport(e, i);
      }
      _getTelemetryAdditionalData() {
        let e = "";
        if (this._metaInfo.pine && this._metaInfo.pine.version && this._metaInfo.shortId.indexOf("USER") >= 0) {
          e = "_v" + this._metaInfo.pine.version;
        }
        return {
          symbol: this.series().actualSymbol(),
          resolution: this.series().interval(),
          study: this._metaInfo.shortId + e
        };
      }
      _onSourceFormatterChanged() {
        if (this._formatter === null) {
          if (this._priceScale !== null) {
            this._priceScale.updateFormatter();
          }
          this._formatterChanged.fire();
        }
      }
      _onSourcePriceStepChanged() {
        if (this._priceStep === null) {
          this._priceStepChanged.fire();
        }
      }
      _bandsFirstValue(e) {
        const t = this._metaInfo;
        if (!t.bands) {
          return null;
        }
        for (let i = 0; i < t.bands.length; i++) {
          const t = (0, r.ensureDefined)(this._properties.childs().bands).childs()[i];
          if (t.childs().visible.value()) {
            const i = t.childs().value.value();
            if (e && i === 0) {
              continue;
            }
            return i;
          }
        }
        return null;
      }
      _prepareInputs(e) {
        (0, r.assert)(!!e, "options not set");
        const t = this.metaInfo();
        const i = {};
        const s = e.allowedInputTypes ? new Set(e.allowedInputTypes) : null;
        const o = !!e.asObject && !!e.useNameAndGroupAsKey;
        for (let n = 0; n < t.inputs.length; n++) {
          const a = t.inputs[n];
          if (s !== null && !s.has(a.type)) {
            continue;
          }
          if (a.isFake && e.skipFakeInputs) {
            continue;
          }
          if (a.isMTFResolution && e.noResolution) {
            continue;
          }
          if (e.displayMask !== undefined && !((0, r.ensureDefined)(a.display) & e.displayMask)) {
            continue;
          }
          if (e.skipHiddenInputs && (!e.doNotSkipHiddenWithMigrate || !a.migrate)) {
            let t = false;
            switch (a.type) {
              case "bool":
                t = e.skipBooleanInputs;
                break;
              case "color":
                t = e.skipColorInputs;
                break;
              case "time":
                t = e.skipTimeInputs;
                break;
              case "text_area":
                t = e.skipTextareaInputs;
                break;
              default:
                t = Boolean(a.isHidden);
            }
            if (t) {
              continue;
            }
          }
          if (a.groupId !== undefined && e.skippedGroups.indexOf(a.groupId) !== -1) {
            continue;
          }
          if (e.skippedInputs.indexOf(a.id) !== -1) {
            continue;
          }
          const l = this._prepareInput(a, e);
          if (a.type === "symbol" && e.skipOptionalEmptySymbolInputs && l === "") {
            continue;
          }
          let c;
          if (o) {
            c = h(a);
            if (c !== undefined && c in i) {
              c = undefined;
            }
          }
          i[c || a.id] = (0, R.clone)(l);
        }
        return i;
      }
      _prepareInputValue(e, t) {
        const i = e.id;
        const s = this._properties.childs();
        if (t.valuesAsIsFromProperties) {
          return s.inputs.childs()[i].value();
        }
        if (e.type === "symbol") {
          const o = t && t.symbolsForDisplay;
          const n = s.inputs.childs()[i].value();
          let r = o ? n : this._getSymbolForApi(n);
          let a = this._resolvedSymbols?.[this._getSymbolForResolve(r)] ?? null;
          if (r === "" && e.optional) {
            if (t && t.keepOptionalSymbolsEmpty) {
              return r;
            }
            r = this._model.mainSeries().symbol();
            a = this._model.mainSeries().symbolInfo();
          }
          if (o) {
            if (a) {
              if (Rt) {
                switch (this._model.mainSeries().symbolTextSourceProxyProperty().value()) {
                  case "description":
                    r = a.description;
                    break;
                  case "ticker-and-description":
                    r = `${a.name}, ${a.description}`;
                    break;
                  case "ticker":
                    r = a.name;
                }
              } else {
                r = (0, gt.symbolTitle)(a, t.noExchanges);
              }
            } else if (Ft) {
              r = "";
            }
          } else {
            if (a) {
              r = a.ticker || a.full_name;
            }
            if (!this.isPine() && t && t.symbolsForChartApi) {
              r = this.getSymbolString(r);
            }
          }
          return r;
        }
        if (e.type === "bar_time") {
          let e = s.inputs.childs()[i].value();
          if (e < 0) {
            const t = this._rightOffsetToUnixTime(-e);
            e = t && t >= 0 ? t : e;
          }
          return e;
        }
        if (this._metaInfo.isTVScript || this._metaInfo.pine) {
          if (i === "text") {
            return this._metaInfo.defaults.inputs?.text ?? "";
          }
          if (i === "pineId") {
            return this._metaInfo.scriptIdPart;
          }
          if (i === "pineVersion") {
            if (this._metaInfo.pine) {
              return this._metaInfo.pine.version;
            } else {
              return "-1";
            }
          }
          if (e.type === "color" && this._metaInfo.isRGB) {
            const e = s.inputs.childs()[i].value();
            return (0, _.colorToInteger)(e);
          }
          if (e.type === "price") {
            const e = s.inputs.childs()[i].value();
            if (t.priceInputsForDisplay) {
              return this.formatter().format(e);
            } else {
              return e;
            }
          }
        }
        return s.inputs.childs()[i].value();
      }
      _getAllOwnerSources() {
        const e = [];
        let t = this.ownerSource();
        while (t !== null) {
          e.push(t);
          t = t.ownerSource();
        }
        return e;
      }
      _getStudyIdWithLatestVersion() {
        return v.StudyMetaInfo.getStudyIdWithLatestVersion(this.metaInfo());
      }
      _debugId() {
        const e = [];
        if (this._studyId) {
          e.push(this._studyId);
        }
        e.push(this._metaInfo.fullId);
        e.push(this._metaInfo.description);
        return JSON.stringify({
          study: e
        });
      }
      _hasAvailableAlertPlots() {
        return false;
      }
      _hasAlertConditions() {
        return false;
      }
      _hasAlertFunction() {
        return false;
      }
      async _updateParentSources(e, t, i) {
        this._sources.forEach(e => e.unsetChild(this));
        if (i) {
          await Promise.all(e.map(e => e.isStarted() ? Promise.resolve() : e.start(false, true)));
        }
        e.forEach(e => e.setChild(this));
        this._setSources(e);
        this._recreatePriceFormattingDependencies();
        if (t !== 0 && this._sources.length <= 1) {
          const e = this._firstSourceOrSeries();
          const t = this._priceScale;
          const i = (0, r.ensureNotNull)(e.priceScale());
          if (t !== i) {
            const t = this._model.paneForSource(this);
            const s = (0, r.ensureNotNull)(this._model.paneForSource(e));
            if (t === s) {
              s.move(this, i, true);
            }
          }
        }
      }
      _calcSources() {
        const e = this._properties.childs().inputs.state();
        return v.StudyMetaInfo.getSourceIdsByInputs(this._metaInfo.inputs, e).map(e => {
          if (e === "high" || e === "open" || e === "low" || e === "close" || e === "hl2" || e === "ohl3" || e === "ohlc4") {
            return null;
          }
          return this._model.allStudies().find(t => t.canHaveChildren() && t.id() === e) ?? null;
        }).filter(R.notNull);
      }
      _isStopped() {
        return !this.isStarted();
      }
      _onDataUnpacked(e, t, i, s) {
        if (this._isDestroyed) {
          return;
        }
        if (t !== "nochange") {
          this._processPlotOffsets(s);
        }
        this._transformData(e);
        const o = this._mergeData(e);
        if (s !== null) {
          if (s.indexes_replace) {
            (0, r.assert)(t !== "nochange");
            this._graphics.replaceIndexesTo(t);
          } else {
            if (t !== "nochange") {
              this._graphics.replaceIndexesTo(t);
            }
            if (s.graphicsCmds !== undefined) {
              this._graphics.processCommands(s.graphicsCmds);
            }
          }
        }
        this._onDataUpdated(e, s, t, o && o.index);
        if (!this.priceRangeReady()) {
          this._enablePriceRangeReady();
        }
        this._dataUpdated.fire(i, false, o);
      }
      _processPlotOffsets(e) {
        if (e && e.indexes_replace) {
          return;
        }
        const t = this._plotOffsets;
        this._plotOffsets = e && e.offsets || {};
        if (!(0, s.default)(t, this._plotOffsets)) {
          this.updateAllViews((0, P.sourceChangeEvent)({
            sourceId: this.id(),
            clearData: true
          }));
        }
        this._updateMaxOffsetValue();
      }
      _applyPlotToPrecalculatedAutoscaleInfo(e, t, i, s) {
        const o = s.id;
        const n = this._properties.childs().styles.childs()[o];
        const a = (0, M.isShapesPlot)(s) || (0, M.isCharsPlot)(s);
        i.useMainSeriesRange = i.useMainSeriesRange || (0, M.isArrowsPlot)(s);
        let l = (0, M.isLinePlot)(s) || (0, M.isOhlcPlot)(s);
        if (a) {
          const e = (0, r.ensureDefined)(n).childs().location.value();
          const t = [w.MarkLocation.Absolute, w.MarkLocation.Top, w.MarkLocation.Bottom].indexOf(e) < 0;
          i.useMainSeriesRange = i.useMainSeriesRange || a && t;
          l = l || e === w.MarkLocation.Absolute;
        }
        if (!l) {
          return i;
        }
        const c = {
          name: o,
          offset: this.offset(o)
        };
        const h = n.childs().plottype.value();
        if (!this._skipHistogramBaseOnAutoScale() && [M.LineStudyPlotStyle.Histogram, M.LineStudyPlotStyle.Columns, M.LineStudyPlotStyle.Area].indexOf(h) >= 0) {
          const s = (this._metaInfo.styles ?? {})?.[o]?.histogramBase;
          if (s === undefined) {
            return i;
          }
          const n = this.data().minMaxOnRangeCached(e, t, [c]);
          if ((0, R.isNumber)(s) && n !== null) {
            i.baseValueMinMax = (0, y.mergeMinMax)(i.baseValueMinMax, {
              min: s,
              max: s
            });
            i.baseValueMinMax = (0, y.mergeMinMax)(i.baseValueMinMax, n);
          }
          return i;
        }
        i.fields.push(c);
        return i;
      }
      async _onSourceInputChanged() {
        if (!this.isStarted()) {
          this._calcSources();
          Dt;
        }
      }
      _buildInputs(e) {
        (0, r.assert)(!!e, "options not set");
        let t = {};
        try {
          t = this._prepareInputs(e);
        } catch (e) {
          Lt.logWarn("Failed to prepare study inputs: " + e);
        }
        if (e.asObject) {
          const e = {};
          Object.keys(t).forEach(i => {
            if (t[i] != null) {
              e[i] = t[i];
            }
          });
          return e;
        }
        {
          const e = [];
          Object.keys(t).forEach(i => {
            if (t[i] != null) {
              e.push(t[i]);
            }
          });
          return e;
        }
      }
      _prepareInput(e, t) {
        const i = this._prepareInputValue(e, t);
        if (!e.isFake || t.fakeInputsForDisplay || t.onlyAtomValues) {
          return i;
        } else {
          return {
            v: i,
            f: true,
            t: e.type
          };
        }
      }
      _plotsForAlert() {
        return [];
      }
      _formatterStateForAlert() {
        try {
          const e = this.formatter();
          if (FormattersSerializer.isSerializable(e)) {
            return FormattersSerializer.serialize(e);
          } else {
            return null;
          }
        } catch {
          return null;
        }
      }
      _calcIsActualInterval() {
        const e = this._isActualInterval;
        this._isActualInterval = (0, _t.isActualInterval)(this._series.intervalObj(), this._properties.childs().intervalsVisibilities);
        if (e !== this._isActualInterval) {
          this._onIsActualIntervalChange.fire();
          this._visibleChanged();
          this.processHibernate();
        }
      }
      _visibleChanged() {
        this._series.invalidateBarColorerCache();
      }
      _getNonPriceParent() {
        const e = this._sources;
        for (const t of e) {
          if (t instanceof Kt) {
            const e = t.metaInfo();
            if (e.is_price_study && e.id !== "Compare@tv-basicstudies") {
              return t._getNonPriceParent();
            } else {
              return t;
            }
          }
        }
        return null;
      }
      _updateInputValue(e, t) {
        const i = this._properties.childs().inputs.childs();
        if (i[t.id]) {
          if (t.type === "price") {
            i[t.id].setValue(e.price);
          } else if (t.type === "time") {
            const s = this._model.timeScale().indexToTimePoint(e.index);
            if (s !== null) {
              i[t.id].setValue(s * 1000);
            }
          }
        }
      }
      _initializeStudyInputsPaneViews() { }
      _updateCurrencySourceSymbolInfo() {
        if (this._currencySourceSymbolInputProperty !== null) {
          this._currencySourceSymbolInfo = this._resolvedSymbolsByInput[this._currencySourceSymbolInputProperty.value()] ?? null;
        }
      }
      _initializeCurrencySource() {
        const e = this.metaInfo();
        const t = e.symbolSource?.type === "symbolInputSymbolSource" && e.symbolSource?.inputId;
        const i = e.inputs.find(e => e.id === t);
        if (typeof t == "string" && i?.type === "symbol" && e.is_price_study) {
          const e = this._properties.childs().inputs.childs()[t];
          if (e !== undefined) {
            e.subscribe(this, this._onCurrencyMayChange);
            this._currencySourceSymbolInputProperty = e;
          }
        }
      }
      _recreatePaneViews() {
        if (this.hasBarColorer()) {
          this._model.mainSeries().invalidateBarStylesCache();
        }
        this._createViews();
        this.recalculate();
        this.updateAllViews((0, P.sourceChangeEvent)(this.id()));
      }
      _pinePatchProps() {
        throw new Error("Not implemented");
      }
      _areStudyInputsModified(e) {
        if (Object.keys(e).length === 0) {
          return false;
        }
        if (this._oldStudyInputs === undefined) {
          return true;
        }
        const t = Object.keys(this._oldStudyInputs);
        (0, r.assert)(t.length === Object.keys(e).length, "keys quantity should be equal");
        for (const i of t) {
          (0, r.assert)(e.hasOwnProperty(i), `key '${i}' should exist in study inputs`);
          if ((0, r.ensureDefined)(this._oldStudyInputs)[i] !== e[i]) {
            return true;
          }
        }
        return false;
      }
      _onVisibleTimeRangeInputsChanged(e) {
        if (e !== null) {
          this._updateVisibleTimeRangeInputs(e);
        } else if (this.isStarted() && this._chartApi.isConnected().value()) {
          this.stop(true);
        }
      }
      _updateVisibleTimeRangeInputs(e, t = true) {
        const i = {
          first_visible_bar_time: e.firstVisibleBarTime,
          last_visible_bar_time: e.lastVisibleBarTime,
          subscribeRealtime: e.subscribeRealtime
        };
        const s = this.metaInfo().inputs;
        const o = [];
        for (const e of s) {
          if (i.hasOwnProperty(e.id)) {
            o.push(e.id);
          }
        }
        const n = this.properties().childs().inputs;
        for (const e of o) {
          n.childs()[e].setValueSilently(i[e]);
        }
        if (t && o.length > 0) {
          n.fireChanged();
        }
      }
      _getStudyErrorText(e) {
        const t = e.split(":", 2)[0];
        return decodeURIComponent(t);
      }
      _priceScaleByProperties() {
        if (this.properties().childs().precision.value() === "default") {
          return null;
        }
        const e = parseInt(this.properties().childs().precision.value());
        if (isFinite(e)) {
          return Math.pow(10, e);
        } else {
          return null;
        }
      }
      _priceScaleByMetaInfo() {
        const e = this.metaInfo().format;
        const t = e.type !== "inherit" ? e.precision : undefined;
        const i = (0, R.isNumber)(t) ? Math.pow(10, t) : undefined;
        if (e.type === "price" || e.type === "percent") {
          return i || 100;
        }
        if (e.type === "volume") {
          if (e.precision === undefined) {
            const e = this.series().symbolInfo();
            if (e !== null && (0, R.isNumber)(e.volume_precision)) {
              return Math.pow(10, e.volume_precision);
            }
          }
          return 1;
        }
        if (e.type !== "inherit") {
          Lt.logWarn("Unsupported format type: " + e.type);
        }
        return null;
      }
      _inputSymbols() {
        return this.metaInfo().inputs.filter(e => e.type === "symbol").map(e => (0, r.ensureDefined)(this._properties.childs().inputs.child(e.id)).value());
      }
      _studySpec(e) {
        return {
          id: this._metaInfo.id,
          child: e ?? this.isChildStudy(),
          fundamental: false
        };
      }
      _onFormatterPropsChanged() {
        this._recreatePriceFormattingDependencies();
      }
      _setSources(e) {
        this.invalidateTitleCache();
        this._sources = e;
        this._onParentSourcesChanges.fire();
      }
    }
  },
  31785: (e, t, i) => {
    "use strict";

    i.d(t, {
      plotShapesData: () => o
    });
    var s = i(11542);
    const o = {
      shape_arrow_down: {
        guiName: s.t(null, undefined, i(34247)),
        id: "shape_arrow_down",
        paneRendererClass: "PaneRendererArrowDown",
        pineName: "shape.arrowdown",
        icon: "arrow_down"
      },
      shape_arrow_up: {
        guiName: s.t(null, undefined, i(77231)),
        id: "shape_arrow_up",
        paneRendererClass: "PaneRendererArrowUp",
        pineName: "shape.arrowup",
        icon: "arrow_up"
      },
      shape_circle: {
        guiName: s.t(null, undefined, i(91944)),
        id: "shape_circle",
        paneRendererClass: "PaneRendererCircleShape",
        pineName: "shape.circle",
        icon: "circle"
      },
      shape_cross: {
        guiName: s.t(null, undefined, i(6969)),
        id: "shape_cross",
        paneRendererClass: "PaneRendererCrossShape",
        pineName: "shape.cross",
        icon: "cross"
      },
      shape_diamond: {
        guiName: s.t(null, undefined, i(15179)),
        id: "shape_diamond",
        paneRendererClass: "PaneRendererDiamond",
        pineName: "shape.diamond",
        icon: "diamond"
      },
      shape_flag: {
        guiName: s.t(null, undefined, i(33885)),
        id: "shape_flag",
        paneRendererClass: "PaneRendererFlagShape",
        pineName: "shape.flag",
        icon: "flag"
      },
      shape_label_down: {
        guiName: s.t(null, undefined, i(85924)),
        id: "shape_label_down",
        paneRendererClass: "PaneRendererLabelDown",
        pineName: "shape.labeldown",
        icon: "label_down"
      },
      shape_label_up: {
        guiName: s.t(null, undefined, i(52402)),
        id: "shape_label_up",
        paneRendererClass: "PaneRendererLabelUp",
        pineName: "shape.labelup",
        icon: "label_up"
      },
      shape_square: {
        guiName: s.t(null, undefined, i(66205)),
        id: "shape_square",
        paneRendererClass: "PaneRendererSquare",
        pineName: "shape.square",
        icon: "square"
      },
      shape_triangle_down: {
        guiName: s.t(null, undefined, i(76152)),
        id: "shape_triangle_down",
        paneRendererClass: "PaneRendererTriangleApexDown",
        pineName: "shape.triangledown",
        icon: "triangle_down"
      },
      shape_triangle_up: {
        guiName: s.t(null, undefined, i(21236)),
        id: "shape_triangle_up",
        paneRendererClass: "PaneRendererTriangleApexUp",
        pineName: "shape.triangleup",
        icon: "triangle_up"
      },
      shape_xcross: {
        guiName: s.t(null, undefined, i(11316)),
        id: "shape_xcross",
        paneRendererClass: "PaneRendererXCross",
        pineName: "shape.xcross",
        icon: "x_cross"
      }
    };
  },
  9482: (e, t, i) => {
    "use strict";

    var s = i(1640).Version;
    var o = i(9343).getLogger("Chart.StudyMigration");
    function n(e) {
      this._studyId = e;
      this._maxToVers = s.ZERO;
      this._maxFromVers = s.ZERO;
      this._migrs = [];
    }
    n.prototype.addMigration = function (e, t, i) {
      var o = s.parse(e);
      var n = s.parse(t);
      if (o.isGreater(this._maxFromVers)) {
        this._maxFromVers = o;
      }
      if (n.isGreater(this._maxToVers)) {
        this._maxToVers = n;
      }
      this._migrs.push({
        fromVers: o,
        toVers: n,
        rules: i
      });
    };
    n.prototype.updateInputs = function (e, t, i) {
      if (!i) {
        return i;
      }
      var s = TradingView.clone(i);
      for (var n = e; n.isLess(t);) {
        var r = this._findMigration(n);
        if (r == null) {
          break;
        }
        o.logNormal("Migrating study inputs from " + r.fromVers + " to " + r.toVers + " version, studyId: " + this._studyId + ", migration: " + JSON.stringify(r) + ", inputs: " + JSON.stringify(i));
        s = this._applyMigration(s, r);
        if (!n.isLess(r.toVers)) {
          throw new Error("Problems in study migration process... Possible infinite cycle has been detected and stopped.");
        }
        n = r.toVers;
      }
      if (n > e) {
        o.logNormal("Study inputs migration is done, studyId: " + this._studyId + ", inputs: " + JSON.stringify(s));
      }
      return s;
    };
    n.prototype._findMigration = function (e) {
      var t = -1;
      var i = this._maxFromVers;
      for (var s = 0; s < this._migrs.length; s++) {
        var o = this._migrs[s];
        if (!o.fromVers.isLess(e)) {
          if (o.fromVers.isLessOrEqual(i)) {
            i = o.fromVers;
            t = s;
          }
        }
      }
      if (t < 0) {
        return null;
      } else {
        return this._migrs[t];
      }
    };
    n.prototype._applyMigration = function (e, t) {
      var i = e;
      for (var s = 0; s < t.rules.length; s++) {
        var o = t.rules[s];
        i = this._getApplyRuleFun(o.type)(i, o);
      }
      return i;
    };
    n.prototype._getApplyRuleFun = function (e) {
      if (e === "inputRemoved") {
        return n._applyInputRemovedRule;
      }
      if (e === "inputChangedType") {
        return n._applyInputChangedTypeRule;
      }
      if (e === "inputChangedMinMax") {
        return n._applyInputChangedMinMaxRule;
      }
      if (e === "inputChangedOptions") {
        return n._applyInputChangedOptionsRule;
      }
      throw new Error("Unknown migration rule type: " + e);
    };
    n._applyInputRemovedRule = function (e, t) {
      if (!(t.inputId in e)) {
        return e;
      }
      if (t.action !== "removeVal") {
        throw new Error("Unexpected rule.action=" + t.action + " in rule.type=" + t.type);
      }
      var i = e[t.inputId];
      delete e[t.inputId];
      o.logNormal("Input " + t.inputId + "=" + i + " removed");
      return e;
    };
    n._applyInputChangedTypeRule = function (e, t) {
      var i = e[t.inputId];
      if (t.action === "resetToDefVal") {
        e[t.inputId] = t.defVal;
        o.logNormal("Input " + t.inputId + "=" + i + " reset to default value " + t.defVal);
        return e;
      }
      if (t.action === "convertVal") {
        if (i == null) {
          return e;
        }
        if (t.inputTypeFrom === "float" && t.inputType === "integer") {
          e[t.inputId] = Math.round(e[t.inputId]);
          o.logNormal("Input " + t.inputId + "=" + i + " converted to value " + e[t.inputId]);
          return e;
        }
        if (t.inputTypeFrom === "integer" && t.inputType === "float") {
          return e;
        }
        if (t.inputTypeFrom === "text" && t.inputType === "source") {
          if (!n._isValidSource(i, t.options)) {
            e[t.inputId] = t.defVal;
          }
          return e;
        }
        throw new Error("Cannot convertVal from " + t.inputTypeFrom + " to " + t.inputType);
      }
      throw new Error("Unknown action " + t.action + " for rule with type " + t.type);
    };
    n._isValidSource = function (e, t) {
      return e.indexOf("$") >= 0 || t.indexOf(e) >= 0;
    };
    n._applyInputChangedMinMaxRule = function (e, t) {
      if (t.action !== "adjustValIfNeeded") {
        throw new Error("Unknown action " + t.action + " for rule with type " + t.type);
      }
      var i = e[t.inputId];
      if (i < t.minVal) {
        e[t.inputId] = t.minVal;
      } else if (i > t.maxVal) {
        e[t.inputId] = t.maxVal;
      }
      o.logNormal("Input " + t.inputId + "=" + i + " adjusted to value " + e[t.inputId]);
      return e;
    };
    n._applyInputChangedOptionsRule = function (e, t) {
      if (!(["text"].indexOf(t.inputType) >= 0) || t.action !== "resetToDefValIfNeeded") {
        throw new Error("Unexpected rule.inputType=" + t.inputType + " in rule.action=" + t.action);
      }
      var i = e[t.inputId];
      if (t.options.indexOf(i) < 0) {
        e[t.inputId] = t.defVal;
        o.logNormal("Input " + t.inputId + "=" + i + " reset to default value " + t.defVal);
      }
      return e;
    };
    e.exports = n;
  },
  79303: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyVersioning: () => m
    });
    var s = i(16738);
    var o = i(50151);
    var n = i(68159);
    var r = i(9482);
    var a = i.n(r);
    var l = i(9343);
    var c = i(1640);
    var h = i(72530);
    var d = i(37265);
    const u = (0, l.getLogger)("Chart.Study.Versioning");
    const _ = 1000000000000;
    var p;
    (function (e) {
      e[e.VersionStudyArgSource = 41] = "VersionStudyArgSource";
      e[e.MetaInfoFormatVersionSosV2 = 42] = "MetaInfoFormatVersionSosV2";
      e[e.VersionPineProtectTv4164 = 43] = "VersionPineProtectTv4164";
      e[e.VersionNewStudyPrecisionFormat = 46] = "VersionNewStudyPrecisionFormat";
      e[e.CurrentMetaInfoFormatVersion = 52] = "CurrentMetaInfoFormatVersion";
    })(p ||= {});
    class m {
      constructor(e, t) {
        this._migrations = {};
        if (!e) {
          throw new Error("No studies metainfo");
        }
        this._studiesMetainfo = e;
        if (!t) {
          throw new Error("No studies migrations");
        }
        this._studiesMigrations = t;
        for (let e = 0; e < this._studiesMigrations.length; e++) {
          const t = this._studiesMigrations[e];
          const i = t.versFrom;
          const s = t.versTo;
          for (let e = 0; e < t.studyMigrations.length; e++) {
            const o = t.studyMigrations[e];
            const n = o.studyId;
            if (o.rules.length === 0) {
              u.logError("Study Migration should have at least one convertion rule");
              continue;
            }
            const r = n in this._migrations ? this._migrations[n] : new (a())(n);
            r.addMigration(i, s, o.rules);
            this._migrations[n] = r;
          }
        }
        this._clientMigrations = [(e, t) => {
          if (this._studiesMetainfo.length === 0 || !e.isTVScript || e.version >= 22) {
            return t;
          }
          const i = {};
          let s = 0;
          let o = 0;
          let n = t[o];
          while (n !== undefined) {
            const e = t[n.id];
            if (n.isFake) {
              n.id = "in_" + s++;
            }
            i[o] = n;
            i[n.id] = e;
            o++;
            n = t[o];
          }
          return i;
        }];
      }
      updateMetaInfoAsync(e) {
        n.StudyMetaInfo.versionOf(e);
        {
          let t = null;
          const i = this._studiesMetainfo;
          for (let s = 0; s < i.length; s++) {
            if (i[s].id === e.id) {
              t = i[s];
              break;
            }
          }
          return {
            sync: true,
            result: t ? new n.StudyMetaInfo(t.state()) : null
          };
        }
      }
      updateStudyState(e, t, i) {
        if (e == null || t == null || i == null) {
          return e;
        }
        e = (0, d.clone)(e);
        this.updateStudyInputsIfNeeded(e, t.version, i);
        for (const i of this._clientMigrations) {
          const s = i.call(this, t, e.inputs);
          if (Object.keys(s).length === Object.keys(e.inputs).length) {
            e.inputs = s;
          } else {
            u.logWarn("StudyVersioning._clientMigrations application returned bad result. Skipping it...");
          }
        }
        const s = n.StudyMetaInfo.versionOf(t);
        if (t.isTVScript && t.TVScriptSourceCode && s >= 12 && s <= 26) {
          const s = {};
          for (let e = 0; e < t.plots.length; ++e) {
            const o = t.plots[e];
            const n = i.plots[e];
            s[o.id] = n.id;
          }
          const o = Object.keys(e.styles);
          for (let t = 0; t < o.length; ++t) {
            const i = o[t];
            const n = e.styles[i];
            delete e.styles[i];
            const r = s[i];
            e.styles[r] = n;
          }
          const n = Object.keys(e.plots);
          for (let t = 0; t < n.length; ++t) {
            const i = n[t];
            const o = e.plots[i].id;
            e.plots[i].id = s[o];
          }
        }
        return e;
      }
      updateStudyInputsIfNeeded(e, t, i) {
        if (!i.isTVScript && !i.pine && t !== i.version) {
          const s = i && i.defaults.inputs;
          e.inputs = this.updateStudyInputs(i.id, t, i.version, e.inputs, s);
        }
      }
      updateStudyInputs(e, t, i, s, o) {
        let n = (0, d.clone)(s);
        if (e in this._migrations) {
          const s = c.Version.parse(t);
          let o;
          if (i === "last") {
            const t = this.lastVersionOfStudy(e);
            o = c.Version.parse(t);
          } else {
            o = c.Version.parse(i);
          }
          n = this._migrations[e].updateInputs(s, o, n);
        }
        if (o == null) {
          return n;
        }
        for (const e in o) {
          if (!(e in n)) {
            n[e] = o[e];
          }
        }
        for (const i in n) {
          if (!(i in o)) {
            const s = n[i];
            u.logWarn(`Extra input detected, studyId='${e}', versionFrom='${t}', inputId='${i}', inputValue='${s}', removing it and continue...`);
            delete n[i];
          }
        }
        return n;
      }
      lastVersionOfStudy(e) {
        return (0, o.ensureDefined)(this._studiesMetainfo.find(t => t.id === e)).version;
      }
      updateMetaInfo(e) {
        if (!e) {
          return e;
        }
        (0, o.assert)(e instanceof n.StudyMetaInfo);
        (0, o.assert)(!e.isTVScript, "This method should update only built-in java indicators metaInfo. For Pine indicators use updateMetaInfoAsync");
        const t = this._studiesMetainfo.find(t => e.id === t.id);
        if (t) {
          return new n.StudyMetaInfo(t.state());
        } else {
          return null;
        }
      }
      static patchPointsBasedStudyState(e) {
        this._fixInputsMaxValue(e.state, e.metaInfo);
        return e;
      }
      static patchStudyData(e, t, i, s) {
        return {
          data: t,
          nsData: i,
          indexes: s ?? undefined
        };
      }
      static patchPointsBasedStudyData(e, t) {
        return t;
      }
      static patchPropsStateAndMetaInfo(e, t, i) {
        let o = t.state();
        if (t.productId === "Script$BOOKER" && !o.alerts) {
          delete e.alerts;
        }
        this._fixInputsOrder(e, o);
        this._fixInputsMaxValue(e, o);
        const r = this.splitInputs(e.inputs);
        e.inputs = r.obj;
        const a = n.StudyMetaInfo.versionOf(t);
        if (a < 42 && o.isChildStudy) {
          e.isChildStudy = o.isChildStudy;
        }
        if (t.isTVScript && t.version < 60) {
          if (t.id === "Script$TV_EARNINGS@tv-scripting" || t.id === "Script$TV_DIVIDENDS@tv-scripting" || t.id === "Script$TV_SPLITS@tv-scripting") {
            delete o.TVScriptSourceCode;
          }
        }
        if ((t.id === "Volume" || t.id === "Volume@tv-basicstudies") && t.inputs.length === 0) {
          o.inputs = [{
            id: "length",
            type: "integer",
            defval: 20,
            min: 1,
            max: 1000
          }];
          o.plots.push({
            id: "vol_ma",
            type: "line"
          });
        }
        if (t.id === "Volume@tv-basicstudies" && t.version && t.version <= 46 && e.styles.vol.transparency === undefined) {
          e.styles.vol.transparency = e.transparency || 87;
        }
        if (t.id === "PivotPointsStandard@tv-basicstudies" && (o.inputs.length === 0 ? (e.inputs = {
          kind: "Traditional",
          showHistoricalPivots: true
        }, o.inputs = [{
          defval: "Traditional",
          id: "kind",
          type: "text",
          options: ["Traditional", "Fibonacci", "Woodie", "Classic", "DeMark", "Camarilla"]
        }, {
          id: "showHistoricalPivots",
          type: "bool",
          defval: true
        }]) : o.inputs.length === 1 && (e.inputs = {
          kind: "Traditional"
        }, o.inputs = [{
          defval: "Traditional",
          id: "kind",
          type: "text",
          options: ["Traditional", "Fibonacci", "Woodie", "Classic", "DeMark", "Camarilla"]
        }, {
          id: "showHistoricalPivots",
          type: "bool",
          defval: true
        }]), e._hardCodedDefaultsVersion === undefined)) {
          e._hardCodedDefaultsVersion = 1;
          const t = e.color;
          delete e.color;
          e.levelsStyle = {
            colors: {
              P: t,
              "S1/R1": t,
              "S2/R2": t,
              "S3/R3": t,
              "S4/R4": t,
              "S5/R5": t
            }
          };
        }
        if (t.shortId === "CMF" && o.inputs.length === 2) {
          e.inputs = {
            length: e.inputs["length fast"]
          };
          o.inputs = o.inputs.splice(0, 1);
          o.inputs[0].id = "length";
        }
        if (o.defaults && o.defaults.precision === undefined && a < 46) {
          if (["Volume@tv-basicstudies", "VbPVisible@tv-volumebyprice", "VbPSessions@tv-volumebyprice"].indexOf(t.id) !== -1) {
            o.defaults.precision = 0;
          } else {
            o.defaults.precision = 4;
          }
        }
        let l = t.id;
        if (t.version < 60) {
          const e = ["TV_DIVIDENDS", "TV_SPLITS", "TV_EARNINGS"];
          const i = 6;
          for (let s = 0; s < e.length; s++) {
            if (t.id.startsWith("Script$" + e[s] + "@tv-scripting")) {
              o.fullId = "ESD" + o.fullId.substring(i);
              o.id = "ESD" + o.id.substring(i);
              o.name &&= "ESD" + o.name.substring(i);
              o.shortId = "ESD" + o.shortId.substring(i);
              o.productId = "ESD" + o.productId.substring(i);
              l = "ESD" + t.id.substring(i);
            }
          }
        }
        const c = {
          "ESD$TV_EARNINGS@tv-scripting": {
            fullId: "Earnings@tv-basicstudies-129!",
            id: "Earnings@tv-basicstudies",
            name: "Earnings@tv-basicstudies",
            shortId: "Earnings",
            productId: "tv-basicstudies"
          },
          "ESD$TV_SPLITS@tv-scripting": {
            fullId: "Splits@tv-basicstudies-129!",
            id: "Splits@tv-basicstudies",
            name: "Splits@tv-basicstudies",
            shortId: "Splits",
            productId: "tv-basicstudies"
          },
          "ESD$TV_DIVIDENDS@tv-scripting": {
            fullId: "Dividends@tv-basicstudies-129!",
            id: "Dividends@tv-basicstudies",
            name: "Dividends@tv-basicstudies",
            shortId: "Dividends",
            productId: "tv-basicstudies"
          }
        };
        if (l in c) {
          Object.assign(o, c[l]);
        }
        if (a < 43) {
          const i = {
            "StrategyScript$STD;Consecutive%1Ups/Downs%1Strategy": {
              pineId: "STD;Consecutive%1Ups%1Downs%1Strategy",
              className: "StrategyScript"
            },
            Script$EDGR_NET_INCOME_FROM_CONTINUING_OPERATIONS_APPLICABLE_TO_COMMON_V2: {
              pineId: "Script$EDGR_NET_INCOME_FROM_CONTINUING_OPS_APPLICABLE_TO_COMMON_V2",
              className: "Script"
            }
          };
          if (t.shortId in i) {
            const n = i[t.shortId].className + "$" + i[t.shortId].pineId;
            const r = {
              scriptIdPart: i[t.shortId].pineId,
              fullId: o.fullId.replace(o.shortId, n),
              id: o.id.replace(o.shortId, n),
              name: o.name?.replace(o.shortId, n),
              shortId: n
            };
            (0, s.default)(o, r);
            (0, s.default)(e, r);
          }
          const n = false;
          const r = n && n.match(/^(USER)(_\d+)(;)(.*)$/);
          if (r) {
            const t = r[0];
            const i = r[1] + r[3] + r[2] + r[4];
            const n = {
              scriptIdPart: i,
              fullId: o.fullId.replace(t, i),
              id: o.id.replace(t, i),
              name: o.name?.replace(t, i),
              shortId: o.shortId.replace(t, i)
            };
            (0, s.default)(o, n);
            (0, s.default)(e, n);
          }
        }
        if (t.id === "MA") {
          const t = {
            id: "MAExp",
            properties: [{
              id: "is_price_study",
              type: "bool",
              value: "true"
            }],
            inputs: [{
              id: "length",
              type: "integer",
              defval: 20,
              min: 1,
              max: 500
            }, {
              id: "source",
              type: "text",
              defval: "close",
              options: ["open", "high", "low", "close"]
            }],
            plots: [{
              id: "MovAvgExp",
              type: "line"
            }],
            palettes: {}
          };
          const i = {
            id: "MASimple",
            properties: [{
              id: "is_price_study",
              type: "bool",
              value: "true"
            }],
            inputs: [{
              id: "length",
              type: "integer",
              defval: 20,
              min: 1,
              max: 500
            }, {
              id: "source",
              type: "text",
              defval: "close",
              options: ["open", "high", "low", "close"]
            }],
            plots: [{
              id: "MovAvgSimple",
              type: "line"
            }],
            palettes: {}
          };
          const s = {
            id: "MAVolumeWeighted",
            properties: [{
              id: "is_price_study",
              type: "bool",
              value: "true"
            }],
            inputs: [{
              id: "length",
              type: "integer",
              defval: 20,
              min: 1,
              max: 500
            }, {
              id: "source",
              type: "text",
              defval: "close",
              options: ["open", "high", "low", "close"]
            }],
            plots: [{
              id: "MovAvgVolumeWeighted",
              type: "line"
            }],
            palettes: {}
          };
          const n = {
            id: "MAWeighted",
            properties: [{
              id: "is_price_study",
              type: "bool",
              value: "true"
            }],
            inputs: [{
              id: "length",
              type: "integer",
              defval: 20,
              min: 1,
              max: 500
            }, {
              id: "source",
              type: "text",
              defval: "close",
              options: ["open", "high", "low", "close"]
            }],
            plots: [{
              id: "MovAvgWeighted",
              type: "line"
            }],
            palettes: {}
          };
          switch (e.inputs.type) {
            case "exp":
              o = t;
              break;
            case "simple":
              o = i;
              break;
            case "weighted":
              o = n;
              break;
            case "volume weighted":
              o = s;
          }
          e.styles[o.plots[0].id] = e.styles.MovAvg;
          delete e.styles.MovAvg;
          delete e.inputs.type;
        }
        if (i.oldShowStudyLastValueProperty) {
          e.oldShowLastValue = e.showLastValue;
        }
        delete e.showLastValue;
        delete e.showStudyArguments;
        (0, h.migrateMetaInfoAndPropState)(o, e);
        return {
          propsState: e,
          metaInfo: o
        };
      }
      static splitInputs(e) {
        const t = {};
        const i = {};
        for (const [s, o] of Object.entries(e)) {
          if ((0, d.isNumber)(parseInt(s, 10))) {
            t[s] = o;
          } else {
            i[s] = o;
          }
        }
        return {
          arr: t,
          obj: i
        };
      }
      static verifyInputsMaxValue(e) {
        if (e.inputs) {
          for (const t of e.inputs) {
            if (t.type === "integer" && t.max && t.max > _) {
              u.logWarn("Bad integer input max value in metaInfo id=" + e.id + " title=" + e.description);
            }
          }
        }
      }
      static mergeInputsObjPart(e, t) {
        const i = this.splitInputs(t);
        (0, s.default)(e, i.obj);
      }
      static _fixInputsOrder(e, t) {
        const i = this._getOrderedInputIds(t);
        const o = this.splitInputs(e.inputs);
        const n = o.arr;
        const r = o.obj;
        const a = (0, s.default)({}, r);
        for (let e = 0; e < i.length; ++e) {
          const t = i[e];
          const s = this._findInputKeyById(n, t);
          if (s !== null) {
            a[e] = n[s];
          }
        }
        e.inputs = a;
      }
      static _fixInputsMaxValue(e, t) {
        if ((0, d.isAbsent)(t)) {
          return;
        }
        const i = _;
        if (t.inputs) {
          for (const e of t.inputs) {
            if (e.type === "integer" && e.max && e.max > i) {
              e.max = i;
            }
          }
        }
        if (!e || !e.inputs) {
          return;
        }
        const o = this.splitInputs(e.inputs);
        const n = o.arr;
        for (const [, e] of Object.entries(n)) {
          if (e.type === "integer" && e.max && e.max > i) {
            e.max = i;
          }
        }
        e.inputs = (0, s.default)(o.obj, o.arr);
      }
      static _findInputKeyById(e, t) {
        let i = null;
        for (const s in e) {
          if ((0, d.isNumber)(parseInt(s, 10)) && e[s].id === t) {
            i = s;
            break;
          }
        }
        return i;
      }
      static _getOrderedInputIds(e) {
        const t = [];
        for (const i of e.inputs) {
          t.push(i.id);
        }
        return t;
      }
      static _patchOldVolumeProfiles(e, t) {
        if (!t?.hhists) {
          return;
        }
        const i = t.hhists[e].data;
        const s = [];
        for (const [, e] of Object.entries(i)) {
          s.push(e);
        }
        t.hhists[0].data = s;
      }
    }
  },
  52270: (e, t, i) => {
    "use strict";

    function s(e, t, i) {
      return e === t || e === i;
    }
    i.d(t, {
      symbolSameAsResolved: () => s
    });
  },
  95700: (e, t, i) => {
    "use strict";

    i.d(t, {
      translateSessionDescription: () => r,
      translateSessionShortDescription: () => l
    });
    var s;
    var o = i(11542);
    (function (e) {
      e.RegularTradingHours = "Regular Trading Hours";
      e.ExtendedTradingHours = "Extended Trading Hours";
      e.ElectronicTradingHours = "Electronic Trading Hours";
      e.Premarket = "Premarket";
      e.Postmarket = "Postmarket";
    })(s ||= {});
    const n = new Map([["Premarket", o.t(null, {
      context: "sessions"
    }, i(59330))], ["Postmarket", o.t(null, {
      context: "sessions"
    }, i(50434))], ["Regular Trading Hours", o.t(null, {
      context: "sessions"
    }, i(84246))], ["Extended Trading Hours", o.t(null, {
      context: "sessions"
    }, i(36862))], ["Electronic Trading Hours", o.t(null, {
      context: "sessions"
    }, i(34647))]]);
    function r(e) {
      return n.get(e) ?? e;
    }
    const a = new Map([["Premarket", o.t(null, {
      context: "sessions"
    }, i(46273))], ["Postmarket", o.t(null, {
      context: "sessions"
    }, i(7807))], ["Regular Trading Hours", o.t(null, {
      context: "sessions"
    }, i(35342))], ["Extended Trading Hours", o.t(null, {
      context: "sessions"
    }, i(8029))], ["Electronic Trading Hours", o.t(null, {
      context: "sessions"
    }, i(8029))]]);
    function l(e) {
      return a.get(e) ?? e;
    }
  },
  76350: (e, t, i) => {
    "use strict";

    i.d(t, {
      areEqualSymbols: () => a,
      compareSymbolParams: () => d,
      symbolParams: () => h,
      symbolSameAsCurrent: () => c
    });
    var s = i(56570);
    var o = i(68805);
    var n = i(85049);
    const r = s.enabled("uppercase_instrument_names");
    function a(e, t) {
      if (e === undefined) {
        return t === undefined;
      } else {
        return t !== undefined && (r ? e.toUpperCase() === t.toUpperCase() : e === t);
      }
    }
    function l(e, t) {
      return e.some(e => a(t, e));
    }
    function c(e, t) {
      if (t === null) {
        return false;
      }
      if (t) {
        if (a(t.full_name, e) || a(t.pro_name, e)) {
          return true;
        }
        if (a(t.ticker, e)) {
          return true;
        }
        if (t.aliases && l(t.aliases, e)) {
          return true;
        }
        if (t.alternatives && l(t.alternatives, e)) {
          return true;
        }
        if (e.indexOf("FRA:") === 0 && a(t.pro_name, e.replace("FRA:", "FWB:"))) {
          return true;
        }
      }
      return false;
    }
    function h(e) {
      return {
        symbol: e.symbol(),
        currency: e.currency(),
        unit: e.unit(),
        interval: e.interval(),
        style: e.style()
      };
    }
    function d(e, t, i) {
      const {
        symbol: s,
        currency: r,
        unit: a,
        style: l,
        interval: c
      } = t;
      const h = s !== undefined && !e.symbolSameAsResolved(s);
      let d;
      let u;
      const _ = e.symbolInfo();
      if (_ !== null) {
        d = r !== undefined && !function (e, t) {
          return e === null && !(0, o.isConvertedToOtherCurrency)(t) || e === (0, o.symbolCurrency)(t);
        }(r, _);
        u = a !== undefined && !function (e, t, i) {
          return e === null && !(0, o.isConvertedToOtherUnit)(t, i) || e === (0, o.symbolUnit)(t, i);
        }(a, _, i);
      } else {
        d = r !== undefined && r !== e.currency();
        u = a !== undefined && a !== e.unit();
      }
      return {
        symbolChanged: h,
        intervalChanged: c !== undefined && !n.Interval.isEqual(e.interval(), c),
        currencyChanged: d,
        unitChanged: u,
        styleChanged: l !== undefined && l !== e.style(),
        styleChangeRequiresRestart: l !== undefined && (0, o.styleChangeRequiresRestart)(l, e.style())
      };
    }
  },
  2844: (e, t, i) => {
    "use strict";

    i.d(t, {
      TextWidthCache: () => n,
      getMinTextMetrics: () => o
    });
    var s = i(5201);
    function o(e) {
      return {
        width: e.width,
        actualBoundingBoxAscent: e.actualBoundingBoxAscent,
        actualBoundingBoxDescent: e.actualBoundingBoxDescent,
        fontBoundingBoxAscent: e.fontBoundingBoxAscent,
        fontBoundingBoxDescent: e.fontBoundingBoxDescent
      };
    }
    class n {
      constructor(e = 150) {
        this._fontStyle = "";
        this._cache = new s.CircularCacheBuffer(e, 1.5);
      }
      reset() {
        this._cache.clear();
      }
      measureText(e, t) {
        return this.getMetrics(e, t).width;
      }
      yMidCorrection(e, t) {
        const i = this.getMetrics(e, t);
        if (i.actualBoundingBoxAscent !== undefined && i.actualBoundingBoxDescent !== undefined) {
          return (i.actualBoundingBoxAscent - i.actualBoundingBoxDescent) / 2;
        } else {
          return 0;
        }
      }
      getMetrics(e, t) {
        if (e.font !== this._fontStyle) {
          this.reset();
          this._fontStyle = e.font;
        }
        const i = this._cache.get(t);
        if (i !== undefined) {
          return i;
        }
        const s = e.textBaseline;
        e.textBaseline = "middle";
        const n = o(e.measureText(t));
        e.textBaseline = s;
        if (n.width !== 0 || !t.length) {
          this._cache.set(t, n);
        }
        return n;
      }
    }
  },
  66156: (e, t, i) => {
    "use strict";

    i.d(t, {
      TimeAxisView: () => r
    });
    var s = i(19063);
    var o = i(7114);
    class n {
      constructor() {
        this._data = null;
      }
      setData(e) {
        this._data = e;
      }
      draw(e, t, i) {
        if (this._data === null || !this._data.visible || this._data.text.length === 0) {
          return;
        }
        const s = this._data;
        e.font = i.font;
        const n = Math.round(i.widthCache.measureText(e, s.text));
        if (n <= 0) {
          return;
        }
        e.save();
        const r = i.paddingHorizontal;
        const a = n + r * 2;
        const l = a / 2;
        let c = s.coordinate;
        let h = Math.floor(c - l) + 0.5;
        if (s.alwaysInViewPort) {
          const e = s.width;
          if (h < 0) {
            c += Math.abs(0 - h);
            h = Math.floor(c - l) + 0.5;
          } else if (h + a > e) {
            c -= Math.abs(e - (h + a));
            h = Math.floor(c - l) + 0.5;
          }
        }
        const d = h + a;
        const u = Math.ceil(0 + i.borderSize + i.offsetSize + i.paddingTop + i.fontSize + i.paddingBottom);
        const {
          horizontalPixelRatio: _,
          verticalPixelRatio: p
        } = t;
        e.fillStyle = s.background;
        const m = Math.round(h * _);
        const g = Math.round(p * 0);
        const f = Math.round(d * _);
        const y = Math.round(u * p);
        const v = Math.round(_ * 2);
        e.beginPath();
        e.moveTo(m, g);
        e.lineTo(m, y - v);
        e.arcTo(m, y, m + v, y, v);
        e.lineTo(f - v, y);
        e.arcTo(f, y, f, y - v, v);
        e.lineTo(f, g);
        e.fill();
        const S = 0 + i.borderSize + i.offsetSize + i.paddingTop + i.fontSize / 2;
        e.textAlign = "left";
        e.textBaseline = "middle";
        e.fillStyle = s.color;
        const b = i.widthCache.yMidCorrection(e, "Apr0");
        e.translate((h + r) * _, (S + b) * p);
        (0, o.drawScaled)(e, _, p, () => e.fillText(s.text, 0, 0));
        e.restore();
      }
    }
    class r {
      constructor(e) {
        this._renderer = new n();
        this._rendererData = {
          background: "",
          color: "",
          coordinate: 0,
          text: "",
          visible: false,
          width: 0,
          alwaysInViewPort: true
        };
        this._invalidated = true;
        this._model = e;
        this._renderer.setData(this._rendererData);
      }
      update() {
        this._invalidated = true;
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        return this._renderer;
      }
      coordinate() {
        return this._rendererData.coordinate;
      }
      _getAlwaysInViewPort() {
        return true;
      }
      _getText(e) {
        const t = this._model.timeScale().indexToUserTime(e);
        if (t !== null) {
          return this._model.dateTimeFormatter().format(t);
        } else {
          return "";
        }
      }
      _updateImpl() {
        const e = this._rendererData;
        e.visible = false;
        if (this._model.timeScale().isEmpty() || !this._isVisible()) {
          return;
        }
        const t = this._getIndex();
        if (t !== null && Number.isFinite(t)) {
          e.visible = true;
          e.width = this._model.timeScale().width();
          e.background = this._getBgColor();
          e.color = (0, s.colorFromBackground)(e.background);
          e.coordinate = this._model.timeScale().indexToCoordinate(t);
          e.alwaysInViewPort = this._getAlwaysInViewPort();
          e.text = this._getText(t);
          this._invalidated = false;
        }
      }
    }
  },
  50503: (e, t, i) => {
    "use strict";

    i.d(t, {
      INVALID_TIME_POINT_INDEX: () => s,
      UNPLOTTABLE_TIME_POINT_INDEX: () => o
    });
    const s = -2000000;
    const o = -1000000;
  },
  11497: (e, t, i) => {
    "use strict";

    i.d(t, {
      restoreTimeHoursFormatSettingsValue: () => l,
      timeHoursFormatProperty: () => a
    });
    var s = i(56840);
    var o = i(17625);
    const n = "time_hours_format";
    function r() {
      return s.getValue(n, "24-hours");
    }
    const a = (0, o.createPrimitiveProperty)(r());
    function l() {
      a.setValue("24-hours");
      s.remove(n);
    }
    s.onSync.subscribe(null, () => a.setValue(r()));
    a.subscribe(null, () => s.setValue(n, a.value()));
  },
  55158: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      DAY_SPAN: () => a,
      DEFAULT_BAR_SPACING: () => d,
      HOUR_SPAN: () => r,
      MILLISECOND_SPAN: () => s,
      MINUTE_SPAN: () => n,
      MONTH_SPAN: () => c,
      SECOND_SPAN: () => o,
      WEEK_SPAN: () => l,
      YEAR_SPAN: () => h
    });
    const s = 5;
    const o = 10;
    const n = 20;
    const r = 30;
    const a = 40;
    const l = 50;
    const c = 60;
    const h = 70;
    const d = 6;
  },
  63146: (e, t, i) => {
    "use strict";

    i.d(t, {
      getHourMinuteFormat: () => o,
      getHourMinuteSecondFormat: () => n,
      getTimeFormatForInterval: () => r
    });
    var s = i(15344);
    function o(e) {
      if (e === "12-hours") {
        return s.twelveHourMinuteFormat;
      } else {
        return s.hourMinuteFormat;
      }
    }
    function n(e) {
      if (e === "12-hours") {
        return s.twelveHourMinuteSecondFormat;
      } else {
        return s.hourMinuteSecondFormat;
      }
    }
    function r(e, t) {
      if (e.isRange()) {
        return function (e) {
          if (e === "12-hours") {
            return s.twelveHourMinuteNonZeroSecondFormat;
          } else {
            return s.hourMinuteNonZeroSecondFormat;
          }
        }(t);
      }
      if (e.isTicks()) {
        return s.hourMinuteSecondMillisecFormat;
      }
      if (e.isSeconds() || e.isTicks()) {
        return n(t);
      } else {
        return o(t);
      }
    }
  },
  24708: (e, t, i) => {
    "use strict";

    i.d(t, {
      translatedIntervalString: () => o
    });
    var s = i(10074);
    function o(e) {
      const t = (0, s.getTranslatedResolutionModel)(e, true);
      if (t === null) {
        return e;
      } else {
        return t.multiplier + (t.mayOmitShortKind ? "" : t.shortKind);
      }
    }
  },
  70618: (e, t, i) => {
    "use strict";

    i.d(t, {
      ExcludeLineToolsFromGroupUndoCommand: () => h
    });
    var s = i(50151);
    i(21251);
    var o = i(11542);
    var n = i(45126);
    var r = i(37265);
    var a = i(60265);
    var l = i(85719);
    const c = new n.TranslatedString("exclude line tools from group {group}", o.t(null, undefined, i(99395)));
    class h extends a.UndoCommand {
      constructor(e, t, i) {
        super(c.format({
          group: t.name().value()
        }), undefined, !l.lineToolsDoNotAffectChartInvalidation);
        this._model = e;
        this._groupId = t.id;
        this._groupName = t.name().value();
        this._lineToolsIds = i.map(e => e.id());
      }
      redo() {
        const e = (0, s.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId));
        const t = this._lineToolsIds.map(e => this._model.dataSourceForId(e)).filter(r.notNull);
        e.excludeLineTools(t);
        if (e.lineTools().length === 0) {
          this._model.lineToolsGroupModel().removeGroup(e);
        }
      }
      undo() {
        const e = this._lineToolsIds.map(e => this._model.dataSourceForId(e));
        const t = this._model.lineToolsGroupModel().groupForId(this._groupId);
        if (t !== null) {
          t.addLineTools(e);
        } else {
          this._model.lineToolsGroupModel().createGroup(e, this._groupName, this._groupId);
        }
      }
    }
  },
  69661: (e, t, i) => {
    "use strict";

    i.d(t, {
      LineToolSynchronizeUndoCommand: () => o
    });
    var s = i(60265);
    class o extends s.UndoCommand {
      constructor(e, t, i, s = true) {
        super(t, i, s);
        this._invalidateViaSync = false;
        this._chartModel = e;
      }
      redo() {
        if (this._invalidateViaSync) {
          this._chartModel.lineToolsSynchronizer().executeSyncedAction(() => this._redo());
        } else {
          this._redo();
        }
      }
      undo() {
        if (this._invalidateViaSync) {
          this._chartModel.lineToolsSynchronizer().executeSyncedAction(() => this._undo());
        } else {
          this._undo();
        }
      }
    }
  },
  74174: (e, t, i) => {
    "use strict";

    i.d(t, {
      RemoveSourcesUndoCommand: () => y
    });
    var s = i(50151);
    var o = i(11542);
    var n = i(45126);
    var r = i(69661);
    var a = i(9343);
    var l = i(96286);
    var c = i(79036);
    var h = i(85719);
    var d = i(70618);
    class u extends r.LineToolSynchronizeUndoCommand {
      constructor({
        chartModel: e,
        title: t,
        lineDataSourceIds: i
      }) {
        super(e, t, undefined, !h.lineToolsDoNotAffectChartInvalidation);
        this._excludeLineToolsFromGroupUndoCommands = [];
        this._undoState = [];
        this._lineDataSourceIds = i;
      }
      _redo() {
        const e = this._lineDataSourceIds.map(e => (0, s.ensureNotNull)(this._chartModel.dataSourceForId(e)));
        this._groupLineToolsByGroups(e).forEach((e, t) => {
          const i = new d.ExcludeLineToolsFromGroupUndoCommand(this._chartModel, t, e);
          i.redo();
          this._excludeLineToolsFromGroupUndoCommands.push(i);
        });
        e.forEach(e => {
          this._undoState.push({
            state: e.state(false),
            paneIndex: this._chartModel.panes().indexOf((0, s.ensureNotNull)(this._chartModel.paneForSource(e))),
            sharingMode: e.sharingMode().value()
          });
          this._chartModel.removeSource(e);
        });
      }
      _undo() {
        for (let e = this._undoState.shift(); e; e = this._undoState.shift()) {
          this._chartModel.restoreSource(false, e.paneIndex, null, e.state, null)?.share(e.sharingMode);
        }
        this._excludeLineToolsFromGroupUndoCommands.forEach(e => e.undo());
      }
      _groupLineToolsByGroups(e) {
        const t = this._chartModel.lineToolsGroupModel();
        return e.reduce((e, i) => {
          const s = t.groupForLineTool(i);
          if (s !== null) {
            const t = e.get(s) || [];
            t.push(i);
            e.set(s, t);
          }
          return e;
        }, new Map());
      }
    }
    var _ = i(21239);
    var p = i(300);
    var m = i(78956);
    const g = (0, a.getLogger)("Chart.RemoveSourcesUndoCommand");
    const f = new n.TranslatedString("remove line data sources", o.t(null, undefined, i(38199)));
    class y extends r.LineToolSynchronizeUndoCommand {
      constructor(e, t, i) {
        super(e, i, undefined, (0, p.sourcesAffectState)(t));
        this._removeLineDataSourcesUndoCommand = null;
        this._initialPriceScaleMode = null;
        const [o, n] = (0, l.closeSourcesSet)(e, t).reduce((e, t) => {
          if ((0, m.isLineTool)(t)) {
            e[1].push(t.id());
          } else {
            e[0].push(t.id());
          }
          return e;
        }, [[], []]);
        this._sourceIds = o;
        this._lineDataSourceIds = n;
        this._sourceStates = [];
        this._paneIndexes = [];
        this._priceScalePositionIds = [];
        this._paneStates = [];
        this._restorePanes = [];
        const r = t[0];
        if (t.length === 1 && (0, c.isStudy)(r)) {
          this._initialPriceScaleMode = (0, s.ensureNotNull)(r.priceScale()).mode();
        }
      }
      removedIds() {
        return [...this._sourceIds, ...this._lineDataSourceIds];
      }
      _redo() {
        this._chartModel.panes().length;
        const e = this._sourceIds.map(e => (0, s.ensureNotNull)(this._chartModel.dataSourceForId(e)));
        this._sourceStates = e.map(e => {
          const t = e.state(false);
          if (t === null && (0, c.isStudyStub)(e)) {
            return e.getDescriptor();
          } else {
            return t;
          }
        });
        const t = e.map(e => (0, s.ensureNotNull)(this._chartModel.paneForSource(e)));
        this._paneIndexes = t.map(e => this._chartModel.panes().indexOf(e));
        if (this._lineDataSourceIds.length > 0) {
          this._removeLineDataSourcesUndoCommand = new u({
            title: f,
            chartModel: this._chartModel,
            lineDataSourceIds: this._lineDataSourceIds
          });
          this._removeLineDataSourcesUndoCommand.redo();
        }
        this._priceScalePositionIds = e.map((e, i) => {
          const s = e.priceScale();
          if (s === null) {
            return null;
          }
          const o = t[i].priceScalePosition(s);
          return {
            id: s.id(),
            position: o,
            priceScaleIndex: t[i].priceScaleIndex(s, o)
          };
        });
        const i = new Set();
        e.forEach((e, t) => {
          i.add(this._paneIndexes[t]);
        });
        this._paneStates = e.map((e, s) => {
          const o = this._paneIndexes[s];
          if (i.has(o)) {
            return t[s].state(false, true);
          } else {
            return null;
          }
        });
        this._restorePanes = e.map(e => this._chartModel.removeSource(e));
      }
      _undo() {
        const e = [];
        for (let t = this._sourceStates.length - 1; t >= 0; t--) {
          const i = this._sourceStates[t];
          if (i !== null) {
            let s = null;
            s = (0, _.isStudyStubDescriptor)(i) ? this._chartModel.restoreStudyStub(i) : this._chartModel.restoreSource(this._restorePanes[t], this._paneIndexes[t], this._paneStates[t], i, this._priceScalePositionIds[t]);
            if (s) {
              e.push(s);
            }
          }
        }
        if (e.some((t, i) => t.id() !== this._sourceIds[e.length - i - 1])) {
          g.logError("Source was restored improperly - source ids does not match");
        }
        if (this._initialPriceScaleMode !== null) {
          (0, s.ensureNotNull)(e[0].priceScale()).setMode(this._initialPriceScaleMode);
        }
        if (this._removeLineDataSourcesUndoCommand) {
          this._removeLineDataSourcesUndoCommand.undo();
        }
      }
    }
  },
  96286: (e, t, i) => {
    "use strict";

    function s(e, t) {
      let i = [];
      const o = e.children(t, false);
      for (let t = 0; t < o.length; t++) {
        i = i.concat(s(e, o[t]));
      }
      i.push(t);
      return i;
    }
    function o(e, t) {
      const i = new Set();
      const o = t => {
        e.children(t, false).forEach(e => {
          if (!i.has(e)) {
            i.add(e);
            o(e);
          }
        });
      };
      t.forEach(o);
      return t.filter(e => !i.has(e)).map(t => s(e, t)).reduce((e, t) => e.concat(t), []);
    }
    i.d(t, {
      closeSourcesSet: () => o
    });
  },
  60265: (e, t, i) => {
    "use strict";

    i.d(t, {
      UndoCommand: () => o
    });
    var s = i(45126);
    class o {
      constructor(e, t = true, i = true) {
        this._text = e || new s.TranslatedString("", "");
        this._executeOnPush = t;
        this._affectsState = i;
      }
      text() {
        return this._text;
      }
      executeOnPush() {
        return this._executeOnPush;
      }
      affectsState() {
        return this._affectsState;
      }
      canMerge(e) {
        return false;
      }
      merge(e) {
        throw new Error("Should be re-implemented in child classes");
      }
    }
  },
  17656: (e, t, i) => {
    "use strict";

    i.d(t, {
      createVisibilityController: () => d
    });
    var s;
    var o = i(11542);
    var n = i(32563);
    var r = i(17625);
    var a = i(56840);
    (function (e) {
      e.AlwaysOn = "alwaysOn";
      e.VisibleOnMouseOver = "visibleOnMouseOver";
      e.AlwaysOff = "alwaysOff";
    })(s ||= {});
    const l = "visibleOnMouseOver";
    function c(e) {
      if (e === "alwaysOn" || e === "alwaysOff") {
        return e;
      } else {
        return l;
      }
    }
    var h;
    function d(e, t) {
      let s;
      let h;
      function d() {
        if (!s) {
          s = (0, r.createPrimitiveProperty)();
          let i = a.getValue(e);
          if (i === undefined && t !== undefined) {
            i = a.getValue(t);
          }
          s.setValue(c(i));
          s.subscribe(s, t => {
            a.setValue(e, c(t.value()));
          });
        }
        return s;
      }
      return {
        property: d,
        availableValues: function () {
          return [{
            id: "visibleOnMouseOver",
            value: "visibleOnMouseOver",
            title: n.mobiletouch ? o.t(null, undefined, i(58302)) : o.t(null, undefined, i(10309))
          }, {
            id: "alwaysOn",
            value: "alwaysOn",
            title: o.t(null, undefined, i(36299))
          }, {
            id: "alwaysOff",
            value: "alwaysOff",
            title: o.t(null, undefined, i(40452))
          }];
        },
        actualBehavior: function () {
          if (!h) {
            h = (0, r.createPrimitiveProperty)();
            const e = d();
            const t = () => {
              const t = function (e) {
                switch (e) {
                  case "alwaysOn":
                    return "alwaysOn";
                  case "alwaysOff":
                    return "alwaysOff";
                  case "visibleOnMouseOver":
                    if (n.mobiletouch) {
                      return "visibleOnTapSelection";
                    } else {
                      return "visibleOnMouseOver";
                    }
                  default:
                    throw new Error(`Unknown visibility type: ${e}`);
                }
              }(e.value());
              if (h) {
                h.setValue(t);
              }
            };
            e.subscribe(h, t);
            t();
          }
          return h;
        },
        restoreDefaultValue: function () {
          d().setValue(l);
          a.remove(e);
        }
      };
    }
    (function (e) {
      e.AlwaysOn = "alwaysOn";
      e.VisibleOnMouseOver = "visibleOnMouseOver";
      e.VisibleOnTapSelection = "visibleOnTapSelection";
      e.AlwaysOff = "alwaysOff";
    })(h ||= {});
  },
  94664: (e, t, i) => {
    "use strict";

    i.d(t, {
      getSymbolSearchCompleteOverrideFunction: () => n,
      setSymbolSearchCompleteOverrideFunction: () => o
    });
    let s = (e, t) => Promise.resolve({
      symbol: e,
      name: t?.symbol ?? e
    });
    function o(e) {
      s = e;
    }
    function n() {
      return s;
    }
  },
  5633: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyMetaInfoBase: () => g
    });
    var s = i(83873);
    var o = i(90054);
    var n = i(50151);
    var r = i(94113);
    var a = i(65383);
    var l = i(37265);
    var c = i(35039);
    const h = new Set(["CorrelationCoefficient@tv-basicstudies", "Correlation - Log@tv-basicstudies-1"]);
    const d = new Set([]);
    const u = new Set(["line", "shapes", "chars", "arrows", "alertcondition"]);
    const _ = new Map([["AnchoredVWAP@tv-basicstudies", "linetoolanchoredvwap"], ["RegressionTrend@tv-basicstudies", "linetoolregressiontrend"], ["VbPAnchored@tv-basicstudies", "linetoolanchoredvp"]]);
    const p = /^([^\$]+)\$\d+$/;
    const m = ["bool", "color", "time", "text_area"];
    class g {
      constructor(e, t = false) {
        (0, l.merge)(this, {
          palettes: {},
          inputs: [],
          plots: [],
          graphics: {},
          defaults: {}
        });
        (0, l.merge)(this, e);
        const i = e.fullId || e.id;
        (0, l.merge)(this, g.parseIdString(i));
        this._updateInputDisplayDefaults();
        this.useVersionFromMetaInfo = t;
      }
      state() {
        const e = {};
        for (const [t, i] of Object.entries(this)) {
          if (t !== "useVersionFromMetaInfo" && this.hasOwnProperty(t)) {
            e[t] = (0, o.default)(i);
            if (t === "id") {
              e[t] += "-" + this.version;
            }
          }
        }
        return e;
      }
      createDefaults() {
        if (this.defaults) {
          const e = (0, l.clone)(this.defaults);
          e.precision = "default";
          const t = g.getStudyPropertyRootName(this);
          (0, c.createDefaults)(t, e);
        }
      }
      removeDefaults() {
        (0, c.removeDefaults)(g.getStudyPropertyRootName(this));
      }
      isPlotForceOverlay(e) {
        const t = this.styles?.[e];
        const i = this.plots.find(t => t.id === e);
        return !!t?.forceOverlay || i && (0, r.isOhlcPlot)(i) && this.ohlcPlots?.[i.target]?.forceOverlay || !!this.ohlcPlots?.[e]?.forceOverlay;
      }
      hasForceOverlayPlots() {
        return this.plots.some(e => this.isPlotForceOverlay(e.id)) || Object.values(this.ohlcPlots ?? {}).some(e => !!e?.forceOverlay);
      }
      static getSourceIdsByInputs(e, t) {
        if (!Array.isArray(e) || !t) {
          return [];
        }
        const i = [];
        for (const o of e) {
          if (g.isSourceInput(o) && (0, s.default)(t[o.id])) {
            const e = t[o.id];
            if (e.includes("$")) {
              i.push(e.split("$")[0]);
            }
          }
        }
        return i;
      }
      static isSourceInput(e) {
        return Boolean(e.id && ((e.id === "source" || e.id === "src") && (e.type === "text" || e.type === "source") || e.type === "source"));
      }
      static getSourceInputIds(e) {
        const t = [];
        for (const i of e.inputs) {
          if (g.isSourceInput(i)) {
            t.push(i.id);
          }
        }
        return t;
      }
      static setChildStudyMetaInfoPropertiesSourceId(e, t, i) {
        for (const s of e.inputs) {
          if (!g.isSourceInput(s)) {
            continue;
          }
          const e = i.childs().inputs && i.childs().inputs.childs()[s.id];
          if (e) {
            const i = e.value();
            const s = p.exec(i);
            if (s?.length === 2) {
              if (s[1] === "{pid}") {
                const s = i.replace(/^[^\$]+/, t);
                e.setValue(s);
              }
            }
          }
        }
      }
      static patchSoSInputs(e, t) {
        const i = e => {
          const i = p.exec(e);
          if (i?.length === 2) {
            const s = i[1];
            const o = `${(0, n.ensureNotNull)(t(s))}`;
            return e.replace(/^[^\$]+/, o);
          }
          return e;
        };
        for (const t in e) {
          if (/in_[\d+]/.test(t) || t === "source") {
            const o = e[t];
            if ((0, s.default)(o)) {
              e[t] = i(o);
            } else if ((0, a.isExtendedInput)(o) && (0, a.isExtendedInputSource)(o)) {
              o.v = i(o.v);
            }
          }
        }
      }
      static canBeChild(e) {
        if ((0, s.default)(e)) {
          return true;
        }
        if (!e) {
          return false;
        }
        if (e.extra && !g.isAllowedSourceInputsCount(e.extra.sourceInputsCount) || e.canNotBeChild === true || e.canBeChild === false || h.has(e.id)) {
          return false;
        }
        let t = 0;
        for (const i of e.inputs) {
          if (g.isSourceInput(i)) {
            t += 1;
          }
        }
        return g.isAllowedSourceInputsCount(t);
      }
      static isAllowedSourceInputsCount(e) {
        return e === 1;
      }
      static canHaveChildren(e) {
        if (e) {
          if (e.isTVScriptStrategy || e.TVScriptSourceCode && isStrategy(e.TVScriptSourceCode)) {
            return false;
          }
          if (e.id && !d.has(e.id) && Array.isArray(e.plots)) {
            for (const t of e.plots) {
              if (u.has(t.type)) {
                return true;
              }
            }
          }
        }
        return false;
      }
      static getChildSourceInputTitles(e, t, i) {
        const s = {};
        if (t.plots && t.plots.length && e.options && e.options.length) {
          for (const o of e.options) {
            const e = o ? +o.split("$")[1] : NaN;
            const n = isFinite(e) && t.plots[e];
            if (n && u.has(n.type)) {
              s[o] = t.styles && t.styles[n.id] && t.styles[n.id]?.title || n.id;
              if (i) {
                s[o] = i + ":\u2009" + s[o];
              }
            }
          }
        }
        return s;
      }
      static canPlotBeSourceOfChildStudy(e) {
        return u.has(e);
      }
      static getStudyPropertyRootName(e) {
        const t = _.get(e.id);
        if (t !== undefined) {
          return t;
        }
        let i = "study_" + e.id;
        if (e.pine && e.pine.version) {
          i += "_" + e.pine.version.replace(".", "_");
        }
        return i;
      }
      static getStudyPropertyRootNameById(e) {
        const t = _.get(e);
        if (t !== undefined) {
          return t;
        } else {
          return "study_" + e;
        }
      }
      static isScriptStrategy(e) {
        return false;
      }
      static isReplayStrategy(e) {
        return e.id === "ReplayStrategy@tv-scripting";
      }
      static parseIdString(e) {
        return function (e) {
          const t = {};
          if (e.indexOf("@") === -1) {
            t.shortId = e;
            t.packageId = "tv-basicstudies";
            t.id = e + "@" + t.packageId;
            t.version = 1;
          } else {
            const i = e.split("@");
            t.shortId = i[0];
            const s = i[1].split("-");
            if (s.length === 3) {
              t.packageId = s.slice(0, 2).join("-");
              t.id = t.shortId + "@" + t.packageId;
              t.version = parseInt(s[2]);
            } else if (s.length === 1 && s[0] === "decisionbar") {
              t.packageId = "les-" + s[0];
              t.id = t.shortId + "@" + t.packageId;
              t.version = 1;
            } else {
              if (s.length !== 1) {
                throw new Error("unexpected study id:" + e);
              }
              t.packageId = "tv-" + s[0];
              t.id = t.shortId + "@" + t.packageId;
              t.version = 1;
            }
          }
          t.fullId = t.id + "-" + t.version;
          if (t.packageId === "tv-scripting") {
            const e = t.shortId;
            if (e.indexOf("Script$") === 0 || e.indexOf("StrategyScript$") === 0) {
              const i = e.indexOf("_");
              t.productId = i >= 0 ? e.substring(0, i) : t.packageId;
            } else {
              t.productId = t.packageId;
            }
          } else {
            t.productId = t.packageId;
          }
          return t;
        }(e);
      }
      _updateInputDisplayDefaults() {
        this.inputs.filter(e => e.display === undefined).forEach(e => {
          if (m.includes(e.type)) {
            e.display = a.InputDisplayFlags.None;
          } else {
            e.display = a.InputDisplayFlags.All;
          }
        });
      }
    }
  },
  68159: (e, t, i) => {
    "use strict";

    i.d(t, {
      StudyMetaInfo: () => h,
      getStudyIdWithVersion: () => c
    });
    var s = i(9343).getLogger("Chart.Study.MetaInfo");
    var o = i(9343).LOGLEVEL;
    var n = i(78749).applyOverridesToStudyDefaults;
    var r = i(18112).getPersistentLogger;
    var a = i(5633).StudyMetaInfoBase;
    var l = {};
    function c(e) {
      return h.cutDollarHash(e.id) + "-" + e.version;
    }
    class h extends a {
      static versionOf(e) {
        var t = "_metainfoVersion" in e && isNumber(e._metainfoVersion) ? e._metainfoVersion : 0;
        if (t < 0) {
          s.logError("Metainfo format version cannot be negative: " + t);
        }
        return t;
      }
      static getPackageName(e) {
        const t = /^[^@]+@([^-]+-[^-]+)/.exec(e || "");
        if (t === null || t.length === 0 || !t[1]) {
          r()?.addPersistentLogEntry(`getStudyPackageName: study id ${e} with stack ${new Error().stack}`, o.INFO, "chart.StudyMetaInfo");
        }
        return (t || [0, "tv-basicstudies"])[1];
      }
      static cutDollarHash(e) {
        var t = e.indexOf("$");
        var i = e.indexOf("@");
        if (t === -1) {
          return e;
        } else {
          return e.substring(0, t) + (i >= 0 ? e.substring(i) : "");
        }
      }
      static hasUserIdSuffix(e) {
        return /^USER;[\d\w]+;\d+$/.test(e);
      }
      static hasPubSuffix(e) {
        return /^PUB;.+$/.test(e);
      }
      static hasStdSuffix(e) {
        return /^STD;.+$/.test(e);
      }
      static isStandardPine(e) {
        return /^(Strategy)?Script\$STD;.*@tv-scripting$/.test(e);
      }
      static getStudyIdWithLatestVersion(e) {
        const t = h.cutDollarHash(e.id);
        let i = t;
        if (i === "ReplayStrategy@tv-scripting") {
          i += "-581!";
        } else if (t.indexOf("@tv-scripting") >= 0) {
          i += "-101!";
        } else if (t.endsWith("CP@tv-basicstudies")) {
          i += "-" + Math.min(e.version, 207);
        } else if (t.endsWith("CP@tv-chartpatterns")) {
          i += "-" + Math.min(e.version, 9);
        } else if (t.endsWith("@tv-volumebyprice")) {
          i += "-" + e.version + "!";
        } else {
          i += "-" + e.version;
        }
        return i;
      }
      defaultInputs() {
        var e = [];
        for (var t = 0; t < this.inputs.length; t++) {
          e.push(this.inputs[t].defval);
        }
        return e;
      }
      symbolInputId() {
        var e = this.inputs.filter(function (e) {
          return e.type === "symbol";
        });
        if (e.length > 0) {
          return e[0].id;
        } else {
          return null;
        }
      }
      static findStudyMetaInfoByDescription(e, t) {
        if (e) {
          for (var i = 0; i < e.length; ++i) {
            if (e[i].description.toLowerCase() === t.toLowerCase()) {
              return e[i];
            }
          }
          throw new Error("unexpected study id:" + t);
        }
        throw new Error("There is no studies metainfo");
      }
      static isParentSourceId(e) {
        return typeof e == "string" && /^[^\$]+\$\d+$/.test(e);
      }
      static overrideDefaults(e) {
        if (e.length !== 0) {
          n(l, e, function (e) {
            return TradingView.defaultProperties[h.getStudyPropertyRootName(e)] || null;
          });
        }
      }
      static mergeDefaultsOverrides(e) {
        TradingView.merge(l, e);
      }
    }
    TradingView.StudyMetaInfo = h;
  },
  81503: (e, t, i) => {
    "use strict";

    window.TradingView = window.TradingView || {};
    i(32563).setClasses();
    i(44286);
    i(56186).install();
    i(49483);
    i(37265);
    i(21251);
    i(11417);
    i(86129);
    i(55561);
    i(56840);
  },
  23291: (e, t, i) => {
    "use strict";

    var s = i(81251);
    var o = i(20057);
    var n = i(50151);
    var r = i(36986);
    var a = i(11542);
    i(20041);
    i(17192);
    i(69681);
    i(73052);
    i(95047);
    var l = i(56570);
    const c = (0, r.getChartingLibraryGlobalContext)();
    JSON.parse(c.urlParams.disabledFeatures).forEach(e => {
      l.setEnabled(e, false);
    });
    JSON.parse(c.urlParams.enabledFeatures).forEach(e => {
      l.setEnabled(e, true);
    });
    i(81503);
    var h = i(35039);
    i(80437);
    var d = i(56840);
    var u = i.n(d);
    const _ = (0, r.getChartingLibraryGlobalContext)();
    const p = (0, r.getChartingLibraryOwner)();
    _.__settingsOverrides = p.settingsOverrides || {};
    const m = p.settingsAdapter;
    if (m != null) {
      d.setSettingsAdapter(m);
      d.sync();
    } else if (l.enabled("use_localstorage_for_settings")) {
      d.sync();
    }
    var g = i(15938);
    const f = (0, r.getChartingLibraryGlobalContext)();
    if (f.urlParams.customFontFamily) {
      (0, g.setChartFontFamily)(f.urlParams.customFontFamily);
    }
    var y = i(38881);
    class v extends y.ChunkLoader {
      _startLoading() {
        return Promise.all([i.e(8356), i.e(3703), i.e(3953), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(7384), i.e(2197), i.e(2736), i.e(4066), i.e(6489), i.e(9766), i.e(4353), i.e(3362), i.e(3745), i.e(4876), i.e(5168), i.e(6164), i.e(5975), i.e(2444), i.e(779), i.e(8054), i.e(2227), i.e(8402), i.e(2544), i.e(3999), i.e(653), i.e(5516)]).then(i.bind(i, 95230)).then(e => e.getRestrictedToolSet());
      }
    }
    var S;
    var b;
    var w = i(72894);
    var C = i(10048);
    function P(e = [], t = []) {
      const i = document.createElement("div");
      const s = document.createElement("div");
      i.appendChild(s);
      i.classList.add(C.container);
      s.classList.add(C.inner);
      e.forEach(e => {
        i.classList.add(C[e]);
      });
      t.forEach(e => {
        i.classList.add(C[e]);
      });
      return i;
    }
    (function (e) {
      e.Top = "border-top";
      e.Right = "border-right";
      e.Bottom = "border-bottom";
      e.Left = "border-left";
    })(S ||= {});
    (function (e) {
      e.TopLeft = "top-left-radius";
      e.TopRight = "top-right-radius";
      e.BottomLeft = "bottom-left-radius";
      e.BottomRight = "bottom-right-radius";
    })(b ||= {});
    class T extends y.ChunkLoader {
      constructor(e, t) {
        super();
        this._toolsBootloader = e;
        this._headerProps = t;
        this._headerProps.resizerBridge.negotiateHeight(w.HEADER_TOOLBAR_HEIGHT_EXPANDED);
        this._headerProps.resizerBridge.container.value().appendChild(P());
      }
      _startLoading() {
        return Promise.all([this._toolsBootloader.load(), this._loadHeaderToolbar()]).then(([e, t]) => new t(this._headerProps.resizerBridge.container.value(), {
          ...this._headerProps,
          tools: e
        }));
      }
      _loadHeaderToolbar() {
        return Promise.all([i.e(8370), i.e(4256), i.e(2227), i.e(3005)]).then(i.bind(i, 39214)).then(e => e.HeaderToolbarRenderer);
      }
    }
    var x = i(6307);
    var I = i(27235);
    class M extends y.ChunkLoader {
      constructor(e) {
        super();
        this._opts = e;
        if (x.isDrawingToolbarVisible.value()) {
          this._opts.resizerBridge.negotiateWidth(I.TOOLBAR_WIDTH_EXPANDED);
          this._opts.resizerBridge.container.value().appendChild(P());
        }
      }
      _startLoading() {
        return Promise.all([i.e(2134), i.e(3703), i.e(3953), i.e(4178), i.e(5826), i.e(9481), i.e(2197), i.e(2736), i.e(9766), i.e(4353), i.e(5375), i.e(3362), i.e(6842), i.e(5975), i.e(5699), i.e(2227), i.e(4931), i.e(2544), i.e(769), i.e(1890), i.e(7843), i.e(2878)]).then(i.bind(i, 37159)).then(e => new e.DrawingToolbarRenderer(this._opts.resizerBridge.container.value(), {
          ...this._opts
        }));
      }
    }
    var A = i(97990);
    var L = i(32563);
    var k = i(85662);
    var D = i(45345);
    var E = i(64289);
    var B = i(26709);
    var V = i(3343);
    function R(e) {
      if (typeof e == "number") {
        return e;
      }
      switch (e.toLowerCase()) {
        case "ctrl":
          return V.Modifiers.Control;
        case "shift":
          return V.Modifiers.Shift;
        case "alt":
          return V.Modifiers.Alt;
        default:
          return e.toUpperCase().charCodeAt(0);
      }
    }
    function N(e) {
      let t = 0;
      for (let i = 0; i < e.length; i++) {
        t |= R(e[i]);
      }
      return t;
    }
    var O = i(97488);
    var F = i(64147);
    var W = i(76422);
    var H = i(22980);
    function z(e, t) {
      if (l.enabled("saveload_requires_authentication")) {
        (0, H.runOrSigninWithFeature)(e, {
          ...t,
          feature: "savedCharts"
        });
      } else {
        e();
      }
    }
    i(21251);
    l.enabled("atsv2s");
    var U;
    (function (e) {
      e[e.OneSecond = 1000] = "OneSecond";
      e[e.OneMinute = 60000] = "OneMinute";
      e[e.TwoMinutes = 120000] = "TwoMinutes";
      e[e.ThreeMinutes = 180000] = "ThreeMinutes";
      e[e.FiveMinutes = 300000] = "FiveMinutes";
      e[e.SevenMinutes = 420000] = "SevenMinutes";
      e[e.TenMinutes = 600000] = "TenMinutes";
      e[e.TwentyMinutes = 1200000] = "TwentyMinutes";
      e[e.ThirtyMinutes = 1800000] = "ThirtyMinutes";
      e[e.Year = 31536000000] = "Year";
    })(U ||= {});
    var j = i(39076);
    async function G() {
      return true;
    }
    var q = i(3615);
    const $ = l.enabled("confirm_overwrite_if_chart_layout_with_name_exists");
    class K {
      constructor(e, t, i) {
        this._visibility = new F.WatchedValue(false);
        this._chartWidgetCollection = e;
        this._doSave = t;
        this._doLoad = i;
      }
      hide() {
        this._hide?.();
        this._visibility.setValue(false);
      }
      visible() {
        return this._visibility.readonly();
      }
      _showDialog(e, t, s, o) {
        return (0, q.showRename)({
          title: this._dialogTitle(),
          text: this._dialogText(),
          maxLength: 64,
          emojiPicker: true,
          initValue: e,
          onRename: async e => {
            if (!$) {
              this._actionHandler(e, t, s, o);
              return;
            }
            const {
              newValue: n,
              dialogClose: r
            } = e;
            const l = (await this._doLoad()).find(e => e.name === n);
            r();
            if (l !== undefined) {
              this._hide = await (0, q.showConfirm)({
                title: a.t(null, undefined, i(7219)),
                text: a.t(null, undefined, i(67635)),
                onConfirm: ({
                  dialogClose: e
                }) => {
                  e();
                  this._doOverwriteExistingLayout(l.id, n, t, s, o);
                },
                onCancel: ({
                  dialogClose: e
                }) => {
                  e();
                  this._showDialog(n, t, s, o);
                }
              });
            } else {
              this._actionHandler({
                newValue: n,
                dialogClose: r
              }, t, s, o);
            }
          },
          onClose: () => this._visibility.setValue(false)
        });
      }
      _doSaveCurrentLayout(e, t, i, s) {
        const o = this._chartWidgetCollection.metaInfo.name.value();
        this._chartWidgetCollection.metaInfo.name.setValue(e);
        this._doSave(t, i, () => {
          this._chartWidgetCollection.metaInfo.name.setValue(o);
          s?.();
        });
      }
      _doOverwriteExistingLayout(e, t, i, s, o) {
        const n = this._chartWidgetCollection.metaInfo.name.value();
        this._chartWidgetCollection.metaInfo.id.setValue(e);
        this._chartWidgetCollection.metaInfo.name.setValue(t);
        this._doSave(i, s, () => {
          this._chartWidgetCollection.metaInfo.name.setValue(n);
          o?.();
        });
      }
    }
    class Y extends K {
      cloneChart() {
        this._cloneChart().then(() => this._visibility.setValue(true));
      }
      show() {
        z(() => this.cloneChart(), {
          source: "Clone chart"
        });
      }
      _dialogTitle() {
        return a.t(null, undefined, i(66134));
      }
      _dialogText() {
        return a.t(null, undefined, i(9541)) + ":";
      }
      _actionHandler({
        newValue: e,
        dialogClose: t
      }) {
        if (l.enabled("saveload_storage_customization")) {
          this._doCloneCurrentLayout(e);
        }
        t();
      }
      async _cloneChart() {
        let e;
        try {
          e = await G();
        } catch {
          showErrorDialog({
            content: a.t(null, undefined, i(73013))
          });
          return;
        }
        if (e) {
          this._hide = await this._showDialog(this._getInitialRenameDialogInput());
        }
      }
      _doCloneCurrentLayout(e) {
        const t = this._chartWidgetCollection.metaInfo.name.value();
        this._chartWidgetCollection.metaInfo.uid.deleteValue();
        this._chartWidgetCollection.metaInfo.id.deleteValue();
        this._chartWidgetCollection.metaInfo.name.setValue(e);
        this._doSave(undefined, undefined, () => {
          this._chartWidgetCollection.metaInfo.name.setValue(t);
        });
      }
      _getInitialRenameDialogInput() {
        return a.t(null, {
          context: "ex: AAPL chart copy"
        }, i(97559)).format({
          title: this._chartWidgetCollection.metaInfo.name.value()
        });
      }
    }
    class Z extends K {
      show(e, t, i) {
        const s = typeof e == "function" ? e : undefined;
        this._saveNewChart(s, t, i).then(() => this._visibility.setValue(true));
      }
      _dialogTitle() {
        return a.t(null, undefined, i(43047));
      }
      _dialogText() {
        return a.t(null, undefined, i(9541)) + ":";
      }
      _actionHandler({
        newValue: e,
        dialogClose: t
      }, i, s, o) {
        this._doSaveCurrentLayout(e, i, s, o);
        t();
      }
      async _saveNewChart(e, t, s) {
        let o;
        try {
          o = await G();
        } catch {
          showErrorDialog({
            content: a.t(null, undefined, i(73013))
          });
          return;
        }
        const n = this._chartWidgetCollection.metaInfo.name.value();
        this._hide = await this._showDialog(n, e, t, s);
      }
    }
    class X extends K {
      show() {
        z(() => this._show(), {
          source: "Rename chart"
        });
      }
      _dialogTitle() {
        return a.t(null, undefined, i(22584));
      }
      _dialogText() {
        return a.t(null, undefined, i(9541)) + ":";
      }
      _actionHandler({
        newValue: e,
        dialogClose: t
      }) {
        this._doSaveCurrentLayout(e);
        t();
      }
      async _show() {
        await this._renameChart();
        this._visibility.setValue(true);
      }
      async _renameChart() {
        const e = this._chartWidgetCollection.metaInfo.name.value();
        this._hide = await this._showDialog(e);
      }
    }
    class J {
      constructor(e, t) {
        this._autosaveTimer = null;
        this._watchedAutoSaveEnabled = new F.WatchedValue();
        this._toggleAutoSaveEnabledHandler = this._toggleAutoSaveEnabled.bind(this);
        this._doSave = (e, t, i, s) => {
          if (e !== undefined) {
            e();
          }
          const o = this._chartChangesWatcher.changes();
          this._chartSaver.saveChartSilently(e => {
            var i;
            if (e && e.uid === this.layoutId()) {
              i = e.uid;
              if (location.pathname === "/chart/") {
                location.href = "/chart/" + i;
              }
            }
            if (t !== undefined) {
              t(e);
            }
          }, () => {
            if (i !== undefined) {
              i();
            }
          }, {
            autoSave: Boolean(s),
            changes: o
          });
        };
        this._doLoad = () => j.backend.getCharts();
        this._chartWidgetCollection = e;
        this._chartSaver = t;
        this._createController = new Z(e, this._doSave, this._doLoad);
        this._renameController = new X(e, this._doSave, this._doLoad);
        this._saveAsController = new Y(e, this._doSave, this._doLoad);
        this._chartChangesWatcher = new A.ChartChangesWatcher(e, t, W);
        e.saveKeysPressed().subscribe(this, this.saveChartOrShowTitleDialog);
        this._chartChangesWatcher.getOnChange().subscribe(this, this._onStateChanged);
        if (l.enabled("saveload_separate_drawings_storage")) {
          const e = true;
          if (e) {
            this._enableAutoSave();
          }
          this._watchedAutoSaveEnabled.setValue(e);
          this._watchedAutoSaveEnabled.subscribe(this._toggleAutoSaveEnabledHandler);
          this._autoSaveEnabledSetting?.getOnChange().subscribe(this, this._autoSaveEnabledSettingHandler);
        }
      }
      autoSaveEnabled() {
        return this._watchedAutoSaveEnabled;
      }
      destroy() {
        if (l.enabled("saveload_separate_drawings_storage")) {
          this._watchedAutoSaveEnabled.unsubscribe();
          delete this._watchedAutoSaveEnabled;
          this._autoSaveEnabledSetting?.destroy();
          delete this._autoSaveEnabledSetting;
        }
      }
      getCreateController() {
        return this._createController;
      }
      getRenameController() {
        return this._renameController;
      }
      getSaveAsController() {
        return this._saveAsController;
      }
      cloneChart() {
        this._saveAsController.cloneChart();
      }
      createEmptyChart() {
        this._createEmptyController?.show();
      }
      saveChartAs() {
        this._saveAsController.show();
      }
      renameChart() {
        this._renameController.show();
      }
      saveNewChart(e, t, i) {
        this._createController.show(e, t, i);
      }
      saveExistentChart(e, t, i) {
        this._doSave(e, t, i);
      }
      changes() {
        return this._chartChangesWatcher.changes();
      }
      hasChanges() {
        return this._chartChangesWatcher.changes() !== 0;
      }
      hasChangesWV() {
        return this._chartChangesWatcher.hasChangesWV();
      }
      getOnChanges() {
        return this._chartChangesWatcher.getOnChange();
      }
      saveChartOrShowTitleDialog(e, t, i) {
        const s = window.saver.isSaveInProcess();
        const o = this._chartChangesWatcher.hasChanges();
        const n = !!this.layoutId();
        if (!window.is_authenticated || !s && (!!o || !n)) {
          z(() => {
            if (this._chartWidgetCollection.metaInfo.id.value() != null) {
              this.saveExistentChart(e, t, i);
            } else {
              this.saveNewChart(e, t, i);
            }
          }, {
            source: "Save chart",
            sourceMeta: "Chart"
          });
        }
      }
      saveToJSON(e) {
        return this._chartSaver.saveToJSON(e);
      }
      saveChartSilently(e, t, i) {
        this._chartSaver.saveChartSilently(e, t, i);
      }
      setAutoSaveEnabled(e) {
        if (!window.is_authenticated || !window.saver.isSaveInProcess()) {
          z(() => {
            this._watchedAutoSaveEnabled.setValue(e);
          }, {
            source: "AutoSave chart"
          });
        }
      }
      saveChartLineTools(e, t, i, s) {
        return this._chartSaver.saveChartLineTools(e, t, i, s);
      }
      layoutId() {
        return this._chartWidgetCollection.metaInfo.uid.value();
      }
      _autoSaveEnabledSettingHandler(e) {
        0;
      }
      _toggleAutoSaveEnabled(e) {
        0;
      }
      _enableAutoSave() {
        0;
      }
      _disableAutoSave() {
        0;
      }
      _onStateChanged(e) {
        if (e) {
          this._startAutosave();
        } else {
          this._stopAutosave();
        }
      }
      _startAutosave() {
        if (l.enabled("charts_auto_save") && this._autosaveTimer === null) {
          this._autosaveTimer = setTimeout(() => {
            this._autosaveTimer = null;
            if (this._chartWidgetCollection.metaInfo.id.value()) {
              this._doSave(undefined, undefined, undefined, true);
            }
          }, 60000);
        }
      }
      _stopAutosave() {
        if (this._autosaveTimer !== null) {
          clearInterval(this._autosaveTimer);
          this._autosaveTimer = null;
        }
      }
    }
    var Q = i(29280);
    i(14051);
    var ee = i(21097);
    var te = i(59063);
    class ie extends te.CommonJsonStoreService {
      constructor(e, t) {
        super(e, t, "FAVORITE_CHARTS_CHANGED", "loadChartDialog.favorites", {});
      }
    }
    function se() {
      return !l.enabled("saveload_requires_authentication") || !!window.is_authenticated;
    }
    class oe extends Q.DialogRenderer {
      constructor(e = null) {
        super();
        this._chartWidgetCollection = null;
        this._promise = null;
        this._dialog = null;
        this._onLoginStateChange = () => {
          if (!se()) {
            this._setState({
              chartList: [],
              favorites: {},
              recents: []
            });
          }
        };
        this._onActiveChartNameChange = e => {
          const {
            chartList: t
          } = this._state.value();
          const i = this._chartWidgetCollection;
          if (!i) {
            return;
          }
          const s = [];
          let o;
          t.forEach(t => {
            if (t.id === i.metaInfo.id.value()) {
              o = t;
              s.push({
                ...t,
                name: e
              });
              return;
            }
            s.push(t);
          });
          if (o) {
            this._setState({
              chartList: s
            });
          }
        };
        this._subscribe = e => {
          this._setVisibility(e);
        };
        this._getChartEntry = e => ({
          id: e.id,
          url: e.url,
          name: e.name,
          symbol: e.short_symbol,
          interval: e.interval,
          toolsCount: 0,
          modified: e.modified_iso,
          favorite: undefined,
          active: () => this._isActiveChart(e.id),
          openAction: (t, i) => this.loadChart(e, t, i),
          deleteAction: () => this._deleteChart(e),
          favoriteAction: () => this._handleFavorite(e)
        });
        this._isActiveChart = e => this._chartWidgetCollection !== null && e === this._chartWidgetCollection.metaInfo.id.value();
        this._deleteChart = e => j.backend.removeChart(e.image_url).then(() => {
          const {
            chartList: t,
            favorites: i
          } = this._state.value();
          const s = t.filter(t => t.id !== e.id);
          if (this._favoriteChartsService) {
            const t = {
              ...i
            };
            if (t[e.id]) {
              delete t[e.id];
            }
            this._favoriteChartsService.set(t);
          }
          if (se()) {
            this._setState({
              chartList: s
            });
          }
          if (this._isActiveChart(e.id)) {
            if (l.enabled("saveload_storage_customization") || isSymphonyEmbed()) {
              if (this._chartWidgetCollection !== null) {
                this._chartWidgetCollection.clearChartMetaInfo();
              }
            } else {
              location.href = "/chart/" + location.search;
            }
          }
        });
        this._chartWidgetCollection = e;
        this._favoriteChartsService = new ie(ee.TVXWindowEvents, d);
        const t = this._favoriteChartsService?.get() || {};
        this._state = new F.WatchedValue({
          chartList: [],
          recents: [],
          favorites: t
        });
        this._chartWidgetCollection?.metaInfo.name.subscribe(this._onActiveChartNameChange);
        window.loginStateChange.subscribe(null, this._onLoginStateChange);
      }
      showLoadDialog() {
        z(this._showLoadDialog.bind(this), {
          source: "Load chart",
          sourceMeta: "Chart"
        });
      }
      show() {
        this.showLoadDialog();
      }
      hide() {
        this._dialog?.hide();
        this._dialog?.visible().unsubscribe(this._subscribe);
      }
      state() {
        return this._state.readonly();
      }
      refreshChartList(e) {
        return (se() ? j.backend.getCharts() : Promise.resolve([])).then(t => {
          if (!se()) {
            return;
          }
          const i = t.map(this._getChartEntry);
          this._setState({
            chartList: i,
            favorites: this._initFavorites(i)
          });
          if (e !== undefined) {
            e();
          }
        });
      }
      getRecentCharts(e) { }
      async deleteAllFavorites() {
        return Promise.resolve();
      }
      async loadChart(e, t, i) {
        {
          const t = await j.backend.loadLayout(e);
          W.emit("chart_load_requested", t.chartWidgetCollectionState);
        }
      }
      async loadChartByUrl(e, t, i) {
        let s = this._state.value().chartList.find(t => t.url === e);
        if (!s) {
          await this.refreshChartList();
          s = this._state.value().chartList.find(t => t.url === e);
        }
        await s?.openAction(t, i);
      }
      async _handleFavorite(e) {
        const {
          favorites: t
        } = this._state.value();
        const i = {
          ...t
        };
        if (i[e.id]) {
          delete i[e.id];
        } else {
          i[e.id] = true;
        }
        this._favoriteChartsService?.set(i);
        if (se()) {
          this._setState({
            favorites: i
          });
        }
      }
      _showLoadDialog() {
        this.refreshChartList(() => {
          const e = this._promise = Promise.all([i.e(3357), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(9481), i.e(6445), i.e(3799), i.e(1072), i.e(2736), i.e(4066), i.e(9766), i.e(4353), i.e(625), i.e(4876), i.e(8692), i.e(6190), i.e(9967), i.e(9977), i.e(2227), i.e(4931), i.e(9418), i.e(2544), i.e(3999), i.e(5378), i.e(5009)]).then(i.bind(i, 55127)).then(t => {
            if (this._promise === e) {
              if (this._dialog) {
                this._dialog.hide();
                this._dialog.visible().unsubscribe(this._subscribe);
              }
              this._dialog = new t.LoadChartDialogRenderer({
                chartWidgetCollection: this._chartWidgetCollection,
                serviceState: this.state()
              });
              this._dialog.visible().subscribe(this._subscribe);
              this._dialog.show();
            }
          });
        });
      }
      _setState(e) {
        this._state.setValue({
          ...this._state.value(),
          ...e
        });
      }
      async _changeFavoriteState(e, t, i) {
        return Promise.resolve();
      }
      _initFavorites(e) {
        if (this._favoriteChartsService) {
          return this._favoriteChartsService.get();
        }
        const t = {};
        e.filter(e => e.favorite).forEach(e => {
          t[e.id] = true;
        });
        return t;
      }
    }
    var ne = i(51768);
    var re = i(52033);
    var ae = i(9343);
    const le = (0, ae.getLogger)("Platform.StudyTemplates");
    const ce = a.t(null, undefined, i(15096));
    class he {
      constructor(e) {
        this._chartWidgetCollection = e.chartWidgetCollection;
        this._recentStudyTemplatesService = e.recentStudyTemplatesService;
        window.loginStateChange.subscribe(null, j.backend.invalidateStudyTemplatesList);
        this._list = new F.WatchedValue([]);
        this._onChange = new re.Delegate();
        this._list.subscribe(() => this._onChange.fire());
      }
      findRecordByName(e) {
        return this._list.value().find(t => t.name === e) || null;
      }
      showSaveAsDialog(e) {
        const t = this._chartWidgetCollection.activeChartWidget.value().model();
        Promise.all([i.e(3597), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(5826), i.e(4600), i.e(2564), i.e(6445), i.e(3799), i.e(5480), i.e(5323), i.e(6489), i.e(9766), i.e(8222), i.e(5375), i.e(5083), i.e(601), i.e(4876), i.e(4137), i.e(9654), i.e(2227), i.e(4931), i.e(9418), i.e(2544), i.e(769), i.e(4411), i.e(6631)]).then(i.bind(i, 3606)).then(i => {
          new i.StudyTemplateSaver({
            controller: t,
            onSave: (e, t) => {
              if (t) {
                this._recentStudyTemplatesService?.add(t);
              }
              this._list.setValue(e);
            }
          }).show(e);
        });
      }
      applyTemplate(e) {
        const t = this.findRecordByName(e);
        if (t !== null) {
          window.runOrSignIn(() => {
            const e = this._chartWidgetCollection.activeChartWidget.value();
            const i = i => {
              (0, ne.trackEvent)("GUI", "Load Study Template");
              e.model().applyStudyTemplate(JSON.parse(i.content), t.name);
            };
            if (t.is_default && typeof t.id == "number") {
              j.backend.getStandardStudyTemplateById(t.id, i);
            } else {
              j.backend.getStudyTemplateById(t.id).then(i);
            }
          }, {
            source: "Study templates apply"
          });
        } else {
          le.logNormal(`Template ${e} not found in cache`);
        }
      }
      deleteStudyTemplate(e, t, i) {
        const s = this.findRecordByName(e);
        if (s !== null) {
          this._removeTemplate(s, t, i);
        } else {
          le.logNormal(`Template ${e} not found in cache`);
        }
      }
      list() {
        return this._list.value();
      }
      getOnChange() {
        return this._onChange;
      }
      refreshStudyTemplateList(e) {
        j.backend.getStudyTemplatesList().then(t => {
          this._list.setValue(t);
          if (e !== undefined) {
            e();
          }
        });
      }
      invalidate() {
        j.backend.invalidateStudyTemplatesList();
      }
      _removeTemplate(e, t, i) {
        window.runOrSignIn(() => {
          (0, q.showConfirm)({
            text: ce.format({
              name: e.name
            }),
            onConfirm: ({
              dialogClose: t
            }) => new Promise(s => {
              j.backend.invalidateStudyTemplatesList();
              j.backend.removeStudyTemplate(e.id).then(() => {
                this.refreshStudyTemplateList(() => {
                  const o = this.list();
                  this._list.setValue(o.filter(t => t !== e));
                  if (this._recentStudyTemplatesService) {
                    this._recentStudyTemplatesService.remove(e.id);
                  }
                  s();
                  t();
                  i?.();
                });
              });
            })
          }, t);
        }, {
          source: "Study templates delete"
        });
      }
    }
    var de = i(82992);
    var ue = i(11345);
    var _e = i(24526);
    class pe {
      constructor(e, t) {
        this._visibility = new F.WatchedValue(false);
        this._dialogPromise = null;
        this._dialog = null;
        this._chartWidgetCollection = e;
        this._options = t;
      }
      visible() {
        return this._visibility.readonly();
      }
      show(e, t, i) {
        const s = Array.isArray(e) ? e : [];
        const o = Array.isArray(e) ? undefined : e;
        if (this._dialog === null) {
          this._requestDialog(s ?? [], t, i, o);
        }
        this._dialog?.open(s ?? [], this._options?.indicatorsPreloader?.getIndicatorPromises(), t, i, o);
      }
      hide() {
        this._dialog?.hide();
      }
      getDialog() {
        return this._dialog;
      }
      resetAllPages() {
        this._dialog?.resetAllStudies();
      }
      _requestDialog(e, t, s, o) {
        if (this._dialogPromise === null) {
          let n;
          n = Promise.all([i.e(2530), i.e(3703), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(6445), i.e(1072), i.e(9325), i.e(2736), i.e(7572), i.e(9967), i.e(643), i.e(2227), i.e(9418), i.e(5378), i.e(6456)]).then(i.bind(i, 37020)).then(e => new e.IndicatorsLibraryContainer(this._chartWidgetCollection, this._options));
          this._dialogPromise = n.then(i => {
            this._dialog = i;
            this._dialog.visible().subscribe(e => {
              this._visibility.setValue(e);
            });
            this._dialog.open(e, this._options?.indicatorsPreloader?.getIndicatorPromises(), t, s, o);
          });
        }
        return this._dialogPromise;
      }
    }
    var me = i(14426);
    var ge = i(31054);
    var fe = i(92184);
    var ye = i(42752);
    var ve = i(60859);
    var Se = i(51613);
    var be = i(63829);
    var we = i(11497);
    var Ce = i(2740);
    var Pe = i(63950);
    var Te = i(23998);
    const xe = /^Etc\/GMT([+-])(\d{1,2}):?(\d\d)?$/;
    const Ie = new Map();
    function Me(e) {
      if (Ie.has(e)) {
        return Ie.get(e);
      }
      const t = xe.test(e);
      Ie.set(e, t);
      return t;
    }
    const Ae = new Map();
    function Le(e) {
      if (Ae.has(e)) {
        return Ae.get(e);
      }
      const t = function (e) {
        const t = e.match(xe);
        if (!t) {
          return 0;
        }
        const i = t[1] === "+" ? -1 : 1;
        return (parseInt(t[2], 10) * 60 + parseInt(t[3] || "0", 10)) * 60 * i;
      }(e);
      const i = {
        time: [1924992000 + t],
        offset: [t]
      };
      Ae.set(e, i);
      return i;
    }
    let ke = null;
    const De = new Map();
    class Ee {
      constructor() {
        this._customTimezones = new Map();
      }
      addTimezones(e) {
        e.forEach(e => {
          const {
            id: t,
            ...i
          } = e;
          this._addTimezone(t, i);
        });
        this.updateChartTimezones();
      }
      listTimezoneIds() {
        return [...this._customTimezones.keys()];
      }
      listTimezones() {
        return [...this._customTimezones.entries()].map(([e, t]) => ({
          id: e,
          ...t
        }));
      }
      getTimezoneInfo(e) {
        if (!this.timezoneIsAvailable(e)) {
          throw new Error("Provided timezone alias is not within the list of supported timezones.");
        }
        return (0, n.ensure)(this._customTimezones.get(e));
      }
      getAllTimezoneInfo() {
        return this.listTimezones();
      }
      getAliasTimezone(e) {
        return this.getTimezoneInfo(e).alias;
      }
      timezoneIsAvailable(e) {
        return this._customTimezones.has(e);
      }
      updateChartTimezones() {
        (0, Pe.updateAvailableTimezones)(this.getAllTimezoneInfo());
      }
      getTimezoneData(e) {
        if (De.has(e)) {
          return De.get(e);
        }
        let t = null;
        if (Me(e)) {
          t = Le(e);
        } else if (this.timezoneIsAvailable(e)) {
          const i = this.getAliasTimezone(e);
          if (Te.tzData[i]) {
            t = Te.tzData[i];
          }
          if (!t && Me(i)) {
            t = Le(i);
          }
        }
        if (t) {
          De.set(e, t);
        }
        return t;
      }
      static instance() {
        if (ke === null) {
          ke = new Ee();
        }
        return ke;
      }
      _addTimezone(e, t) {
        try {
          (0, n.ensure)(e, "Custom timezone ID");
          (0, n.ensure)(t.alias, "Custom timezone alias");
          (0, n.ensure)(t.title, "Custom timezone title");
          if ((0, Pe.timezoneIsAvailable)(e) && !this.timezoneIsAvailable(e)) {
            throw new Error("Custom timezone id already exists.");
          }
          if (!(0, Pe.timezoneIsSupported)(t.alias) && !Me(t.alias)) {
            throw new Error("Custom timezone alias is not a supported timezone.");
          }
          if (e.length < 1) {
            throw new Error("Custom timezone id is empty");
          }
          if (t.title.length < 1) {
            throw new Error("Custom timezone title is empty");
          }
          this._customTimezones.set(e, t);
        } catch (e) {
          console.warn(`Unable to add custom timezone. ${e}`);
        }
      }
    }
    (0, Ce.setCustomTimezones)(Ee);
    var Be = i(50788);
    let Ve = null;
    var Re = i(85049);
    class Ne {
      constructor(e) {
        this._alive = new F.WatchedValue();
        this._container = new F.WatchedValue();
        this._width = new F.WatchedValue();
        this._height = new F.WatchedValue();
        this._fullscreen = new F.WatchedValue();
        this._detachable = new F.WatchedValue();
        this._fullscreenable = new F.WatchedValue();
        this._visible = new F.WatchedValue();
        this._availWidth = new F.WatchedValue();
        this._availHeight = new F.WatchedValue();
        this._owner = new F.WatchedValue();
        this._ownersStack = [];
        this.owner = this._owner.readonly();
        this._bridge = {
          alive: this._alive.readonly(),
          container: this._container.readonly(),
          width: this._width.readonly(),
          height: this._height.readonly(),
          fullscreen: this._fullscreen.readonly(),
          detachable: this._detachable.readonly(),
          fullscreenable: this._fullscreenable.readonly(),
          visible: this._visible.readonly(),
          availWidth: this._availWidth.readonly(),
          availHeight: this._availHeight.readonly(),
          remove: () => {
            const e = this._owner.value();
            if (e && e.remove) {
              e.remove();
            }
          },
          negotiateWidth: e => {
            const t = this._owner.value();
            if (t && t.negotiateWidth) {
              t.negotiateWidth(e);
            }
          },
          negotiateHeight: e => {
            const t = this._owner.value();
            if (t && t.negotiateHeight) {
              t.negotiateHeight(e);
            }
          },
          requestFullscreen: () => {
            const e = this._owner.value();
            if (e && e.requestFullscreen) {
              e.requestFullscreen();
            }
          },
          exitFullscreen: () => {
            const e = this._owner.value();
            if (e && e.exitFullscreen) {
              e.exitFullscreen();
            }
          },
          detach: e => {
            const t = this._owner.value();
            if (t && t.detach) {
              t.detach(e);
            }
          },
          attach: () => {
            const e = this._owner.value();
            if (e && e.attach) {
              e.attach();
            }
          }
        };
        if (e) {
          this.pushOwner(e);
        }
      }
      destroy() {
        for (const e of this._ownersStack) {
          this._unsubscribeOwner(e);
        }
      }
      bridge() {
        return this._bridge;
      }
      pushOwner(e) {
        if (!e.alive.value()) {
          return;
        }
        for (const e of this._ownersStack) {
          this._unsubscribeOwner(e);
        }
        const t = {
          owner: e
        };
        this._ownersStack.push(t);
        this._subscribeOwner(t);
      }
      _subscribeOwner(e) {
        const t = e.owner;
        if (!e.deathWatcher) {
          this._alive.setValue(true);
          e.deathWatcher = t.alive.spawn();
          e.deathWatcher.subscribe(t => {
            if (!t) {
              this._deadHandler(e);
            }
          });
        }
        this._owner.setValue(t);
        if (!e.subscriptions) {
          const i = e.subscriptions = [];
          this._visible.setValue(false);
          const s = (e, t) => {
            if (e) {
              const s = e.spawn();
              i.push(s);
              s.subscribe(e => {
                t.setValue(e);
              }, {
                callWithLast: true
              });
            } else {
              t.deleteValue();
            }
          };
          s(t.container, this._container);
          s(t.width, this._width);
          s(t.height, this._height);
          s(t.fullscreen, this._fullscreen);
          s(t.detachable, this._detachable);
          s(t.fullscreenable, this._fullscreenable);
          s(t.availWidth, this._availWidth);
          s(t.availHeight, this._availHeight);
          s(t.visible, this._visible);
        }
      }
      _unsubscribeOwner(e, t) {
        if (e.subscriptions) {
          for (const t of e.subscriptions) {
            t.unsubscribe();
          }
          e.subscriptions = null;
        }
        if (t && e.deathWatcher) {
          e.deathWatcher.unsubscribe();
          e.deathWatcher = null;
        }
      }
      _deadHandler(e) {
        const t = this._ownersStack.indexOf(e);
        (0, n.assert)(t !== -1, "sanitized owner should be in stack");
        for (let e = this._ownersStack.length - 1; e >= t; e--) {
          this._unsubscribeOwner(this._ownersStack[e], true);
        }
        this._ownersStack.length = t;
        if (t > 0) {
          this._subscribeOwner(this._ownersStack[t - 1]);
        } else {
          this._alive.setValue(false);
          this._owner.deleteValue();
        }
      }
    }
    class Oe {
      constructor(e) {
        this._document = e;
        this.isFullscreen = new F.WatchedValue();
        const t = () => {
          const e = ["fullscreenElement", "webkitFullscreenElement", "mozFullscreenElement", "mozFullScreenElement", "msFullscreenElement"];
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            if (i in this._document) {
              this.isFullscreen.setValue(!!this._document[i]);
              break;
            }
          }
        };
        t();
        for (const i of ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"]) {
          e.addEventListener(i, t, false);
        }
      }
      enter() {
        const e = this._document.documentElement;
        for (const t of ["requestFullscreen", "mozRequestFullScreen", "webkitRequestFullscreen", "msRequestFullscreen"]) {
          if (typeof e[t] == "function") {
            e[t]();
            break;
          }
        }
        this.isFullscreen.setValue(true);
      }
      exit() {
        const e = this._document;
        for (const t of ["exitFullscreen", "mozCancelFullScreen", "mozExitFullscreen", "webkitExitFullscreen", "msExitFullscreen"]) {
          if (typeof e[t] == "function") {
            e[t]();
            break;
          }
        }
        this.isFullscreen.setValue(false);
      }
    }
    class Fe {
      constructor(e) {
        let t;
        this.isVisible = new F.WatchedValue(true);
        let i = null;
        for (const s of ["", "moz", "ms", "webkit"]) {
          const o = s ? `${s}Hidden` : "hidden";
          if (o in e) {
            t = `${s}visibilitychange`;
            i = () => {
              this.isVisible.setValue(!e[o]);
            };
            i();
            e.addEventListener(t, i, false);
            break;
          }
        }
        this.destroy = () => {
          if (i) {
            e.removeEventListener(t, i, false);
            i = null;
          }
        };
      }
    }
    var We;
    var He = i(84015);
    var ze = i(49483);
    (function (e) {
      e.Quirks = "quirks";
      e.Visual = "visual";
    })(We ||= {});
    function Ue(e, t) {
      let i = 0;
      for (const {
        min: s,
        max: o
      } of t) {
        if (e < s || o < s) {
          continue;
        }
        const t = Math.min(e, o);
        i = Math.max(i, t);
        if (e === i) {
          break;
        }
      }
      return i;
    }
    function je(e) {
      const t = [];
      if (e === undefined) {
        return [];
      }
      if (!Array.isArray(e)) {
        e = [e];
      }
      for (const i of e) {
        let e;
        let s;
        if (isFinite(i)) {
          e = s = Number(i);
        } else {
          e = +i.min;
          s = +i.max;
        }
        if (e < 0 || isNaN(e)) {
          e = 0;
        }
        if (isNaN(s)) {
          s = Infinity;
        }
        if (e <= s && s > 0) {
          t.push({
            min: e,
            max: s
          });
        }
      }
      t.sort((e, t) => e.min - t.min || e.max - t.max);
      return t;
    }
    function Ge(e, t) {
      if (e.length !== t.length) {
        return false;
      }
      for (let i = e.length; i--;) {
        if (e[i].min !== t[i].min) {
          return false;
        }
        if (e[i].max !== t[i].max) {
          return false;
        }
      }
      return true;
    }
    const qe = l.enabled("no_min_chart_width");
    var $e;
    (function (e) {
      e[e.MinChartHeight = 300] = "MinChartHeight";
      e[e.MinChartWidth = 300] = "MinChartWidth";
      e[e.DefaultOffset = 4] = "DefaultOffset";
      e[e.ThinOffset = 1] = "ThinOffset";
      e[e.TopToolbarMargin = 0] = "TopToolbarMargin";
    })($e ||= {});
    const Ke = l.enabled("bypass_chart_height_check");
    function Ye(e) {
      const t = l.enabled("side_toolbar_in_fullscreen_mode");
      const i = l.enabled("header_in_fullscreen_mode");
      return e === "center" || e === "left" && t || e === "top" && i;
    }
    var Ze = i(42003);
    var Xe = i(77788);
    var Je = i(16216);
    i(9001);
    var Qe = i(16738);
    var et = i(83873);
    var tt = i(60265);
    const it = (0, ae.getLogger)("Common.UndoStack");
    class st {
      constructor() {
        this._commands = [];
        this._onChange = new re.Delegate();
      }
      onChange() {
        return this._onChange;
      }
      isEmpty() {
        return this._commands.length === 0;
      }
      size() {
        return this._commands.length;
      }
      clear() {
        if (!this.isEmpty()) {
          this._commands.length = 0;
          this._onChange.fire();
        }
      }
      push(e) {
        if (!(e instanceof tt.UndoCommand)) {
          throw new TypeError("argument must be an instance of UndoCommand");
        }
        this._commands.push(e);
        this._onChange.fire(e);
      }
      pop() {
        if (this.isEmpty()) {
          it.logDebug("pop: undo stack is empty");
          return;
        }
        const e = this._commands.pop();
        this._onChange.fire(e);
        return e;
      }
      head() {
        if (!this.isEmpty()) {
          return this._commands[this._commands.length - 1];
        }
      }
    }
    class ot extends tt.UndoCommand {
      constructor(e) {
        super(e, false);
        this._subcommands = [];
      }
      addCommand(e) {
        this._subcommands.push(e);
      }
      isEmpty() {
        return this._subcommands.length === 0;
      }
      redo(e) {
        for (let t = 0; t < this._subcommands.length; t++) {
          this._subcommands[t].redo(e);
        }
      }
      undo(e) {
        for (let t = this._subcommands.length - 1; t >= 0; t--) {
          this._subcommands[t].undo(e);
        }
      }
      commands() {
        return this._subcommands;
      }
      affectsState() {
        return this._subcommands.some(e => e.affectsState());
      }
    }
    class nt extends tt.UndoCommand {
      constructor(e, t, i, s, o = true) {
        super(s, undefined, o);
        this._setter = e;
        this._oldValue = t;
        this._newValue = i;
      }
      redo() {
        this._setter(this._newValue);
      }
      undo() {
        this._setter(this._oldValue);
      }
    }
    class rt extends nt {
      constructor(e, t, i, s, o = true) {
        super(e => this._vwState.setValue(e), t, i, s, o);
        this._vwState = e;
      }
    }
    const at = (0, ae.getLogger)("Common.UndoHistory");
    var lt = i(928);
    var ct = i(68335);
    var ht = i(91676);
    var dt = i(37265);
    var ut = i(14729);
    var _t = i(5171);
    var pt = i(36915);
    class mt extends Q.DialogRenderer {
      constructor(e) {
        super();
        this._dialog = null;
        this._subscribe = e => {
          this._setVisibility(e);
        };
        this._chartWidgetCollection = e;
      }
      show(e) {
        const t = this._chartWidgetCollection;
        const s = t.activeChartWidget.value();
        return s.generalPropertiesDefinitions().then(o => Promise.all([i.e(2486), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(2564), i.e(6445), i.e(7384), i.e(3799), i.e(2197), i.e(5480), i.e(5323), i.e(1072), i.e(9325), i.e(4066), i.e(116), i.e(8985), i.e(9766), i.e(8222), i.e(4106), i.e(7444), i.e(4353), i.e(5375), i.e(2440), i.e(9296), i.e(625), i.e(5083), i.e(3362), i.e(9255), i.e(7935), i.e(601), i.e(422), i.e(1531), i.e(8544), i.e(7519), i.e(7572), i.e(779), i.e(6710), i.e(2227), i.e(4931), i.e(9418), i.e(3202), i.e(2751), i.e(769), i.e(9928), i.e(7223), i.e(9443), i.e(3489), i.e(7078)]).then(i.bind(i, 56080)).then(i => {
          const n = new i.GeneralChartPropertiesDialogRenderer({
            chartWidgetCollection: t,
            propertyPages: o,
            activePageId: this._activePageId,
            model: s.model()
          });
          this._dialog?.hide();
          this._dialog?.visible().unsubscribe(this._subscribe);
          this._dialog = n;
          n.visible().subscribe(this._subscribe);
          n.show(e);
          this._activePageId = undefined;
          return n;
        }));
      }
      hide() {
        this._dialog?.hide();
      }
      isVisible() {
        return this.visible().value();
      }
      focusOnText() { }
      setActivePage(e) {
        this._activePageId = e;
      }
    }
    class gt extends Q.DialogRenderer {
      constructor(e) {
        super();
        this._dialog = null;
        this._subscribe = e => {
          this._setVisibility(e);
        };
        this._chartWidgetCollection = e;
      }
      show(e) {
        this._load().then(t => {
          this._dialog?.hide();
          this._dialog?.visible().unsubscribe(this._subscribe);
          this._dialog = t;
          t.visible().subscribe(this._subscribe);
          t.show(e);
          W.emit("compare_add");
        });
      }
      hide() {
        this._dialog?.hide();
      }
      _load() {
        return Promise.all([Promise.all([i.e(4040), i.e(7271)]).then(i.bind(i, 56217)), Promise.all([i.e(6703), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(2564), i.e(7384), i.e(2197), i.e(5323), i.e(1072), i.e(9325), i.e(116), i.e(8985), i.e(4106), i.e(7444), i.e(2444), i.e(7435), i.e(2227), i.e(4931), i.e(9418), i.e(2544), i.e(3202), i.e(2751), i.e(731)]).then(i.bind(i, 14283))]).then(([e, t]) => {
          const i = new e.CompareModel(this._chartWidgetCollection);
          return t.getCompareDialogRenderer(i);
        });
      }
    }
    var ft = i(29981);
    var yt = i(68805);
    const vt = () => i.e(4389).then(i.bind(i, 7960));
    function St(e, t = {}) {
      return vt().then(i => i.copyToClipboardImageOfChart(e, t));
    }
    function bt(e, t = {}) {
      return vt().then(i => i.getImageOfChartSilently(e, t));
    }
    var wt = i(15764);
    var Ct = i(68993);
    function Pt(e) {
      const t = e.querySelector("#chart-aria-description");
      if (t !== null) {
        return t;
      }
      const i = e.createElement("div");
      i.id = "chart-aria-description";
      i.tabIndex = -1;
      i.role = "alert";
      i.ariaLive = "assertive";
      e.body.appendChild(i);
      return i;
    }
    function Tt(e, t) {
      const i = {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: t ? "2-digit" : undefined,
        minute: t ? "2-digit" : undefined,
        hour12: true
      };
      return new Date(e * 1000).toLocaleString(undefined, i);
    }
    class xt {
      constructor() {
        this._ariaElement = null;
        this._customProvider = null;
        this._lastDescription = null;
        this._locale = "en";
      }
      createElement(e) {
        this._ariaElement = Pt(e);
      }
      setCustomProvider(e) {
        this._customProvider = e;
      }
      setLocale(e) {
        this._locale = e;
      }
      async updateChartDescription(e, t, i) {
        const s = function (e) {
          const t = Ct.layouts[e];
          return t?.count ?? 1;
        }(i);
        const o = await this._buildChartContext(e, t, s);
        if (o === null) {
          return;
        }
        if (this._customProvider) {
          const e = await this._customProvider(o);
          if (e !== null) {
            this._setChartDescription(e);
            return;
          }
        }
        if (this._locale !== "en") {
          return;
        }
        const n = function (e) {
          const t = function (e) {
            if (!l.enabled("aria_detailed_chart_descriptions") || !e.visibleData) {
              return "";
            }
            let t;
            try {
              t = function (e) {
                let t = e.schema.findIndex(e => e.type === "userTime");
                if (t < 0) {
                  t = e.schema.findIndex(e => e.type === "time");
                }
                if (t < 0) {
                  throw new Error("Exported Data should contain `time`.");
                }
                const i = It(e, e => e.type === "value" && e.sourceType === "series" && e.plotTitle === "close", -1);
                if (i < 0) {
                  throw new Error("Exported Data should contain `close`.");
                }
                const s = It(e, e => e.type === "value" && e.sourceType === "series" && e.plotTitle === "low", i);
                const o = It(e, e => e.type === "value" && e.sourceType === "series" && e.plotTitle === "high", i);
                const n = It(e, e => e.type === "value" && e.sourceType === "series" && e.plotTitle === "open", i);
                const r = e.data.map(e => ({
                  time: e[t],
                  open: e[n],
                  high: e[o],
                  low: e[s],
                  close: e[i]
                }));
                const a = {
                  start: r[0],
                  close: r[r.length - 1],
                  low: r[0],
                  high: r[0]
                };
                for (const e of r) {
                  if (e.high > a.high.high) {
                    a.high = e;
                  }
                  if (e.low < a.low.low) {
                    a.low = e;
                  }
                }
                return a;
              }(e.visibleData);
            } catch (e) {
              if (e instanceof Error) {
                console.warn("Unable to generate chart description. " + e.message);
              }
              return "";
            }
            const i = `The first price is ${e.priceFormatter.format(t.start.open)} at ${Tt(t.start.time)}.`;
            const s = `The last price is ${e.priceFormatter.format(t.close.close)} at ${Tt(t.close.time)}.`;
            const o = t.close.close - t.start.open;
            const n = o / t.start.open * 100;
            const r = `The actual change in price was ${e.priceFormatter.format(o)}, corresponding to a percentage change of ${n.toFixed(2)}%.`;
            let a = "";
            if (t.low.time !== t.start.time && t.low.time !== t.close.time) {
              a += `The lowest price was ${e.priceFormatter.format(t.low.low)} at ${Tt(t.low.time)}.`;
            }
            if (t.high.time !== t.start.time && t.high.time !== t.close.time) {
              a += ` The highest price was ${e.priceFormatter.format(t.high.high)} at ${Tt(t.high.time)}.`;
            }
            return `${i} ${s} ${r} ${a}`.trim();
          }(e);
          const i = function (e) {
            const t = e.description ?? e.symbol;
            const i = e.chartTypeName;
            const s = function (e) {
              if (e.chartCount <= 1) {
                return "";
              }
              return `Chart ${e.chartIndex + 1} of ${e.chartCount}. `;
            }(e);
            return `${s}${i} chart of ${t}`;
          }(e);
          return `${i}. ${t}`;
        }(o);
        this._setChartDescription(n);
      }
      static getInstance() {
        if (this._instance === null) {
          this._instance = new xt();
        }
        return this._instance;
      }
      async _getExportData(e, t) {
        return (await i.e(9498).then(i.bind(i, 99992))).exportData(e, t);
      }
      async _getData(e, t, i) {
        const s = e.model().model();
        return await this._getExportData(s, {
          from: t,
          to: i,
          includeTime: true,
          includeUserTime: true
        });
      }
      _setChartDescription(e) {
        if (!this._ariaElement) {
          return;
        }
        let t = e;
        if (e === this._lastDescription) {
          t += ".";
        }
        this._ariaElement.textContent = t;
        this._lastDescription = t;
      }
      async _buildChartContext(e, t, i) {
        const s = e.model().mainSeries().properties().childs().style.value();
        const o = s;
        const n = (0, yt.getTranslatedChartStyleName)(s);
        const r = e.model().mainSeries().symbolInfo();
        const a = e.model().timeScale();
        const c = a.visibleBarsStrictRange();
        if (!c) {
          return null;
        }
        const h = c.firstBar();
        const d = Math.min(c.lastBar(), a.baseIndex());
        const u = a.indexToTimePoint(h);
        const _ = a.indexToTimePoint(d);
        if (!u || !_) {
          return null;
        }
        let p;
        if (l.enabled("aria_detailed_chart_descriptions")) {
          p = await this._getData(e, u, _);
        }
        const m = e.model().mainSeries().interval();
        const g = Re.Interval.parse(m).isIntraday();
        return {
          chartType: o,
          chartTypeName: n,
          symbol: e.model().mainSeries().symbol(),
          description: r?.description,
          symbolInfo: r,
          exchange: r?.exchange,
          ticker: r?.ticker,
          visibleData: p,
          visibleRange: {
            from: u,
            to: _
          },
          chartCount: i,
          chartIndex: t,
          priceFormatter: e.model().mainSeries().formatter(),
          interval: m,
          isIntraday: g
        };
      }
    }
    function It(e, t, i) {
      const s = e.schema.findIndex(t);
      if (s >= 0) {
        return s;
      } else {
        return i;
      }
    }
    xt._instance = null;
    var Mt;
    var At = i(86441);
    var Lt = i(19625);
    var kt = i(24377);
    var Dt = i(27714);
    var Et = i(35236);
    var Bt = i(44672);
    var Vt = i(56468);
    var Rt = i(95201);
    var Nt = i(34026);
    var Ot = i(51056);
    var Ft = i(37743);
    var Wt = i(7114);
    var Ht = i(61993);
    (function (e) {
      e[e.SizeDelta = 1] = "SizeDelta";
    })(Mt ||= {});
    class zt {
      constructor(e, t, i) {
        this._data = e;
        this._hittest = t;
        this._textWidthCache = i;
      }
      draw(e, t) {
        const {
          horizontalPixelRatio: i,
          verticalPixelRatio: s
        } = t;
        const o = this._data.centerPoint;
        const n = Math.round(o.x * i);
        const r = Math.round(o.y * s);
        const a = Math.max(1, Math.floor(i)) % 2 / 2;
        const l = Math.max(1, Math.floor(s)) % 2 / 2;
        const c = new At.Point(n + a, r - l);
        this._drawLollipop(e, c, t);
        this._drawLabel(e, c, t);
      }
      hitTest(e) {
        const t = (0, Ht.interactionTolerance)().esd;
        const i = this._data.centerPoint.y - this._data.style.lollipop.height / 2 - t;
        const s = this._data.centerPoint.x - this._data.style.lollipop.width / 2 - t;
        const o = (0, At.box)(new At.Point(s, i), new At.Point(s + this._data.style.lollipop.width + t * 2, i + this._data.style.lollipop.height + t * 2));
        if ((0, Nt.pointInBox)(e, o)) {
          return this._hittest;
        } else {
          return null;
        }
      }
      _drawLollipop(e, t, i) {
        const s = this._data.style;
        const {
          horizontalPixelRatio: o
        } = i;
        const n = this._fillRadius(o);
        if (s.lollipop.fillCircle && s.lollipop.backgroundColor) {
          this._drawFilledCircle(e, t, n, s.lollipop.backgroundColor);
        }
        const r = Math.round(s.lollipop.lineWidth * o);
        const a = n - Math.round(o * 1 + r / 2);
        this._drawBorderLine(e, t, r, a);
        if (s.lollipop.fillCircle && s.lollipop.fillStyle) {
          this._drawFilledCircle(e, t, a, s.lollipop.fillStyle);
        }
      }
      _drawLabel(e, t, i) {
        const s = this._data.style.lollipop.text;
        const o = s.label;
        if (o === "") {
          return;
        }
        const {
          horizontalPixelRatio: n,
          verticalPixelRatio: r
        } = i;
        e.textAlign = "center";
        e.textBaseline = "middle";
        e.fillStyle = s.strokeStyle;
        e.font = s.font;
        const a = this._textWidthCache.yMidCorrection(e, o);
        e.translate(t.x, t.y + ((s.deltaY || 0) + a) * r);
        (0, Wt.drawScaled)(e, n, r, () => {
          e.fillText(o, 0, 0);
        });
      }
      _fillRadius(e) {
        const t = this._data.style;
        const i = Math.max(1, Math.floor(e));
        let s = Math.round(t.lollipop.width * e);
        if (s % 2 != i % 2) {
          s += 1;
        }
        return s / 2;
      }
      _drawBorderLine(e, t, i, s) {
        const o = this._data.style;
        e.strokeStyle = o.lollipop.strokeStyle;
        e.lineWidth = i;
        (0, Ft.setLineStyle)(e, Ot.LINESTYLE_SOLID);
        (0, Ft.createCircle)(e, t.x, t.y, s);
        e.stroke();
      }
      _drawFilledCircle(e, t, i, s) {
        e.fillStyle = s;
        (0, Ft.createCircle)(e, t.x, t.y, i);
        e.fill();
      }
    }
    var Ut;
    var jt = i(95173);
    var Gt = i(2844);
    var qt = i(72791);
    (function (e) {
      e[e.SpaceBetweenRows = 25] = "SpaceBetweenRows";
      e[e.TooltipTopMargin = 15] = "TooltipTopMargin";
      e[e.SpaceBetweenCardAndLollipop = 8] = "SpaceBetweenCardAndLollipop";
    })(Ut ||= {});
    class $t {
      constructor(e, t, i) {
        this._invalidated = false;
        this._renderer = new Rt.CompositeRenderer();
        this._textWidthCache = new Gt.TextWidthCache();
        this._stylesCache = null;
        this._lollipops = {};
        this._lollipopsCounter = 0;
        this._lastClickedId = new F.WatchedValue(null);
        this.onPaneBgChange = () => {
          this._recreateStyles(this._model);
        };
        this._model = e;
        this._source = t;
        this._clickHandler = i;
        this._recreateStyles(e);
        e.backgroundColor().subscribe(this.onPaneBgChange);
        e.mainSeries().onSymbolIntervalChanged().subscribe(this, this._onSymbolOrIntervalChanged);
        this._lastClickedId.subscribe(e => {
          if (e === null) {
            this._source.destroyTooltip();
          }
        });
        this._lastClickedId.subscribe(() => {
          this._source.model().updateSource(this._source);
          this.update((0, Bt.sourceChangeEvent)(this._source.id()));
        });
      }
      destroy() {
        this._model.backgroundColor().unsubscribe(this.onPaneBgChange);
        this._model.mainSeries().onSymbolIntervalChanged().unsubscribeAll(this);
      }
      processClickOutside(e, t) {
        const i = this._lastClickedId.value();
        if (i === null || !t) {
          this.clearLastClicked();
          return;
        }
        const s = (0, Et.getClickPosition)(t);
        if (s === null) {
          return;
        }
        const o = this._renderer.hitTest(new At.Point(s.x, s.y), e);
        if (o === null || o.data()?.activeItem !== (0, n.ensureDefined)(this._lollipops[i]).itemIndex) {
          this.clearLastClicked();
        }
      }
      processClickInside(e, t, i) {
        const s = this._lollipops[i];
        return !!s && !!s.visible && (s.active = !s.active, this._lollipopMouseClickHandler(e, this._getLollipopRendererData(s), (0, Dt.size)({
          width: t.clientWidth,
          height: t.clientHeight
        }), {
          preventDefault: () => { },
          target: t
        }), true);
      }
      clearLastClicked() {
        const e = this._lastClickedId.value();
        const t = e !== null && this._lollipops[e] || null;
        if (t !== null) {
          t.active = false;
          this.update((0, Bt.sourceChangeEvent)(this._source.id()));
          this._source.model().updateSource(this._source);
        }
        this._lastClickedId.setValue(null);
      }
      getLastClickedLollipopId() {
        return this._lastClickedId.value();
      }
      update(e) {
        this._invalidated = true;
      }
      afterUpdate(e, t, i, s) { }
      getStyle(e, t) {
        let i = t;
        if (e.stack) {
          i += "_stack:" + e.stack;
        }
        if (i === "active") {
          return this._activeStyle;
        }
        if (i === "hovered") {
          return this._hoveredStyle;
        }
        if (i === "default") {
          return this._defaultStyle;
        }
        this._stylesCache ||= {};
        if (!this._stylesCache[i]) {
          const s = (0, dt.clone)(t === "active" ? this._activeStyle : t === "hovered" ? this._hoveredStyle : this._defaultStyle);
          if (e.stack) {
            s.lollipop.incHeight = e.stack * 25;
          }
          this._stylesCache[i] = s;
        }
        return this._stylesCache[i];
      }
      hasTooltip(e) {
        return true;
      }
      _getY() {
        let e = 0;
        const t = this._model.panes();
        for (let i = t.length; i--;) {
          const s = t[i];
          if (s.containsMainSeries()) {
            e += s.height();
          }
        }
        return e;
      }
      _showBarLine(e) {
        return this.hasTooltip(e) && (e.hovered || e.active);
      }
      _getLollipopRendererData(e) {
        const t = this._getLollipopStatus(e);
        const i = this.getStyle(e, t);
        return {
          id: e.id,
          centerPoint: new At.Point(e.basePoint.x, e.basePoint.y - i.lollipop.bottom - i.lollipop.height / 2 - (i.lollipop.incHeight || 0)),
          style: i,
          status: t
        };
      }
      _createRenderers(e) {
        const {
          mediaSize: t
        } = e;
        this._renderer.clear();
        for (const i of Object.values(this._lollipops)) {
          if (i !== undefined && i.visible) {
            const s = this._getLollipopStatus(i);
            const o = this.getStyle(i, s);
            const n = {
              id: i.id,
              centerPoint: new At.Point(i.basePoint.x, i.basePoint.y - o.lollipop.bottom - o.lollipop.height / 2 - (o.lollipop.incHeight || 0)),
              style: o,
              status: s
            };
            const r = {
              cursorType: qt.PaneCursorType.Default,
              activeItem: i.itemIndex,
              hideCrosshairLinesOnHover: true,
              clickHandler: this._lollipopMouseClickHandler.bind(this, e, n, t),
              tapHandler: this._lollipopMouseClickHandler.bind(this, e, n, t)
            };
            this._renderer.append(this._createRendererForLollipop(n, r));
            if (this._showBarLine(i)) {
              const {
                strokeStyle: e,
                lineStyle: t,
                lineWidth: s
              } = o.barLine;
              const n = {
                color: e,
                linestyle: t,
                linewidth: s,
                x: i.basePoint.x,
                top: 0,
                bottom: i.basePoint.y - o.lollipop.bottom - o.lollipop.height
              };
              const r = new jt.VerticalLineRenderer();
              r.setData(n);
              this._renderer.insert(r, 0);
            }
          }
        }
      }
      _recreateStyles(e) {
        this._stylesCache = null;
      }
      _createRendererForLollipop(e, t) {
        return new zt(e, new Vt.HitTestResult(Vt.HitTarget.Custom, t), this._textWidthCache);
      }
      _onSymbolOrIntervalChanged() {
        this._lollipops = {};
        this._lollipopsCounter = 0;
        this._renderer.clear();
        this.clearLastClicked();
      }
      async _lollipopMouseClickHandler(e, t, i, s) {
        s.preventDefault();
        const o = t.id;
        this._lastClickedId.setValue(this._lastClickedId.value() === o ? null : o);
        const r = {
          target: s.target,
          targetSize: i,
          point: new At.Point(t.centerPoint.x, t.centerPoint.y - t.style.lollipop.height / 2 - 8),
          marginTop: 15
        };
        await this._clickHandler(this._lastClickedId.value() !== null, e, r, () => {
          const e = (0, n.ensureDefined)(this._lollipops[o]);
          return this._createTooltipContent(e);
        });
      }
      _getLollipopStatus(e) {
        if (e.active) {
          return "active";
        } else if (e.hovered) {
          return "hovered";
        } else {
          return "default";
        }
      }
    }
    var Kt;
    var Yt = i(68979);
    class Zt extends zt {
      _drawLollipop(e, t, i) {
        if (!this._imageLoaded()) {
          super._drawLollipop(e, t, i);
          return;
        }
        const s = this._data.style;
        const {
          horizontalPixelRatio: o
        } = i;
        const n = this._fillRadius(o);
        let r = Math.round(s.lollipop.lineWidth * o);
        let a = n - Math.round(o * 1 + r / 2);
        if (s.lollipop.fillCircle) {
          if (s.lollipop.backgroundColor) {
            this._drawFilledCircle(e, t, n, s.lollipop.backgroundColor);
          }
          if (s.lollipop.fillStyle) {
            this._drawFilledCircle(e, t, a, s.lollipop.fillStyle);
          }
        }
        if (this._data.style.lollipop.image?.imageElement) {
          const i = n - Math.round(o * 1 + r * 2);
          const s = i * 2;
          e.save();
          e.imageSmoothingEnabled = true;
          e.imageSmoothingQuality = "high";
          (0, Ft.createCircle)(e, t.x, t.y, i);
          e.clip();
          e.drawImage(this._data.style.lollipop.image.imageElement, t.x - i, t.y - i, s, s);
          e.restore();
        }
        if (this._data.status === "active") {
          a -= r / 2;
          r *= 1.5;
        }
        this._drawBorderLine(e, t, r, a);
      }
      _drawLabel(e, t, i) {
        if (!this._imageLoaded() || !!this._data.style.lollipop.text.showWhenImageLoaded) {
          super._drawLabel(e, t, i);
        }
      }
      _imageLoaded() {
        return Boolean(this._data.style.lollipop.image && this._data.style.lollipop.image.imageElement && this._data.style.lollipop.image.imageElement.complete && this._data.style.lollipop.image.imageElement.naturalWidth);
      }
    }
    (function (e) {
      e.PositiveEarningFillPath = "M8.961.92a3 3 0 0 1 3.078 0l7.5 4.48A3 3 0 0 1 21 7.975V20a3 3 0 0 1-3 3H3a3 3 0 0 1-3-3V7.975A3 3 0 0 1 1.461 5.4l7.5-4.48z";
      e.PositiveEarningStrokePath = "M9.867 2.742c.39-.23.875-.23 1.266 0l7.5 4.406c.382.225.617.635.617 1.078V20c0 .69-.56 1.25-1.25 1.25H3c-.69 0-1.25-.56-1.25-1.25V8.226c0-.443.235-.853.617-1.078l7.5-4.406z";
      e.NegativeEarningFillPath = "M8.961 23.08a3 3 0 0 0 3.078 0l7.5-4.48A3 3 0 0 0 21 16.025V4a3 3 0 0 0-3-3H3a3 3 0 0 0-3 3v12.025A3 3 0 0 0 1.461 18.6l7.5 4.48z";
      e.NegativeEarningStrokePath = "M9.866 21.257c.391.23.877.23 1.268 0l7.5-4.414a1.25 1.25 0 0 0 .616-1.078V4c0-.69-.56-1.25-1.25-1.25H3c-.69 0-1.25.56-1.25 1.25v11.765c0 .443.234.853.616 1.078l7.5 4.414z";
      e.DefaultEarningFillPath = "M3 0h15c1.662 0 3 1.338 3 3v15c0 1.662-1.338 3-3 3H3c-1.662 0-3-1.338-3-3V3c0-1.662 1.338-3 3-3z";
      e.DefaultEarningStrokePath = "M3 1.75h15c.693 0 1.25.557 1.25 1.25v15c0 .693-.557 1.25-1.25 1.25H3c-.692 0-1.25-.558-1.25-1.25V3c0-.692.558-1.25 1.25-1.25z";
    })(Kt ||= {});
    const Xt = {
      fillPath: new Path2D("M8.961.92a3 3 0 0 1 3.078 0l7.5 4.48A3 3 0 0 1 21 7.975V20a3 3 0 0 1-3 3H3a3 3 0 0 1-3-3V7.975A3 3 0 0 1 1.461 5.4l7.5-4.48z"),
      strokePath: new Path2D("M9.867 2.742c.39-.23.875-.23 1.266 0l7.5 4.406c.382.225.617.635.617 1.078V20c0 .69-.56 1.25-1.25 1.25H3c-.69 0-1.25-.56-1.25-1.25V8.226c0-.443.235-.853.617-1.078l7.5-4.406z")
    };
    const Jt = {
      fillPath: new Path2D("M8.961 23.08a3 3 0 0 0 3.078 0l7.5-4.48A3 3 0 0 0 21 16.025V4a3 3 0 0 0-3-3H3a3 3 0 0 0-3 3v12.025A3 3 0 0 0 1.461 18.6l7.5 4.48z"),
      strokePath: new Path2D("M9.866 21.257c.391.23.877.23 1.268 0l7.5-4.414a1.25 1.25 0 0 0 .616-1.078V4c0-.69-.56-1.25-1.25-1.25H3c-.69 0-1.25.56-1.25 1.25v11.765c0 .443.234.853.616 1.078l7.5 4.414z")
    };
    const Qt = {
      fillPath: new Path2D("M3 0h15c1.662 0 3 1.338 3 3v15c0 1.662-1.338 3-3 3H3c-1.662 0-3-1.338-3-3V3c0-1.662 1.338-3 3-3z"),
      strokePath: new Path2D("M3 1.75h15c.693 0 1.25.557 1.25 1.25v15c0 .693-.557 1.25-1.25 1.25H3c-.692 0-1.25-.558-1.25-1.25V3c0-.692.558-1.25 1.25-1.25z")
    };
    function ei(e, t, i, s, o) {
      const {
        horizontalPixelRatio: n,
        verticalPixelRatio: r
      } = i;
      e.save();
      e.translate(t.x - s.lollipop.width * n / 2, t.y - s.lollipop.height * r / 2);
      e.scale(n, r);
      if (s.lollipop.fillCircle && s.lollipop.backgroundColor) {
        e.fillStyle = s.lollipop.backgroundColor;
        e.fill(o.fillPath);
      }
      e.strokeStyle = s.lollipop.strokeStyle;
      e.lineWidth = Math.round(s.lollipop.lineWidth * n) / n;
      (0, Ft.setLineStyle)(e, Ot.LINESTYLE_SOLID);
      if (s.lollipop.fillCircle && s.lollipop.fillStyle) {
        e.fillStyle = s.lollipop.fillStyle;
        e.fill(o.strokePath);
      }
      e.stroke(o.strokePath);
      e.restore();
    }
    function ti(e, t, i, s) {
      ei(e, t, i, s, Xt);
    }
    function ii(e, t, i, s) {
      ei(e, t, i, s, Jt);
    }
    function si(e, t, i, s) {
      ei(e, t, i, s, Qt);
    }
    class oi extends zt {
      _drawLollipop(e, t, i) {
        const s = this._data.style;
        switch (s.shape) {
          case "earningUp":
            ti(e, t, i, s);
            break;
          case "earningDown":
            ii(e, t, i, s);
            break;
          case "earning":
            si(e, t, i, s);
            break;
          default:
            super._drawLollipop(e, t, i);
        }
      }
    }
    var ni;
    (function (e) {
      e[e.HoveredColorTransparency = 85] = "HoveredColorTransparency";
      e.ActiveTextColor = "rgba(255, 255, 255, 0.92)";
    })(ni ||= {});
    const ri = {
      backgroundDark: (0, Lt.getHexColorByName)("color-cold-gray-900"),
      backgroundLight: (0, Lt.getHexColorByName)("color-white")
    };
    class ai extends $t {
      constructor(e, t, i) {
        super(e, t, i);
        this.stylesCache = {};
        this.templatesCache = {};
        this._itemIndexToId = new Map();
        this.source = t;
      }
      clearCaches() {
        this.clearLastClicked();
        this._lollipops = {};
        this._lollipopsCounter = 0;
      }
      renderer(e) {
        if (this._invalidated) {
          this._createLollipops(e);
          this._invalidated = false;
        }
        return this._renderer;
      }
      getStyle(e) {
        const t = e.active ? "active" : e.hovered ? "hovered" : "default";
        return this._generateStyle(t, e);
      }
      hasTooltip(e) {
        return Boolean(e.items && e.items.length);
      }
      _createTooltipContent(e) {
        const t = e.items;
        if (t) {
          return [{
            type: "common",
            subTitle: Array.isArray(t) ? t.map(e => ({
              value: e
            })) : [{
              value: t
            }],
            style: {
              color: e.color
            }
          }];
        } else {
          return null;
        }
      }
      _createRendererForLollipop(e, t) {
        return new (e.style.lollipop.image ? Zt : oi)(e, new Vt.HitTestResult(Vt.HitTarget.Custom, t), this._textWidthCache);
      }
      async _lollipopMouseClickHandler(e, t, i, s) {
        (0, W.emit)("onTimescaleMarkClick", t.id);
        await super._lollipopMouseClickHandler(e, t, i, s);
      }
      _createLollipops(e) {
        const t = this._model.timeScale();
        const i = super._getY();
        const s = this._model.lastHittestData();
        const o = this._model.hoveredSource();
        const n = this.source.marks();
        const r = new Map();
        Object.keys(n).forEach(e => {
          const a = n[e];
          const l = a.id;
          const c = a.index;
          if (c != null) {
            const e = l === this.getLastClickedLollipopId();
            const n = this._lollipops[l];
            const h = n !== undefined ? n.itemIndex : this._lollipopsCounter++;
            if (!this._itemIndexToId.has(h)) {
              this._itemIndexToId.set(h, l);
            }
            const d = o === this.source && s !== null && s.activeItem === h;
            const u = (r.get(c) ?? -1) + 1;
            r.set(c, u);
            this._lollipops[l] = {
              id: l,
              itemIndex: h,
              basePoint: new At.Point(t.indexToCoordinate(c) + 1, i),
              hovered: d,
              active: e,
              label: a.label,
              color: a.color,
              items: a.tooltip,
              visible: true,
              stack: u,
              shape: a.shape,
              image: this._getImageForUrl(a.imageUrl),
              showLabelWhenImageLoaded: a.showLabelWhenImageLoaded,
              textColor: a.labelFontColor
            };
          }
        });
        super._createRenderers(e);
      }
      _getImageForUrl(e) {
        if (e) {
          return this.source.getImageElement(e);
        }
      }
      _generateStyle(e, t) {
        const {
          color: i,
          label: s,
          stack: o,
          shape: n,
          image: r,
          textColor: a
        } = t;
        let l = e + i + s + (this._model.dark().value() ? "dark" : "light");
        if (o !== undefined) {
          l += "_stack" + o;
        }
        if (!(l in this.stylesCache)) {
          const c = this._model.dark().value() ? ri.backgroundDark : ri.backgroundLight;
          let h;
          let d = i;
          if (e === "active") {
            h = i;
            d = "rgba(255, 255, 255, 0.92)";
          } else if (e === "hovered") {
            const e = (0, kt.tryParseRgba)(i);
            if (e !== null) {
              const t = e[3] * 0.15000000000000002;
              h = (0, kt.rgbaToString)((0, kt.rgba)(e[0], e[1], e[2], t));
            }
          }
          if (a) {
            d = a;
          }
          let u = 23;
          let _ = 23;
          let p = 1;
          let m = 0;
          if (n === "earning") {
            _ = 21;
            u = 21;
            p = 2;
          } else if (n === "earningUp") {
            u = 21;
            m = 1;
            p = 2;
          } else if (n === "earningDown") {
            u = 21;
            m = -0.5;
            p = 0.5;
          }
          const f = {
            barLine: {
              lineStyle: Ot.LINESTYLE_DASHED,
              lineWidth: 1,
              strokeStyle: i
            },
            lollipop: {
              width: u,
              height: _,
              bottom: p,
              backgroundColor: c,
              lineWidth: 1.5,
              fillStyle: h,
              strokeStyle: i,
              fillCircle: true,
              text: {
                label: s,
                deltaY: m,
                strokeStyle: d,
                font: (0, Yt.makeFont)(12, g.CHART_FONT_FAMILY, "bold"),
                showWhenImageLoaded: t.showLabelWhenImageLoaded
              },
              image: r
            },
            shape: n
          };
          if (o !== undefined) {
            f.lollipop.incHeight = o * 25;
          }
          this.stylesCache[l] = f;
        }
        return this.stylesCache[l];
      }
    }
    var li = i(32679);
    var ci = i(2718);
    var hi = i(19938);
    var di = i(29137);
    const ui = (0, ae.getLogger)("Chart.BarsMarksContainer");
    const _i = Math.round(new Date(2037, 0, 1).getTime() / 1000);
    var pi;
    (function (e) {
      e[e.MaxPlatesPerBar = 10] = "MaxPlatesPerBar";
    })(pi ||= {});
    class mi extends di.DataSource {
      constructor(e, t, i) {
        const s = e.onWidget();
        let o;
        o = s ? !e.hideIdeas() : !!l.enabled("bars_marks") && u().getBool("BarsMarksContainer.visibile", false);
        t.merge({
          visible: o
        });
        t.childs().visible.subscribe(null, t => {
          if (!s && !e.isSnapshot() && !!l.enabled("bars_marks")) {
            u().setValue("BarsMarksContainer.visibile", !!t.value());
          }
        });
        super(i);
        this._paneViews = [];
        this._model = e;
        this._properties = t;
        this._requests = [];
        this._marks = {};
        this._loadedRange = null;
        this._getDataTimeout = null;
        this._collectedRange = null;
        this._lastRange = null;
        const r = this._model.mainSeries();
        r.onSymbolIntervalChanged().subscribe(this, this.clearMarks);
        r.dataEvents().symbolResolved().subscribe(this, this.clearMarks);
        r.dataEvents().completed().subscribe(this, () => {
          const e = r.data();
          if (e.size() === 0) {
            return;
          }
          const t = (0, n.ensureNotNull)(e.first()).index;
          const i = (0, n.ensureNotNull)(e.last()).index;
          const s = this.timeScale();
          this.getData({
            start: s.indexToTimePoint(t) ?? Infinity,
            end: s.indexToTimePoint(i) ?? -Infinity
          });
        });
        this._initialize();
        this._pinnedTooltips = {};
      }
      destroy() {
        const e = this._model.mainSeries();
        e.onSymbolIntervalChanged().unsubscribeAll(this);
        e.dataEvents().symbolResolved().unsubscribeAll(this);
        e.dataEvents().completed().unsubscribeAll(this);
        super.destroy();
      }
      model() {
        return this._model;
      }
      properties() {
        return this._properties;
      }
      marks() {
        return this._marks;
      }
      pinTooltip(e, t) {
        this._pinnedTooltips[e] = t;
      }
      timeScale() {
        return this._model.timeScale();
      }
      getIntervalInTicks() {
        const e = this._model.mainSeries().properties().childs().interval.value();
        const t = Re.Interval.parse(e);
        if (!t.isValid()) {
          throw new TypeError("Unexpected interval");
        }
        if (t.isRange()) {
          return 60;
        } else {
          return t.inMilliseconds() / 1000;
        }
      }
      getVisibleTickMarksRange() {
        if (this.timeScale().isEmpty()) {
          return {
            start: 0,
            end: 0
          };
        }
        const e = (0, n.ensureNotNull)(this.timeScale().visibleBarsStrictRange());
        const {
          firstIndex: t,
          lastIndex: i
        } = (0, n.ensureNotNull)(this.timeScale().points().range().value());
        if (!(e.lastBar() > t) || !(e.firstBar() < i)) {
          return {
            start: 0,
            end: 0
          };
        }
        let s;
        s = e.lastBar() < i ? this.timeScale().indexToTimePoint(e.lastBar()) : _i;
        const o = {
          start: this.timeScale().indexToTimePoint(Math.max(e.firstBar(), t)),
          end: s
        };
        return {
          start: o.start ?? Infinity,
          end: o.end ?? -Infinity
        };
      }
      getVisibleRangePlates() {
        const e = [];
        const t = this.getVisibleTickMarksRange();
        const i = this.getIntervalInTicks();
        Object.keys(this._marks).forEach(s => {
          const o = this._marks[s];
          const n = o.tickmark;
          if (n >= (t.start ?? Infinity) && n <= (t.end ?? -Infinity) + i) {
            e.push(o);
          }
        });
        return e;
      }
      getPublishedPlates() {
        const e = {};
        if (window.is_authenticated) {
          this.getVisibleRangePlates().forEach(t => {
            if (t.is_public && (this._pinnedTooltips[t.id] || t.user__id === window.user.id)) {
              e[t.id] = t;
            }
          });
          return e;
        } else {
          return e;
        }
      }
      filterDisplayedPlates(e) {
        const t = e.reduce((e, t) => {
          const i = this._getIndex(t.tickmark);
          if (i !== null) {
            e[i] = e[i] || [];
            e[i].push(t);
          }
          return e;
        }, {});
        return Object.keys(t).reduce((e, i) => {
          let s = t[i];
          s = s.sort((e, t) => t.views_count - e.views_count);
          s = s.slice(0, 10);
          return e.concat(s);
        }, []);
      }
      getPlatesViewData() {
        const e = this._model.mainSeries();
        if (e.data().isEmpty()) {
          return [];
        }
        const t = (0, yt.isPriceSourceStyle)(e.style()) ? e.barFunction() : null;
        const i = this.filterDisplayedPlates(this.getVisibleRangePlates());
        const s = {};
        const o = this._model.lastHittestData() ?? this._model.lastSelectedHittestData();
        let r = null;
        if (o !== null && this._model.hoveredSource() === this) {
          r = o.activeItem ?? null;
        }
        const a = [];
        for (const e of i) {
          const i = (0, n.ensureNotNull)(this._getIndex(e.tickmark));
          const o = this._getBar(i);
          if (o === null) {
            continue;
          }
          const l = this._layout(e.direction);
          const c = this._theme(e.direction);
          const h = r === e.id;
          const d = this.timeScale().indexToCoordinate(i);
          const u = this._offset(l, o, t);
          const _ = (0, n.ensureNotNull)(this.priceScale()).isInverted();
          let p = 0;
          if (!(i in s)) {
            s[i] = {
              up: 0,
              down: 0
            };
          }
          p = s[i][l]++;
          a.push({
            id: e.id,
            x: d,
            y: u,
            yInverted: _,
            order: p,
            direction: l,
            theme: c,
            hovered: h,
            pinned: this._pinnedTooltips[e.id] === true,
            user__id: e.user__id,
            label: e.label,
            labelFontColor: e.labelFontColor || "#444",
            minSize: e.minSize || 5,
            ...this._plateViewData(e)
          });
        }
        const l = a.filter(e => e.hovered === true);
        for (let e = 0; e < i.length; e++) {
          if (i[e].user__id === l[0]?.user__id) {
            i[e].highlightByAuthor = true;
          }
        }
        a.sort((e, t) => e.hovered && !t.hovered ? 1 : 0);
        return a;
      }
      priceAxisViews() {
        return null;
      }
      updateAllViews(e) {
        for (const t of this._paneViews) {
          t.update(e);
        }
      }
      updateAllViewsAndRepaint() {
        this.updateAllViews((0, Bt.sourceChangeEvent)(this.id()));
        this._model.updateSource(this);
      }
      roundRange(e) {
        return {
          start: Math.round(e.start),
          end: Math.round(e.end)
        };
      }
      refreshData() {
        if (this._lastRange !== null) {
          this.getData(this._lastRange);
        }
      }
      getData(e) {
        if ((0, dt.isNumber)(e.start) && (0, dt.isNumber)(e.end)) {
          this._lastRange = e;
          e.end = _i;
          this._pushGetDataStack(Object.assign({}, e));
        } else {
          ui.logError("Wrong range");
        }
      }
      clearMarks() {
        this._abortAllRequests();
        this._marks = {};
        this._loadedRange = null;
      }
      isUserDeletable() {
        return false;
      }
      isSavedInChart(e) {
        return false;
      }
      isSpeciallyZOrderedSource() {
        return true;
      }
      showInObjectTree() {
        return false;
      }
      _plateViewData(e) {
        return {};
      }
      _layout(e) {
        switch (e) {
          default:
          case 0:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            return "up";
          case 1:
            return "down";
        }
      }
      _theme(e) {
        switch (e) {
          default:
          case 0:
            return "neutral";
          case 1:
          case 5:
            return "green";
          case 2:
          case 6:
            return "red";
          case 3:
            return "yellow";
          case 4:
            return "blue";
        }
      }
      _offset(e, t, i) {
        let s;
        switch (e) {
          default:
          case "up":
            s = i === null ? t[2] : i(t);
            break;
          case "down":
            s = i === null ? t[3] : i(t);
        }
        return (0, n.ensureNotNull)(this.priceScale()).priceToCoordinate(s, (0, n.ensureNotNull)((0, n.ensureNotNull)(this.ownerSource()).firstValue()));
      }
      _getIndex(e) {
        return this.timeScale().timePointToIndex(e);
      }
      _getBar(e) {
        return this._model.mainSeries().data().valueAt(e);
      }
      _rangeDifference(e) {
        e = Object.assign({
          start: Infinity,
          end: -Infinity
        }, e);
        if (this._loadedRange) {
          if (e.start < this._loadedRange.start) {
            e.end = this._loadedRange.start;
          } else if (e.end > this._loadedRange.end) {
            e.start = this._loadedRange.end;
          }
        }
        return e;
      }
      _rangeUnion(e, t) {
        e = Object.assign({
          start: Infinity,
          end: -Infinity
        }, e);
        if (t) {
          e.start = Math.min(t.start, e.start);
          e.end = Math.max(t.end, e.end);
        }
        return e;
      }
      _pushGetDataStack(e) {
        if ((0, dt.isNumber)(e.start) && (0, dt.isNumber)(e.end)) {
          if (this._getDataTimeout) {
            clearTimeout(this._getDataTimeout);
          }
          this._collectedRange = this._rangeUnion(e, this._collectedRange);
          this._getDataTimeout = setTimeout(() => {
            this._getData(this._collectedRange);
            this._getDataTimeout = this._collectedRange = null;
          }, 300);
        } else {
          ui.logError("Wrong tickmark range");
        }
      }
      _abortAllRequests() {
        this._requests.forEach(e => {
          e.cancel();
        });
        this._requests = [];
        if (this._getDataTimeout) {
          clearTimeout(this._getDataTimeout);
        }
        this._getDataTimeout = this._collectedRange = null;
      }
    }
    const gi = (0, ae.getLogger)("Chart.UserDefinedImageMarks");
    class fi extends mi {
      constructor() {
        super(...arguments);
        this._imageItems = new Map();
        this._destroyed = false;
      }
      destroy() {
        this._destroyed = true;
        super.destroy();
      }
      getImageElement(e) {
        if (!this._imageItems.has(e)) {
          this.addImageToStore(e);
        }
        return this._imageItems.get(e);
      }
      addImageToStore(e) {
        if (!this._imageItems.has(e)) {
          this._loadNewImage(e);
        }
      }
      _loadNewImage(e) {
        const t = {
          imageElement: null
        };
        (0, hi.getImage)(e, e).then(e => {
          if (!this._destroyed) {
            t.imageElement = e;
            this.updateAllViewsAndRepaint();
            this._model.updateSource(this);
          }
        }).catch(() => {
          gi.logWarn(`An error ocurred while loading image ${e}`);
        });
        this._imageItems.set(e, t);
      }
    }
    var yi = i(45687);
    class vi extends fi {
      constructor(e) {
        super(e, new li.DefaultProperty({
          defaultName: "UserDefinedTimescaleMarks",
          state: {
            visible: true
          }
        }));
        this._requestedPointsets = new Set();
        this._lollipopTooltipRenderer = null;
        (0, lt.hideMarksOnBars)().subscribe(this, () => this._properties.childs().visible.setValue(!(0, lt.hideMarksOnBars)().value()));
        this._paneView = new ai(e, this, this._onLollipopClicked.bind(this));
        this._paneViews = [this._paneView];
      }
      destroy() {
        (0, lt.hideMarksOnBars)().unsubscribeAll(this);
        super.destroy();
      }
      zorder() {
        return ci.sortSourcesPreOrdered.TimeScaleMarks;
      }
      name() {
        return "UserDefinedTimescaleMarks";
      }
      userEditEnabled() {
        return false;
      }
      clearMarks(e = 0) {
        if (e === 1) {
          return;
        }
        const t = this._model.chartApi();
        if (t.isConnected().value()) {
          Object.keys(this._marks).forEach(e => {
            const i = this._getPointsetId(e);
            t.removePointset(i);
          });
        }
        this._requestedPointsets.clear();
        super.clearMarks();
        this._paneView.clearCaches();
        this.updateAllViewsAndRepaint();
      }
      hasContextMenu() {
        return false;
      }
      paneViews() {
        if (this._properties.childs().visible.value()) {
          return this._paneViews;
        } else {
          return [];
        }
      }
      updateAllViews(e) {
        this._paneView.update(e);
      }
      onClickOutside(e, t) {
        if (this._lollipopTooltipRenderer === null || !t || !this._lollipopTooltipRenderer.isClickInside(t)) {
          this._paneView.processClickOutside(e, t);
        }
      }
      isVisible() {
        return this.properties().childs().visible.value();
      }
      hideTooltip() {
        this._paneView.clearLastClicked();
      }
      destroyTooltip() {
        this._lollipopTooltipRenderer?.hide();
        this._lollipopTooltipRenderer = null;
      }
      lollipopsAtIndex(e) {
        throw new Error("Method not implemented.");
      }
      _initialize() {
        this._properties.childs().visible.setValue(!(0, lt.hideMarksOnBars)().value());
      }
      _plateViewData(e) {
        return {
          text: e.text
        };
      }
      _getData(e) {
        const t = this._model.mainSeries().symbolInfo();
        if (!t) {
          return;
        }
        const i = this.roundRange(this._rangeDifference(e));
        const s = this._model.mainSeries();
        const o = s.seriesSource().symbolInstanceId();
        const r = (0, yi.getServerInterval)(s.properties().childs().interval.value());
        window.ChartApiInstance.getTimescaleMarks(t, i.start, i.end, t => {
          const i = this._model.chartApi();
          for (const e of t) {
            e.index = null;
            const t = e.id;
            const s = this._getPointsetId(t.toString());
            const a = this._marks[t];
            if (a && a.index !== null) {
              if (a.tickmark === e.tickmark) {
                e.index = a.index;
              } else if (this._requestedPointsets.has(s) && i.isConnected().value()) {
                i.removePointset(s);
                this._requestedPointsets.delete(s);
              }
            }
            if (e.imageUrl) {
              this.addImageToStore(e.imageUrl);
            }
            this._marks[t] = e;
            if (e.index === null && i.isConnected().value()) {
              this._requestedPointsets.add(s);
              const t = [[e.tickmark, 0]];
              i.createPointset(s, "turnaround", (0, n.ensureNotNull)(o), r, t, e => this._onPointsetData(e));
            }
          }
          this._loadedRange = this._rangeUnion(e, this._loadedRange);
          this.updateAllViewsAndRepaint();
        }, r);
      }
      _getPointsetId(e) {
        return "pointsetMark_" + e;
      }
      _onPointsetData(e) {
        if (e.method === "data_update") {
          const t = e.params.customId.split(/_(.+)/)[1] ?? "";
          const i = this._marks[t];
          const s = e.params.plots;
          if (i && s.length === 1) {
            i.index = s[0].value[0];
          }
        }
        this.updateAllViewsAndRepaint();
      }
      async _onLollipopClicked(e, t, s, o) {
        if (!e) {
          return;
        }
        const r = o();
        if (!r) {
          return;
        }
        const {
          showLollipopTooltip: a
        } = await Promise.all([i.e(6838), i.e(3953), i.e(5826), i.e(2564), i.e(1933), i.e(2227), i.e(2544), i.e(9039)]).then(i.bind(i, 184));
        if (this._isDestroyed) {
          return;
        }
        const l = this._model.timeScale();
        const c = [l.onScroll(), l.barSpacingChanged(), this._model.mainSeries().onSymbolIntervalChanged()];
        this._lollipopTooltipRenderer = a({
          items: r,
          position: s,
          customCloseSubscriptions: c,
          onClose: () => this._paneView.processClickOutside(t),
          onClickOutside: e => this.onClickOutside(t, e),
          onSizeChanged: (0, n.ensureNotNull)(this._model.paneForSource(this)).onSizeChanged()
        });
      }
    }
    var Si;
    var bi;
    var wi = i(71382);
    function Ci(e, t) {
      const {
        horizontalPixelRatio: i,
        verticalPixelRatio: s
      } = t;
      const o = Math.max(1, Math.floor(i));
      const n = Math.round(e.x * i) + o % 2 / 2;
      let r = Math.round(e.size * i);
      if ((n + r / 2) % 1 != 0) {
        r += 1;
      }
      const a = Math.min(Math.max(1, Math.round(i * e.borderWidth)), r / 2);
      let l;
      const c = (e.direction === "up" ? -1 : 1) * (e.yInverted ? -1 : 1);
      const h = c * (Math.round(e.size * s / 2) + o % 2);
      if (e.fixedSpaceYPosition !== undefined) {
        const t = Math.round(e.fixedSpaceYPosition.itemSpacing * s);
        const i = e.fixedSpaceYPosition.order;
        const o = c * (r * i + t * (i + 1));
        l = Math.round(e.fixedSpaceYPosition.basePosition * s) + o + h;
      } else {
        l = Math.round(e.y * s) + h;
      }
      return {
        x: n,
        y: l,
        size: r,
        borderWidth: a,
        tickSize: o
      };
    }
    function Pi(e, t, i, s) {
      e.save();
      if (i && !s.highlightByAuthor) {
        e.globalAlpha = 0.4;
      }
      if (s.mine) {
        (function (e, t, i) {
          const {
            borderColor: s,
            backgroundColor: o,
            doNotFill: n,
            direction: r,
            yInverted: a
          } = i;
          const {
            x: l,
            y: c,
            borderWidth: h,
            size: d,
            tickSize: u
          } = Ci(i, t);
          e.strokeStyle = s;
          e.fillStyle = o;
          e.lineWidth = h;
          const _ = r === "up" !== a ? -1 : 1;
          let p = Math.round(d / 2 / Math.tan(Math.PI / 6)) + u % 2 / 2;
          if ((l + p / 2) % 1 != 0) {
            p -= 1;
          }
          e.translate(l, c + p / 2 * _);
          e.beginPath();
          const m = h / 2;
          e.moveTo(0, -_ * (p - m));
          e.lineTo(d / 2 - m, h / 2);
          e.lineTo(-d / 2 + m, h / 2);
          e.lineTo(0, -_ * (p - h / 2));
          e.closePath();
          if (!n) {
            e.fill();
          }
          e.stroke();
        })(e, t, s);
      } else {
        // Sửa lại cách vẽ marks 

        const drawSignal = (e, t, i, s, o) => {
          const { x: l, y: c, size: size } = Ci(i, t);

          e.strokeStyle = n;
          e.fillStyle = r;
          e.lineWidth = h;
          e.beginPath();

          // ==== style ====
          const labelText = i?.label?.text ?? '';
          if (labelText?.toLowerCase()?.includes('s')) {
            i.backgroundColor = '#ED5A5A';
          } else if (labelText?.toLowerCase()?.includes('p') && i?.originalItem?.text?.toLowerCase()?.includes('pullback 10')) {
            i.backgroundColor = '#F7941D';
          } else {
            i.backgroundColor = '#26A69A';
          }
          const color = i.backgroundColor;

          // === Các hệ số điều khiển kích thước ===
          const TRIANGLE_WIDTH_FACTOR = 1.2;   // >1 làm tam giác rộng hơn
          const TRIANGLE_HEIGHT_FACTOR = 1.8;  // >1 làm tam giác dài hơn

          const radius = size / 2;
          // os: đơn vị cơ sở (base unit) theo kích thước
          let os = (radius) / 4;

          // w: nửa chiều rộng của khối hộp (để tam giác khớp đẹp với hộp)
          let w = os * 3.5;

          // phóng to tam giác theo hệ số
          const triHalfWidth = os * TRIANGLE_WIDTH_FACTOR;      // nửa rộng tam giác
          const triHeight = os * TRIANGLE_HEIGHT_FACTOR;        // chiều dài tam giác

          const cx = l;
          const cy = i.direction == 'up' ? c + 10 : c - 10;
          const fs = w * 2;

          // Kích thước hộp
          const bx1 = cx - w;
          const bx2 = cx + w;
          const by1 = cy - w;
          const by2 = cy + w;

          e.strokeStyle = color;
          e.fillStyle = color;
          e.lineWidth = i.borderWidth;
          e.beginPath();

          if (i.direction === 'up') {
            // Vẽ hộp
            e.moveTo(cx, by2);
            e.arcTo(bx1, by2, bx1, by1, 4);
            e.arcTo(bx1, by1, bx2, by1, 4);
            e.arcTo(bx2, by1, bx2, by2, 4);
            e.arcTo(bx2, by2, bx1, by2, 4);

            // Tam giác hướng xuống (võng xuống) – to & dài hơn
            const ax1 = cx - triHalfWidth;
            const ax2 = cx + triHalfWidth;
            const ay = by2 + triHeight;

            e.lineTo(ax2, by2);
            e.lineTo(cx, ay);
            e.lineTo(ax1, by2);
          } else {
            // Vẽ hộp
            e.moveTo(cx, by1);
            e.arcTo(bx2, by1, bx2, by2, 4);
            e.arcTo(bx2, by2, bx1, by2, 4);
            e.arcTo(bx1, by2, bx1, by1, 4);
            e.arcTo(bx1, by1, bx2, by1, 4);

            // Tam giác hướng lên (võng lên) – to & dài hơn
            const ax1 = cx - triHalfWidth;
            const ax2 = cx + triHalfWidth;
            const ay = by1 - triHeight;

            e.lineTo(ax2, by1);
            e.lineTo(cx, ay);
            e.lineTo(ax1, by1);
          }

          e.closePath();
          e.stroke();
          e.fill();

          const fontFamily = ' -apple-system, BlinkMacSystemFont, "Trebuchet MS", Roboto, Ubuntu, sans-serif';
          if (i.label.text && radius > 6) {
            e.textAlign = "center";
            e.textBaseline = "middle";
            e.font = "bold " + fs * 0.8 + "px " + fontFamily;
            e.fillStyle = i.label.fontColor;
            e.fillText(i.label.text, cx + 0, cy + 1);
          }
        };

        // Helper: bo góc
        function roundedRect(ctx, x, y, w, h, r) {
          const rr = Math.min(r, w / 2, h / 2);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.arcTo(x + w, y, x + w, y + h, rr);
          ctx.arcTo(x + w, y + h, x, y + h, rr);
          ctx.arcTo(x, y + h, x, y, rr);
          ctx.arcTo(x, y, x + w, y, rr);
          ctx.closePath();
        }

        // Helper: cắt dòng theo maxWidth (tôn trọng \n nếu có)
        function wrapLines(ctx, text, maxWidth) {
          const hardLines = String(text).split('\n');
          const lines = [];

          for (const hard of hardLines) {
            const words = hard.split(/\s+/).filter(Boolean);
            if (words.length === 0) { lines.push(''); continue; }

            let line = words[0];
            for (let i = 1; i < words.length; i++) {
              const test = line + ' ' + words[i];
              if (ctx.measureText(test).width <= maxWidth) {
                line = test;
              } else {
                lines.push(line);
                line = words[i];
              }
            }
            lines.push(line);
          }
          return lines;
        }

        const markTextPadidngX = 8;
        const markTextPaddingY = 2;
        const markMaxTextWidth = 120;
        const markLineHeight = 16;
        const markFontSize = 12;

        // === HÀM CHÍNH (đã sửa): vẽ RECT + text nhiều dòng ===
        const drawSignalTexts = (e, t, i, s, o) => {
          let { x: l, y: c } = Ci(i, t);
          c = i.direction == 'down' ? c - 30 : c + 30;

          // ==== style ====
          const labelText = i?.label?.text ?? '';
          if (
            labelText?.toLowerCase()?.includes('buy') ||
            labelText?.toLowerCase()?.includes('gia tăng') ||
            labelText?.toLowerCase()?.includes('pullback')) {
            i.backgroundColor = '#26A69A';
          } else {
            i.backgroundColor = '#ED5A5A';
          }
          let bg = i.backgroundColor || '#2962FF';
          const borderColor = 'transparent';
          const borderWidth = 0.1;
          const radius = i.borderRadius ?? 6;
          const paddingX = markTextPadidngX;
          const paddingY = markTextPaddingY;
          const maxTextWidth = i.maxTextWidth ?? 120;
          const lineHeight = i.lineHeight ?? 16;

          // ==== font ====
          const fontFamily = '-apple-system, BlinkMacSystemFont, "Trebuchet MS", Roboto, Ubuntu, sans-serif';
          const fontPx = i.fontSize ?? 12;
          const fontWeight = i.bold ? 'bold ' : '';
          e.font = `${fontWeight}${fontPx}px ${fontFamily}`;
          e.textAlign = 'center';
          e.textBaseline = 'middle';

          // ==== text wrap ====
          const label = (i.label && i.label.text) ? i.label.text : '';
          const lines = wrapLines(e, label, maxTextWidth);
          const lineWidths = lines.map(str => e.measureText(str).width);
          const textW = lineWidths.length ? Math.max(...lineWidths) : 0;
          const boxW = Math.ceil(textW + paddingX * 2);
          const boxH = Math.ceil((lines.length || 1) * lineHeight + paddingY * 2);

          // ==== pointer ====
          const pointerH = i.pointerHeight ?? 8;
          const pointerWraw = i.pointerWidth ?? 10;
          const gap = i.pointerGap ?? 2;

          const tipX = l;
          const tipY = c;

          // hạn chế đáy tam giác không vượt quá hộp
          const pointerW = Math.min(pointerWraw, boxW - 8);

          // ==== box position theo hướng ====
          let rectX = Math.round(tipX - boxW / 2);
          let rectY;

          if (i.direction === 'down') {
            // mũi tên hướng lên: hộp nằm DƯỚI tip, tam giác ở mép TRÊN
            rectY = Math.round(tipY + pointerH + gap);
            i.__box = { x: rectX, y: rectY - (pointerH + gap), w: boxW, h: boxH + pointerH + gap };
          } else {
            // (mặc định) mũi tên hướng xuống: hộp nằm TRÊN tip, tam giác ở mép DƯỚI
            rectY = Math.round(tipY - pointerH - gap - boxH);
            i.__box = { x: rectX, y: rectY, w: boxW, h: boxH + pointerH + gap };
          }

          // ==== draw path ====
          e.fillStyle = bg;
          e.strokeStyle = borderColor;
          e.lineWidth = borderWidth;

          e.beginPath();

          const r = Math.min(radius, boxW / 2, boxH / 2);
          const x = rectX, y = rectY, w = boxW, h = boxH;

          if (i.direction === 'down') {
            // hộp + tam giác ở mép TRÊN, tip ở TRÊN hộp
            e.moveTo(x + r, y);
            e.lineTo(x + w - r, y);
            e.quadraticCurveTo(x + w, y, x + w, y + r);
            e.lineTo(x + w, y + h - r);
            e.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            e.lineTo(x + r, y + h);
            e.quadraticCurveTo(x, y + h, x, y + h - r);
            e.lineTo(x, y + r);
            e.quadraticCurveTo(x, y, x + r, y);

            // chèn tam giác ở mép TRÊN
            const baseY = y;
            const triLeftX = tipX - pointerW / 2;
            const triRightX = tipX + pointerW / 2;

            // từ cạnh trên (đang ở x+r,y) đi tới phải rồi vẽ rãnh tam giác
            e.moveTo(triRightX, baseY);
            e.lineTo(tipX, tipY);
            e.lineTo(triLeftX, baseY);
          } else {
            // hộp + tam giác ở mép DƯỚI, tip ở DƯỚI hộp
            e.moveTo(x + r, y);
            e.lineTo(x + w - r, y);
            e.quadraticCurveTo(x + w, y, x + w, y + r);
            e.lineTo(x + w, y + h - r);
            e.quadraticCurveTo(x + w, y + h, x + w - r, y + h);

            // chèn tam giác ở mép DƯỚI
            const baseY = y + h;
            const triLeftX = tipX - pointerW / 2;
            const triRightX = tipX + pointerW / 2;

            e.lineTo(triRightX, baseY);
            e.lineTo(tipX, tipY);
            e.lineTo(triLeftX, baseY);

            e.lineTo(x + r, y + h);
            e.quadraticCurveTo(x, y + h, x, y + h - r);
            e.lineTo(x, y + r);
            e.quadraticCurveTo(x, y, x + r, y);
          }

          e.closePath();
          if (borderWidth > 0) e.stroke();
          e.fill();

          // ==== text ====
          e.fillStyle = (i.label && i.label.fontColor) ? i.label.fontColor : '#FFFFFF';
          const totalTextH = (lines.length || 1) * lineHeight;
          let ty = Math.round(y + (h - totalTextH) / 2 + lineHeight / 2);
          for (const line of lines) {
            e.fillText(line, Math.round(x + w / 2), ty);
            ty += lineHeight;
          }
        };

        let i = false;
        {
          const e = s.image && (o = s.image, Boolean(o && o.imageElement && o.imageElement.complete && o.imageElement.naturalWidth));
          i = Boolean(e && !s.showLabelWhenImageLoaded);
        }
        (function (e, t, i, s, o) {
          const {
            borderColor: n,
            backgroundColor: r,
            label: a
          } = i;
          const {
            x: l,
            y: c,
            borderWidth: h,
            size: d
          } = Ci(i, t);

          if (i && i.label && i.label.text && i.label.text.length > 1) {
            drawSignalTexts(e, t, i, s, o);
          } else {
            drawSignal(e, t, i, s, o);
          }

          if (o) {
            (function (e, t, i, s, o) {
              if (t) {
                const n = i * 2;
                e.save();
                e.imageSmoothingEnabled = true;
                e.imageSmoothingQuality = "high";
                (0, Ft.createCircle)(e, s, o, i);
                e.clip();
                e.drawImage(t, s - i, o - i, n, n);
                e.restore();
              }
            })(e, o, u, l, c);
          }
          e.stroke();
          //   if (!s && a && d / 2 >= 7) {
          //     e.textAlign = "center";
          //     e.textBaseline = "middle";
          //     e.font = a.font;
          //     e.fillStyle = a.fontColor;
          //     (0, Wt.drawScaled)(e, t.horizontalPixelRatio, t.verticalPixelRatio, () => {
          //       e.fillText(a.text, l / t.horizontalPixelRatio, c / t.verticalPixelRatio);
          //     });
          //   }
        })(e, t, s, i, s.image?.imageElement ?? undefined);
      }
      var o;
      e.restore();
    }
    (function (e) {
      e[e.MinRadiusToDrawText = 7] = "MinRadiusToDrawText";
    })(Si ||= {});
    class Ti {
      constructor(e, t, i, s) {
        this._canvas = null;
        this._clickHandler = e;
        this._enterHandler = t;
        this._leaveHandler = i;
        this._data = s ?? null;
      }
      setData(e) {
        this._data = e;
      }
      hitTest(e, t) {
        if (this._data === null) {
          return null;
        }
        for (let i = this._data.items.length - 1; i >= 0; --i) {
          const s = this._hitTestDot(this._data.items[i], e, t);
          if (s) {
            return s;
          }
        }
        return null;
      }
      draw(e, t) {
        this._canvas = e.canvas;
        if (this._data !== null) {
          this._data.items.forEach(Pi.bind(null, e, t, this._data.highlightByAuthor));
        }
      }
      pointInRect(p, rect, padding = 0) {
        return (
          p.x >= rect.x - padding &&
          p.x <= rect.x + rect.w + padding &&
          p.y >= rect.y - padding &&
          p.y <= rect.y + rect.h + padding
        );
      }
      _hitTestDot(e, t, i) {
        // e: mark item (có e.x, v.v.)
        // t: mouse point (panePoint)
        // i: info/pane (dùng Ci để lấy y chuẩn theo verticalPixelRatio)
        // Giữ cách tính tâm theo code gốc để ra đúng không gian toạ độ
        const s = new At.Point(e.x, Ci(e, i).y / i.verticalPixelRatio);

        // Ưu tiên dùng bbox đã lưu khi vẽ (chuẩn 100%)
        let rect = e.__box;

        // Fallback: nếu chưa lưu, ước lượng từ size (ít chính xác hơn)
        if (!rect) {
          var estWidth = Math.max(e.size * 2, 100);     // tuỳ chỉnh theo thực tế
          var estHeight = Math.max(e.size, 24);
          try {
            const estSize = calculateSize(e,)
          } catch (_) { }
          const x = Math.round(s.x - estWidth / 2);
          const y = Math.round(s.y - estHeight / 2);
          rect = { x, y, w: estWidth, h: estHeight };
        }

        // Tuỳ bạn muốn dễ hover hơn, có thể nới padding vài px
        const hoverPadding = 0;
        const pointInRect = this.pointInRect(t, rect, hoverPadding);

        if (pointInRect) {
          const canvas = this._canvas;
          const handlers = canvas == null ? undefined : {
            mouseEnterHandler: () => this._enterHandler(e, s.y, canvas),
            mouseLeaveHandler: () => this._leaveHandler(),
            clickHandler: (evt) => this._clickHandler(e, s.y, canvas, evt),
            tapHandler: (evt) => this._clickHandler(e, s.y, canvas, evt),
          };

          return new Vt.HitTestResult(Vt.HitTarget.Regular, {
            activeItem: e.originalItem.id,
            cursorType: qt.PaneCursorType.Default,
            ...handlers,
          });
        }

        return null;
      }
    }
    (function (e) {
      e[e.BarSpacingToSizeRatio = 0.8] = "BarSpacingToSizeRatio";
      e[e.MinSize = 7] = "MinSize";
      e[e.MaxSize = 553] = "MaxSize";
    })(bi ||= {});
    const xi = {
      green: {
        border: (0, Lt.getHexColorByName)("color-minty-green-700"),
        background: (0, Lt.getHexColorByName)("color-minty-green-a600")
      },
      red: {
        border: (0, Lt.getHexColorByName)("color-ripe-red-700"),
        background: (0, Lt.getHexColorByName)("color-ripe-red-500")
      },
      neutral: {
        border: (0, Lt.getHexColorByName)("color-tan-orange-700"),
        background: (0, Lt.getHexColorByName)("color-tan-orange-500")
      },
      yellow: {
        border: "#EAC300",
        background: "#FFD400"
      },
      blue: {
        border: "#047ACE",
        background: "#0496FF"
      }
    };
    class Ii {
      constructor(e, t) {
        this._tooltip = null;
        this._hoveredBarsMarkData = null;
        this._destroyed = false;
        this._invalidated = true;
        this._originalData = [];
        this._source = e;
        this._model = t;
        this._renderer = new Ti(this._onItemClicked.bind(this), this._showItem.bind(this), this._hideItem.bind(this));
        this._createTooltipRenderer().then(e => {
          if (this._destroyed) {
            e?.destroy();
          } else {
            this._tooltip = e;
          }
        });
        e.properties().childs().visible.subscribe(null, () => {
          this._tooltip?.hide(true);
        });
      }
      destroy() {
        this._destroyed = true;
        this._tooltip?.destroy();
      }
      source() {
        return this._source;
      }
      update() {
        this._invalidated = true;
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        return this._renderer;
      }
      onClickOutside(e, t) {
        if (t && ((0, Et.isTouchMouseEvent)(t) ? t.isTouch : (0, wi.isTouchEvent)(t)) && this._tooltip !== null && !this._tooltip.contains(t.target)) {
          this._tooltip.hide(true);
        }
      }
      _extractBarMarksRendererItemData(e, t) {
        const i = t.overridedTheme ?? xi[t.theme];
        const s = this._calculateSize(e, t);
        const o = this._calculateY(e, s, t);
        if (this._hoveredBarsMarkData !== null && this._hoveredBarsMarkData.id === t.id && (this._hoveredBarsMarkData.x !== t.x || this._hoveredBarsMarkData.y !== Math.round(o))) {
          this._tooltip?.hide(true);
          this._hoveredBarsMarkData = null;
        }
        return {
          x: t.x,
          y: this._calculateY(e, s, t),
          direction: t.direction,
          borderColor: i.border,
          borderWidth: Mi(t),
          backgroundColor: i.background,
          size: s,
          doNotFill: !t.public,
          yInverted: t.yInverted,
          label: t.label === undefined ? undefined : {
            text: t.label,
            fontColor: t.labelFontColor,
            font: (0, Yt.makeFont)(Math.ceil(Math.max(10, Math.min(s / 2, 20))), g.CHART_FONT_FAMILY, "bold")
          },
          originalItem: t
        };
      }
      _onItemClicked(e, t, i, s) {
        if (s.isTouch) {
          this._showItem(e, t, i);
        }
      }
      async _showItem(e, t, i) {
        const s = await this._tooltipProps(e);
        if (s === null) {
          return;
        }
        const o = this._model.timeScale().barSpacing();
        const r = this._calculateSize(o, e.originalItem);
        this._hoveredBarsMarkData = {
          x: e.x,
          y: Math.round(this._calculateY(o, r, e.originalItem)),
          id: e.originalItem.id
        };
        const output = this._tooltip?.show({
          itemSize: r,
          container: (0, n.ensureNotNull)(i.parentElement),
          x: e.x,
          y: t,
          factoryProps: s,
          onClickOutside: () => this._tooltip?.hide(true)
        });
      }
      _hideItem() {
        this._tooltip?.hide();
      }
      _calculateSize(e, t) {
        return Math.min(553, Math.max(7, t.minSize, e * 0.8));
      }
      _updateImpl() {
        this._originalData = this._source.getPlatesViewData();
        const e = this._model.timeScale().barSpacing();
        const t = this._originalData.map(this._extractBarMarksRendererItemData.bind(this, e));
        this._renderer.setData({
          items: t,
          barSpacing: e,
          highlightByAuthor: false
        });
      }
    }
    function Mi(e) {
      if (e.hovered || e.highlightByAuthor) {
        return e.overrideBorderWidth?.hoveredWidth ?? 4;
      } else {
        return e.overrideBorderWidth?.width ?? 2;
      }
    }
    class Ai extends Ii {
      async _createTooltipRenderer() {
        const [{
          TooltipRenderer: e
        }, {
          UserDefinedBarsMarksTooltip: t
        }] = await Promise.all([Promise.all([i.e(4057), i.e(2227), i.e(8020)]).then(i.bind(i, 6897)), Promise.all([i.e(4057), i.e(2227), i.e(8020)]).then(i.bind(i, 16608))]);
        return new e(t);
      }
      _calculateY(e, t, i) {
        const s = Math.max(i.minSize * 1.4, e + 4);
        const o = (i.direction === "up" ? -1 : 1) * (i.yInverted ? -1 : 1) * (s * (i.order + 0.6) + s * 0.25);
        return i.y + o;
      }
      _onItemClicked(e, t, i, s) {
        super._onItemClicked(e, t, i, s);
        e.originalItem.onClicked?.();
      }
      _tooltipProps(e) {
        const t = e.originalItem.text;
        if (t) {
          return Promise.resolve({
            text: t
          });
        } else {
          return Promise.resolve(null);
        }
      }
      _extractBarMarksRendererItemData(e, t) {
        return {
          ...super._extractBarMarksRendererItemData(e, t),
          showLabelWhenImageLoaded: t.showLabelWhenImageLoaded,
          image: t.image
        };
      }
    }
    class Li extends fi {
      constructor(e) {
        super(e, new li.DefaultProperty({
          defaultName: "UserDefinedBarsMarks",
          state: {
            visible: true
          }
        }));
        this._paneView = new Ai(this, e);
        this._paneViews = [this._paneView];
        (0, lt.hideMarksOnBars)().subscribe(this, () => {
          this.properties().childs().visible.setValue(!(0, lt.hideMarksOnBars)().value());
        });
      }
      destroy() {
        (0, lt.hideMarksOnBars)().unsubscribeAll(this);
        this._paneView.destroy();
        super.destroy();
      }
      zorder() {
        return ci.sortSourcesPreOrdered.BarMarks;
      }
      name() {
        return "UserDefinedBarsMarks";
      }
      userEditEnabled() {
        return false;
      }
      clearMarks(e = 0) {
        if (e !== 2) {
          super.clearMarks();
          this.updateAllViewsAndRepaint();
        }
      }
      hasContextMenu() {
        return false;
      }
      paneViews() {
        if (this._properties.childs().visible.value()) {
          return this._paneViews;
        } else {
          return [];
        }
      }
      isVisible() {
        return this.properties().childs().visible.value();
      }
      onClickOutside(e, t) {
        this._paneView.onClickOutside(e, t);
      }
      _initialize() {
        this.properties().childs().visible.setValue(!(0, lt.hideMarksOnBars)().value());
      }
      _plateViewData(e) {
        const t = {
          text: e.text,
          onClicked: e.onClicked
        };
        if (typeof e.color == "object") {
          t.theme = "user_defined_theme";
          t.overridedTheme = {};
          t.overridedTheme.border = e.color.border;
          t.overridedTheme.background = e.color.background;
        }
        const i = (0, dt.isNumber)(e.borderWidth) ? e.borderWidth : undefined;
        const s = (0, dt.isNumber)(e.hoveredBorderWidth) ? e.hoveredBorderWidth : undefined;
        if (i !== undefined || s !== undefined) {
          t.overrideBorderWidth = {
            width: i,
            hoveredWidth: s
          };
        }
        if (e.showLabelWhenImageLoaded) {
          t.showLabelWhenImageLoaded = true;
        }
        if (e.imageUrl) {
          const i = this.getImageElement(e.imageUrl);
          t.image = i;
        }
        return t;
      }
      _getData(e) {
        const t = this._model.mainSeries().symbolInfo();
        if (!t) {
          return;
        }
        const i = this.roundRange(this._rangeDifference(e));
        const s = (0, yi.getServerInterval)(this._model.mainSeries().properties().childs().interval.value());
        window.ChartApiInstance.getMarks(t, i.start, i.end, t => {
          for (const e of t) {
            this._marks[e.id] = e;
            if (e.imageUrl) {
              this.addImageToStore(e.imageUrl);
            }
          }
          this._loadedRange = this._rangeUnion(e, this._loadedRange);
          this.updateAllViewsAndRepaint();
        }, s);
      }
    }
    var ki = i(69109);
    var Di = i(45126);
    function Ei(e) {
      const t = {};
      return {
        promise: new Promise((i, s) => {
          e.subscribe(t, i, true);
        }),
        destroy: () => {
          e.unsubscribeAll(t);
        }
      };
    }
    var Bi = i(22820);
    class Vi extends tt.UndoCommand {
      constructor(e, t) {
        super(null);
        this._chartModel = e;
        this._targetIndex = t;
      }
      redo() {
        const e = this._chartModel.createPane(this._targetIndex, undefined, this._paneId);
        this._paneId = e.id();
      }
      undo() {
        const e = (0, n.ensureDefined)(this._paneId);
        const t = this._chartModel.panes().find(t => t.id() === e);
        if (t !== undefined) {
          this._chartModel.removePane(t);
        }
      }
      createdPaneId() {
        return this._paneId;
      }
    }
    var Ri = i(91682);
    var Ni = i(56616);
    const Oi = (0, ae.getLogger)("Clipboard");
    var Fi;
    (function (e) {
      e.MagicAttrName = "data-tradingview-clip";
    })(Fi ||= {});
    class Wi {
      constructor(e) {
        this._e = e;
      }
      write(e) {
        return (0, Ni.writeImpl)(this._toRaw(e), this._e);
      }
      _toRaw(e) {
        const t = {
          files: []
        };
        t.text = e.text;
        if (e.app !== undefined) {
          t.html = this._serializeAppData(e.app, e.text);
        } else if (e.html) {
          t.html = e.html;
        }
        for (const i of e.files || []) {
          t.files.push(i);
        }
        return t;
      }
      _serializeAppData(e, t) {
        return `<meta charset="utf-8"><span data-tradingview-clip="${(0, Ri.htmlEscape)(e)}">${t ? (0, Ri.htmlEscape)(t.slice(0, 256)) : "&#128200;"}</span>`;
      }
    }
    class Hi {
      constructor(e) {
        this._e = e;
      }
      async read() {
        if (this._e && this._e.eventPhase === 0) {
          Oi.logWarn("Cannot use an already dispatched ClipboardEvent for reading");
          this._e = null;
        }
        const e = this._e ? this._readUsingEvent(this._e) : await this._readUsingApi();
        return this._fromRaw(e);
      }
      _readUsingEvent(e) {
        const t = (0, n.ensure)(e.clipboardData);
        e.preventDefault();
        const i = {
          files: []
        };
        for (let e = 0; e < t.files.length; e++) {
          i.files.push(t.files[e]);
        }
        for (let e = 0; e < t.items.length; e++) {
          const s = t.items[e];
          if (s.kind === "string") {
            if (s.type === "text/plain") {
              i.text = t.getData(s.type);
            } else if (s.type === "text/html") {
              i.html = t.getData(s.type);
            } else {
              i.files.push(new Blob([t.getData(s.type)], {
                type: s.type
              }));
            }
          }
        }
        return i;
      }
      async _readUsingApi() {
        const e = (0, Ni.getClipboard)();
        if (!e || !e.read) {
          throw new DOMException("ClipboardApi is not supported", "NotSupportedError");
        }
        let t;
        let i;
        const s = [];
        const o = await e.read();
        for (const e of o) {
          for (const o of e.types) {
            if (o === "text/html") {
              t = e.getType(o).then(this._readBlobAsText);
            } else if (o === "text/plain") {
              i = e.getType(o).then(this._readBlobAsText);
            } else {
              s.push(e.getType(o));
            }
          }
        }
        return {
          text: await i,
          html: await t,
          files: await Promise.all(s)
        };
      }
      _fromRaw(e) {
        const t = {};
        if (e.text !== undefined) {
          t.text = e.text;
        }
        if (e.html !== undefined) {
          const i = this._parseAppData(e.html);
          if (i) {
            t.app = i;
          } else {
            t.html = e.html;
          }
        }
        if (e.files.length > 0) {
          t.files = e.files;
        }
        return t;
      }
      _parseAppData(e) {
        if (e.slice(0, 1024).indexOf("data-tradingview-clip") === -1) {
          return;
        }
        const t = new DOMParser().parseFromString(e, "text/html").querySelector("[data-tradingview-clip]");
        if (t) {
          return t.getAttribute("data-tradingview-clip") || "";
        } else {
          return undefined;
        }
      }
      _readBlobAsText(e) {
        return new Promise((t, i) => {
          const s = new FileReader();
          s.onloadend = () => {
            t(s.result);
          };
          s.onerror = () => {
            i(s.error);
          };
          s.readAsText(e);
        });
      }
    }
    class zi {
      constructor(e) {
        this._callbacks = Object.assign({}, e);
        this._boundOnCopy = this._onCopyEv.bind(this);
        this._boundOnCut = this._onCutEv.bind(this);
        this._boundOnPaste = this._onPasteEv.bind(this);
      }
      listen() {
        document.addEventListener("copy", this._boundOnCopy);
        document.addEventListener("cut", this._boundOnCut);
        document.addEventListener("paste", this._boundOnPaste);
      }
      async peek() {
        if ((await navigator.permissions.query({
          name: "clipboard-read"
        })).state !== "granted") {
          throw new Error("clipboard-read is not granted");
        }
        return new Hi(null).read();
      }
      uiRequestCopy(e) {
        if (this._callbacks.copyRequested) {
          this._callbacks.copyRequested(new Wi(null), e);
        }
      }
      uiRequestCut(e) {
        if (this._callbacks.cutRequested) {
          this._callbacks.cutRequested(new Wi(null), e);
        }
      }
      uiRequestPaste(e) {
        if (this._callbacks.pasteRequested) {
          this._callbacks.pasteRequested(new Hi(null), e);
        }
      }
      destroy() {
        document.removeEventListener("copy", this._boundOnCopy);
        document.removeEventListener("cut", this._boundOnCut);
        document.removeEventListener("paste", this._boundOnPaste);
      }
      _onCopyEv(e) {
        if (!e.defaultPrevented) {
          if (this._callbacks.copyRequested) {
            this._callbacks.copyRequested(new Wi(e));
          }
        }
      }
      _onCutEv(e) {
        if (!e.defaultPrevented) {
          if (this._callbacks.cutRequested) {
            this._callbacks.cutRequested(new Wi(e));
          }
        }
      }
      _onPasteEv(e) {
        if (!e.defaultPrevented) {
          if (this._callbacks.pasteRequested) {
            this._callbacks.pasteRequested(new Hi(e));
          }
        }
      }
    }
    var Ui = i(35749);
    function ji(e) {
      const t = e.target;
      return t !== null && t.nodeType === 1 && (0, Ui.isTextEditingField)(t);
    }
    function Gi(e) {
      const t = e.target;
      if (t === null) {
        return false;
      }
      const i = (t.ownerDocument || t).getSelection();
      return i !== null && !i.isCollapsed;
    }
    class qi extends zi {
      _onCopyEv(e) {
        if (!ji(e) && !Gi(e)) {
          return super._onCopyEv(e);
        }
      }
      _onCutEv(e) {
        if (!ji(e) && !Gi(e)) {
          return super._onCutEv(e);
        }
      }
      _onPasteEv(e) {
        if (!ji(e)) {
          return super._onPasteEv(e);
        }
      }
    }
    var $i = i(65952);
    const Ki = new Di.TranslatedString("change chart layout to {title}", a.t(null, undefined, i(68846)));
    class Yi extends tt.UndoCommand {
      constructor(e, t) {
        super(Ki.format({
          title: Ct.layouts[t].title
        }));
        this._chartWidgetCollection = e;
        this._newLayoutType = t;
        this._oldLayoutType = e.layout.value();
      }
      redo() {
        this._chartWidgetCollection.setLayout(this._newLayoutType);
      }
      undo() {
        this._chartWidgetCollection.setLayout(this._oldLayoutType);
      }
    }
    const Zi = new Di.TranslatedString("apply toolbars theme", a.t(null, undefined, i(86708)));
    class Xi extends tt.UndoCommand {
      constructor(e, t, i = true) {
        super(Zi);
        this._prevThemeName = e;
        this._themeName = t;
        this._syncState = i;
      }
      undo() {
        if ((0, k.isStdThemeName)(this._prevThemeName)) {
          (0, D.setTheme)(this._prevThemeName);
          if (this._syncState) {
            (0, k.syncTheme)();
          }
        }
      }
      redo() {
        if ((0, k.isStdThemeName)(this._themeName.toLowerCase())) {
          (0, D.setTheme)(this._themeName.toLowerCase());
          if (this._syncState) {
            (0, k.syncTheme)();
          }
        }
      }
    }
    var Ji = i(88960);
    var Qi = i(23869);
    var es = i(10074);
    var ts = i(16638);
    var is = i(68159);
    i(99647);
    (0, ae.getLogger)("ChartWidgetCollectionBase");
    const ss = new Di.TranslatedString("apply indicators to entire layout", a.t(null, undefined, i(70507)));
    const os = new Di.TranslatedString("sync time", a.t(null, undefined, i(91677)));
    const ns = new Di.TranslatedString("reset layout sizes", a.t(null, undefined, i(85366)));
    const rs = new Di.TranslatedString("apply chart theme", a.t(null, undefined, i(68231)));
    const as = new Di.TranslatedString("symbol lock", a.t(null, undefined, i(53278)));
    const ls = new Di.TranslatedString("interval lock", a.t(null, undefined, i(56558)));
    const cs = new Di.TranslatedString("date range lock", a.t(null, undefined, i(58850)));
    const hs = new Di.TranslatedString("track time", a.t(null, undefined, i(46807)));
    const ds = new Di.TranslatedString("change series style", a.t(null, undefined, i(49965)));
    a.t(null, undefined, i(28298));
    a.t(null, undefined, i(78972));
    a.t(null, undefined, i(10615));
    a.t(null, undefined, i(81518));
    a.t(null, undefined, i(92101));
    a.t(null, undefined, i(85902));
    a.t(null, undefined, i(94656));
    function us(e, t) {
      for (const i of e.sources) {
        if (i.type !== "study") {
          return true;
        }
        if (t.checkIfFeatureAvailable(new is.StudyMetaInfo(i.source.metaInfo), [])) {
          return true;
        }
      }
      return false;
    }
    function _s(e) {
      return function (e) {
        return vt().then(t => t.downloadClientScreenshot(e));
      }(e);
    }
    function ps(e) {
      return function (e) {
        return vt().then(t => t.copyToClipboardClientScreenshot(e));
      }(e).then(() => {
        (0, W.emit)("onClientScreenshotCopiedToClipboard");
      });
    }
    const ms = {
      s: 0,
      "2h": 0,
      "2v": 1,
      "2-1": 1,
      "3s": 0,
      "3h": 0,
      "3v": 2,
      4: 1,
      6: 1,
      8: 1,
      "1-2": 1,
      "3r": 1,
      "4h": 0,
      "4v": 3,
      "4s": 0,
      "4s-l": 0,
      "5h": 0,
      "5v": 0,
      "6h": 0,
      "6v": 0,
      "7h": 0,
      "8h": 0,
      "8v": 0,
      "1-3": 1,
      "2-2": 3,
      "2-2-l": 0,
      "2-3": 2,
      "3-2": 3,
      "1-4": 1,
      "2-4": 2,
      "5s": 0,
      "6c": 4,
      "8c": 6,
      "9s": 6,
      "9h": 0,
      "9v": 0,
      "10h": 0,
      "10v": 0,
      "10c5": 1,
      "12c6": 1,
      "12c4": 3,
      "14c7": 1,
      "16c8": 1,
      "16c4": 3
    };
    function gs(e, t, i, s) {
      const o = e.actualLayoutCount();
      e.chartWidgetsDefs.slice(0, o).filter(e => e.rdState.bridge().visible.value()).map(e => e.chartWidget).filter(t => t.id() !== i && !!t.hasModel() && e.crosshairLockRaw).forEach(e => e.model().model().setExternalPosition(t, s));
      return true;
    }
    function fs(e, t) {
      return t;
    }
    async function ys(e, t = this.activeChartWidget.value()) {
      return !!t && (function (e, t) {
        const i = e.model();
        const s = i.mainSeries().properties().childs().style;
        i.setChartStyleProperty(s, t, ds);
      }(t, e), true);
    }
    async function vs(e, t, i, s) {
      return !e.flags.loadingChart && !e.flags.setTimeFrameActive && !e.flags.setNewResolution && (function (e, t, i, s) {
        (0, es.setLastUsedResolution)(t);
        e.flags.setNewResolution = true;
        s = s ?? e.activeChartWidget.value();
        if (i === undefined) {
          i = s.linkingGroupIndex().value();
        }
        if (e.intervalLock.value()) {
          for (const i of e.chartWidgetsDefs) {
            const e = i.chartWidget;
            if (e.resolutionWV().value() !== t) {
              e.setResolution(t);
            }
          }
        } else {
          s.setResolution(t);
        }
        e.flags.setNewResolution = false;
      }(e, t, i, s), true);
    }
    function Ss(e, t) {
      t = null;
      let i = e.linkingGroupsCharts.get(t);
      if (i === undefined) {
        i = new ht.WatchedObject([], ft.compareTwoCollectionsByIds);
        e.linkingGroupsCharts.set(t, i);
      }
      return i;
    }
    function bs(e, t, i) {
      return (0, Ji.combine)((e, t) => e || t, t.weakReference(), new F.WatchedValue(false).spawn().ownership());
    }
    function ws(e) {
      e.syncChartsDateRangesWithActiveChartRange();
    }
    const Cs = new Map();
    function Ps(e) {
      const t = Cs.get(e.id()) ?? {};
      Cs.set(e.id(), t);
      return t;
    }
    var Ts = i(15943);
    var xs = i(24317);
    var Is = i(19063);
    var Ms = i(48341);
    function As(e, t) {
      const i = Object.create(Object.getPrototypeOf(e));
      for (const s of t) {
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          i[s] = e[s];
        }
      }
      return i;
    }
    var Ls = i(58473);
    var ks = i(90995);
    let Ds;
    class Es extends Q.DialogRenderer {
      constructor() {
        super();
        this._dialog = null;
        this._subscribe = e => {
          this._setVisibility(e);
        };
      }
      show() {
        this._load().then(e => e.show());
      }
      hide() {
        this._dialog?.hide();
      }
      static getInstance() {
        Ds ||= new Es();
        return Ds;
      }
      _load() {
        return Promise.all([i.e(7714), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(7384), i.e(3799), i.e(2197), i.e(5480), i.e(9325), i.e(2736), i.e(4066), i.e(116), i.e(4353), i.e(3745), i.e(8692), i.e(3693), i.e(6190), i.e(2709), i.e(2227), i.e(4931), i.e(7746), i.e(9418), i.e(3202), i.e(4862)]).then(i.bind(i, 34489)).then(e => {
          this._dialog?.hide();
          this._dialog?.visible().unsubscribe(this._subscribe);
          this._dialog = new e.ObjectTreeDialogRenderer();
          this._dialog.visible().subscribe(this._subscribe);
          return this._dialog;
        });
      }
    }
    var Bs;
    var Vs = i(65383);
    var Rs = i(12988);
    async function Ns(e, t, s, o, n, r = "default") {
      let l;
      let c = [];
      const h = e.model().model();
      const d = (0, dt.clone)(t);
      const u = new Rs.Property({
        inputs: d
      });
      const _ = function (e, t) {
        if (t === "symbol") {
          return e.inputs.filter(t => t.id === e.symbolInputId());
        } else {
          return e.inputs.filter(e => e.confirm);
        }
      }(s, r);
      const p = () => {
        if (l) {
          h.removeCustomSource(l);
        }
      };
      const m = () => {
        p();
        n();
      };
      const g = e => {
        o({
          inputs: e,
          parentSources: c
        });
        p();
      };
      const f = _.filter(Vs.isTimeOrPriceNotHiddenInput);
      if (f.length > 0) {
        try {
          const t = await Promise.all([i.e(9003), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(9481), i.e(4600), i.e(2564), i.e(6445), i.e(7384), i.e(3799), i.e(2197), i.e(5480), i.e(5323), i.e(1072), i.e(9325), i.e(116), i.e(8985), i.e(8222), i.e(4106), i.e(7444), i.e(2440), i.e(9296), i.e(625), i.e(5083), i.e(9255), i.e(7935), i.e(422), i.e(1531), i.e(6316), i.e(2227), i.e(4931), i.e(9418), i.e(3202), i.e(2751), i.e(9928), i.e(7223), i.e(9443), i.e(3030)]).then(i.bind(i, 73339));
          const o = await t.selectInputValuesOnChart(e, f, u, s.shortDescription, s.inputs);
          l = o.customSourceId;
          if (o.destPane) {
            const e = o.destPane.mainDataSource();
            c = e === h.mainSeries() ? [] : [e];
          } else {
            c = [];
          }
        } catch (e) {
          m();
          return;
        }
      }
      if (f.length !== _.length) {
        Promise.all([i.e(9003), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(9481), i.e(4600), i.e(2564), i.e(6445), i.e(7384), i.e(3799), i.e(2197), i.e(5480), i.e(5323), i.e(1072), i.e(9325), i.e(116), i.e(8985), i.e(8222), i.e(4106), i.e(7444), i.e(2440), i.e(9296), i.e(625), i.e(5083), i.e(9255), i.e(7935), i.e(422), i.e(1531), i.e(6316), i.e(2227), i.e(4931), i.e(9418), i.e(3202), i.e(2751), i.e(9928), i.e(7223), i.e(9443), i.e(3030)]).then(i.bind(i, 29638)).then(t => {
          const o = new t.ConfirmInputsDialogRenderer(function (e) {
            if (e === "symbol") {
              return a.t(null, undefined, i(46501));
            }
            return a.t(null, undefined, i(48141));
          }(r), _, u, r, s, e.model(), g, m);
          o.show();
          return o;
        });
      } else {
        g(u.state().inputs || {});
      }
    }
    (function (e) {
      e.Default = "default";
      e.Symbol = "symbol";
    })(Bs ||= {});
    let Os = null;
    i(15216);
    var Fs = i(49481);
    var Ws = i(58096);
    const Hs = (0, Fs.parseHtmlElement)(function (e = "") {
      return `<div class="tv-spinner ${e}" role="progressbar"></div>`;
    }());
    class zs {
      constructor(e) {
        this._shown = false;
        this._el = Hs.cloneNode(true);
        this.setSize(Ws.spinnerSizeMap[e || Ws.DEFAULT_SIZE]);
      }
      spin(e) {
        this._el.classList.add("tv-spinner--shown");
        if (this._container === undefined) {
          this._container = e;
          if (e !== undefined) {
            e.appendChild(this._el);
          }
        }
        this._shown = true;
        return this;
      }
      stop(e) {
        if (e && this._container !== undefined) {
          this._container.removeChild(this._el);
        }
        if (this._el) {
          this._el.classList.remove("tv-spinner--shown");
        }
        this._shown = false;
        return this;
      }
      setStyle(e) {
        Object.keys(e).forEach(t => {
          const i = e[t];
          if (i !== undefined) {
            this._el.style.setProperty(t, i);
          }
        });
        return this;
      }
      style() {
        return this._el.style;
      }
      setSize(e) {
        const t = e !== undefined ? `tv-spinner--size_${e}` : "";
        this._el.className = `tv-spinner ${t} ${this._shown ? "tv-spinner--shown" : ""}`;
        return this;
      }
      getEl() {
        return this._el;
      }
      destroy() {
        this.stop();
        delete this._el;
        delete this._container;
      }
    }
    function Us(e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }
    function js(e) {
      return e.reduce((e, t) => {
        for (const i in t) {
          if (Us(t, i)) {
            const s = t[i];
            const o = e[i];
            if (o) {
              o.push(s);
            } else {
              e[i] = [s];
            }
          }
        }
        return e;
      }, {});
    }
    var Gs = i(43550);
    const qs = new Di.TranslatedString("move left", a.t(null, undefined, i(79209)));
    const $s = new Di.TranslatedString("move right", a.t(null, undefined, i(60114)));
    var Ks;
    (function (e) {
      e[e.AccelerationPerMSecPixels = 0.003] = "AccelerationPerMSecPixels";
      e[e.MaxSpeedPerMSecPixels = 1.1] = "MaxSpeedPerMSecPixels";
    })(Ks ||= {});
    class Ys {
      constructor(e) {
        this._chartModel = null;
        this._animation = null;
        this._chart = e;
        this._chart.withModel(this, () => {
          this._chartModel = this._chart.model();
        });
      }
      destroy() {
        this._animation?.stop();
      }
      move(e) {
        if (this._chartModel !== null) {
          if (this._chartModel.timeScale().isEmpty()) {
            return;
          }
          const t = 0.003;
          const i = 1.1;
          const s = Math.round(i / t);
          this._moveImpl(e, (o, n, r) => {
            const a = Math.min(n, s);
            const l = e * t * Math.pow(a, 2) / 2;
            if (n <= s) {
              return o + l;
            }
            const c = Number.isFinite(r) ? Math.max(0, s - r) : 0;
            return o + l + e * (n - a - c) * i + e * (i * c - t * Math.pow(c, 2) / 2);
          }, e => Math.max(0, s - e) + s);
        }
      }
      moveByBar(e) {
        if (this._chartModel !== null) {
          const t = this._chartModel.timeScale();
          const i = t.visibleBarsStrictRange();
          if (t.isEmpty() || i === null) {
            return;
          }
          const s = 300;
          const o = i.lastBar();
          this._moveImpl(e, (i, n) => {
            const r = Math.floor(Math.max(0, n - s) / 100) + 1;
            const a = o + e * r;
            const l = t.indexToCoordinate(o);
            return i + (t.indexToCoordinate(a) - l);
          }, () => 0, true);
        }
      }
      stopMove() {
        this._animation?.stop();
        this._animation = null;
      }
      scrollToRealtime(e) {
        if (this._chartModel !== null) {
          this._chartModel.timeScale().scrollToRealtime(e);
        }
      }
      _moveImpl(e, t, i, s) {
        if (this._chartModel === null) {
          return;
        }
        const o = this._chartModel.timeScale();
        if (o.isEmpty()) {
          return;
        }
        this._chartModel.changeTimeScale(e === 1 ? qs : $s, false);
        if (s && o.visibleBarsStrictRange() !== null) {
          const e = o.indexToCoordinate(o.visibleBarsStrictRange().lastBar()) + o.barSpacing() / 2;
          if (Math.abs(o.width() - e) > o.barSpacing() / 6) {
            o.setRightOffset(Math.round(o.rightOffset()));
          }
        }
        const n = performance.now();
        let r = Infinity;
        this._animation = {
          getStartPosition: () => 0,
          getPosition: e => {
            e = Math.min(r, e);
            return t(0, e - n, r - e);
          },
          finished: e => e >= r,
          stop: () => {
            const e = performance.now() - n;
            r = performance.now() + i(e);
          }
        };
        this._chartModel.model().stopTimeScaleAnimation();
        this._chartModel.model().setTimeScaleAnimation(this._animation);
      }
    }
    var Zs = i(26023);
    function Xs(e, t, s, o, n) {
      return Promise.all([i.e(4593), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(2564), i.e(6445), i.e(7384), i.e(3799), i.e(2197), i.e(5480), i.e(5323), i.e(1072), i.e(9325), i.e(4066), i.e(116), i.e(8985), i.e(9766), i.e(8222), i.e(4106), i.e(7444), i.e(5375), i.e(2440), i.e(9296), i.e(625), i.e(5083), i.e(3362), i.e(9255), i.e(7935), i.e(601), i.e(422), i.e(1531), i.e(8544), i.e(3828), i.e(7519), i.e(5168), i.e(6847), i.e(2864), i.e(2227), i.e(4931), i.e(9418), i.e(3202), i.e(2751), i.e(769), i.e(9928), i.e(7223), i.e(9443), i.e(3489), i.e(6265)]).then(i.bind(i, 81346)).then(i => {
        const r = new (0, i.EditObjectDialogRenderer)(e, t, o, n);
        r.show(s);
        return r;
      });
    }
    var Js = i(79036);
    let Qs = null;
    var eo = i(32755);
    const to = {
      [Zs.TabNames.symbol]: "symbol",
      [Zs.TabNames.legend]: "legend",
      [Zs.TabNames.scales]: "scales",
      [Zs.TabNames.trading]: "trading",
      [Zs.TabNames.events]: "events",
      [Zs.TabNames.alerts]: "alerts",
      [Zs.TabNames.timezoneSessions]: "canvas",
      [Zs.TabNames.text]: "text",
      [Zs.TabNames.style]: "style",
      [Zs.TabNames.visibility]: "visibility"
    };
    const io = {
      [Zs.TabNames.style]: "style",
      [Zs.TabNames.visibility]: "visibilities"
    };
    async function so(e, t, s = {}, o, n) {
      const r = o.activeChartWidget.value();
      const {
        initialTab: a,
        tabName: l
      } = s;
      if (l && !a) {
        s.initialTab = io[l];
      }
      if ((0, eo.isStudyLineTool)(e) && function (e) {
        if (!(0, eo.isStudyLineTool)(e)) {
          return false;
        }
        return ["LineToolFixedRangeVolumeProfile", "LineToolVbPFixed", null].filter(dt.notNull).some(t => e.toolname === t);
      }(e)) {
        return r.propertiesDefinitionsForSource(e).then(i => i !== null ? Xs(e, t, s, n, i) : null);
      }
      if ((0, Js.isStudy)(e) && function (e) {
        const {
          shortId: t
        } = e.metaInfo();
        return t === "Overlay";
      }(e) || (0, eo.isLineTool)(e)) {
        return r.propertiesDefinitionsForSource(e).then(o => {
          if (o !== null) {
            return function (e) {
              return Promise.all([i.e(6655), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(2564), i.e(6445), i.e(7384), i.e(3799), i.e(2197), i.e(5480), i.e(5323), i.e(1072), i.e(9325), i.e(4066), i.e(116), i.e(8985), i.e(9766), i.e(8222), i.e(4106), i.e(7444), i.e(5375), i.e(2440), i.e(9296), i.e(625), i.e(5083), i.e(9255), i.e(7935), i.e(601), i.e(422), i.e(1531), i.e(8544), i.e(3828), i.e(7519), i.e(6847), i.e(1833), i.e(2227), i.e(4931), i.e(9418), i.e(3202), i.e(2751), i.e(769), i.e(9928), i.e(7223), i.e(9443), i.e(3489), i.e(6780)]).then(i.bind(i, 75892)).then(t => {
                const i = new (0, t.SourcePropertiesEditorRenderer)(e);
                if (Qs !== null) {
                  Qs.hide();
                }
                i.show({
                  shouldReturnFocus: e.shouldReturnFocus
                });
                Qs = i;
                return i;
              });
            }({
              propertyPages: o,
              model: t,
              source: e,
              activePageId: l && to[l],
              shouldReturnFocus: s.shouldReturnFocus
            });
          }
          return null;
        });
      }
      if ((0, Js.isStudy)(e)) {
        return Xs(e, t, s, n);
      }
      {
        const e = l && to[l];
        const t = o.getChartPropertiesDialogRenderer();
        t.setActivePage(e);
        return t.show(s);
      }
    }
    var oo = i(24633);
    async function no() {
      return (await Promise.all([i.e(2564), i.e(8666), i.e(2227), i.e(139)]).then(i.bind(i, 81200))).ErrorCardRenderer;
    }
    var ro = i(82236);
    var ao = i(62825);
    const lo = (0, Lt.getHexColorByName)("color-cold-gray-700");
    const co = (0, Lt.getHexColorByName)("color-cold-gray-400");
    const ho = (0, Lt.getHexColorByName)("color-cold-gray-900");
    const uo = (0, Lt.getHexColorByName)("color-white");
    const _o = a.t(null, undefined, i(18905));
    function po(e) {
      if (e) {
        return {
          ...e,
          message: (0, ro.formatStudyError)(e.message),
          rawHtml: true
        };
      } else {
        return null;
      }
    }
    class mo {
      constructor(e) {
        this._container = null;
        this._errorCardRenderer = null;
        this._mainSeriesErrorMessage = null;
        this._banErrorMessage = new F.WatchedValue(null).spawn();
        this._errorMessageHandler = e => {
          e = po(e);
          if (this._chartWidget.hasModel()) {
            this._updatePaneWidgets(e);
          } else {
            this._renderErrorWithoutModel(e);
          }
        };
        this._chartWidget = e;
        this._subscribeToMainSeriesErrors();
      }
      destroy() {
        this._mainSeriesErrorMessage?.destroy();
        this._banErrorMessage.destroy();
        this._errorCardRenderer?.then(e => {
          e.container.remove();
          e.destroy();
        });
      }
      updatePaneWidgets() {
        this._updatePaneWidgets();
      }
      setContainer(e) {
        if (this._container !== e) {
          this._container = e;
          this._errorCardRenderer?.then(e => e.container.remove());
          const t = this._getErrorMessage();
          if (t) {
            this._errorMessageHandler(t);
          }
        }
      }
      _updatePaneWidgets(e = this._getErrorMessage()) {
        this._chartWidget.paneWidgets().forEach(t => t.setErrorMessage(e));
      }
      async _renderErrorWithoutModel(e) {
        if (this._container === null || e === null && this._errorCardRenderer === null) {
          return;
        }
        const t = await this._getErrorCardRenderer();
        if (!this._container.contains(t.container)) {
          this._container.appendChild(t.container);
        }
        t.update(this._createErrorCardRendererState(e));
      }
      async _getErrorCardRenderer() {
        return this._errorCardRenderer ||= this._createErrorCardRenderer();
      }
      async _createErrorCardRenderer() {
        return new (await no())();
      }
      _createErrorCardRendererState(e) {
        if (e) {
          return {
            message: e.message,
            icon: e.icon,
            textColor: D.watchedTheme.value() === oo.StdTheme.Dark ? co : lo,
            backgroundColor: D.watchedTheme.value() === oo.StdTheme.Dark ? ho : uo,
            solutionId: e.solutionId,
            rawHtml: e.rawHtml,
            buttons: e.buttons
          };
        } else {
          return {
            message: null
          };
        }
      }
      _subscribeToMainSeriesErrors() {
        const e = this._chartWidget;
        e.withModel(this, () => {
          const t = e.model().model().mainSeries();
          this._mainSeriesErrorMessage = (0, Ji.combine)((t, s) => {
            if (t) {
              return t;
            }
            if (s === null) {
              return null;
            }
            switch (s.type) {
              case "invalid_symbol":
                return {
                  message: a.t(null, undefined, i(52969)),
                  icon: "ghost"
                };
              case "calculations_error":
                return {
                  message: s.errorMessage,
                  icon: "attention"
                };
              case "no_data":
                return {
                  message: a.t(null, undefined, i(36252)),
                  icon: "ghost"
                };
              case "unsupported_resolution":
                return this._createErrorParamsForUnsupportedResolution(e);
            }
          }, this._banErrorMessage.weakReference(), (0, yt.getSeriesDisplayErrorWV)(t).ownership());
          this._mainSeriesErrorMessage.subscribe(this._errorMessageHandler, {
            callWithLast: true
          });
        });
      }
      _createErrorParamsForUnsupportedResolution(e) {
        const t = e.model();
        const i = t.mainSeries().unsupportedResolutionState().value();
        if (i === null) {
          return null;
        } else {
          return {
            message: (0, ao.getErrorFromUnsupportedResolutionState)(i, true),
            icon: "unsupported-resolution",
            rawHtml: true,
            maxHeight: 400,
            zeroHeight: 200,
            buttons: [{
              name: _o.format({
                resolution: i.applicableResolution
              }),
              onClick: () => {
                t.setResolution(t.model().mainSeries(), i.applicableResolution);
              }
            }]
          };
        }
      }
      _getErrorMessage() {
        return po(this._banErrorMessage.value() || this._mainSeriesErrorMessage?.value() || null);
      }
    }
    var go;
    var fo = i(776);
    var yo = i(62288);
    var vo = i(69186);
    var So = i(46088);
    var bo = i(4340);
    var wo = i(20350);
    class Co {
      constructor(e, t) {
        this._showed = false;
        this._additionalReadyPromise = null;
        this._cw = e;
        this._element = document.createElement("div");
        this._element.classList.add(wo.screen);
        t.appendChild(this._element);
        this._cw.withModel(this, this._connectToModel);
      }
      destroy() {
        this.hide();
        this._element.remove();
      }
      show(e, t) {
        if (e) {
          const e = this._cw.model().mainSeries().status();
          if (e !== 1 && e !== 2) {
            return;
          }
        }
        this._additionalReadyPromise = t;
        this._cw.setInLoadingState(true);
        if (!this._showed) {
          this._showed = true;
          this._show();
        }
      }
      hide() {
        this._cw.setInLoadingState(false);
        if (this._showed) {
          this._hide();
        }
      }
      isShown() {
        return this._showed;
      }
      _connectToModel() {
        const e = this._cw.model().mainSeries();
        const t = e.dataEvents();
        t.symbolError().subscribe(this, e => {
          if (e !== bo.permissionDenied) {
            this.hide();
          }
        });
        t.seriesError().subscribe(this, () => {
          if ((0, l.enabled)("hide_loading_screen_on_series_error")) {
            this.hide();
          }
        });
        e.statusWV().subscribe(e => {
          if (e === 4 || e === 12 || e === 13 || e === 14) {
            this.hide();
          }
          if (_t.seriesReadyStatuses.has(e)) {
            const e = this._additionalReadyPromise;
            if (e) {
              e.then(() => {
                this.hide();
              });
            } else {
              this.hide();
            }
          }
        });
      }
      _show() {
        const e = this._cw.properties().childs().paneProperties.childs();
        let t;
        if (e.backgroundType.value() === So.ColorType.Solid) {
          t = e.background.value();
        } else {
          t = `linear-gradient(${e.backgroundGradientStartColor.value()},${e.backgroundGradientEndColor.value()})`;
        }
        this._element.style.background = t;
        this._element.classList.add(wo.fade);
      }
      _hide() {
        this._showed = false;
        this._element.classList.remove(wo.fade);
      }
    }
    function Po(e, t) {
      let {
        deltaX: i,
        deltaY: s
      } = e;
      i /= 100;
      s /= 100;
      switch (t.deltaMode) {
        case t.DOM_DELTA_PAGE:
          i *= 120;
          s *= 120;
          break;
        case t.DOM_DELTA_LINE:
          i *= 32;
          s *= 32;
      }
      return {
        deltaX: i,
        deltaY: s
      };
    }
    (function (e) {
      e[e.MaxNextEventDelay = 100] = "MaxNextEventDelay";
      e[e.IgnoreSmallerDeltaCoeff = 3] = "IgnoreSmallerDeltaCoeff";
    })(go ||= {});
    class To {
      constructor() {
        this._totalDeltaX = 0;
        this._totalDeltaY = 0;
        this._prevWheelTime = 0;
      }
      processWheel(e) {
        if (e.timeStamp - this._prevWheelTime > 100) {
          this._reset();
        }
        const t = !(0, ze.isMac)() && e.shiftKey;
        const i = t ? -e.deltaY : e.deltaX;
        const s = t ? e.deltaX : e.deltaY;
        this._totalDeltaX += i;
        this._totalDeltaY += s;
        this._prevWheelTime = e.timeStamp;
        const o = {
          deltaX: i,
          deltaY: s
        };
        if (this._totalDeltaX !== 0 && this._totalDeltaY !== 0) {
          if (Math.abs(this._totalDeltaX) >= Math.abs(this._totalDeltaY * 3)) {
            o.deltaY = 0;
          }
          if (Math.abs(this._totalDeltaY) >= Math.abs(this._totalDeltaX * 3)) {
            o.deltaX = 0;
          }
        }
        return Po(o, e);
      }
      _reset() {
        this._totalDeltaX = 0;
        this._totalDeltaY = 0;
      }
    }
    var xo;
    var Io = i(9859);
    var Mo = i(56479);
    (function (e) {
      e[e.Height = 1] = "Height";
      e[e.MinPaneHeight = 30] = "MinPaneHeight";
    })(xo ||= {});
    class Ao {
      constructor(e, t, i) {
        this._handleEl = null;
        this._resizeInfo = null;
        this._colorCache = {
          lineColor: "",
          backgroundColor: "",
          color: ""
        };
        this._selected = new F.WatchedValue();
        this._chart = e;
        this._topPaneIndex = t;
        this._bottomPaneIndex = i;
        this._element = document.createElement("div");
        this._element.classList.add(Mo.paneSeparator);
        this._element.style.background = this._color();
        this.adjustSize();
        this._element.addEventListener("click", () => { });
        const s = document.createElement("div");
        s.classList.add(Mo.handle);
        this._element.appendChild(s);
        this._mouseEventHandler = new Et.MouseEventHandler(s, this, {
          treatVertTouchDragAsPageScroll: false,
          treatHorzTouchDragAsPageScroll: true
        });
        this._handleEl = s;
        this._handleEl.classList.toggle(Mo.mobile, ze.CheckMobile.any());
        this._element.setAttribute("aria-hidden", "true");
        this._selected.subscribe(e => this._handleEl?.classList.toggle(Mo.selected, e));
      }
      destroy() {
        this._mouseEventHandler.destroy();
        if (this._element.parentElement) {
          this._element.parentElement.removeChild(this._element);
        }
      }
      topPaneIndex() {
        return this._topPaneIndex;
      }
      bottomPaneIndex() {
        return this._bottomPaneIndex;
      }
      getElement() {
        return this._element;
      }
      hide() {
        this._element.classList.add("js-hidden");
      }
      show() {
        this._element.classList.remove("js-hidden");
      }
      selected() {
        return this._selected.readonly();
      }
      adjustSize() {
        this._element.style.height = Ao.height() + "px";
      }
      mouseEnterEvent(e) {
        const {
          topPane: t,
          bottomPane: i
        } = this._topBottomPane(true);
        if (t !== null && i !== null) {
          (0, n.ensureNotNull)(this._handleEl).classList.add(Mo.hovered);
        }
      }
      mouseLeaveEvent(e) {
        (0, n.ensureNotNull)(this._handleEl).classList.remove(Mo.hovered);
      }
      mouseDownEvent(e) {
        this._mouseDownOrTouchStartEvent(e);
      }
      tapEvent() {
        this._selected.setValue(!this._selected.value());
      }
      touchStartEvent(e) {
        if (this._selected.value()) {
          this._mouseDownOrTouchStartEvent(e);
        }
      }
      pressedMouseMoveEvent(e) {
        this._pressedMouseOrTouchMoveEvent(e);
      }
      touchMoveEvent(e) {
        if (this._selected.value()) {
          this._pressedMouseOrTouchMoveEvent(e);
        }
      }
      mouseUpEvent(e) {
        this._mouseUpOrTouchEndEvent(e);
      }
      touchEndEvent(e) {
        if (this._selected.value()) {
          this._mouseUpOrTouchEndEvent(e);
        }
      }
      touchStartOutsideEvent() {
        this._selected.setValue(false);
      }
      update() {
        this._element.style.background = this._color().toString();
      }
      paint() { }
      image() {
        const {
          topPane: e
        } = this._topBottomPane(false);
        const t = e.leftPriceAxisesContainer().getWidth();
        const i = e.width();
        const s = e.rightPriceAxisesContainer().getWidth();
        const o = this._color();
        const n = (0, Wt.createDisconnectedCanvas)(document, (0, Dt.size)({
          width: t,
          height: 1
        }));
        const r = (0, Wt.getPrescaledContext2D)(n);
        r.fillStyle = o;
        r.fillRect(0, 0, t, 1);
        const a = (0, Wt.createDisconnectedCanvas)(document, (0, Dt.size)({
          width: i,
          height: 1
        }));
        const l = (0, Wt.getPrescaledContext2D)(a);
        l.fillStyle = o;
        l.fillRect(0, 0, i, 1);
        const c = (0, Wt.createDisconnectedCanvas)(document, (0, Dt.size)({
          width: s,
          height: 1
        }));
        const h = (0, Wt.getPrescaledContext2D)(c);
        h.fillStyle = o;
        h.fillRect(0, 0, s, 1);
        return {
          type: "separator",
          leftAxis: {
            content: n.toDataURL(),
            canvas: n,
            contentWidth: t,
            contentHeight: 1
          },
          rightAxis: {
            content: c.toDataURL(),
            canvas: c,
            contentWidth: s,
            contentHeight: 1
          },
          content: a.toDataURL(),
          canvas: a,
          contentWidth: i,
          contentHeight: 1
        };
      }
      static height() {
        const e = window.devicePixelRatio || 1;
        if (e >= 1) {
          return 1;
        } else {
          return 1 / e;
        }
      }
      _mouseDownOrTouchStartEvent(e) {
        const {
          topPane: t,
          bottomPane: i
        } = this._topBottomPane(true);
        if (t === null || i === null) {
          return;
        }
        const s = t.state().stretchFactor() + i.state().stretchFactor();
        const o = s / (t.height() + i.height());
        const r = o * 30;
        if (!(s <= r * 2)) {
          this._resizeInfo = {
            startY: e.pageY,
            prevStretchTopPane: t.state().stretchFactor(),
            maxPaneStretch: s - r,
            totalStretch: s,
            pixelStretchFactor: o,
            minPaneStretch: r
          };
          (0, n.ensureNotNull)(this._handleEl).classList.add(Mo.active);
        }
      }
      _pressedMouseOrTouchMoveEvent(e) {
        const {
          topPane: t,
          bottomPane: i
        } = this._topBottomPane(true);
        const s = this._resizeInfo;
        if (s === null || t === null || i === null) {
          return;
        }
        const o = (e.pageY - s.startY) * s.pixelStretchFactor;
        const n = (0, Io.clamp)(s.prevStretchTopPane + o, s.minPaneStretch, s.maxPaneStretch);
        t.state().setStretchFactor(n);
        i.state().setStretchFactor(s.totalStretch - n);
        this._chart.model().model().fullUpdate();
      }
      _mouseUpOrTouchEndEvent(e) {
        const {
          topPane: t,
          bottomPane: i
        } = this._topBottomPane(true);
        const s = this._resizeInfo;
        if (s !== null && t !== null && i !== null) {
          this._chart.model().addPaneStretchFactorUndoCommand(t.state(), i.state(), s.prevStretchTopPane, t.state().stretchFactor());
          this._resizeInfo = null;
          (0, n.ensureNotNull)(this._handleEl).classList.remove(Mo.active);
        }
      }
      _color() {
        const e = this._chart.properties().childs().paneProperties.childs().separatorColor.value();
        const t = this._chart.model().model().backgroundColor().value();
        if (this._colorCache.lineColor !== e || this._colorCache.backgroundColor !== t) {
          const i = (0, kt.parseRgba)(t);
          const s = (0, kt.parseRgba)(e);
          const o = i[3] === 0 && s[3] === 0 ? "rgba(0,0,0,0)" : (0, kt.rgbaToString)((0, kt.blendRgba)(i, s));
          this._colorCache = {
            lineColor: e,
            backgroundColor: t,
            color: o
          };
        }
        return this._colorCache.color;
      }
      _topBottomPane(e) {
        const t = this._chart.paneWidgets();
        let i = null;
        let s = null;
        for (let s = this._topPaneIndex; s >= 0; --s) {
          const o = t[s];
          if (!e || !o.state().collapsed().value()) {
            i = o;
            break;
          }
        }
        for (let i = this._bottomPaneIndex; i < t.length; ++i) {
          const o = t[i];
          if (!e || !o.state().collapsed().value()) {
            s = o;
            break;
          }
        }
        return {
          topPane: i,
          bottomPane: s
        };
      }
    }
    var Lo;
    var ko;
    var Do = i(50279);
    var Eo = i(80720);
    var Bo = i(28331);
    var Vo = i(66666);
    var Ro = i(77336);
    var No = i(12027);
    var Oo = i(40443);
    var Fo = i(94194);
    var Wo = i(7983);
    (function (e) {
      e[e.LabelRadius = 9.5] = "LabelRadius";
      e[e.LabelFontSize = 11] = "LabelFontSize";
    })(Lo ||= {});
    (function (e) {
      e[e.Gear = 0] = "Gear";
      e[e.Symbol = 1] = "Symbol";
      e[e.Auto = 2] = "Auto";
    })(ko ||= {});
    const Ho = (0, Yt.makeFont)(11, g.CHART_FONT_FAMILY);
    const zo = {
      enableTooltip: true,
      showLabels: true,
      enableMenu: true,
      enableHighlight: true
    };
    function Uo(e, t) {
      return Math.max(1, Math.floor(e.borderSize * t));
    }
    class jo {
      constructor(e, t, i, s, o, n = null) {
        this._invalidated = true;
        this._size = (0, Dt.size)({
          width: 0,
          height: 0
        });
        this._offset = 0;
        this._axisInfo = null;
        this._onLabelHovered = new re.Delegate();
        this._highlighted = false;
        this._labelMode = 2;
        this._fixedLabelMode = null;
        this._textWidthCache = new Gt.TextWidthCache(5);
        this._gearRenderer = (0, No.svgRenderer)(Wo);
        this._canvasConfiguredHandler = () => {
          this.update();
          this._textWidthCache.reset();
        };
        this._timeAxisWidget = n;
        this._isLeft = e === "left";
        const {
          rendererOptionsProvider: r,
          sourcesTitlesProvider: a,
          contextMenuItemsProvider: l,
          backgroundBasedTheme: c,
          onActiveOrHoveredChart: h = new F.WatchedValue(false).ownership(),
          requestRepaint: d,
          getBackgroundTopColor: u,
          getBackgroundBottomColor: _,
          showHorizontalBorder: p
        } = s;
        this._rendererOptionsProvider = r;
        this._sourcesTitlesProvider = a;
        this._contextMenuItemsProvider = l;
        this._backgroundBasedTheme = c;
        this._onActiveOrHoveredChart = h;
        this._requestRepaint = d;
        this._getBackgroundTopColor = u;
        this._getBackgroundBottomColor = _;
        this._showHorizontalBorder = Boolean(p);
        this._properties = t;
        this._axisInfo = i;
        this._labelOptions = {
          ...zo,
          ...o
        };
        this._properties.lineColor.subscribe(this, this._onPropertyChanged);
        this._cell = document.createElement("div");
        if (this._labelOptions.enableTooltip) {
          this._cell.classList.add("apply-common-tooltip");
        }
        this._cell.style.width = "25px";
        this._cell.style.height = "100%";
        this._cell.style.position = "absolute";
        this._cell.style.left = "0";
        this._cell.style.overflow = "hidden";
        if (this._labelOptions.showLabels) {
          if (this._labelOptions.enableTooltip) {
            (0, Fo.setTooltipData)(this._cell, "text", e => this._tooltipContent());
          }
          this._onActiveOrHoveredChart.subscribe(d);
        }
        this._mouseEventHandler = new Et.MouseEventHandler(this._cell, this, {
          treatHorzTouchDragAsPageScroll: true,
          treatVertTouchDragAsPageScroll: true
        });
        this._canvasBinding = (0, Wt.createBoundCanvas)(this._cell, (0, Dt.size)({
          width: 16,
          height: 16
        }));
        this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        const m = this._canvasBinding.canvasElement;
        m.style.position = "absolute";
        m.style.left = "0";
        m.style.top = "0";
        this._cell.setAttribute("aria-hidden", "true");
      }
      destroy() {
        this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        this._canvasBinding.dispose();
        this._properties.lineColor.unsubscribe(this, this._onPropertyChanged);
        this._mouseEventHandler.destroy();
        this._backgroundBasedTheme.release();
        this._onActiveOrHoveredChart.unsubscribe(this._requestRepaint);
        this._onActiveOrHoveredChart.release();
      }
      mouseEnterEvent(e) {
        this._mouseOrTouchEnterEvent(e);
      }
      touchStartEvent(e) {
        this._mouseOrTouchEnterEvent(e);
      }
      mouseLeaveEvent(e) {
        this._mouseOrTouchLeaveEvent(e);
      }
      touchEndEvent(e) {
        this._mouseOrTouchLeaveEvent(e);
      }
      mouseClickEvent(e) {
        this._mouseClickOrTapEvent(e);
      }
      tapEvent(e) {
        this._mouseClickOrTapEvent(e);
      }
      update() { }
      getElement() {
        return this._cell;
      }
      onLabelHovered() {
        return this._onLabelHovered;
      }
      setSizeAndOffset(e, t) {
        if (!(0, Dt.equalSizes)(this._size, e)) {
          this._size = e;
          this._canvasBinding.resizeCanvasElement(e);
          this._cell.style.width = `${e.width}px`;
          this._cell.style.minWidth = `${e.width}px`;
          this._cell.style.height = `${e.height}px`;
          this._invalidated = true;
        }
        if (this._offset !== t) {
          this._offset = t;
          this._cell.style.left = `${t}px`;
        }
      }
      paint(e) {
        if (!(e < yo.InvalidationLevel.Full) || !!this._invalidated) {
          if (this._size.width !== 0 && this._size.height !== 0) {
            this._invalidated = false;
            (0, Wt.tryApplySuggestedCanvasBitmapSize)(this._canvasBinding);
            this._paintImpl((0, Wt.getContext2D)(this._canvasBinding.canvasElement), (0, Wt.getBindingRenderingInfo)(this._canvasBinding));
          }
        }
      }
      getWidth() {
        return this._size.width;
      }
      getImage() {
        const e = (0, Wt.getBindingRenderingInfo)(this._canvasBinding);
        const t = (0, Wt.createDisconnectedCanvasByRenderingInfo)(document, e);
        this._paintImpl((0, Wt.getContext2D)(t), e, true);
        return t;
      }
      setLabelMode(e) {
        if (e !== this._labelMode) {
          this._labelMode = e;
          this._cell.classList.toggle("apply-common-tooltip", e !== 1 && this._labelOptions.enableTooltip);
        }
      }
      _paintImpl(e, t, i) {
        this._drawBackground(e, t);
        this._drawVerticalBorder(e, t);
        if (this._showHorizontalBorder) {
          this._drawHorizontalBorder(e, t);
        }
        if (this._labelOptions.showLabels) {
          this._drawLabel(e, t, i);
        }
      }
      _setHighlighted(e) {
        if (this._labelOptions.enableHighlight) {
          this._onLabelHovered.fire("stubButton", e);
          if (this._highlighted !== e) {
            this._highlighted = e;
            this._invalidated = true;
          }
        }
      }
      _onPropertyChanged() {
        this._invalidated = true;
      }
      _drawVerticalBorder(e, t) {
        e.save();
        e.fillStyle = this._vertBorderColor();
        const i = Uo(this._rendererOptionsProvider.options(), t.horizontalPixelRatio);
        const s = this._isLeft ? t.bitmapSize.width - i : 0;
        e.fillRect(s, 0, i, t.bitmapSize.height);
        e.restore();
      }
      _drawHorizontalBorder(e, t) {
        e.save();
        e.fillStyle = this._horzBorderColor();
        const i = Uo(this._rendererOptionsProvider.options(), t.verticalPixelRatio);
        const s = this._isLeft ? 0 : i;
        e.fillRect(s, 0, t.bitmapSize.width - i, i);
        e.restore();
      }
      _drawBackground(e, t) {
        const i = this._getBackgroundTopColor();
        const s = this._getBackgroundBottomColor();
        const {
          bitmapSize: o
        } = t;
        if (i === s) {
          (0, Wt.clearRect)(e, 0, 0, o.width, o.height, i);
        } else {
          (0, Ft.clearRectWithGradient)(e, 0, 0, o.width, o.height, i, s);
        }
        if (this._highlighted) {
          const t = k.themes[this._backgroundBasedTheme.value()].getThemedColor("color-price-axis-highlight");
          (0, Wt.fillRect)(e, 0, 0, o.width, o.height, t);
          e.globalAlpha = 1;
        }
      }
      _drawLabel(e, t, i) {
        const s = this._backgroundBasedTheme.value();
        const o = this._axisInfo;
        if (o === null || !i && !this._onActiveOrHoveredChart.value()) {
          return;
        }
        const {
          bitmapSize: n,
          horizontalPixelRatio: r,
          verticalPixelRatio: a
        } = t;
        const l = Uo(this._rendererOptionsProvider.options(), r);
        const c = Math.round(n.width) - l;
        const h = Uo(this._rendererOptionsProvider.options(), a);
        const d = Math.round(n.height) - h;
        const u = (0, At.point)(l + c / 2, h + d / 2);
        if (this._labelMode === 1 || this._labelMode === 2 && (!this._highlighted || i)) {
          e.fillStyle = k.themes[s].getThemedColor("color-price-axis-label-back");
          e.globalAlpha = 0.5;
          e.beginPath();
          e.arc(u.x, u.y, r * 9.5, 0, Math.PI * 2, true);
          e.fill();
          e.globalAlpha = 1;
          e.fillStyle = k.themes[s].getThemedColor("color-price-axis-label-text");
          e.font = Ho;
          e.textAlign = "center";
          e.textBaseline = "middle";
          const t = this._textWidthCache.yMidCorrection(e, o.label);
          (0, Wt.drawScaled)(e, r, a, () => {
            e.fillText(o.label, u.x / r, u.y / a + t);
          });
        } else if (!i && this._onActiveOrHoveredChart.value()) {
          const t = this._gearRenderer.viewBox();
          const i = Math.round(u.x - t.width * r / 2);
          const o = Math.round(u.y - t.height * a / 2);
          e.fillStyle = k.themes[s].getThemedColor("color-text-primary");
          e.imageSmoothingQuality = "high";
          this._gearRenderer.render(e, {
            targetViewBox: {
              x: i,
              y: o,
              width: t.width * r,
              height: t.height * a
            },
            doNotApplyColors: true
          });
        }
      }
      _vertBorderColor() {
        return this._properties.lineColor.value();
      }
      _horzBorderColor() {
        return this._timeAxisWidget?.lineColor() ?? this._vertBorderColor();
      }
      _tooltipContent() {
        return this._sourcesTitlesProvider().join("\n");
      }
      _mouseOrTouchEnterEvent(e) {
        if (this._labelOptions.showLabels && this._labelOptions.enableHighlight) {
          this._setHighlighted(true);
        }
      }
      _mouseOrTouchLeaveEvent(e) {
        if (this._labelOptions.showLabels && this._labelOptions.enableHighlight) {
          this._setHighlighted(false);
        }
      }
      _mouseClickOrTapEvent(e) {
        e.preventDefault();
        if (this._fixedLabelMode !== null || this._labelMode === 1 || !this._labelOptions.enableMenu || !this._labelOptions.showLabels) {
          Oo.ContextMenuManager.hideAll();
          return;
        }
        this._fixedLabelMode = this._labelMode;
        this.setLabelMode(0);
        const t = this._cell.getBoundingClientRect();
        Oo.ContextMenuManager.showMenu(this._contextMenuItemsProvider(), {
          clientX: this._isLeft ? t.left : t.right,
          clientY: t.top,
          attachToXBy: this._isLeft ? "left" : "right",
          attachToYBy: "bottom"
        }, {
          statName: "PriceScaleLabelContextMenu",
          doNotCloseOn: this.getElement()
        }, {
          menuName: "PriceScaleLabelContextMenu"
        }, () => {
          this.setLabelMode((0, n.ensureNotNull)(this._fixedLabelMode));
          this._fixedLabelMode = null;
        });
      }
    }
    var Go = i(96152);
    class qo {
      constructor(e, t, i, s, o, n = null) {
        this._axises = [];
        this._stubs = [];
        this._size = (0, Dt.size)({
          width: 0,
          height: 0
        });
        this._onLabelHovered = new re.Delegate();
        this._scalesProperties = e;
        this._priceAxisWidgetFactory = i;
        this._timeAxisWidget = n;
        this._rendererOptionsProvider = s.rendererOptionsProvider;
        this._titlesProvider = s.titlesProvider;
        this._stubContextMenuProvider = s.stubContextMenuProvider;
        this._backgroundBasedTheme = s.backgroundBasedTheme;
        this._onActiveOrHoveredChart = s.onActiveOrHoveredChart;
        this._getBackgroundTopColor = s.getBackgroundTopColor;
        this._getBackgroundBottomColor = s.getBackgroundBottomColor;
        this._requestRepaint = s.requestRepaint;
        this._showHorisontalBorder = Boolean(s.showHorizontalBorder);
        this._labelsOptions = {
          ...zo,
          ...o
        };
        const r = this._scalesProperties.childs();
        this._stubProperties = {
          lineColor: r.lineColor,
          fontSize: r.fontSize
        };
        this._side = t;
        this._cell = document.createElement("div");
        this._cell.classList.add("chart-markup-table", "price-axis-container");
        this._cell.style.width = "25px";
        this._cell.style.position = "relative";
      }
      destroy() {
        this.setScales([], 0, 0, 0);
        this._backgroundBasedTheme.release();
        this._onActiveOrHoveredChart?.release();
      }
      onLabelHovered() {
        return this._onLabelHovered;
      }
      setScales(e, t, i, s) {
        while (e.length > this._axises.length && this._axises.length < t) {
          const e = (0, Go.getPriceAxisNameInfo)(this._side, this._axises.length);
          const t = this._priceAxisWidgetFactory(this._side, this._rendererOptionsProvider, this._scalesProperties, e, this._backgroundBasedTheme);
          this._axises.push(t);
          this._cell.appendChild(t.getElement());
        }
        while (e.length < this._axises.length) {
          const e = (0, n.ensureDefined)(this._axises.pop());
          this._cell.removeChild(e.getElement());
          e.destroy();
        }
        for (let t = 0; t < this._axises.length; ++t) {
          this._axises[t].setPriceScale(e[t]);
        }
        const o = t - e.length;
        const r = Math.max(0, o);
        while (this._stubs.length > r) {
          const e = (0, n.ensureDefined)(this._stubs.pop());
          e.onLabelHovered().unsubscribeAll(this);
          this._cell.removeChild(e.getElement());
          e.destroy();
        }
        while (this._stubs.length < o) {
          const e = this._labelsOptions.showLabels ? (0, Go.getPriceAxisNameInfo)(this._side, this._stubs.length) : null;
          const t = new jo(this._side, this._stubProperties, e, this._stubParams(this._stubs.length), this._labelsOptions, this._timeAxisWidget);
          t.onLabelHovered().subscribe(this, (t, i) => {
            if (this._labelsOptions.showLabels && this._labelsOptions.enableHighlight) {
              this._onLabelHovered.fire({
                owner: t,
                axis: (0, n.ensureNotNull)(e)
              }, i);
            }
          });
          this._stubs.push(t);
          this._cell.appendChild(t.getElement());
        }
        const a = this._labelsOptions.enableMenu;
        if (s === 1) {
          this._stubs.forEach((e, t) => e.setLabelMode(a ? 0 : 1));
        } else {
          this._stubs.forEach((e, t) => e.setLabelMode(t < i && a ? 2 : 1));
        }
      }
      getElement() {
        return this._cell;
      }
      updateCurrencyLabels() {
        return this._axises.forEach(e => e.updateCurrencyLabel());
      }
      optimalWidths() {
        return this._axises.map(e => e.optimalWidth());
      }
      setSizes(e, t) {
        this._size = (0, Dt.size)({
          width: t.reduce((e, t) => e + t, 0),
          height: e
        });
        this._cell.style.width = this._size.width + "px";
        this._cell.style.minWidth = this._size.width + "px";
        this._cell.style.height = this._size.height + "px";
        if (t.length !== this._axises.length + this._stubs.length) {
          (0, n.assert)(t.length === this._axises.length + this._stubs.length, "Widgets count should be the same as widths one");
        }
        let i = 0;
        this._forEachWidgetFromLeft((s, o) => {
          const n = t[o];
          s.setSizeAndOffset((0, Dt.size)({
            width: n,
            height: e
          }), i);
          i += n;
        });
      }
      update() {
        this._axises.forEach(e => e.update());
        this._stubs.forEach(e => e.update());
      }
      paint(e) {
        this._axises.forEach((t, i) => t.paint(e(i)));
        this._stubs.forEach((t, i) => t.paint(e(i)));
      }
      paintStubs(e) {
        this._stubs.forEach(t => t.paint(e));
      }
      restoreDefaultCursor() {
        this._axises.forEach(e => e.restoreDefaultCursor());
      }
      getWidth() {
        return this._size.width;
      }
      findAxisWidgetForScale(e) {
        const t = this._axises.find(t => t.priceScale() === e);
        if (t === undefined) {
          return null;
        } else {
          return t;
        }
      }
      getScreenshotData() {
        const e = this._getImage();
        return {
          canvas: e,
          content: e.toDataURL(),
          contentHeight: this._size.height,
          contentWidth: this._size.width
        };
      }
      getImage() {
        return this._getImage();
      }
      slotsCount() {
        return this._axises.length + this._stubs.length;
      }
      highlightPriceAxisByLabel(e) {
        this._axises.forEach(t => {
          const i = t.axisInfo();
          t.setHighlighted(i !== null && i.equals(e));
        });
      }
      axes() {
        return this._axises;
      }
      _stubParams(e) {
        return {
          rendererOptionsProvider: this._rendererOptionsProvider,
          backgroundBasedTheme: this._backgroundBasedTheme.spawnOwnership(),
          onActiveOrHoveredChart: this._onActiveOrHoveredChart?.spawnOwnership(),
          sourcesTitlesProvider: () => this._titlesProvider(this._side, e),
          contextMenuItemsProvider: () => this._stubContextMenuProvider(this._side, e),
          getBackgroundTopColor: this._getBackgroundTopColor,
          getBackgroundBottomColor: this._getBackgroundBottomColor,
          requestRepaint: this._requestRepaint,
          showHorizontalBorder: this._showHorisontalBorder
        };
      }
      _getImage() {
        const e = (0, Wt.createDisconnectedCanvas)(document, this._size);
        const t = (0, Wt.getPrescaledContext2D)(e);
        let i = 0;
        this._forEachWidgetFromLeft((e, s) => {
          const o = e.getWidth();
          if (o !== 0 && this._size.height !== 0) {
            t.drawImage(e.getImage(), i, 0, o, this._size.height);
            i += o;
          }
        });
        return e;
      }
      _forEachWidgetFromLeft(e) {
        const t = [...this._axises, ...this._stubs];
        const i = this._side === "left";
        const s = i ? -1 : t.length;
        const o = i ? -1 : 1;
        for (let n = i ? t.length - 1 : 0; n !== s; n += o) {
          e(t[n], n, t);
        }
      }
    }
    var $o = i(55824);
    var Ko = i(98714);
    class Yo {
      constructor(e = 0) {
        this._width = null;
        this._labelBottom = null;
        this._currencyInfo = null;
        this._unitInfo = null;
        this._measureUnitIdInfo = null;
        this._currencyAndUnitLabelsWrapper = document.createElement("div");
        this._currencyAndUnitLabelsWrapper.className = Ko["price-axis-currency-label-wrapper"];
        this._currencyAndUnitLabelsWrapper.setAttribute("data-name", "currency-unit-label-wrapper");
        this._controlsContainer = document.createElement("div");
        this._controlsContainer.className = Ko["price-axis-currency-label"];
        this._currencyAndUnitLabelsWrapper.appendChild(this._controlsContainer);
        this._currencyLabelDiv = document.createElement("div");
        this._currencyLabelDiv.classList.add(Ko.row, "apply-common-tooltip");
        this._currencyLabelDiv.dataset.name = "currency-label-selector";
        (0, Fo.setTooltipData)(this._currencyLabelDiv, "text", e => this._currencyTooltipContent());
        this._currencyText = document.createElement("div");
        this._currencyText.className = Ko["price-axis-currency-label-text"];
        this._currencyLabelDiv.appendChild(this._currencyText);
        this._currencyArrowDown = document.createElement("div");
        this._currencyArrowDown.className = Ko["price-axis-currency-label-arrow-down"];
        this._currencyArrowDown.innerHTML = $o;
        this._currencyLabelDiv.appendChild(this._currencyArrowDown);
        this._measureUnitIdLabelDiv = document.createElement("div");
        this._measureUnitIdLabelDiv.className = Ko.row;
        this._measureUnitIdLabelDiv.classList.add("apply-common-tooltip");
        this._measureUnitIdLabelDiv.classList.add("readonly");
        (0, Fo.setTooltipData)(this._measureUnitIdLabelDiv, "text", e => this._measureUnitIdTooltipContent());
        this._measureUnitIdText = document.createElement("div");
        this._measureUnitIdText.className = Ko["price-axis-currency-label-text"];
        this._measureUnitIdLabelDiv.appendChild(this._measureUnitIdText);
        this._unitLabelDiv = document.createElement("div");
        this._unitLabelDiv.classList.add(Ko.row, "apply-common-tooltip");
        this._unitLabelDiv.dataset.name = "unit-label-selector";
        (0, Fo.setTooltipData)(this._unitLabelDiv, "text", e => this._unitTooltipContent());
        this._unitText = document.createElement("div");
        this._unitText.className = Ko["price-axis-currency-label-text"];
        this._unitLabelDiv.appendChild(this._unitText);
        this._unitArrowDown = document.createElement("div");
        this._unitArrowDown.className = Ko["price-axis-currency-label-arrow-down"];
        this._unitArrowDown.innerHTML = $o;
        this._unitLabelDiv.appendChild(this._unitArrowDown);
        this._controlsContainer.appendChild(this._currencyLabelDiv);
        this._controlsContainer.appendChild(this._measureUnitIdLabelDiv);
        this._controlsContainer.appendChild(this._unitLabelDiv);
        this.disableCurrency();
        this.disableUnit();
        this.setFontSize(e);
      }
      element() {
        return this._currencyAndUnitLabelsWrapper;
      }
      currencyLabelElement() {
        return this._currencyLabelDiv;
      }
      unitLabelElement() {
        return this._unitLabelDiv;
      }
      isEnabled() {
        return this.currencyLabelEnabled() || this.unitLabelEnabled() || this.measureUnitIdLableEnabled();
      }
      isHidden() {
        return this._currencyAndUnitLabelsWrapper.classList.contains(Ko.hidden);
      }
      setCurrencyExpanded(e) {
        this._currencyLabelDiv.classList.toggle(Ko.expanded, e);
      }
      setUnitExpanded(e) {
        this._unitLabelDiv.classList.toggle(Ko.expanded, e);
      }
      width() {
        if (this._width !== null) {
          return this._width;
        }
        let e = 0;
        if (this.currencyLabelEnabled()) {
          const t = this._currencyText.getBoundingClientRect();
          const i = this._currencyArrowDown.getBoundingClientRect();
          e = Math.max(e, t.width + i.width + this._textMarginAndPadding() * 2);
        }
        if (this.measureUnitIdLableEnabled()) {
          const t = this._measureUnitIdText.getBoundingClientRect();
          e = Math.max(e, t.width + this._textMarginAndPadding() * 2);
        }
        if (this.unitLabelEnabled()) {
          const t = this._unitText.getBoundingClientRect();
          const i = this._unitArrowDown.getBoundingClientRect();
          e = Math.max(e, t.width + i.width + this._textMarginAndPadding() * 2);
        }
        return this._width = e;
      }
      drawLabel(e, t, i) {
        if (!this.isEnabled()) {
          return;
        }
        const s = Math.round(Number(Ko.css_wrapper_margin) * i);
        const o = (0, Io.ceiledEven)(t * i) - s * 2;
        const n = Math.round(this.labelBottom() * i);
        const r = n - s * 2;
        const a = Math.round(Number(Ko.css_value_currency_label_radius) * i);
        e.fillStyle = getComputedStyle(this._currencyAndUnitLabelsWrapper).backgroundColor;
        e.fillRect(0, 0, Math.ceil(t * i), n);
        const l = [];
        l.push(this.currencyLabelEnabled() ? this._currencyText.textContent ?? "" : "");
        l.push(this.measureUnitIdLableEnabled() ? this._measureUnitIdText.textContent ?? "" : "");
        l.push(this.unitLabelEnabled() ? this._unitText.textContent ?? "" : "");
        e.font = (0, Yt.makeFont)(this._fontSize, g.CHART_FONT_FAMILY);
        const c = new Gt.TextWidthCache();
        let h = 0;
        const d = [];
        l.forEach(t => {
          let i = 0;
          if (t !== "") {
            i = c.yMidCorrection(e, t);
            h++;
          }
          d.push(i);
        });
        const u = r / h;
        e.beginPath();
        const _ = getComputedStyle(this._controlsContainer);
        e.fillStyle = _.backgroundColor;
        e.strokeStyle = _.borderColor;
        (0, Ft.drawRoundRect)(e, s, s, o, r, a);
        e.fill();
        e.stroke();
        e.fillStyle = getComputedStyle(this._currencyLabelDiv).color;
        e.textBaseline = "middle";
        e.textAlign = "left";
        const p = Math.round(this._textMarginAndPadding() * i) + s;
        const m = u / 2;
        let f = s + m;
        l.forEach((t, s) => {
          if (t !== "") {
            (0, Wt.drawScaled)(e, i, i, () => {
              e.fillText(t, p / i, (f + d[s]) / i);
            });
            f = Math.ceil(f + m * 2);
          }
        });
      }
      setHidden(e) {
        this._currencyAndUnitLabelsWrapper.classList.toggle(Ko.hidden, e);
      }
      enableCurrency() {
        this._currencyLabelDiv.classList.remove("js-hidden");
        this._resetSizesAndVisibility();
      }
      disableCurrency() {
        this._currencyLabelDiv.classList.add("js-hidden");
        this._resetSizesAndVisibility();
      }
      enableUnit() {
        this._unitLabelDiv.classList.remove("js-hidden");
        this._resetSizesAndVisibility();
      }
      disableUnit() {
        this._unitLabelDiv.classList.add("js-hidden");
        this._resetSizesAndVisibility();
      }
      enableMeasureUnitId() {
        this._measureUnitIdLabelDiv.classList.remove("js-hidden");
        this._resetSizesAndVisibility();
      }
      disableMeasureUnitId() {
        this._measureUnitIdLabelDiv.classList.add("js-hidden");
        this._resetSizesAndVisibility();
      }
      currencyLabelEnabled() {
        return !this._currencyLabelDiv.classList.contains("js-hidden");
      }
      unitLabelEnabled() {
        return !this._unitLabelDiv.classList.contains("js-hidden");
      }
      measureUnitIdLableEnabled() {
        return !this._measureUnitIdLabelDiv.classList.contains("js-hidden");
      }
      currencyConversionAvailable() {
        return !this._currencyLabelDiv.classList.contains("readonly");
      }
      unitConversionAvailable() {
        return !this._unitLabelDiv.classList.contains("readonly");
      }
      setCurrencyInfo(e) {
        if (this._currencyInfo === e) {
          return false;
        }
        this._currencyInfo = e;
        const t = e.selectedCurrency === null ? a.t(null, undefined, i(54215)) : (0, n.ensureDefined)(e.displayedValues.get(e.selectedCurrency));
        if (this._currencyText.textContent !== t) {
          this._currencyText.textContent = t;
          this._width = null;
        }
        if (this._currencyArrowDown.classList.contains("js-hidden") !== e.readOnly) {
          this._currencyArrowDown.classList.toggle("js-hidden", e.readOnly);
          this._currencyLabelDiv.classList.toggle("readonly", e.readOnly);
          this._width = null;
        }
        return true;
      }
      setUnitInfo(e) {
        if (this._unitInfo !== null && this._unitInfo.selectedUnit === e.selectedUnit && this._unitInfo.availableGroups.size === 0 == (e.availableGroups.size === 0) && this._unitInfo.originalUnits.size === e.originalUnits.size) {
          this._unitInfo = e;
          return false;
        }
        this._unitInfo = e;
        const t = e.selectedUnit === null ? a.t(null, undefined, i(54215)) : (0, n.ensureDefined)(e.names.get(e.selectedUnit));
        if (this._unitText.textContent !== t) {
          this._unitText.textContent = t;
          this._width = null;
        }
        if (this._unitArrowDown.classList.contains("js-hidden") !== (e.availableGroups.size === 0)) {
          this._unitArrowDown.classList.toggle("js-hidden", e.availableGroups.size === 0);
          this._unitLabelDiv.classList.toggle("readonly", e.availableGroups.size === 0);
          this._width = null;
        }
        return true;
      }
      setMeasureUnitIdInfo(e) {
        if (this._measureUnitIdInfo === e) {
          return false;
        }
        this._measureUnitIdInfo = e;
        const t = e.selectedMeasureUnitId === null ? a.t(null, undefined, i(54215)) : (0, n.ensureDefined)(e.names.get(e.selectedMeasureUnitId));
        if (this._measureUnitIdText.textContent !== t) {
          this._measureUnitIdText.textContent = t;
          this._width = null;
        }
        if (this._measureUnitIdLabelDiv.classList.contains("js-hidden") !== (e.names.size === 0)) {
          this._measureUnitIdLabelDiv.classList.toggle("js-hidden", e.names.size === 0);
          this._width = null;
        }
        return true;
      }
      currencyInfo() {
        return this._currencyInfo;
      }
      unitInfo() {
        return this._unitInfo;
      }
      measureUnitIdInfo() {
        return this._measureUnitIdInfo;
      }
      setFontSize(e) {
        if (this._fontSize !== e) {
          this._fontSize = e;
          this._currencyLabelDiv.style.fontSize = e + "px";
          this._measureUnitIdLabelDiv.style.fontSize = e + "px";
          this._unitLabelDiv.style.fontSize = e + "px";
          this._width = null;
          this._labelBottom = null;
        }
      }
      labelBottom() {
        if (this._labelBottom !== null) {
          return this._labelBottom;
        }
        const e = this._controlsContainer.getBoundingClientRect();
        const t = this._currencyAndUnitLabelsWrapper.getBoundingClientRect();
        const i = e.y - t.y;
        return this._labelBottom = e.height + i * 2;
      }
      _resetSizesAndVisibility() {
        this._width = null;
        this._labelBottom = null;
        this._updateVisibility();
      }
      _textMarginAndPadding() {
        return Number(Ko.css_wrapper_margin) + Number(Ko.css_row_left_right_padding) + 2;
      }
      _currencyTooltipContent() {
        const e = this._currencyInfo;
        if (e === null) {
          return "";
        } else if (e.selectedCurrency === null) {
          return Array.from(e.currencies).map(t => (0, n.ensureDefined)(e.displayedValues.get(t))).join(", ");
        } else if (e.readOnly) {
          return a.t(null, undefined, i(43931));
        } else {
          return a.t(null, undefined, i(48566));
        }
      }
      _unitTooltipContent() {
        const e = this._unitInfo;
        if (e === null) {
          return "";
        } else if (e.selectedUnit === null) {
          return Array.from(e.units).map(t => (0, n.ensureDefined)(e.names.get(t))).join(", ");
        } else if (e.availableGroups.size === 0) {
          return a.t(null, undefined, i(40012));
        } else {
          return a.t(null, undefined, i(85110));
        }
      }
      _measureUnitIdTooltipContent() {
        const e = this._measureUnitIdInfo;
        if (e === null) {
          return "";
        } else if (e.selectedMeasureUnitId === null) {
          return Array.from(e.measureUnitIds).map(t => (0, n.ensureDefined)(e.names.get(t))).join(", ");
        } else {
          return e.descriptions.get(e.selectedMeasureUnitId) || "";
        }
      }
      _updateVisibility() {
        const e = this.isEnabled();
        this._currencyAndUnitLabelsWrapper.classList.toggle("js-hidden", !e);
      }
    }
    async function Zo(e, t, s, o) {
      const {
        UnitConversionRenderer: n
      } = await Promise.all([i.e(9093), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(4600), i.e(1072), i.e(2736), i.e(3362), i.e(6164), i.e(8257), i.e(2227), i.e(9418), i.e(2544), i.e(2704)]).then(i.bind(i, 28587));
      return new n(e, s, t, o);
    }
    async function Xo(e, t, s) {
      const {
        CurrencyMenuResultEvents: o
      } = await i.e(5639).then(i.bind(i, 19550));
      return new o(e, t, s);
    }
    var Jo = i(29023);
    class Qo {
      constructor(e) {
        const {
          action: t,
          property: i,
          undoModel: s,
          undoText: o,
          callback: n = null
        } = e;
        this._property = i;
        this._undoModel = s;
        this._undoText = o;
        this._action = t;
        this.setValue(i.value());
        i.subscribe(this, this._propertyChanged);
        if (n !== null) {
          t.update({
            onExecute: n.bind(this)
          });
        } else {
          t.update({
            onExecute: this._onActionCallback.bind(this)
          });
        }
      }
      destroy() {
        this._property.unsubscribe(this, this._propertyChanged);
      }
      value() {
        return this._action.isChecked();
      }
      setValue(e) {
        this._action.update({
          checked: Boolean(e)
        });
      }
      _onActionCallback() {
        this._undoModel.setProperty(this._property, this.value(), this._undoText);
      }
      _propertyChanged(e) {
        this.setValue(e.value());
      }
    }
    class en extends Jo.Action {
      constructor(e, t) {
        super(e);
        this._binding = new Qo({
          action: this,
          ...t
        });
      }
      destroy() {
        this._binding.destroy();
        super.destroy();
      }
    }
    var tn = i(73866);
    var sn = i(56657);
    var on = i(92158);
    var nn = i(81199);
    i(82815);
    const rn = new Di.TranslatedString("change no overlapping labels", a.t(null, undefined, i(61557)));
    const an = new Di.TranslatedString("toggle auto scale", a.t(null, undefined, i(42240)));
    const ln = new Di.TranslatedString("toggle log scale", a.t(null, undefined, i(49403)));
    const cn = a.t(null, undefined, i(88314));
    const hn = a.t(null, undefined, i(5119));
    const dn = a.t(null, undefined, i(59396));
    const un = a.t(null, undefined, i(15432));
    const _n = a.t(null, undefined, i(15332));
    const pn = a.t(null, undefined, i(24157));
    const mn = a.t(null, {
      context: "scale_menu"
    }, i(34954));
    const gn = a.t(null, {
      context: "scale_menu"
    }, i(35210));
    const fn = a.t(null, {
      context: "scale_menu"
    }, i(31340));
    const yn = a.t(null, {
      context: "scale_menu"
    }, i(55300));
    const vn = a.t(null, {
      context: "scale_menu"
    }, i(19405));
    const Sn = a.t(null, {
      context: "scale_menu"
    }, i(75163));
    const bn = function (e) {
      const t = new tn.LimitedPrecisionNumericFormatter(e);
      return (e, i) => (0, dt.isNumber)(i) && !e.isLog() ? t.format(i) : "";
    }(4);
    const wn = l.enabled("currency_menu_disabled");
    const Cn = l.enabled("unit_menu_disabled");
    const Pn = {
      contextMenuEnabled: true,
      currencyConversionEnabled: false,
      unitConversionEnabled: false,
      countdownEnabled: true,
      contextMenu: {
        general: true,
        source: true
      },
      pressedMouseMoveScale: true,
      mouseWheelScale: true,
      pinchScale: true,
      croppedTickMarks: true
    };
    var Tn;
    var xn;
    var In;
    (function (e) {
      e[e.LabelOffset = 4] = "LabelOffset";
      e[e.DefaultOptimalWidth = 34] = "DefaultOptimalWidth";
      e[e.WheelScaleCoeff = 15] = "WheelScaleCoeff";
      e[e.CurrencyLabelFontSize = 12] = "CurrencyLabelFontSize";
    })(Tn ||= {});
    (function (e) {
      e[e.Back = 0] = "Back";
      e[e.Top = 1] = "Top";
      e[e.All = 2] = "All";
    })(xn ||= {});
    class Mn {
      constructor(e, t, i, s, o, n, r, a, l) {
        this._actions = null;
        this._priceScale = null;
        this._scaleModeButtons = null;
        this._widthCache = new Gt.TextWidthCache(1000);
        this._color = null;
        this._fontSize = null;
        this._isVisible = true;
        this._currencyMenu = null;
        this._unitMenu = null;
        this._size = (0, Dt.size)({
          width: 0,
          height: 0
        });
        this._currentCursorClassName = "";
        this._destroyed = false;
        this._highlighted = false;
        this._highlightColorCache = null;
        this._mouseWheelHelper = null;
        this._dragScaleActive = false;
        this._offset = NaN;
        this._pinching = false;
        this._lastHittestResult = null;
        this._isHovered = new F.WatchedValue(false);
        this._selectedViaTap = new F.WatchedValue(false);
        this._recalcCurrencyAndUnitVisibility = () => {
          if (this._currencyLabel === null) {
            return;
          }
          const e = (0, Be.actualCurrencyUnitVisibility)().value();
          let t = !this._pane.visuallyCollapsed().value();
          if (t) {
            switch (e) {
              case "alwaysOff":
                t = false;
                break;
              case "visibleOnMouseOver":
                const e = this._chart.anyPriceAxisHovered().value();
                const i = !!this._currencyMenu;
                const s = !!this._unitMenu;
                t = e || i || s;
                break;
              case "visibleOnTapSelection":
                t = this._selectedViaTap.value();
            }
          }
          this._currencyLabel.setHidden(!t);
        };
        this._handleActualAutoLogButtonsVisibility = async e => {
          const t = e.value();
          if (t === "alwaysOff") {
            if (this._scaleModeButtons) {
              this._destroyScaleModeButtons();
            }
          } else {
            if (!this._scaleModeButtons) {
              this._scaleModeButtons = await this._createScaleModeButtons();
              this._pane.visuallyCollapsed().subscribe(this._updatePriceScaleModeButtonsVisibility);
            }
            if (t === "alwaysOn") {
              this._isHovered.unsubscribe(this._updatePriceScaleModeButtonsVisibility);
              this._selectedViaTap.unsubscribe(this._updatePriceScaleModeButtonsVisibility);
            } else if (t === "visibleOnMouseOver") {
              this._selectedViaTap.unsubscribe(this._updatePriceScaleModeButtonsVisibility);
              this._isHovered.subscribe(this._updatePriceScaleModeButtonsVisibility);
            } else {
              this._isHovered.unsubscribe(this._updatePriceScaleModeButtonsVisibility);
              this._selectedViaTap.subscribe(this._updatePriceScaleModeButtonsVisibility);
            }
            this._updatePriceScaleModeButtonsVisibility();
          }
          this.onOptimalWidthNeedToBeRecalculated();
        };
        this._updatePriceScaleModeButtonsVisibility = () => {
          const e = this._isHovered.value();
          const t = this._selectedViaTap.value();
          let i = false;
          if (!this._pane.visuallyCollapsed().value()) {
            switch ((0, on.actualAutoLogButtonsVisibility)().value()) {
              case "visibleOnMouseOver":
                i = e;
                break;
              case "visibleOnTapSelection":
                i = t;
                break;
              case "alwaysOn":
                i = true;
            }
          }
          this._scaleModeButtons?.element().classList.toggle("price-axis__modeButtons_hidden", !i);
        };
        this._updateScaleModeButtons = () => {
          this._scaleModeButtons?.update();
        };
        this._chart = e;
        this._pane = t;
        this._undoModel = i;
        this._properties = s;
        this._isLeft = n === "left";
        this._options = (0, dt.merge)((0, dt.clone)(Pn), r);
        this._rendererOptionsProvider = o;
        this._backgroundBasedTheme = l;
        this._cell = document.createElement("div");
        this._cell.className = "price-axis";
        this._cell.dataset.name = `price-axis-${a.label}`;
        this._cell.style.width = "25px";
        this._cell.style.left = "0";
        this._canvasConfiguredHandler = () => {
          this._undoModel.model().lightUpdate();
        };
        this._canvasBinding = (0, Wt.createBoundCanvas)(this._cell, (0, Dt.size)({
          width: 16,
          height: 16
        }));
        this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        const c = this._canvasBinding.canvasElement;
        c.style.position = "absolute";
        c.style.zIndex = "1";
        c.style.left = "0";
        c.style.top = "0";
        this._topCanvasBinding = (0, Wt.createBoundCanvas)(this._cell, (0, Dt.size)({
          width: 16,
          height: 16
        }));
        this._topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        const h = this._topCanvasBinding.canvasElement;
        h.style.position = "absolute";
        h.style.zIndex = "2";
        h.style.left = "0";
        h.style.top = "0";
        this._cell.setAttribute("aria-hidden", "true");
        this._mouseEventHandler = new Et.MouseEventHandler(this._cell, this, {
          treatVertTouchDragAsPageScroll: false,
          treatHorzTouchDragAsPageScroll: true
        });
        if (this._options.currencyConversionEnabled || this._options.unitConversionEnabled) {
          this._currencyLabel = new Yo(12);
          this._cell.appendChild(this._currencyLabel.element());
        } else {
          this._currencyLabel = null;
        }
        this._properties.childs().fontSize.subscribe(this, this._onFontSizeChanged);
        if (this._options.mouseWheelScale) {
          this._mouseWheelHelper = new To();
          this._cell.addEventListener("wheel", this._onMousewheel.bind(this), {
            passive: false
          });
        }
        this._axisInfo = a;
        this._offset = 0;
        this.restoreDefaultCursor();
        (0, Be.actualCurrencyUnitVisibility)().subscribe(this, this._recalcCurrencyAndUnitVisibility);
        this._selectedViaTap.subscribe(this._recalcCurrencyAndUnitVisibility.bind(this));
        (0, on.actualAutoLogButtonsVisibility)().subscribe(this, this._handleActualAutoLogButtonsVisibility);
        this._handleActualAutoLogButtonsVisibility((0, on.actualAutoLogButtonsVisibility)()).catch(() => { });
        this._chart.anyPriceAxisHovered().subscribe(this._recalcCurrencyAndUnitVisibility, {
          callWithLast: true
        });
        this._pane.visuallyCollapsed().subscribe(this._recalcCurrencyAndUnitVisibility, {
          callWithLast: true
        });
        this.update();
      }
      getContextMenuActions(e) {
        this._initActions();
        const t = (0, n.ensureNotNull)(this._actions);
        const i = this._chart.actions();
        const s = [];
        if (this._priceScale?.resetScaleAvailable().value()) {
          s.push(t.reset, new Jo.Separator());
        }
        s.push(this._autoScaleAction());
        if (this._isMainSeriesAxis()) {
          s.push(this._lockScaleAction());
        }
        s.push(i.scaleSeriesOnly, this._invertAction(), new Jo.Separator(), this._regularScaleAction(), this._percentageAction(), this._indexedTo100Action(), this._logAction(), new Jo.Separator());
        if (!ze.CheckMobile.any()) {
          s.push(this._createMergeScalesAction());
          s.push(new Jo.Separator());
        }
        if (!l.enabled("fundamental_widget")) {
          const e = [i.showSymbolLabelsAction, i.showSeriesLastValue, null, null, i.showHighLowPriceLabels, l.enabled("show_average_close_price_line_and_label") ? i.showAverageClosePriceLabel : null, null, i.showStudyPlotNamesAction, i.showStudyLastValue, this._options.countdownEnabled ? i.showCountdown : null, new Jo.Separator(), t.alignLabels].filter(dt.notNull);
          s.push(new Jo.Action({
            actionId: "Chart.PriceScale.Labels",
            options: {
              label: hn,
              subItems: e
            }
          }));
        }
        s.push((0, sn.createLinesAction)(this._chart));
        if (this._undoModel.crosshairSource().isMenuEnabled()) {
          s.push(i.addPlusButton);
        }
        if (e && !this._chart.onWidget() && l.enabled("show_chart_property_page") && l.enabled("chart_property_page_scales") && i.scalesProperties) {
          s.push(new Jo.Separator(), i.scalesProperties);
        }
        return s;
      }
      getElement() {
        return this._cell;
      }
      onOptimalWidthNeedToBeRecalculated(e) {
        if (this._size.width < this.optimalWidth() || e) {
          this._undoModel.model().fullUpdate();
        }
      }
      optimalWidth() {
        if (!this.isVisible()) {
          return 0;
        }
        let e = 0;
        const t = this.rendererOptions();
        if (this._pane.hasState()) {
          const t = (0, Wt.getContext2D)(this._canvasBinding.canvasElement);
          t.font = this.baseFont();
          const i = this._views(2, this._groupedSources());
          for (const s of i) {
            if (!s.isAxisLabelVisible()) {
              continue;
            }
            const i = this._widthCache.measureText(t, s.text());
            e = Math.max(e, i);
            const o = s.secondLineText();
            if (o) {
              e = Math.max(e, this._widthCache.measureText(t, o));
            }
            const n = s.thirdLineText();
            if (n) {
              e = Math.max(e, this._widthCache.measureText(t, n));
            }
          }
          const s = this.priceScale();
          for (const i of s.marks()) {
            e = Math.max(e, this._widthCache.measureText(t, i.label));
          }
          const o = s.mainSource()?.firstValue() || null;
          if (o !== null && !s.isPercentage() && !s.isIndexedTo100()) {
            const i = s.coordinateToPrice(1, o);
            const n = s.coordinateToPrice(this._size.height - 2, o);
            if (Math.abs(i - n) > 1e-14) {
              const r = 0.11111111111111;
              const a = s.formatPrice(Math.min(i, n) - r, o);
              const l = s.formatPrice(Math.max(i, n) + r, o);
              e = Math.max(e, this._widthCache.measureText(t, a), this._widthCache.measureText(t, l));
            }
          }
        }
        const i = this._isCurrencyLabelEnabled() ? Math.round((0, n.ensureNotNull)(this._currencyLabel).width()) : 0;
        const s = e || 34;
        let o = Math.max(i, this._scaleModeButtons?.width() ?? 0, Math.ceil(t.borderSize + t.additionalPaddingInner + t.paddingInner + t.paddingOuter + s + 4));
        o += o % 2;
        return o;
      }
      setSizeAndOffset(e, t) {
        if (!(0, Dt.equalSizes)(this._size, e)) {
          this._size = e;
          this._canvasBinding.resizeCanvasElement(e);
          this._topCanvasBinding.resizeCanvasElement(e);
          this._cell.style.width = e.width + "px";
          this._cell.style.height = e.height + "px";
          this._cell.style.minWidth = e.width + "px";
        }
        if (this._offset !== t) {
          this._offset = t;
          this._cell.style.left = t + "px";
        }
      }
      getWidth() {
        return this._size.width;
      }
      getImage() {
        const e = this._size;
        const t = (0, Wt.createDisconnectedCanvas)(document, e);
        (0, Wt.getPrescaledContext2D)(t).drawImage(this._canvasBinding.canvasElement, 0, 0, e.width, e.height);
        if (this._currencyLabel !== null && !this._currencyLabel.isHidden()) {
          this._currencyLabel.drawLabel((0, Wt.getContext2D)(t), e.width, (0, fo.getCanvasDevicePixelRatio)(t));
        }
        return t;
      }
      update() {
        if (this._priceScale !== null) {
          this._priceScale.marks();
          this.rendererOptions();
        }
      }
      paint(e) {
        if (!this._isVisible || this._size.width === 0 || this._size.height === 0) {
          return;
        }
        if (e === yo.InvalidationLevel.None) {
          return;
        }
        const t = this._pane.state();
        const i = !t.maximized().value() && t.collapsed().value();
        if (i && e < yo.InvalidationLevel.Full) {
          return;
        }
        const s = this._pane.hasState();
        (0, Wt.tryApplySuggestedCanvasBitmapSize)(this._canvasBinding);
        (0, Wt.tryApplySuggestedCanvasBitmapSize)(this._topCanvasBinding);
        const o = this._currencyLabel !== null && !this._currencyLabel.isHidden();
        const r = (e, t, i) => {
          if (o) {
            e.save();
            e.beginPath();
            const i = (0, n.ensureNotNull)(this._currencyLabel).labelBottom();
            e.rect(0, i * t.verticalPixelRatio, t.bitmapSize.width, t.bitmapSize.height);
            e.clip();
          }
          i();
          if (o) {
            e.restore();
          }
        };
        let a;
        if (e > yo.InvalidationLevel.Cursor) {
          const e = (0, Wt.getContext2D)(this._canvasBinding.canvasElement);
          const t = (0, Wt.getBindingRenderingInfo)(this._canvasBinding);
          if (!i) {
            this._alignLabels();
            if (s) {
              this.updateCurrencyLabel();
            }
          }
          this._drawBackground(e, t);
          if (!i) {
            r(e, t, () => {
              this._drawDrawingsHighlight(e, t);
            });
          }
          this._drawBorder(e, t);
          if (s && !i) {
            if (this._scaleModeButtons) {
              this._scaleModeButtons.element().style.background = this._highlighted ? this._highlightColor() : this.backgroundColor();
            }
            const i = this._groupedSources();
            r(e, t, () => {
              this._drawTickMarks(e, t);
              this._drawLabels(this._views(0, i), e, t);
            });
            a = i;
          }
        }
        if (s && !i) {
          const e = (0, Wt.getContext2D)(this._topCanvasBinding.canvasElement);
          const t = (0, Wt.getBindingRenderingInfo)(this._topCanvasBinding);
          e.clearRect(0, 0, t.bitmapSize.width, t.bitmapSize.height);
          r(e, t, () => {
            this._drawLabels(this._views(1, a ?? this._groupedSources()), e, t);
            this._drawCrossHairLabel(e, t);
          });
        }
      }
      restoreDefaultCursor() {
        this._setCursor("");
      }
      priceScale() {
        return (0, n.ensureNotNull)(this._priceScale);
      }
      setPriceScale(e) {
        if (this._priceScale !== e) {
          if (this._priceScale !== null) {
            this._priceScale.onMarksChanged().unsubscribe(this, this.onOptimalWidthNeedToBeRecalculated);
            this._priceScale.modeChanged().unsubscribeAll(this);
          }
          this._priceScale = e;
          if (e !== null) {
            e.onMarksChanged().subscribe(this, this.onOptimalWidthNeedToBeRecalculated);
            e.modeChanged().subscribe(this, () => this.onOptimalWidthNeedToBeRecalculated(true));
            this.onOptimalWidthNeedToBeRecalculated();
            if (this._scaleModeButtons) {
              e.modeChanged().subscribe(this, this._updateScaleModeButtons);
              this._updateScaleModeButtons();
            }
          }
        }
      }
      isVisible() {
        return this._isVisible;
      }
      setVisible(e) {
        if ((e = !!e) !== this._isVisible) {
          this._cell.style.display = e ? "table-cell" : "none";
          this._isVisible = e;
        }
      }
      destroy() {
        if (this._currencyMenu !== null) {
          this._currencyMenu.destroy();
          this._currencyMenu = null;
        }
        if (this._unitMenu !== null) {
          this._unitMenu.destroy();
          this._unitMenu = null;
        }
        this._pane.visuallyCollapsed().unsubscribe(this._recalcCurrencyAndUnitVisibility);
        this._topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        this._topCanvasBinding.dispose();
        this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        this._canvasBinding.dispose();
        if (this._priceScale !== null) {
          this._priceScale.onMarksChanged().unsubscribe(this, this.onOptimalWidthNeedToBeRecalculated);
          this._priceScale.modeChanged().unsubscribeAll(this);
        }
        this._priceScale = null;
        this._mouseEventHandler.destroy();
        this._properties.childs().fontSize.unsubscribe(this, this._onFontSizeChanged);
        if (this._actions !== null) {
          Object.values(this._actions).forEach(e => {
            e.destroy();
          });
          this._actions = null;
        }
        (0, Be.actualCurrencyUnitVisibility)().unsubscribeAll(this);
        this._chart.anyPriceAxisHovered().unsubscribe(this._recalcCurrencyAndUnitVisibility);
        (0, on.actualAutoLogButtonsVisibility)().unsubscribeAll(this);
        this._chart.setPriceAxisHovered(this, false);
        this._destroyScaleModeButtons();
        this._destroyed = true;
      }
      axisInfo() {
        return this._axisInfo;
      }
      setHighlighted(e) {
        this._highlighted = e;
      }
      backgroundColor() {
        return this._pane.state().model().backgroundColor().value();
      }
      backgroundTopColor() {
        return this._pane.state().model().backgroundTopColor().value();
      }
      lineColor() {
        return this._properties.childs().lineColor.value();
      }
      textColor() {
        return this._properties.childs().textColor.value();
      }
      fontSize() {
        return this._properties.childs().fontSize.value();
      }
      baseFont() {
        return (0, Yt.makeFont)(this.fontSize(), g.CHART_FONT_FAMILY, "");
      }
      rendererOptions() {
        let e = this._rendererOptionsProvider.options();
        if (this._color !== e.color || this._fontSize !== e.fontSize) {
          this._color = e.color;
        }
        if (this._fontSize !== e.fontSize) {
          this._widthCache.reset();
          this._fontSize = e.fontSize;
          this.onOptimalWidthNeedToBeRecalculated();
        }
        return e;
      }
      mouseEnterEvent(e) {
        this._chart.setPriceAxisHovered(this, true);
        this._isHovered.setValue(true);
        this._applyLightUpdateIfRequired();
        this._mouseEnterOrTouchStartEvent(e);
      }
      mouseMoveEvent(e) {
        this._mouseOrTouchMoveEvent(e);
      }
      mouseDownEvent(e) {
        this._mouseDownOrTouchStartEvent(e);
      }
      touchStartEvent(e) {
        this._mouseOrTouchMoveEvent(e);
        this._mouseEnterOrTouchStartEvent(e);
        this._mouseDownOrTouchStartEvent(e);
      }
      pressedMouseMoveEvent(e) {
        this._pressedMouseOrTouchMoveEvent(e);
      }
      touchMoveEvent(e) {
        this._pressedMouseOrTouchMoveEvent(e);
      }
      pinchStartEvent(e, t, i, s) {
        return s.bothPointsOnTargetElement;
      }
      pinchEvent(e, t, i) {
        if (this._zoomAvailable() && this._options.pinchScale) {
          if (this._dragScaleActive) {
            this._finishScale();
          }
          if (!this._pinching) {
            this._pinching = true;
            this._undoModel.startTwoPointsScalePrice(this._pane.state(), this.priceScale(), t.y, i.y);
            return;
          }
          this._undoModel.twoPointsScalePriceTo(this._pane.state(), this.priceScale(), t.y, i.y);
        }
      }
      pinchEndEvent() {
        this._pinching = false;
        this._undoModel.endTwoPointsScalePrice(this._pane.state(), this.priceScale());
      }
      mouseDownOutsideEvent() {
        this._finishScale();
      }
      touchStartOutsideEvent() {
        this._finishScale();
        this._selectedViaTap.setValue(false);
      }
      mouseUpEvent(e) {
        this._mouseUpOrTouchEndEvent(e);
      }
      touchEndEvent(e) {
        this._mouseLeaveOrTouchEndEvent(e);
        this._mouseUpOrTouchEndEvent(e);
      }
      mouseClickEvent(e) {
        this._mouseClickOrTapEvent(e);
      }
      tapEvent(e) {
        this._mouseClickOrTapEvent(e);
      }
      mouseLeaveEvent(e) {
        this._chart.setPriceAxisHovered(this, false);
        this._isHovered.setValue(false);
        this._applyLightUpdateIfRequired();
        this._mouseLeaveOrTouchEndEvent(e);
      }
      mouseDoubleClickEvent(e) {
        this._mouseDoubleClickOrDoubleTapEvent(e);
      }
      doubleTapEvent(e) {
        this._mouseDoubleClickOrDoubleTapEvent(e);
      }
      contextMenuEvent(e) {
        this._contextMenuOrTouchContextMenuEvent(e);
      }
      touchContextMenuEvent(e) {
        this._contextMenuOrTouchContextMenuEvent(e);
      }
      dataSourceAtPoint(e, t) {
        const i = this._pane.state();
        if (!i.maximized().value() && i.collapsed().value()) {
          return null;
        }
        const s = this._groupedSources();
        const o = [...s.sources, ...s.topLevelSources, ...i.customSources(), ...i.sourcesByGroup().multipaneSources()];
        let n = null;
        let r = null;
        if (!this._priceScale) {
          return null;
        }
        const a = (e, t) => {
          const i = r?.target() ?? 0;
          if (e.target() > i) {
            r = e;
            n = t;
          }
        };
        const l = new At.Point(e, t);
        const c = (0, Wt.getBindingRenderingInfo)(this._canvasBinding);
        for (let e = o.length - 1; e >= 0; --e) {
          const t = o[e];
          const s = t.priceAxisViews(i, this._priceScale);
          if (s && s.length !== 0) {
            for (let e = s.length - 1; e >= 0; --e) {
              const i = s[e].renderer();
              if (i.hitTest !== undefined) {
                const e = i.hitTest(l, c, this._isLeft ? "left" : "right");
                if (e !== null) {
                  a(e, t);
                }
              }
            }
          }
        }
        this._lastHittestResult = r;
        return n;
      }
      reset() {
        const e = this._pane.state();
        const t = this.priceScale();
        this._undoModel.resetPriceScale(e, t);
        this.onOptimalWidthNeedToBeRecalculated(true);
      }
      updateCurrencyLabel() {
        if (this._currencyLabel !== null) {
          if (this._options.currencyConversionEnabled) {
            const e = this.priceScale().currency(this._undoModel.model().availableCurrencies());
            if (e === null || (0, Be.actualCurrencyUnitVisibility)().value() === "alwaysOff") {
              this._currencyLabel.disableCurrency();
            } else {
              this._currencyLabel.enableCurrency();
              this._currencyLabel.setCurrencyInfo(e);
            }
          } else {
            this._currencyLabel.disableCurrency();
          }
          if (this._options.unitConversionEnabled) {
            const e = (0, Be.actualCurrencyUnitVisibility)().value() === "alwaysOff";
            const t = this._undoModel.model().availableUnits();
            const i = this.priceScale().unit(t);
            if (i === null || e) {
              this._currencyLabel.disableUnit();
            } else {
              this._currencyLabel.enableUnit();
              this._currencyLabel.setUnitInfo(i);
            }
            const s = this.priceScale().measureUnitId(t);
            if (s === null || e) {
              this._currencyLabel.disableMeasureUnitId();
            } else {
              this._currencyLabel.enableMeasureUnitId();
              this._currencyLabel.setMeasureUnitIdInfo(s);
            }
          } else {
            this._currencyLabel.disableUnit();
            this._currencyLabel.disableMeasureUnitId();
          }
        }
      }
      _groupedSources() {
        const e = this._pane.state();
        const t = e.model();
        const i = this._pane.state().sourcesByGroup();
        const s = this._isLeft ? i.leftPriceScalesSources() : i.rightPriceScalesSources();
        const o = this._priceScale === e.defaultPriceScale();
        const n = new Set(e.customSources());
        const r = t => !!n.has(t) || t.priceScale() === this._priceScale || o && e.isOverlay(t);
        const a = {
          sources: [...s.filter(r), ...e.customSources()],
          topLevelSources: new Set()
        };
        if (o) {
          const t = this._pane.state().dataSources();
          for (const i of t) {
            if (e.isOverlay(i)) {
              a.sources.push(i);
            }
          }
        }
        const l = t.lineBeingEdited() ?? t.lineBeingCreated();
        if (l && r(l)) {
          a.topLevelSources.add(l);
          a.lineBeingEditedOrCreated = l;
        }
        const c = t.customSourceBeingMoved();
        if (c && r(c)) {
          a.topLevelSources.add(c);
          a.customSourceBeingMoved = c;
        }
        const h = t.sourcesBeingMoved().filter(r);
        if (h.length > 0) {
          t.sourcesBeingMoved().forEach(e => a.topLevelSources.add(e));
          a.sourcesBeingMoved = h;
        }
        const d = t.selection().allSources().filter(r);
        if (d.length > 0) {
          d.forEach(e => a.topLevelSources.add(e));
          a.selectedSources = d;
        }
        const u = t.hoveredSource();
        if (u && r(u)) {
          a.topLevelSources.add(u);
          a.hoveredSource = u;
        }
        return a;
      }
      _isCurrencyLabelEnabled() {
        return this._currencyLabel !== null && this._currencyLabel.isEnabled();
      }
      _alignLabels() {
        const e = this._size.height;
        let t = e / 2;
        const i = [];
        const s = this.priceScale();
        const o = s.orderedSources().slice();
        const n = this._pane.state();
        const r = this.rendererOptions();
        if (s === n.defaultPriceScale()) {
          const e = n.priceDataSources();
          for (let t = 0; t < e.length; t++) {
            if (n.isOverlay(e[t])) {
              o.push(e[t]);
            }
          }
        }
        const a = s.mainSource();
        const l = n.sourcesByGroup().multipaneSources();
        for (const c of [o, n.customSources(), l]) {
          for (let o = 0; o < c.length; ++o) {
            const l = c[o];
            const h = [...(l.priceAxisViews(n, s) ?? []), ...(l.topPriceAxisViews?.(n, s) ?? [])];
            if (h) {
              const s = h.filter(t => {
                if (t.ignoreAlignment() || !t.isVisible()) {
                  return false;
                }
                const {
                  total: i
                } = t.topBottomTotalHeight(r);
                const s = t.floatCoordinate();
                return s > -i && s < e + i;
              });
              if (!s.length) {
                continue;
              }
              i.push(...s);
              if (a === l) {
                t = s[0].floatCoordinate();
              }
            }
          }
        }
        const c = i.filter(e => e.floatCoordinate() <= t);
        const h = i.filter(e => e.floatCoordinate() > t);
        c.sort((e, t) => t.floatCoordinate() - e.floatCoordinate());
        if (c.length > 0 && h.length > 0) {
          h.push(c[0]);
        }
        h.sort((e, t) => e.floatCoordinate() - t.floatCoordinate());
        for (const e of i) {
          e.setFixedCoordinate(e.coordinate());
        }
        if (s.properties().childs().alignLabels.value()) {
          if (h.length > 0 || c.length > 0) {
            {
              const t = c[0] ?? h[0];
              const i = t.getFixedCoordinate();
              const {
                top: s,
                bottom: o,
                total: n
              } = t.topBottomTotalHeight(r);
              if (n < e && i - s < 0 && i + o > 0) {
                t.setFixedCoordinate(s);
              }
            }
            {
              const t = h[0] ?? c[0];
              const i = t.getFixedCoordinate();
              const {
                top: s,
                bottom: o,
                total: n
              } = t.topBottomTotalHeight(r);
              if (n < e && i - s < e && i + o > e) {
                t.setFixedCoordinate(e - o);
              }
            }
          }
          for (let e = 1; e < c.length; e++) {
            const t = c[e];
            const i = c[e - 1];
            const {
              top: s,
              bottom: o,
              total: n
            } = t.topBottomTotalHeight(r);
            const a = t.getFixedCoordinate();
            const l = i.getFixedCoordinate();
            if (a > l - n) {
              t.setFixedCoordinate(l - n);
            } else if (l > 0 && a - s < 0 && a + o > 0) {
              const {
                top: e
              } = i.topBottomTotalHeight(r);
              t.setFixedCoordinate(Math.min(l - e - o, s));
            }
          }
          for (let t = 1; t < h.length; t++) {
            const i = h[t];
            const s = h[t - 1];
            const {
              bottom: o,
              total: n
            } = s.topBottomTotalHeight(r);
            const a = i.getFixedCoordinate();
            const l = s.getFixedCoordinate();
            if (a < l + n) {
              i.setFixedCoordinate(l + n);
            } else if (l < e) {
              const {
                top: t,
                bottom: s
              } = i.topBottomTotalHeight(r);
              if (a - t < e && a + s > e) {
                i.setFixedCoordinate(Math.max(l + o + t, e - s));
              }
            }
          }
        }
      }
      _drawTickMarks(e, t) {
        const i = this.priceScale().marks();
        e.save();
        e.font = this.baseFont();
        const s = this.rendererOptions();
        const {
          horizontalPixelRatio: o,
          verticalPixelRatio: r
        } = t;
        const a = this._isLeft ? Math.floor((this._size.width - s.additionalPaddingInner) * o) : 0;
        const l = this._isLeft ? Math.round(a - s.paddingInner * o) : Math.round(a + (s.additionalPaddingInner + s.paddingInner) * o);
        const c = this.fontSize();
        const h = this._isCurrencyLabelEnabled() ? (0, n.ensureNotNull)(this._currencyLabel).labelBottom() : 0;
        const d = i.map(t => {
          if (this._options.croppedTickMarks) {
            return {
              visible: true,
              yCorrection: this._widthCache.yMidCorrection(e, t.label)
            };
          }
          const i = t.coord - c / 2;
          const s = t.coord + c / 2;
          const o = !(s > this._size.height) && !(i < h);
          return {
            visible: !(s > this._size.height) && !(i < h),
            yCorrection: o ? this._widthCache.yMidCorrection(e, t.label) : 0
          };
        });
        e.fillStyle = this.textColor();
        e.textAlign = this._isLeft ? "right" : "left";
        e.textBaseline = "middle";
        (0, Wt.drawScaled)(e, o, r, () => {
          for (let t = i.length; t--;) {
            if (!d[t].visible) {
              continue;
            }
            const s = i[t];
            e.fillText(s.label, l / o, s.coord + d[t].yCorrection);
          }
        });
        e.restore();
      }
      async _showCurrenciesContextMenu() {
        if (this._currencyMenu) {
          this._currencyMenu.destroy();
          this._currencyMenu = null;
          return;
        }
        let e;
        (0, ne.trackEvent)("GUI", "Currency conversion");
        const t = () => {
          this._currencyMenu = null;
          this._recalcCurrencyAndUnitVisibility();
          this._currencyLabel?.setCurrencyExpanded(false);
        };
        if (wn) {
          e = await Xo((0, n.ensureNotNull)(this._currencyLabel).currencyLabelElement(), ["toggle_currency_menu_inner", this._undoModel.model().id(), this._pane.state().id(), this.priceScale().id()], t);
        } else {
          const {
            currencyActions: s
          } = await Promise.all([i.e(9093), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(4600), i.e(1072), i.e(2736), i.e(3362), i.e(6164), i.e(8257), i.e(2227), i.e(9418), i.e(2544), i.e(2704)]).then(i.bind(i, 75556));
          e = await Zo(dn, () => s(this._undoModel, (0, n.ensureNotNull)(this._currencyLabel).currencyInfo(), this.priceScale()), (0, n.ensureNotNull)(this._currencyLabel).currencyLabelElement(), t);
        }
        if (this._destroyed) {
          e.destroy();
        } else {
          this._currencyLabel?.setCurrencyExpanded(true);
          this._currencyMenu = e;
        }
      }
      async _showUnitsContextMenu() {
        if (this._unitMenu) {
          this._unitMenu.destroy();
          this._unitMenu = null;
          return;
        }
        let e;
        (0, ne.trackEvent)("GUI", "Unit conversion");
        const t = () => {
          this._unitMenu = null;
          this._recalcCurrencyAndUnitVisibility();
          this._currencyLabel?.setUnitExpanded(false);
        };
        if (Cn) {
          e = await Xo((0, n.ensureNotNull)(this._currencyLabel).unitLabelElement(), ["toggle_unit_menu_inner", this._undoModel.model().id(), this._pane.state().id(), this.priceScale().id()], t);
        } else {
          const {
            unitActions: s
          } = await Promise.all([i.e(9093), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(4600), i.e(1072), i.e(2736), i.e(3362), i.e(6164), i.e(8257), i.e(2227), i.e(9418), i.e(2544), i.e(2704)]).then(i.bind(i, 59363));
          e = await Zo(un, () => s(this._undoModel, (0, n.ensureNotNull)(this._currencyLabel).unitInfo(), this.priceScale()), (0, n.ensureNotNull)(this._currencyLabel).unitLabelElement(), t);
        }
        if (this._destroyed) {
          e.destroy();
        } else {
          this._currencyLabel?.setUnitExpanded(true);
          this._unitMenu = e;
        }
      }
      _onFontSizeChanged() {
        this.onOptimalWidthNeedToBeRecalculated();
      }
      _mouseOrTouchMoveEvent(e) {
        if (!this._priceScale) {
          return;
        }
        if (e.localX < 0 || e.localY < 0 || e.localX >= this._size.width || e.localY >= this._size.height) {
          return;
        }
        let t = true;
        const i = this.dataSourceAtPoint(e.localX, e.localY);
        if (i) {
          this._setCursorClassName("pointer");
          if (this._lastHittestResult?.data()?.hoverModelFromAxis) {
            this._undoModel.model().setHoveredSource(i, this._lastHittestResult?.data() ?? null, 0);
            t = false;
          }
        } else {
          this._setResizeCursor();
        }
        if (t) {
          this._undoModel.model().setHoveredSource(null, null);
        }
      }
      _mouseDownOrTouchStartEvent(e) {
        if (this._zoomAvailable() && this._options.pressedMouseMoveScale && !this._pinching) {
          this._dragScaleActive = true;
          this._undoModel.startScalePrice(this._pane.state(), this.priceScale(), e.localY);
        }
      }
      _mouseEnterOrTouchStartEvent(e) {
        this._setResizeCursor();
      }
      _pressedMouseOrTouchMoveEvent(e) {
        if (this._dragScaleActive) {
          const t = this.priceScale();
          this._undoModel.scalePriceTo(this._pane.state(), t, e.localY);
        }
      }
      _mouseUpOrTouchEndEvent(e) {
        this._finishScale();
      }
      _finishScale() {
        if (this._dragScaleActive) {
          this._undoModel.endScalePrice(this._pane.state(), this.priceScale());
          this.restoreDefaultCursor();
          this._dragScaleActive = false;
        }
      }
      _mouseClickOrTapEvent(e) {
        if (this._currencyLabel) {
          if (this._currencyLabel.currencyConversionAvailable() && this._currencyLabel.currencyLabelElement().contains(e.target)) {
            this._showCurrenciesContextMenu();
            e.preventDefault();
            return;
          }
          if (this._currencyLabel.unitConversionAvailable() && this._currencyLabel.unitLabelElement().contains(e.target)) {
            this._showUnitsContextMenu();
            e.preventDefault();
            return;
          }
        }
        if (e.isTouch) {
          this._selectedViaTap.setValue(!this._selectedViaTap.value());
        }
        const t = this.dataSourceAtPoint(e.localX, e.localY);
        if (t) {
          this._undoModel.selectionMacro(e => {
            if (!e.selection().isSelected(t) || this._undoModel.model().lastSelectedHittestData() !== this._lastHittestResult?.data()) {
              e.clearSelection();
              e.addSourceToSelection(t, this._lastHittestResult?.data() ?? null);
            }
          });
        }
      }
      _mouseLeaveOrTouchEndEvent(e) {
        this._setCursorClassName("");
      }
      _mouseDoubleClickOrDoubleTapEvent(e) {
        if (this._currencyLabel?.currencyLabelElement().contains(e.target) || this._currencyLabel?.unitLabelElement().contains(e.target)) {
          return;
        }
        const t = this.dataSourceAtPoint(e.localX, e.localY);
        if (t) {
          this._pane.processDoubleClickOnSource(t, this._lastHittestResult ?? undefined, {
            origin: "price_scale"
          });
        } else {
          this.reset();
          (0, ne.trackEvent)("GUI", "Double click price scale");
        }
      }
      _contextMenuOrTouchContextMenuEvent(e) {
        if (this._options.contextMenuEnabled) {
          const t = this.dataSourceAtPoint(e.localX, e.localY);
          if (t !== null && this._options.contextMenu.source) {
            this._undoModel.model().selectionMacro(i => {
              if (!i.selection().isSelected(t)) {
                i.clearSelection();
                i.addSourceToSelection(t);
              }
              this._pane.showContextMenuForSelection(e, {
                origin: "price_scale"
              });
            });
            return;
          }
          if (this._options.contextMenu.general) {
            const t = this.getContextMenuActions(true);
            const i = this._undoModel.model().panes().findIndex(e => e.id() === this._pane.state().id());
            const s = this._chart.chartWidgetCollection().chartModels().value().findIndex(e => e.id() === this._undoModel.id());
            const o = this._priceScale?.id() && i !== -1 && s !== -1;
            Oo.ContextMenuManager.showMenu(t, e, {
              statName: "PriceScaleContextMenu"
            }, {
              menuName: "PriceScaleContextMenu",
              ...(o && {
                detail: {
                  type: "priceScale",
                  id: this._priceScale?.id() ?? "",
                  paneIndex: i,
                  chartIndex: s
                }
              })
            });
          }
        }
      }
      _setResizeCursor() {
        const e = this.priceScale();
        if (e.isPercentage() || e.isIndexedTo100()) {
          this._setCursorClassName("");
        } else if (this._zoomAvailable() && (this._options.pressedMouseMoveScale || this._options.mouseWheelScale)) {
          this._setCursorClassName("ns-resize");
        }
      }
      _setCursorClassName(e) {
        let t = "";
        if (e && !this._pane.visuallyCollapsed().value()) {
          t = "price-axis--cursor-" + e;
        }
        if (this._currentCursorClassName !== t) {
          if (this._currentCursorClassName) {
            this._cell.classList.remove(this._currentCursorClassName);
          }
          if (t) {
            this._cell.classList.add(t);
          }
          this._currentCursorClassName = t;
        }
      }
      _zoomAvailable() {
        return !this.priceScale().isEmpty() && this.priceScale().hasCalculatedPriceRange() && this._undoModel.model().zoomEnabled();
      }
      _onMousewheel(e) {
        if (!this._zoomAvailable() || !this._options.mouseWheelScale) {
          return;
        }
        const t = (0, n.ensureNotNull)(this._mouseWheelHelper).processWheel(e).deltaY;
        if (t === 0) {
          return;
        }
        if (e.cancelable) {
          e.preventDefault();
        }
        const i = this._undoModel;
        const s = this._pane.state();
        const o = this.priceScale();
        const r = this._cell.getBoundingClientRect();
        const a = e.clientY - r.top;
        const l = a + t * 15;
        i.startScalePrice(s, this.priceScale(), a, true);
        i.scalePriceTo(s, o, l);
        i.endScalePrice(s, o);
        e.stopPropagation();
      }
      _drawCrossHairLabel(e, t) {
        const i = this._pane.state();
        const s = i.model();
        const o = this.priceScale();
        const n = s.crosshairSource().priceAxisViews(i, o);
        if (n && n.length > 0) {
          this._drawLabels(n, e, t);
        }
      }
      _drawBackground(e, t) {
        const i = this.backgroundTopColor();
        const s = this.backgroundColor();
        const {
          bitmapSize: o
        } = t;
        if (i === s) {
          (0, Wt.clearRect)(e, 0, 0, o.width, o.height, this.backgroundColor());
        } else {
          (0, Ft.clearRectWithGradient)(e, 0, 0, o.width, o.height, i, s);
        }
        if (this._highlighted) {
          e.globalAlpha = 0.5;
          const t = k.themes[this._backgroundBasedTheme.value()].getThemedColor("color-price-axis-highlight");
          (0, Wt.fillRect)(e, 0, 0, o.width, o.height, t);
          e.globalAlpha = 1;
        }
      }
      _drawDrawingsHighlight(e, t) {
        const i = this._pane.state().model();
        const s = this.priceScale();
        const o = i.selection().lineDataSources().filter(e => !e.isFixed() && e.priceScale() === s).reduce((e, t) => {
          const i = t.priceAxisPoints();
          if (i.length === 0) {
            return e;
          } else {
            return e.concat(i);
          }
        }, []);
        if (o.length > 0) {
          this._hightlightBackground(e, o, this.priceScale().mainSource(), t);
        }
        const n = i.crosshairSource();
        if (n.startMeasurePoint()) {
          this._hightlightBackground(e, n.measurePoints(), this.priceScale().mainSource(), t);
        }
      }
      _drawBorder(e, t) {
        e.save();
        e.fillStyle = this.lineColor();
        const {
          horizontalPixelRatio: i
        } = t;
        const s = Math.max(1, Math.floor(this.rendererOptions().borderSize * i));
        const o = this._isLeft ? t.bitmapSize.width - s : 0;
        e.fillRect(o, 0, s, t.bitmapSize.height);
        e.restore();
      }
      _drawLabels(e, t, i) {
        const s = this.rendererOptions();
        const o = this._isLeft ? "right" : "left";
        for (const n of e) {
          if (n.isAxisLabelVisible()) {
            t.save();
            n.renderer().draw(t, i, s, this._widthCache, o);
            t.restore();
          }
        }
      }
      _hightlightBackground(e, t, i, s) {
        if (!i) {
          return;
        }
        const o = i.firstValue();
        if (o === null) {
          return;
        }
        let n = t[0].price;
        let r = t[0].price;
        for (let e = 1; e < t.length; e++) {
          n = Math.min(n, t[e].price);
          r = Math.max(r, t[e].price);
        }
        const {
          horizontalPixelRatio: a,
          verticalPixelRatio: l
        } = s;
        const c = this.priceScale();
        const h = Math.floor(c.priceToCoordinate(n, o) * l);
        const d = Math.ceil(c.priceToCoordinate(r, o) * l);
        (0, Wt.fillRect)(e, Math.floor(a), h, s.bitmapSize.width, d - h, this._properties.childs().axisHighlightColor.value());
      }
      _viewsOrMaxMinViews(e) {
        const t = this._pane.state();
        const i = this.priceScale();
        if (e.length === 0) {
          return [];
        }
        if (e.length === 1) {
          return e[0].priceAxisViews(t, i) ?? [];
        }
        {
          let s = Infinity;
          let o = -Infinity;
          let n = null;
          let r = null;
          for (const a of e) {
            const e = a.priceAxisViews(t, i) ?? [];
            for (const t of e) {
              const e = t.coordinate();
              if (e >= o) {
                o = e;
                r = t;
              }
              if (e <= s) {
                s = e;
                n = t;
              }
            }
          }
          if (r && n) {
            return [r, n];
          } else {
            return [];
          }
        }
      }
      _views(e, t) {
        const i = this._pane.state();
        const s = this.priceScale();
        const o = [];
        if (e !== 1) {
          for (const e of t.sources) {
            if (!t.topLevelSources.has(e)) {
              o.push(...(e.priceAxisViews(i, s) ?? []));
            }
          }
        }
        if (e !== 0) {
          const e = new Set();
          const n = t => !e.has(t);
          const r = t => {
            const i = t.filter(n);
            o.push(...this._viewsOrMaxMinViews(i));
            for (const t of i) {
              e.add(t);
            }
          };
          if (t.customSourceBeingMoved) {
            r([t.customSourceBeingMoved]);
          }
          if (t.sourcesBeingMoved) {
            r(t.sourcesBeingMoved);
          }
          if (t.selectedSources) {
            r(t.selectedSources);
          }
          if (t.hoveredSource) {
            r([t.hoveredSource]);
          }
          if (t.lineBeingEditedOrCreated) {
            r([t.lineBeingEditedOrCreated]);
          }
          for (const e of [...t.sources, ...i.customSources()]) {
            if (e.topPriceAxisViews) {
              o.push(...(e.topPriceAxisViews(i, s) ?? []));
            }
          }
        }
        return o;
      }
      _initActions() {
        if (!this._pane.hasState() || this._actions !== null) {
          return;
        }
        const e = this._undoModel;
        const t = new nn.ActionWithStandardIcon({
          actionId: "Chart.PriceScale.Reset",
          options: {
            label: _n,
            iconId: "Chart.Reset",
            shortcutHint: (0, ct.humanReadableHash)(ct.Modifiers.Alt + 82),
            statName: "ResetScale",
            onExecute: () => this.reset()
          }
        });
        const i = new Jo.Action({
          actionId: "Chart.PriceScale.ToggleAutoScale",
          options: {
            label: pn,
            checkable: true,
            checked: true,
            statName: "ToggleAutoScale",
            onExecute: () => {
              e.togglePriceScaleAutoScaleMode(this.priceScale());
              this._updateScalesActions();
            }
          }
        });
        const s = new Jo.Action({
          actionId: "Chart.PriceScale.TogglePercentage",
          options: {
            label: mn,
            checkable: true,
            checked: this.priceScale().isPercentage(),
            statName: "TogglePercantage",
            onExecute: () => {
              e.togglePriceScalePercentageScaleMode(this.priceScale());
              this._updateScalesActions();
            }
          }
        });
        const o = new Jo.Action({
          actionId: "Chart.PriceScale.ToggleIndexedTo100",
          options: {
            label: gn,
            checkable: true,
            checked: this.priceScale().isIndexedTo100(),
            statName: "ToggleIndexedTo100",
            onExecute: () => {
              e.togglePriceScaleIndexedTo100ScaleMode(this.priceScale());
              this._updateScalesActions();
            }
          }
        });
        const n = new Jo.Action({
          actionId: "Chart.PriceScale.ToggleLogarithmic",
          options: {
            label: fn,
            checkable: true,
            checked: this.priceScale().isLog(),
            statName: "ToggleLogScale",
            onExecute: () => {
              e.togglePriceScaleLogScaleMode(this.priceScale());
              this._updateScalesActions();
            }
          }
        });
        const r = new Jo.Action({
          actionId: "Chart.PriceScale.ToggleRegular",
          options: {
            label: yn,
            checkable: true,
            checked: this.priceScale().isRegular(),
            statName: "ToggleRegularScale",
            onExecute: () => {
              e.setPriceScaleRegularScaleMode(this.priceScale());
              this._updateScalesActions();
            }
          }
        });
        const a = new en({
          actionId: "Chart.PriceScale.Labels.ToggleNoOverlappingLabelsVisibility",
          options: {
            label: vn,
            checkable: true,
            checked: this.priceScale().properties().childs().alignLabels.value(),
            statName: "TogglePreciseLabels"
          }
        }, {
          property: this.priceScale().properties().childs().alignLabels,
          undoModel: e,
          undoText: rn
        });
        const l = new Jo.Action({
          actionId: "Chart.PriceScale.ToggleInvertScale",
          options: {
            label: Sn,
            checkable: true,
            checked: this.priceScale().isInverted(),
            statName: "Invert Scale",
            onExecute: () => {
              e.invertPriceScale(this.priceScale());
              this._updateScalesActions();
            }
          }
        });
        this._actions = {
          reset: t,
          setAutoScale: i,
          setPercentage: s,
          setIndexedTo100: o,
          setLog: n,
          setRegular: r,
          alignLabels: a,
          invertScale: l
        };
        this._updateScalesActions();
      }
      _logAction() {
        if (this._isMainSeriesAxis()) {
          return this._chart.actions().logSeriesScale;
        } else {
          return (0, n.ensureNotNull)(this._actions).setLog;
        }
      }
      _percentageAction() {
        if (this._isMainSeriesAxis()) {
          return this._chart.actions().percentSeriesScale;
        } else {
          return (0, n.ensureNotNull)(this._actions).setPercentage;
        }
      }
      _indexedTo100Action() {
        if (this._isMainSeriesAxis()) {
          return this._chart.actions().indexedTo100SeriesScale;
        } else {
          return (0, n.ensureNotNull)(this._actions).setIndexedTo100;
        }
      }
      _autoScaleAction() {
        if (this._isMainSeriesAxis()) {
          return this._chart.actions().autoSeriesScale;
        } else {
          return (0, n.ensureNotNull)(this._actions).setAutoScale;
        }
      }
      _regularScaleAction() {
        if (this._isMainSeriesAxis()) {
          return this._chart.actions().regularSeriesScale;
        } else {
          return (0, n.ensureNotNull)(this._actions).setRegular;
        }
      }
      _lockScaleAction() {
        const e = this._chart.actions().lockSeriesScale;
        const t = bn(this.priceScale(), this._undoModel.model().mainSeriesScaleRatio());
        e.update({
          hint: t
        });
        return e;
      }
      _invertAction() {
        if (this._isMainSeriesAxis()) {
          return this._chart.actions().invertSeriesScale;
        } else {
          return (0, n.ensureNotNull)(this._actions).invertScale;
        }
      }
      _isMainSeriesAxis() {
        return this.priceScale().hasMainSeries();
      }
      _updateScalesActions() {
        const e = this.priceScale();
        const t = this._isMainSeriesAxis();
        const i = (0, n.ensureNotNull)(e.mainSource()).properties();
        const s = t && e.isLockScale();
        const o = t && i.style.value() === 6;
        const r = (0, n.ensureNotNull)(this._actions);
        r.setRegular.update({
          checked: e.isRegular(),
          disabled: s || o
        });
        r.setPercentage.update({
          checked: e.isPercentage(),
          disabled: s || o
        });
        r.setIndexedTo100.update({
          checked: e.isIndexedTo100(),
          disabled: s || o
        });
        r.setLog.update({
          checked: e.isLog(),
          disabled: s || o
        });
        r.setAutoScale.update({
          checked: e.isAutoScale(),
          disabled: e.properties().childs().autoScaleDisabled.value()
        });
      }
      _createMergeScalesAction() {
        const e = this._chart.actions();
        const t = this._undoModel.model().priceScaleSlotsCount();
        if (t.left + t.right === 1) {
          if (t.left === 0) {
            return e.moveScaleToLeft;
          } else {
            return e.moveScaleToRight;
          }
        }
        const i = [];
        i.push(e.mergeLeftScalesAction);
        i.push(e.mergeRightScalesAction);
        return new Jo.Action({
          actionId: "Chart.PriceScale.MergeAllScales",
          options: {
            label: cn,
            subItems: i
          }
        });
      }
      _setCursor(e) {
        let t = "";
        if (e === "grabbing" || e === "ns-resize") {
          t = "price-axis--cursor-" + e;
        }
        if (this._currentCursorClassName !== t) {
          if (this._currentCursorClassName) {
            this._cell.classList.remove(this._currentCursorClassName);
          }
          if (t) {
            this._cell.classList.add(t);
          }
          this._currentCursorClassName = t;
          this._cell.style.cursor;
        }
      }
      async _createScaleModeButtons() {
        const {
          PriceScaleModeButtonsRenderer: e
        } = await Promise.all([i.e(8975), i.e(5446), i.e(2227), i.e(3555)]).then(i.bind(i, 49976));
        const t = new e({
          className: "price-axis__modeButtons",
          setMode: e => {
            if (this._priceScale) {
              if (e === "log") {
                this._chart.model().setPriceScaleMode({
                  log: !this._priceScale.isLog()
                }, this._priceScale, ln);
              } else {
                this._chart.model().setPriceScaleMode({
                  autoScale: !this._priceScale.isAutoScale()
                }, this._priceScale, an);
              }
            }
          },
          getMode: () => this._priceScale?.mode()
        });
        t.element().style.background = this.backgroundColor();
        this._cell.appendChild(t.element());
        this._priceScale?.modeChanged().subscribe(this, this._updateScaleModeButtons);
        return t;
      }
      _destroyScaleModeButtons() {
        if (this._scaleModeButtons) {
          this._isHovered.unsubscribe(this._updatePriceScaleModeButtonsVisibility);
          this._selectedViaTap.unsubscribe(this._updatePriceScaleModeButtonsVisibility);
          this._pane.visuallyCollapsed().unsubscribe(this._updatePriceScaleModeButtonsVisibility);
          this._priceScale?.modeChanged().unsubscribe(this, this._updateScaleModeButtons);
          this._scaleModeButtons.destroy();
          this._scaleModeButtons = null;
        }
      }
      _highlightColor() {
        const e = this.backgroundColor();
        const t = this._backgroundBasedTheme.value();
        if (this._highlightColorCache === null || this._highlightColorCache.backgroundColor !== e || this._highlightColorCache.theme !== t) {
          const i = (0, Is.applyTransparency)(k.themes[this._backgroundBasedTheme.value()].getThemedColor("color-price-axis-highlight"), 50);
          const s = (0, kt.rgbaToString)((0, kt.blendRgba)((0, kt.parseRgba)(this.backgroundColor()), (0, kt.parseRgba)(i)));
          this._highlightColorCache = {
            theme: t,
            backgroundColor: e,
            resultColor: s
          };
        }
        return this._highlightColorCache.resultColor;
      }
      _applyLightUpdateIfRequired() {
        if ((0, Be.actualCurrencyUnitVisibility)().value() === "visibleOnMouseOver") {
          this._undoModel.model().lightUpdate();
        }
      }
    }
    function An(e, t) {
      return e.position - t.position;
    }
    function Ln(e, t, i) {
      const s = (e.position - t.position) / (e.time - t.time);
      return Math.sign(s) * Math.min(Math.abs(s), i);
    }
    (function (e) {
      e[e.MaxStartDelay = 50] = "MaxStartDelay";
      e[e.EpsilonDistance = 1] = "EpsilonDistance";
    })(In ||= {});
    class kn {
      constructor(e, t, i, s) {
        this._position1 = null;
        this._position2 = null;
        this._position3 = null;
        this._position4 = null;
        this._animationStartPosition = null;
        this._durationMsecs = 0;
        this._speedPxPerMsec = 0;
        this._minSpeed = e;
        this._maxSpeed = t;
        this._dumpingCoeff = i;
        this._minMove = s;
      }
      addPosition(e, t) {
        if (this._position1 !== null) {
          if (this._position1.time === t) {
            this._position1.position = e;
            return;
          }
          if (Math.abs(this._position1.position - e) < this._minMove) {
            return;
          }
        }
        this._position4 = this._position3;
        this._position3 = this._position2;
        this._position2 = this._position1;
        this._position1 = {
          time: t,
          position: e
        };
      }
      start(e, t) {
        if (this._position1 === null || this._position2 === null) {
          return;
        }
        if (t - this._position1.time > 50) {
          return;
        }
        let i = 0;
        const s = Ln(this._position1, this._position2, this._maxSpeed);
        const o = An(this._position1, this._position2);
        const n = [s];
        const r = [o];
        i += o;
        if (this._position3 !== null) {
          const e = Ln(this._position2, this._position3, this._maxSpeed);
          if (Math.sign(e) === Math.sign(s)) {
            const t = An(this._position2, this._position3);
            n.push(e);
            r.push(t);
            i += t;
            if (this._position4 !== null) {
              const e = Ln(this._position3, this._position4, this._maxSpeed);
              if (Math.sign(e) === Math.sign(s)) {
                const t = An(this._position3, this._position4);
                n.push(e);
                r.push(t);
                i += t;
              }
            }
          }
        }
        let a = 0;
        for (let e = 0; e < n.length; ++e) {
          a += r[e] / i * n[e];
        }
        if (!(Math.abs(a) < this._minSpeed)) {
          this._animationStartPosition = {
            position: e,
            time: t
          };
          this._speedPxPerMsec = a;
          this._durationMsecs = function (e, t) {
            const i = Math.log(t);
            return Math.log(i * 1 / -e) / i;
          }(Math.abs(a), this._dumpingCoeff);
        }
      }
      getStartPosition() {
        return (0, n.ensureNotNull)(this._animationStartPosition).position;
      }
      getPosition(e) {
        const t = (0, n.ensureNotNull)(this._animationStartPosition);
        const i = e - t.time;
        return t.position + this._speedPxPerMsec * (Math.pow(this._dumpingCoeff, i) - 1) / Math.log(this._dumpingCoeff);
      }
      finished(e) {
        return this._animationStartPosition === null || this._progressDuration(e) === this._durationMsecs;
      }
      _progressDuration(e) {
        const t = e - (0, n.ensureNotNull)(this._animationStartPosition).time;
        return Math.min(t, this._durationMsecs);
      }
    }
    const Dn = (0, ae.getLogger)("Chart.ChartUndoModel");
    class En extends tt.UndoCommand {
      constructor(e, t, i, s = true) {
        super(i, false, s);
        this._newRightOffsetAndBarSpacing = null;
        this._model = e;
        this._rightOffsetAndBarSpacing = t;
      }
      undo() {
        if (this._newRightOffsetAndBarSpacing !== null) {
          Dn.logDebug("TimeScaleChangeUndoCommand.undo: Command is already undone");
          return;
        }
        const e = this._model.timeScale();
        this._newRightOffsetAndBarSpacing = {
          barSpacing: e.barSpacing(),
          rightOffset: e.rightOffset()
        };
        e.setBarSpacing(this._rightOffsetAndBarSpacing.barSpacing);
        e.setRightOffset(this._rightOffsetAndBarSpacing.rightOffset);
        this._model.lightUpdate();
      }
      redo() {
        if (this._newRightOffsetAndBarSpacing === null) {
          Dn.logDebug("TimeScaleChangeUndoCommand.redo: Command is not undone");
          return;
        }
        const e = this._model.timeScale();
        e.setBarSpacing(this._newRightOffsetAndBarSpacing.barSpacing);
        e.setRightOffset(this._newRightOffsetAndBarSpacing.rightOffset);
        this._model.lightUpdate();
        this._newRightOffsetAndBarSpacing = null;
      }
    }
    const Bn = (0, ae.getLogger)("Chart.ChartUndoModel");
    var Vn;
    (function (e) {
      e[e.MergeTimeout = 1000] = "MergeTimeout";
    })(Vn ||= {});
    const Rn = new Di.TranslatedString("scale price", a.t(null, undefined, i(94981)));
    class Nn extends tt.UndoCommand {
      constructor(e, t, i, s, o, n = true) {
        super(Rn, false, n);
        this._newPriceScaleState = null;
        this._model = e;
        this._paneIndex = e.panes().indexOf(t);
        this._priceScaleId = i.id();
        this._state = s;
        this._timestamp = o ? performance.now() : null;
      }
      undo() {
        if (this._newPriceScaleState !== null) {
          Bn.logDebug("PriceScaleChangeUndoCommand.undo: Command is already undone");
          return;
        }
        const [e, t] = this._paneAndScale();
        this._newPriceScaleState = t.state();
        this._model.restorePriceScaleState(e, t, this._state);
      }
      redo() {
        if (this._newPriceScaleState === null) {
          Bn.logDebug("PriceScaleChangeUndoCommand.redo: Command is not undone");
          return;
        }
        const [e, t] = this._paneAndScale();
        this._model.restorePriceScaleState(e, t, this._newPriceScaleState);
        this._newPriceScaleState = null;
      }
      canMerge(e) {
        return e instanceof Nn && this._timestamp !== null && e._timestamp !== null && this._newPriceScaleState === null && e._model === this._model && e._paneIndex === this._paneIndex && e._priceScaleId === this._priceScaleId && Math.abs(e._timestamp - this._timestamp) < 1000;
      }
      merge(e) {
        this._timestamp = e._timestamp;
      }
      _paneAndScale() {
        const e = this._model.panes()[this._paneIndex];
        const t = (0, n.ensureNotNull)(e.getPriceScaleById(this._priceScaleId));
        return [e, t];
      }
    }
    var On;
    var Fn = i(45579);
    function Wn(e, t) {
      0;
    }
    function Hn(e) {
      Wn();
    }
    (function (e) {
      e.Create = "create";
      e.Paste = "paste";
      e.Clone = "clone";
    })(On ||= {});
    var zn = i(38780);
    var Un = i(81171);
    function jn(e) {
      return "startMoving" in e && "move" in e && "endMoving" in e && "convertYCoordinateToPriceForMoving" in e;
    }
    var Gn = i(98017);
    let qn = null;
    function $n() {
      return qn;
    }
    var Kn = i(17730);
    var Yn = i(45982);
    i(26572);
    const Zn = parseInt(Yn["css-value-pane-controls-padding-left"]);
    const Xn = parseInt(Yn["css-value-pane-controls-padding-right"]);
    const Jn = (0, Lt.getHexColorByName)("color-cold-gray-700");
    const Qn = (0, Lt.getHexColorByName)("color-cold-gray-400");
    const er = new Di.TranslatedString("scroll", a.t(null, undefined, i(42070)));
    const tr = a.t(null, undefined, i(66005));
    a.t(null, undefined, i(78972));
    function ir(e, t, i) {
      if (e.drawBackground) {
        e.drawBackground(t, i);
      }
    }
    function sr(e, t, i) {
      e.draw(t, i);
    }
    function or(e, t) {
      return e.paneViews(t);
    }
    function nr(e, t) {
      return e.topPaneViews?.(t) ?? [];
    }
    function rr(e, t) {
      return e.labelPaneViews(t);
    }
    function ar(e, t) {
      const i = e.strategyOrdersPaneView();
      if (i === null) {
        return null;
      } else {
        return [i];
      }
    }
    function lr(e, t) {
      if (e === null || e.source !== t) {
        return null;
      } else {
        return e.hittest.data();
      }
    }
    function cr(e, t, i, s, o) {
      const n = e.result?.hittest.target() ?? 0;
      if (t.target() > n) {
        e.result = {
          hittest: t,
          source: i,
          renderer: s,
          isCustom: o
        };
      }
    }
    const hr = {
      contextMenuEnabled: true,
      contextMenu: sn.defaultContextMenuOptions,
      priceScaleContextMenuEnabled: true,
      legendWidgetEnabled: true,
      controlsEnabled: true,
      propertyPagesEnabled: true,
      sourceSelectionEnabled: true,
      countdownEnabled: true
    };
    const dr = new Map([[Vt.AreaName.Text, "Text"], [Vt.AreaName.Style, "Style"]]);
    const ur = !l.enabled("display_legend_on_all_charts");
    var _r;
    (function (e) {
      e[e.MinScrollSpeed = 0.2] = "MinScrollSpeed";
      e[e.MaxScrollSpeed = 7] = "MaxScrollSpeed";
      e[e.DumpingCoeff = 0.997] = "DumpingCoeff";
      e[e.ScrollMinMove = 15] = "ScrollMinMove";
      e[e.SPenMaxDistance = 5] = "SPenMaxDistance";
      e[e.CollapsedHeight = 33] = "CollapsedHeight";
    })(_r ||= {});
    let pr = null;
    function mr(e, t) {
      return !(0, Vt.shouldDefaultActionBeExecuted)(e, t, "pressedMouseMoveHandler", "touchMoveHandler");
    }
    var gr;
    (function (e) {
      e[e.None = 0] = "None";
      e[e.DownWithoutMove = 1] = "DownWithoutMove";
      e[e.DownWithMove = 2] = "DownWithMove";
    })(gr ||= {});
    class fr {
      constructor(e, t, i, s) {
        this._legendWidget = null;
        this._paneControls = null;
        this._isDestroyed = false;
        this._trackCrosshairOnlyAfterLongTap = (0, vo.lastMouseOrTouchEventInfo)().isTouch;
        this._startTrackPoint = null;
        this._exitTrackingModeOnNextTry = false;
        this._startMoveSourceParams = null;
        this._startChangeLineToolParams = null;
        this._preventSourceChange = false;
        this._preventScrollUntilNextMouseDownOrTouchStart = false;
        this._clonningAtMoveLineTools = null;
        this._startCloningPoint = null;
        this._size = (0, Dt.size)({
          width: 0,
          height: 0
        });
        this._themedTopColor = null;
        this._initCrossHairPosition = null;
        this._firstZoomPoint = null;
        this._editDialog = null;
        this._processing = false;
        this._pressedMoveStage = 0;
        this._touchMove = false;
        this._startTouchPoint = null;
        this._isSelecting = false;
        this._prevHoveredHittest = null;
        this._contextMenuX = 0;
        this._contextMenuY = 0;
        this._startScrollingPos = null;
        this._isScrolling = false;
        this._scrollPriceScale = null;
        this._scrollXAnimation = null;
        this._prevPinchScale = 1;
        this._pinching = false;
        this._wasPinched = false;
        this._longTap = false;
        this._contextMenuOpenedOnLastTap = false;
        this._paneControlsResizeObserver = null;
        this._lastClickedSource = null;
        this._customLegendWidgetsFactoryMap = new Map();
        this._prevMoveEventPosition = null;
        this._onMagnetStateChangedListener = this._onMagnetStateChanged.bind(this);
        this._onShiftKeyStateChangedListener = this._onShiftKeyStateChanged.bind(this);
        this._currentCursorClassName = "";
        this._lastFinishedToolId = null;
        this._needResetMeasureLater = false;
        this._currentChangingLineToolHitTest = null;
        this._currentMovingHitTest = null;
        this._prevTooltipData = null;
        this._errorRenderer = null;
        this._highlightedPriceAxis = new F.WatchedValue({
          owner: "",
          axis: null
        });
        this._visuallyCollapsed = new F.WatchedValue(false);
        this._maximized = new F.WatchedValue(false);
        this._endOfSeriesDataBanner = null;
        this._selectionBeforeMouseDown = new WeakSet();
        this._mouseTouchDownUpInfo = null;
        this._canvasConfiguredHandler = () => this._state && this._chartModel().lightUpdate();
        this._updateVisuallyCollapsed = () => {
          this._visuallyCollapsed.setValue(!this.state().maximized().value() && this.state().collapsed().value());
        };
        this._updateMaximized = () => {
          this._maximized.setValue(this.state().maximized().value());
        };
        this._chart = e;
        this._state = t;
        this._options = (0, dt.merge)((0, dt.clone)(hr), i);
        this._paneWidgetsSharedState = s;
        if (this._state) {
          this._subscribeToState();
        }
        const o = {
          contextMenuEnabled: this._options.priceScaleContextMenuEnabled,
          pressedMouseMoveScale: this._options.handleScale.axisPressedMouseMove.price,
          mouseWheelScale: this._options.handleScale.mouseWheel,
          currencyConversionEnabled: this._options.currencyConversionEnabled,
          unitConversionEnabled: this._options.unitConversionEnabled,
          countdownEnabled: this._options.countdownEnabled,
          croppedTickMarks: this._options.croppedTickMarks
        };
        if (this._options.priceScaleContextMenu !== undefined) {
          o.contextMenu = this._options.priceScaleContextMenu;
        }
        const r = (e, t, i, s, n) => new Mn(this._chart, this, this._chartUndoModel(), i, t, e, o, s, n);
        const a = e.properties().childs().scalesProperties;
        const c = this._chartModel().rendererOptionsProvider();
        const h = {
          backgroundBasedTheme: e.backgroundBasedTheme().spawnOwnership(),
          stubContextMenuProvider: () => [],
          titlesProvider: () => [],
          rendererOptionsProvider: c,
          getBackgroundTopColor: () => this._chartModel().backgroundTopColor().value(),
          getBackgroundBottomColor: () => this._chartModel().backgroundColor().value(),
          requestRepaint: () => this._chartModel().lightUpdate()
        };
        this._rowElement = document.createElement("div");
        this._rowElement.style.display = "flex";
        const d = {
          showLabels: false
        };
        this._lhsPriceAxisesContainer = t.mode() === Bi.PaneMode.Regular ? new qo(a, "left", r, h, d) : new PaneWidgetSideArea(c, "left");
        this._rhsPriceAxisesContainer = t.mode() === Bi.PaneMode.Regular ? new qo(a, "right", r, h, d) : new PaneWidgetSideArea(c, "right");
        this._paneCell = document.createElement("div");
        this._paneCell.classList.add("chart-markup-table", "pane");
        this._div = document.createElement("div");
        this._div.classList.add("chart-gui-wrapper");
        this._div.setAttribute("data-name", "pane-widget-chart-gui-wrapper");
        this._paneCell.appendChild(this._div);
        this._canvasBinding = (0, Wt.createBoundCanvas)(this._div, (0, Dt.size)({
          width: 16,
          height: 16
        }));
        this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        const u = this._canvasBinding.canvasElement;
        u.style.position = "absolute";
        u.style.left = "0";
        u.style.top = "0";
        u.dataset.name = "pane-canvas";
        this._topCanvasBinding = (0, Wt.createBoundCanvas)(this._div, (0, Dt.size)({
          width: 16,
          height: 16
        }));
        this._topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        const _ = this._topCanvasBinding.canvasElement;
        _.style.position = "absolute";
        _.style.left = "0";
        _.style.top = "0";
        _.dataset.name = "pane-top-canvas";
        this._rowElement.appendChild(this._lhsPriceAxisesContainer.getElement());
        this._rowElement.appendChild(this._paneCell);
        this._rowElement.appendChild(this._rhsPriceAxisesContainer.getElement());
        u.setAttribute("aria-hidden", "true");
        const p = this._chartModel().mainSeries();
        p.dataEvents().symbolResolved().subscribe(this, this._updateAccesibilityAttr);
        p.onIntervalChanged().subscribe(this, this._updateAccesibilityAttr);
        this._updateAccesibilityAttr();
        if (this._options.legendWidgetEnabled) {
          if (this._options.customLegendWidgetFactories) {
            this._customLegendWidgetsFactoryMap = this._options.customLegendWidgetFactories;
          }
          this._loadAndCreateLegendWidget();
        }
        if (this._state && !this._chart.readOnly() && this._options.controlsEnabled) {
          this._loadAndCreatePaneControlsWidget(this._state);
        }
        (0, Un.magnetEnabled)().subscribe(this._onMagnetStateChangedListener);
        (0, Gs.shiftPressed)().subscribe(this._onShiftKeyStateChangedListener);
        if (l.enabled("chart_drag_export")) {
          _.draggable = this._chartModel().dragExportEnabled().value();
          this._chartModel().dragExportEnabled().subscribe(e => {
            _.draggable = e;
          });
          _.addEventListener("dragend", e => {
            if (this._chartModel().dragExportEnabled().value()) {
              (0, W.emit)("dragend");
            }
          });
          _.addEventListener("dragstart", async e => {
            if (!this._chartModel().dragExportEnabled().value()) {
              e.preventDefault();
              return;
            }
            e.stopPropagation();
            const t = this._chartUndoModel().model().hoveredSource();
            const i = $n();
            (0, W.emit)("dragstart", {
              preventDefault: () => e.preventDefault(),
              hoveredSourceId: t?.id() ?? null,
              exportData: e => {
                const t = e => s().convertPublicTimeToInternalTime(e);
                const s = () => (0, Kn.getChartWidgetApiTimeConverter)(p.interval(), (0, n.ensureNotNull)(p.symbolInfo(), "main series symbol info"), this._chartModel());
                if (e?.from !== undefined) {
                  e.from = t(e.from);
                }
                if (e?.to !== undefined) {
                  e.to = t(e.to);
                }
                return i?.exportData(this._chartModel(), e);
              },
              setData: (t, i) => {
                if (e.dataTransfer) {
                  e.dataTransfer.setData(t, i);
                }
              },
              setDragImage: (t, i, s) => {
                if (e.dataTransfer) {
                  e.dataTransfer.setDragImage(t, i, s);
                }
              }
            });
            if (!e.dataTransfer?.getData("text/plain") && !e.dataTransfer?.getData("text/html")) {
              e.preventDefault();
            }
          });
        }
        this.setCursorForTool();
        this._mouseEventHandler = new Et.MouseEventHandler(this._topCanvasBinding.canvasElement, this, {
          isMouseMoveHandlingEnabled: () => !this._chartModel().dragExportEnabled().value(),
          treatVertTouchDragAsPageScroll: !this._options.handleScroll.vertTouchDrag,
          treatHorzTouchDragAsPageScroll: !this._options.handleScroll.horzTouchDrag
        });
        this._paneCellMouseEventHandler = new Et.MouseEventHandler(this._paneCell, {
          doubleTapEvent: this._paneDblClickOrTapEvent.bind(this),
          mouseDoubleClickEvent: this._paneDblClickOrTapEvent.bind(this)
        });
        this._prevHoveredHittest = null;
        this._highlightedPriceAxis.subscribe(e => this._highlightPriceAxisByLabel(e.axis));
        this._prevPinchScale = 0;
        this._isDestroyed = false;
        const m = (0, Ji.combine)(() => {
          const e = this._chart.paneWidgetSeparators(this);
          return [e.separatorAbove?.selected()?.weakReference() ?? new F.WatchedValue(false).ownership(), e.separatorBelow?.selected()?.weakReference() ?? new F.WatchedValue(false).ownership()];
        }, this._chart.paneWidgetsWV().weakReference());
        this._anySeparatorSelected = (0, Ji.accumulate)(e => e.some(Boolean), m.ownership());
      }
      destroy() {
        this._chart.onPaneWidgetDestroyed(this);
        const e = this._chartModel().mainSeries();
        e.dataEvents().symbolResolved().unsubscribeAll(this);
        e.onIntervalChanged().unsubscribeAll(this);
        this._customLegendWidgetsFactoryMap.clear();
        this._topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        this._topCanvasBinding.dispose();
        this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        this._canvasBinding.dispose();
        if (this._legendWidget) {
          this._legendWidget.destroy();
          this._legendWidget = null;
        }
        if (this._paneControlsResizeObserver !== null) {
          this._paneControlsResizeObserver.disconnect();
        }
        if (this._paneControls !== null) {
          this._paneControls.destroy();
          this._paneControls = null;
        }
        this._lhsPriceAxisesContainer.destroy();
        this._rhsPriceAxisesContainer.destroy();
        if (this.hasState()) {
          this._unsubscribeFromState();
        }
        (0, Un.magnetEnabled)().unsubscribe(this._onMagnetStateChangedListener);
        (0, Gs.shiftPressed)().unsubscribe(this._onShiftKeyStateChangedListener);
        this._paneWidgetsSharedState.onPaneDestroyed(this);
        if (this._errorRenderer) {
          this._errorRenderer.then(e => {
            e.destroy();
            this._errorRenderer = null;
          });
        }
        this._prevHoveredHittest = null;
        this._mouseEventHandler.destroy();
        this._paneCellMouseEventHandler.destroy();
        this._rowElement.parentElement?.removeChild(this._rowElement);
        this._isDestroyed = true;
      }
      updateOptions(e) {
        (0, dt.merge)(this._options, e);
        if (e.legendWidgetEnabled === false && this._legendWidget) {
          this._legendWidget.destroy();
          this._legendWidget = null;
        }
        if (e.legendWidgetEnabled && !this._legendWidget) {
          if (this._options.customLegendWidgetFactories) {
            this._customLegendWidgetsFactoryMap = this._options.customLegendWidgetFactories;
          }
          this._loadAndCreateLegendWidget();
        }
        if (!this._state) {
          return;
        }
        const t = this._state.mode();
        const i = this._chartModel().rendererOptionsProvider();
        if (t === Bi.PaneMode.Regular && !(this._lhsPriceAxisesContainer instanceof qo)) {
          this._lhsPriceAxisesContainer.destroy();
          this._rhsPriceAxisesContainer.destroy();
          const e = {
            showLabels: false
          };
          const t = {
            contextMenuEnabled: this._options.priceScaleContextMenuEnabled,
            pressedMouseMoveScale: this._options.handleScale.axisPressedMouseMove.price,
            mouseWheelScale: this._options.handleScale.mouseWheel,
            currencyConversionEnabled: this._options.currencyConversionEnabled,
            unitConversionEnabled: this._options.unitConversionEnabled,
            countdownEnabled: this._options.countdownEnabled,
            croppedTickMarks: this._options.croppedTickMarks
          };
          const s = (e, i, s, o, n) => new Mn(this._chart, this, this._chartUndoModel(), s, i, e, t, o, n);
          const o = this._chart.properties().childs().scalesProperties;
          const n = () => this._chartModel().backgroundColor().value();
          const r = () => this._chartModel().backgroundTopColor().value();
          const a = {
            backgroundBasedTheme: this._chart.backgroundBasedTheme().spawnOwnership(),
            stubContextMenuProvider: () => [],
            titlesProvider: () => [],
            rendererOptionsProvider: i,
            getBackgroundTopColor: r,
            getBackgroundBottomColor: n,
            requestRepaint: () => this._chartModel().lightUpdate()
          };
          this._lhsPriceAxisesContainer = new qo(o, "left", s, a, e);
          this._rhsPriceAxisesContainer = new qo(o, "right", s, a, e);
          this._rowElement.innerHTML = "";
          this._rowElement.appendChild(this._lhsPriceAxisesContainer.getElement());
          this._rowElement.appendChild(this._paneCell);
          this._rowElement.appendChild(this._rhsPriceAxisesContainer.getElement());
        }
        if (t === Bi.PaneMode.Widget && !(this._lhsPriceAxisesContainer instanceof PaneWidgetSideArea)) {
          this._lhsPriceAxisesContainer.destroy();
          this._rhsPriceAxisesContainer.destroy();
          this._lhsPriceAxisesContainer = new PaneWidgetSideArea(i, "left");
          this._rhsPriceAxisesContainer = new PaneWidgetSideArea(i, "right");
          this._rowElement.innerHTML = "";
          this._rowElement.appendChild(this._lhsPriceAxisesContainer.getElement());
          this._rowElement.appendChild(this._paneCell);
          this._rowElement.appendChild(this._rhsPriceAxisesContainer.getElement());
        }
      }
      size() {
        return this._size;
      }
      setSize(e) {
        if (!(0, Dt.equalSizes)(this._size, e)) {
          this._size = e;
          this._canvasBinding.resizeCanvasElement(e);
          this._topCanvasBinding.resizeCanvasElement(e);
          this._paneCell.style.width = e.width + "px";
          this._paneCell.style.height = e.height + "px";
          this._div.style.width = e.width + "px";
          this._div.style.height = e.height + "px";
          this._rowElement.classList.toggle("js-hidden", e.height === 0);
          if (this._legendWidget !== null) {
            this._legendWidget.updateWidgetModeBySize(e);
          }
          if (this._paneControls !== null) {
            this._paneControls.updateWidgetModeByWidth(e.width);
          }
        }
      }
      width() {
        return this._size.width;
      }
      height() {
        return this._size.height;
      }
      backgroundColor() {
        return this._chartModel().backgroundColor().value();
      }
      highlightedPriceAxis() {
        return this._highlightedPriceAxis;
      }
      processDoubleClickOnSource(e, t, i) {
        if ((0, eo.isEditableTextLineTool)(e)) {
          const t = e.textEditingActivationTime();
          if (t !== null && performance.now() - t < 500) {
            e.deactivateTextEditing();
          }
        }
        if ((0, Vo.isDataSource)(e) && e.id() !== this._lastFinishedToolId) {
          this._showEditDialogForSource(e, t);
        }
      }
      stretchFactor() {
        if (this._state) {
          return this._state.stretchFactor();
        } else {
          return 0;
        }
      }
      setStretchFactor(e) {
        if (this.hasState()) {
          this.state().setStretchFactor(e);
        }
      }
      setCursorForTool(e, t, i) {
        if (t && t.mod() && e && e !== this._chartModel().crosshairSource()) {
          this._setCursorClassName("pointer");
          return;
        }
        if (i !== undefined) {
          switch (i) {
            case qt.PaneCursorType.VerticalResize:
              this._setCursorClassName("ns-resize");
              break;
            case qt.PaneCursorType.HorizontalResize:
              this._setCursorClassName("ew-resize");
              break;
            case qt.PaneCursorType.DiagonalNeSwResize:
              this._setCursorClassName("nesw-resize");
              break;
            case qt.PaneCursorType.DiagonalNwSeResize:
              this._setCursorClassName("nwse-resize");
              break;
            case qt.PaneCursorType.Default:
              this._setCursorClassName("default");
              break;
            case qt.PaneCursorType.Pointer:
              this._setCursorClassName("pointer");
              break;
            case qt.PaneCursorType.Grabbing:
              this._setCursorClassName("grabbing");
              break;
            case qt.PaneCursorType.Text:
              this._setCursorClassName("text");
          }
          return;
        }
        const s = lt.tool.value();
        if ((0, lt.toolIsCursor)(s)) {
          if (this._paneWidgetsSharedState.draggingSource() !== null || this._isScrolling || this._chartUndoModel() && this._chartUndoModel().model().sourcesBeingMoved().length) {
            this._setCursorClassName("grabbing");
            return;
          }
          if (e && this._options.sourceSelectionEnabled) {
            this._setCursorClassName("pointer");
            return;
          }
        }
        let o = "";
        switch (s) {
          case "eraser":
            o = "eraser";
            break;
          case "zoom":
            o = "zoom-in";
        }
        if (!o) {
          switch (lt.cursorTool.value()) {
            case "arrow":
              o = "default";
              break;
            case "dot":
              o = "dot";
              break;
            case "demonstration":
              o = "demonstration";
              break;
            case "performance":
              o = "performance";
          }
        }
        this._setCursorClassName(o);
      }
      showContextMenuForSelection(e, t, i) {
        const s = this._chartUndoModel().selection();
        if (s.isEmpty()) {
          return;
        }
        const o = s.dataSources().filter(e => e.hasContextMenu());
        this.showContextMenuForSources(o, e, undefined, t, i);
      }
      async showContextMenuForSources(e, t, i, s, o) {
        if (!e.length || !this._state) {
          return Promise.resolve(null);
        }
        const n = e[0];
        const r = (0, dt.merge)((0, dt.clone)(this._options.contextMenu), i || {});
        const a = new sn.ActionsProvider(this._chart, r);
        if (n === this._chartUndoModel().crosshairSource()) {
          n.handleContextMenuEvent(t);
          return Promise.resolve(null);
        }
        {
          const i = await a.contextMenuActionsForSources(e, this._state, t, s?.origin, o?.data()?.customActions);
          if (i.length === 0) {
            return Promise.resolve(null);
          }
          {
            let e;
            e = n instanceof Gn.Series ? {
              menuName: s?.origin ?? "ObjectTreeContextMenu",
              detail: {
                type: "series",
                id: n.instanceId()
              }
            } : (0, eo.isLineTool)(n) ? {
              menuName: s?.origin ?? "ObjectTreeContextMenu",
              detail: {
                type: "shape",
                id: n?.id() ?? null
              }
            } : {
              menuName: s?.origin ?? "ObjectTreeContextMenu",
              detail: {
                type: "study",
                id: n?.id() || null
              }
            };
            return Oo.ContextMenuManager.createMenu(i, {
              takeFocus: true,
              returnFocus: true,
              isKeyboardEvent: r.isKeyboardEvent
            }, e).then(e => {
              e.show(t);
              return e;
            });
          }
        }
      }
      leftPriceAxisesContainer() {
        return this._lhsPriceAxisesContainer;
      }
      rightPriceAxisesContainer() {
        return this._rhsPriceAxisesContainer;
      }
      setPriceAxisSizes(e, t, i) {
        this._priceAxisesContainer(e).setSizes(t, i);
      }
      state() {
        return (0, n.ensureNotNull)(this._state);
      }
      hasState() {
        return this._state !== null;
      }
      setState(e) {
        if (this._state !== e) {
          if (this.hasState()) {
            this._unsubscribeFromState();
            this._paneControls?.destroy();
            this._paneControls = null;
          }
          this._state = e;
          if (this.hasState()) {
            this.updateOptions(this._options);
            this._subscribeToState();
            this._loadAndCreatePaneControlsWidget(this.state());
            this.updatePriceAxisWidgetsStates();
            this._updateAccesibilityAttr();
          }
        }
      }
      getScreenshotData(e) {
        const t = [];
        const i = [];
        let s;
        let o = [];
        const n = this.state();
        const r = n.mode() === Bi.PaneMode.Widget ? [] : n.sourcesByGroup().priceSources().slice().reverse();
        const a = this._chart.properties().childs().paneProperties.childs().legendProperties.childs();
        for (const c of r) {
          const r = c.statusView();
          if ((0, Js.isStudy)(c) && (a.showLegend.value() || e?.showCollapsedStudies)) {
            const s = a.showStudyTitles.value();
            const o = s;
            if (c.properties().childs().visible.value() && this._chartModel().paneForSource(c) === n && r && o) {
              t.push(s ? c.statusProvider(e?.status).text() : "");
              const o = l.enabled("use_last_visible_bar_value_in_legend") ? this._chartModel().timeScale().visibleBarsStrictRange()?.lastBar() ?? null : null;
              const n = c.legendValuesProvider().getValues(o);
              i.push(n);
            }
          } else if (c === this._chartModel().mainSeries() && r && a.showSeriesTitle.value()) {
            s = c.statusProvider(e?.status || {}).text();
            const t = l.enabled("use_last_visible_bar_value_in_legend") ? this._chartModel().timeScale().visibleBarsStrictRange()?.lastBar() ?? null : null;
            o = c.legendValuesProvider().getValues(t);
          }
        }
        return {
          type: "pane",
          leftAxis: this._lhsPriceAxisesContainer.getScreenshotData(),
          rightAxis: this._rhsPriceAxisesContainer.getScreenshotData(),
          content: this._canvasBinding.canvasElement.toDataURL(),
          canvas: this._canvasBinding.canvasElement,
          contentWidth: this._size.width,
          contentHeight: this._size.height,
          studies: t,
          studiesValues: i,
          containsMainSeries: this.containsMainSeries(),
          mainSeriesText: s,
          mainSeriesValues: o
        };
      }
      updatePriceAxisWidgetsStates() {
        if (!this.hasState()) {
          return;
        }
        const e = this._chartModel();
        const t = e.paneForSource(e.mainSeries());
        if (t) {
          if (this._state?.mode() === Bi.PaneMode.Regular) {
            const i = e.priceScaleSlotsCount();
            const s = this.state();
            const o = s.visibleLeftPriceScales();
            const n = s.visibleRightPriceScales();
            this._lhsPriceAxisesContainer.setScales(o, i.left, t.leftPriceScales().length, i.left + i.right);
            this._rhsPriceAxisesContainer.setScales(n, i.right, t.rightPriceScales().length, i.left + i.right);
          } else if (this._state?.mode() === Bi.PaneMode.Widget) {
            this._lhsPriceAxisesContainer.setPane(this._state);
            this._rhsPriceAxisesContainer.setPane(this._state);
          }
        }
      }
      updatePriceAxisWidgets() {
        this._lhsPriceAxisesContainer.update();
        this._rhsPriceAxisesContainer.update();
      }
      update() {
        if (this.hasState()) {
          this.updatePriceAxisWidgets();
          if (this._legendWidget !== null) {
            this._legendWidget.update();
          }
          this.updateControls();
        }
      }
      updateStatusWidget(e) {
        if (this.hasState() && this._legendWidget !== null) {
          if (e.legendWidgetLayoutInvalidated()) {
            this._legendWidget.updateLayout();
          } else {
            this._legendWidget.update();
          }
        }
      }
      updateControls() {
        if (this.hasState() && this._paneControls !== null) {
          this._paneControls.update();
        }
      }
      updateThemedColors(e) {
        this._themedTopColor = e.topColor;
        this._updateByThemedColors();
      }
      statusWidget() {
        return this._legendWidget;
      }
      getElement() {
        return this._rowElement;
      }
      canvasElement() {
        return this._canvasBinding.canvasElement;
      }
      getRenderingInfo() {
        return (0, Wt.getBindingRenderingInfo)(this._canvasBinding);
      }
      hasCanvas(e) {
        return this._canvasBinding.canvasElement === e || this._topCanvasBinding.canvasElement === e;
      }
      pinchStartEvent() {
        return this._paneWidgetsSharedState.scrollingPane() === null && this._paneWidgetsSharedState.pinchingPane() === null && (this._onTouchEvent(), !!this._options.handleScale.pinch && (this._chartModel().stopTimeScaleAnimation(), this._prevPinchScale = 1, this._pinching = true, this._wasPinched = true, this._paneWidgetsSharedState.setPinchingPane(this), true));
      }
      pinchEvent(e, t, i, s) {
        if (this._paneWidgetsSharedState.scrollingPane() !== null || this._paneWidgetsSharedState.pinchingPane() !== this) {
          return;
        }
        this._onTouchEvent();
        if (!this._options.handleScale.pinch) {
          return;
        }
        const o = (s - this._prevPinchScale) * 10;
        this._prevPinchScale = s;
        this._chartModel().zoomTime(e.x, o, true);
        this._prevPinchScale = s;
      }
      pinchEndEvent() {
        if (this._paneWidgetsSharedState.scrollingPane() === null && this._paneWidgetsSharedState.pinchingPane() === this) {
          this._onTouchEvent();
          this._pinching = false;
          this._paneWidgetsSharedState.setPinchingPane(null);
        }
      }
      mouseClickEvent(e) {
        this._onMouseEvent();
        this._mouseClickOrTapEvent(e);
      }
      tapEvent(e) {
        if (!this._preventTouchEventsExceptPinch()) {
          this._onTouchEvent();
          this._mouseClickOrTapEvent(e);
        }
      }
      mouseDownEvent(e) {
        this._onMouseEvent();
        if (this.hasState()) {
          this._mouseDownOrTouchStartEvent(e, this._dataSourceAtPoint(e.localX, e.localY));
        }
      }
      touchStartEvent(e) {
        this._paneWidgetsSharedState.startTouch(this);
        if (this._preventTouchEventsExceptPinch()) {
          return;
        }
        const t = !this._trackCrosshairOnlyAfterLongTap && pr !== null && pr.stateId === this.state().id() && Math.abs(pr.x - e.localX) + Math.abs(pr.y - e.localY) < 5;
        this._onTouchEvent();
        this._chart.setActivePaneWidget(this);
        const i = this._dataSourceAtPoint(e.localX, e.localY);
        if (t) {
          const t = this._chartModel().crosshairSource();
          if (i !== null && i.source === t || t.selectPointMode().value() !== lt.SelectPointMode.None) {
            this.startTrackingMode(new At.Point(e.localX, e.localY), new At.Point(e.localX, e.localY));
          } else if (!this._chart.readOnly() && i !== null && (0, eo.isLineTool)(i.source) && i.source.userEditEnabled()) {
            this._chartUndoModel().selectionMacro(e => {
              e.clearSelection();
              e.addSourceToSelection(i.source, i.hittest.data());
            });
          }
        }
        this._mouseDownOrTouchStartEvent(e, i);
        this._mouseOrTouchMoveEvent(e);
      }
      mouseUpEvent(e) {
        this._onMouseEvent();
        this._mouseUpOrTouchEndEvent(e);
      }
      touchEndEvent(e) {
        this._paneWidgetsSharedState.endTouch(this);
        if (!this._preventTouchEventsExceptPinch()) {
          this._onTouchEvent();
          this._mouseOrTouchLeaveEvent(e);
          this._mouseUpOrTouchEndEvent(e);
        }
      }
      mouseMoveEvent(e) {
        this._onMouseEvent();
        this._mouseOrTouchMoveEvent(e);
      }
      pressedMouseMoveEvent(e) {
        this._onMouseEvent();
        this._pressedMouseOrTouchMoveEvent(e);
      }
      touchMoveEvent(e) {
        if (!this._preventTouchEventsExceptPinch()) {
          this._onTouchEvent();
          this._pressedMouseOrTouchMoveEvent(e);
        }
      }
      mouseLeaveEvent(e) {
        this._onMouseEvent();
        this._updateHoveredSource(null, new Bo.EnvironmentState(e));
        this._mouseOrTouchLeaveEvent(e);
      }
      mouseDoubleClickEvent(e) {
        this._onMouseEvent();
        this._mouseDoubleClickOrDoubleTapEvent(e);
      }
      wheelClickEvent(e) {
        if (this._chart.readOnly()) {
          return;
        }
        const t = this._dataSourceAtPoint(e.localX, e.localY);
        if (t === null || t.isCustom) {
          return;
        }
        if ((t.hittest.target() || 0) <= Vt.HitTarget.MovePointBackground) {
          return;
        }
        const i = new Bo.EnvironmentState(e);
        const s = t.hittest.eraseMarker();
        if (i.mod() && s !== undefined && t.source.processErase) {
          t.source.processErase(this._chartUndoModel(), s);
          return;
        }
        const o = this._chartUndoModel();
        if (!o.selection().isSelected(t.source)) {
          o.selectionMacro(e => {
            e.clearSelection();
            const i = (0, n.ensureNotNull)(t.source);
            e.addSourceToSelection(i, lr(t, i));
          });
        }
        this._chart.removeSelectedSources();
      }
      doubleTapEvent(e) {
        if (!this._preventTouchEventsExceptPinch()) {
          this._onTouchEvent();
          this._mouseDoubleClickOrDoubleTapEvent(e);
        }
      }
      longTapEvent(e) {
        if (this._state === null || this._preventTouchEventsExceptPinch()) {
          return;
        }
        this._onTouchEvent();
        this._longTap = true;
        if (this._startTrackPoint !== null || !this._trackingModeShouldBeActive()) {
          return;
        }
        const t = this._chartModel().selection();
        if (!t.isEmpty()) {
          const i = this._dataSourceAtPoint(e.localX, e.localY);
          if (i !== null && t.isSelected(i.source)) {
            return;
          }
        }
        this.startTrackingMode(new At.Point(e.localX, e.localY), new At.Point(e.localX, e.localY), new Bo.EnvironmentState(e));
      }
      mouseEnterEvent(e) {
        this._onMouseEvent();
        if (!this.hasState()) {
          return;
        }
        this._chart.setActivePaneWidget(this);
        const t = this._dataSourceAtPoint(e.localX, e.localY);
        this._updateHoveredSource(t, new Bo.EnvironmentState(e));
        this.setCursorPosition(e.localX, e.localY, new Bo.EnvironmentState(e));
      }
      contextMenuEvent(e) {
        this._onMouseEvent();
        this._contextMenuEvent(e);
      }
      touchContextMenuEvent(e) {
        if (!this._preventTouchEventsExceptPinch()) {
          this._onTouchEvent();
          this._contextMenuEvent(e);
        }
      }
      mouseDownOutsideEvent(e) {
        this._processOutsideClick(null, e);
      }
      touchStartOutsideEvent(e) {
        this._processOutsideClick(null, e);
      }
      cancelZoom() {
        this._chartModel().crosshairSource().clearSelection();
        this._firstZoomPoint = null;
        if (this._preventCrossHairMove()) {
          this._clearCursorPosition();
        }
      }
      startTrackingMode(e, t, i) {
        this._startChangeLineToolParams = null;
        this._startMoveSourceParams = null;
        this._currentChangingLineToolHitTest = null;
        this._currentMovingHitTest = null;
        this._chartUndoModel().selectionMacro(e => e.clearSelection());
        this._startTrackPoint = e;
        this._exitTrackingModeOnNextTry = false;
        this.setCursorPosition(t.x, t.y, i);
        this._initCrossHairPosition = this._chartModel().crosshairSource().currentPoint();
      }
      setDragToAnotherPaneCursor() {
        this._setCursorClassName("grabbing");
      }
      cloneLineTools(e, t) {
        return this._chartUndoModel().cloneLineTools(e, t);
      }
      exitTrackingMode() {
        if (this._state !== null && this._startTrackPoint !== null) {
          this._exitTrackingModeOnNextTry = true;
          this._tryExitTrackingMode();
        }
      }
      trackingModeEnabled() {
        return this._state !== null && this._startTrackPoint !== null;
      }
      addCustomWidgetToLegend(e, t) {
        if (this._options.legendWidgetEnabled) {
          this._customLegendWidgetsFactoryMap.set(e, t);
          if (this._legendWidget !== null) {
            this._legendWidget.addCustomWidgetToLegend(e, t);
          }
        }
      }
      containsMainSeries() {
        return !!this.hasState() && this.state().containsMainSeries();
      }
      paint(e) {
        if (!this._chartUndoModel() || !this.hasState() || this._size.width === 0 || this._size.height === 0) {
          return;
        }
        (0, Wt.tryApplySuggestedCanvasBitmapSize)(this._canvasBinding);
        (0, Wt.tryApplySuggestedCanvasBitmapSize)(this._topCanvasBinding);
        if (this._state && (e.priceScaleSideMaxLevel("left") > yo.InvalidationLevel.Cursor || e.priceScaleSideMaxLevel("right") > yo.InvalidationLevel.Cursor)) {
          this._recalculatePriceScales((0, Bt.viewportChangeEvent)(this.state()));
          if (pr !== null && pr.stateId === this.state().id()) {
            this.setCursorPosition(pr.x, pr.y, pr.envState);
          }
        }
        const t = e.fullInvalidation();
        if (t > yo.InvalidationLevel.Cursor && pr !== null && pr.stateId === this.state().id()) {
          const e = this._dataSourceAtPoint(pr.x, pr.y);
          this._updateHoveredSource(e, (0, Gs.globalEnvironmentState)());
        }
        this._lhsPriceAxisesContainer.paint(e.getterForPriceScaleInvalidationLevelBySide("left"));
        this._rhsPriceAxisesContainer.paint(e.getterForPriceScaleInvalidationLevelBySide("right"));
        if (t === yo.InvalidationLevel.None) {
          return;
        }
        const i = this._state && (this._state.maximized().value() || !this._state.collapsed().value() || this._state.mode() === Bi.PaneMode.Widget);
        if (t > yo.InvalidationLevel.Cursor) {
          const e = (0, n.ensureNotNull)(this._canvasBinding.canvasElement.getContext("2d"));
          e.setTransform(1, 0, 0, 1, 0, 0);
          const t = (0, Wt.getBindingRenderingInfo)(this._canvasBinding);
          this._makeSureIsUpdated(t);
          this._drawBackground(e, t);
          if (i) {
            this._drawSources(e, t);
          }
        }
        if (this._state !== null) {
          const e = (0, n.ensureNotNull)(this._topCanvasBinding.canvasElement.getContext("2d"));
          e.setTransform(1, 0, 0, 1, 0, 0);
          const t = (0, Wt.getBindingRenderingInfo)(this._topCanvasBinding);
          e.clearRect(0, 0, t.bitmapSize.width, t.bitmapSize.height);
          if (i) {
            this._drawTopViews(e, t);
          }
          this._drawCrossHair(e, t);
          if (i) {
            this._drawActiveLineTools(e, t);
          }
        }
      }
      cancelCreatingLineTool() {
        const e = this._chartUndoModel();
        const t = this._chartUndoModel().lineBeingCreated();
        if (t) {
          if (t.pointsCount() <= 0 && !(0, wt.isLineDrawnWithPressedButton)(t.toolname)) {
            const i = t.points();
            if (i.length > 2) {
              const s = i[i.length - 2];
              e.continueCreatingLine(s);
              this._finishTool(t);
            } else {
              e.cancelCreatingLine();
            }
          } else {
            e.cancelCreatingLine();
          }
        }
        if (this._firstZoomPoint !== null) {
          this.cancelZoom();
        }
        this._clearCursorPosition();
        this.setCursorForTool();
      }
      async drawRightThere(e) {
        if (this.hasState()) {
          await (0, Ro.ensureLineToolLoaded)(e);
          this._chartUndoModel().drawRightThere(e, this.state());
        }
      }
      cancelMeasuring() {
        this._chartUndoModel().crosshairSource().clearMeasure();
        (0, lt.resetToCursor)();
        this.setCursorForTool();
      }
      async setErrorMessage(e) {
        if (e && !this._errorRenderer) {
          this._errorRenderer = this._createErrorBlock();
        }
        (await this._errorRenderer)?.update({
          message: e?.message,
          icon: this._state?.containsMainSeries() || this._state?.maximized().value() ? e?.icon : undefined,
          backgroundColor: `linear-gradient(${this._chartModel().backgroundTopColor().value()}, ${this._chartModel().backgroundColor().value()})`,
          textColor: this._chartModel().dark().value() ? Qn : Jn,
          solutionId: e?.solutionId,
          rawHtml: e?.rawHtml,
          buttons: this.containsMainSeries() ? e?.buttons : undefined,
          maxWidth: e?.maxWidth,
          maxHeight: e?.maxHeight,
          zeroHeight: e?.zeroHeight
        });
      }
      collapsedHeight() {
        return Math.max(Math.ceil(this._paneControls?.bottomWithMargin() ?? 0), 33);
      }
      visuallyCollapsed() {
        return this._visuallyCollapsed.readonly();
      }
      maximized() {
        return this._maximized.readonly();
      }
      setCursorPosition(e, t, i) {
        this._updateLastCrosshairPosition(e, t, i);
        this._chartModel().setAndSaveCurrentPosition(this._correctXCoord(e), this._correctYCoord(t), this.state(), i);
      }
      _tryExitTrackingMode(e) {
        if (this._exitTrackingModeOnNextTry) {
          this._startTrackPoint = null;
          if (!e) {
            this._clearCursorPosition();
          }
        }
      }
      _tryStartMeasure(e, t, i, s, o) {
        return !!(0, lt.toolIsMeasure)(lt.tool.value()) && !t.startMeasurePoint() && (e.isTouch || this._preventCrossHairMove() || this.setCursorPosition(e.localX, e.localY, i), s = this._chartModel().magnet().align(s, o, this.state()), t.startMeasuring({
          price: s,
          index: o
        }, this.state()), true);
      }
      _tryFinishMeasure(e, t) {
        if (t.startMeasurePoint() && !t.endMeasurePoint()) {
          let i = t.price;
          const s = t.index;
          i = this._chartModel().magnet().align(i, s, this.state());
          t.finishMeasure({
            price: i,
            index: s
          });
          if (e.isTouch) {
            (0, lt.resetToCursor)();
          } else {
            this._needResetMeasureLater = true;
          }
          if (this._preventCrossHairMove()) {
            this._clearCursorPosition();
          }
          return true;
        }
        return false;
      }
      _tryStartZoom(e, t, i, s) {
        const o = this._chart.model().model().zoomEnabled();
        if (lt.tool.value() === "zoom" && o) {
          const o = this._chartUndoModel();
          const n = o.timeScale().indexToCoordinate(i) - o.timeScale().barSpacing() * 0.5;
          this._firstZoomPoint = {
            price: t,
            index: i,
            x: n,
            y: e.localY
          };
          if (!this._preventCrossHairMove()) {
            this.setCursorPosition(e.localX, e.localY, s);
          }
          this._chartModel().crosshairSource().startSelection(this.state());
          return true;
        }
        return false;
      }
      _finishZoom(e) {
        const t = this.state();
        const i = t.defaultPriceScale();
        const s = (0, n.ensureNotNull)(t.mainDataSource()).firstValue();
        const o = i.coordinateToPrice(e.localY, (0, n.ensureNotNull)(s));
        const r = this._chartUndoModel();
        const a = Math.round(r.timeScale().coordinateToIndex(e.localX));
        const l = (0, n.ensureNotNull)(this._firstZoomPoint);
        if (a !== l.index) {
          r.zoomToViewport(l.index, a, l.price, o, t);
        }
        this._chartModel().crosshairSource().clearSelection();
        this._firstZoomPoint = null;
        (0, lt.resetToCursor)();
        if (this._preventCrossHairMove()) {
          this._clearCursorPosition();
        }
      }
      _tryFinishZoom(e) {
        return this._firstZoomPoint !== null && (this._finishZoom(e), true);
      }
      _tryHandleEraserMouseDown(e, t) {
        if (lt.tool.value() === "eraser" && !e.isCustom && !(i = e.source, i && i.customization && i.customization.disableErasing)) {
          const i = this._chartUndoModel();
          if ((0, eo.isLineTool)(e.source) || (0, Js.isStudy)(e.source)) {
            const s = e.hittest.eraseMarker();
            if (t.mod() && s !== undefined && e.source.processErase) {
              e.source.processErase(i, s);
            } else {
              i.removeSource(e.source, false);
            }
            return true;
          }
        }
        var i;
        return false;
      }
      _tryStartChangingLineTool(e, t, i, s) {
        if (e.isTouch && this._startTrackPoint !== null) {
          return false;
        }
        const o = t.hittest;
        if ((!e.isTouch || !this._preventSourceChange) && o && (0, eo.isLineTool)(t.source) && o.target() === Vt.HitTarget.ChangePoint) {
          const r = this._chartUndoModel();
          const a = (0, n.ensure)(this.state().mainDataSource()?.firstValue());
          const l = (0, n.ensureNotNull)(t.source.priceScale()).coordinateToPrice(e.localY, a);
          r.selectionMacro(e => {
            e.clearSelection();
            e.addSourceToSelection(t.source, o.data());
          });
          let c = l;
          if (t.source.priceScale() === r.mainSeries().priceScale()) {
            c = r.model().magnet().align(l, s, this.state());
          }
          const h = o.data()?.nonDiscreteIndex;
          if (h) {
            s = r.timeScale().coordinateToFloatIndex(e.localX);
          }
          const d = o.data()?.pointIndex;
          this._startChangeLineToolParams = {
            source: t.source,
            startPoint: {
              index: s,
              price: c,
              nonDiscreteIndex: h
            },
            screenPoint: {
              x: e.localX,
              y: e.localY
            },
            pointIndex: d,
            envState: i
          };
          return true;
        }
        this._startChangeLineToolParams = null;
        return false;
      }
      _tryStartCloning(e, t, i, s) {
        if (i.mod()) {
          const t = this._chartUndoModel().selection().dataSources().filter(e => e.cloneable());
          if (s && s.cloneable()) {
            t.push(s);
          }
          if (t.length > 0) {
            this._clonningAtMoveLineTools = t.map(e => e.id());
            this._startCloningPoint = new At.Point(e.localX, e.localY);
            return true;
          }
        }
        return false;
      }
      _tryFinishClonning(e, t, i) {
        const s = this._chartUndoModel();
        const o = this._chartModel();
        if (t.mod() && this._clonningAtMoveLineTools) {
          const r = new At.Point(e.localX, e.localY);
          const a = (0, n.ensureNotNull)(this._startCloningPoint).subtract(r).length();
          const l = [];
          for (const e of this._clonningAtMoveLineTools) {
            const t = o.dataSourceForId(e);
            if (t !== null) {
              l.push(t);
            }
          }
          if (l.length === 0) {
            return false;
          }
          if (a > 8) {
            const o = this.cloneLineTools(l, true).map(e => (0, n.ensureNotNull)(s.model().dataSourceForId(e)));
            s.selectionMacro(e => {
              e.clearSelection();
              let t = null;
              o.forEach(s => {
                if (t === null) {
                  t = lr(i, s);
                }
                e.addSourceToSelection(s, t);
              });
            });
            const r = new At.Point(e.localX, e.localY);
            const a = (0, n.ensureNotNull)(o[0].priceScale());
            const c = (0, n.ensureNotNull)(this.state().mainDataSource()).firstValue();
            const h = {
              index: s.timeScale().coordinateToIndex(e.localX),
              price: a.coordinateToPrice(e.localY, (0, n.ensureNotNull)(c))
            };
            s.startMovingSources(o, {
              logical: h,
              screen: r
            }, null, t);
            this._clonningAtMoveLineTools = null;
            this._startCloningPoint = null;
          }
          return true;
        }
        return false;
      }
      _mouseDownEventForLineTool(e, t, i, s) {
        const o = lt.tool.value();
        if (!this.hasState() || (0, wt.isLineToolDrawWithoutPoints)(o) || this.state().mode() === Bi.PaneMode.Widget) {
          return;
        }
        const r = this._chartUndoModel();
        let a = false;
        let l = null;
        if ((0, lt.hideAllDrawings)().value()) {
          (0, ks.toggleHideMode)();
        }
        (0, lt.lockDrawings)().setValue(false);
        if (e.isTouch && !e.stylus && ((0, wt.isLineToolName)(o) && !(0, wt.isLineDrawnWithPressedButton)(o) || r.lineBeingCreated())) {
          this._initToolCreationModeParams(e);
        }
        const c = r.lineBeingCreated();
        if (c && !(0, wt.isLineDrawnWithPressedButton)(c.toolname)) {
          const o = (0, n.ensure)(c.ownerSource()?.firstValue());
          if (e.isTouch && !e.stylus) {
            if (!this._startTouchPoint) {
              this._startTouchPoint = new At.Point(e.pageX, e.pageY);
              const t = c.points();
              const i = t[t.length - 1];
              const s = r.timeScale().indexToCoordinate(i.index);
              const a = (0, n.ensureNotNull)(c.priceScale()).priceToCoordinate(i.price, o);
              this._initCrossHairPosition = new At.Point(s, a);
              return;
            }
          } else if (!e.isTouch) {
            l = c;
            const h = r.model().paneForSource(c);
            if (h !== this._state && h !== null) {
              const i = this._externalPaneXCoord(h, e.localX);
              const s = this._externalPaneYCoord(h, e.localY);
              a = r.continueCreatingLine({
                index: Math.round(r.timeScale().coordinateToIndex(i)),
                price: (0, n.ensure)(c.priceScale()?.coordinateToPrice(s, o))
              }, t);
            } else {
              const e = r.model().magnet().align(s, i, this.state());
              a = r.continueCreatingLine({
                index: i,
                price: e
              }, t);
            }
          }
        } else {
          const t = (0, wt.isLineDrawnWithPressedButton)(o);
          if (!e.isTouch || e.stylus || t) {
            const e = c === null || (0, eo.isBrushBasedLineTool)(c) && c.hasOnlyOnePoint();
            const n = {
              index: i,
              price: t && !e ? s : r.model().magnet().align(s, i, this.state())
            };
            l = r.createLineTool({
              pane: this.state(),
              point: n,
              linetool: o
            });
            if (this._mouseTouchDownUpInfo) {
              this._mouseTouchDownUpInfo.toolCreation = true;
            }
            if (!r.lineBeingCreated()) {
              a = true;
            }
          }
        }
        const h = this._dataSourceAtPoint(e.localX, e.localY);
        if (l) {
          r.selectionMacro(e => {
            e.addSourceToSelection((0, n.ensureNotNull)(l), h?.hittest.data());
          });
        }
        if (a && l) {
          this._finishTool(l, h);
          e.preventDefault();
        }
      }
      _handleSelectionMouseDownAndGetJustDeselectedSource(e, t, i) {
        const s = this._chartUndoModel();
        let o = null;
        if (t === null || t.source.isSelectionEnabled()) {
          s.selectionMacro(s => {
            if (!this._preventSourceChange && t !== null && (e.isTouch ? t.hittest.target() >= Vt.HitTarget.MovePointBackground : t.hittest.target() > Vt.HitTarget.MovePointBackground)) {
              if (!i.mod() && !s.selection().isSelected(t.source)) {
                s.clearSelection();
              }
              if (i.mod() && s.selection().isSelected(t.source)) {
                o = t.source;
                s.removeSourceFromSelection(t.source);
              } else {
                s.addSourceToSelection(t.source, t.hittest.data());
              }
              if (s.selection().allSources().length > 1) {
                (0, ne.trackEvent)("GUI", "Multiselect", "Click Select");
              }
            } else if (!i.mod()) {
              s.clearSelection();
              this._clonningAtMoveLineTools = null;
              this._startCloningPoint = null;
            }
          });
        }
        return o;
      }
      _processMouseMoveWhileZoom(e, t) {
        if (!this._preventCrossHairMove()) {
          this.setCursorPosition(e.localX, e.localY, t);
        }
      }
      _updateCommonTooltip(e, t) {
        let i = null;
        if (e !== null && e.hittest !== null) {
          const t = e.hittest.data();
          if (t) {
            i = t.tooltip || null;
          }
        }
        if (this._prevTooltipData === null && i === null) {
          return;
        }
        if (i === null || i.text === "") {
          this._prevTooltipData = null;
          (0, zn.hide)(t);
          return;
        }
        if (this._prevTooltipData && (0, Do.default)(i, this._prevTooltipData)) {
          return;
        }
        this._prevTooltipData = i;
        const s = (0, dt.clone)(i);
        if (s.rect !== undefined) {
          const e = this._paneCell.getBoundingClientRect();
          s.rect.x += e.left;
          s.rect.y += e.top;
        }
        (0, zn.show)(s);
      }
      _setCursorPositionOnExternalPane(e, t, i, s) {
        t = this._externalPaneXCoord(e, t);
        i = this._externalPaneYCoord(e, i);
        this._chart.paneByState(e).setCursorPosition(t, i, s);
      }
      _updateLastCrosshairPosition(e, t, i) {
        const s = this.state().id();
        pr = {
          x: e,
          y: t,
          envState: i,
          stateId: s
        };
      }
      _setCursorClassName(e) {
        let t = "";
        if (e) {
          t = "pane--cursor-" + e;
        }
        if (this._currentCursorClassName !== t) {
          if (this._currentCursorClassName) {
            this._paneCell.classList.remove(this._currentCursorClassName);
          }
          if (t) {
            this._paneCell.classList.add(t);
          }
          this._currentCursorClassName = t;
          this._paneCell.style.cursor;
        }
      }
      _processMouseUpOrTouchEndHandler(e) {
        const t = this._dataSourceAtPoint(e.localX, e.localY);
        if (t !== null) {
          const i = this._sourceWasSelected(t);
          t.hittest.tryCallMouseUpOrTouchEndHandler(e, {
            sourceWasSelected: i
          });
        }
      }
      _crossHairShouldBeVisible() {
        const e = this._chartModel().crosshairSource();
        return (0, wt.isLineToolName)(lt.tool.value()) || (0, lt.toolIsMeasure)(lt.tool.value()) || e.startMeasurePoint() && !e.endMeasurePoint() || this._firstZoomPoint !== null || this._chartModel().lineBeingEdited() !== null || this._chartModel().lineBeingCreated() !== null;
      }
      _clearCursorPosition() {
        pr = null;
        this._chartModel().clearCurrentPosition();
      }
      _dataSourceAtPoint(e, t) {
        if (!this.hasState()) {
          return null;
        }
        const i = {
          result: null
        };
        const s = this._chartUndoModel();
        if ((0, wt.isLineToolName)(lt.tool.value()) || s.lineBeingCreated() !== null) {
          return i.result;
        }
        if (this._currentChangingLineToolHitTest) {
          return this._currentChangingLineToolHitTest;
        }
        const o = new Set();
        if (this._currentMovingHitTest && this._currentMovingHitTest.sourceAtPoint.hittest.data()) {
          if (!this._currentMovingHitTest.cancelledContainer?.cancelled) {
            return this._currentMovingHitTest.sourceAtPoint;
          }
          o.add(this._currentMovingHitTest.sourceAtPoint.source.id());
        }
        if (this._currentMovingHitTest && this._currentMovingHitTest.sourceAtPoint.hittest.data() && !this._currentMovingHitTest.cancelledContainer?.cancelled) {
          return this._currentMovingHitTest.sourceAtPoint;
        }
        const n = this.state();
        const r = (0, Wt.getBindingRenderingInfo)(this._canvasBinding);
        this._makeSureIsUpdated(r);
        const a = cr.bind(null, i);
        const l = new At.Point(e, t);
        if (!n.maximized().value() && n.collapsed().value() || (0, vo.lastMouseOrTouchEventInfo)().isTouch && (lt.activePointSelectionMode.value() !== lt.SelectPointMode.None || this._startTrackPoint !== null)) {
          this._hitTestSources(r, [s.crosshairSource()], l, a, false, o);
          return i.result;
        }
        const c = n.sourcesByGroup();
        const h = s.selection();
        const d = h.dataSources().filter(e => e.isMultiPaneEnabled() || s.paneForSource(e) === n);
        this._hitTestSources(r, d, l, a, false, o);
        this._hitTestSources(r, h.customSources(), l, a, true, o);
        h.allSources().forEach(e => o.add(e.id()));
        this._hitTestSources(r, [s.crosshairSource()], l, a, false, o);
        this._hitTestSources(r, n.customSources(Eo.CustomSourceLayer.Topmost), l, a, true, o);
        this._hitTestSources(r, c.tradingSources(), l, a, false, o);
        this._hitTestSources(r, n.customSources(Eo.CustomSourceLayer.Foreground), l, a, true, o);
        const u = c.hitTestSources();
        this._hitTestSources(r, u, l, a, false, o);
        if (this.containsMainSeries()) {
          const e = s.activeStrategySource().value();
          if (e !== null && !o.has(e.id())) {
            const t = e.strategyOrdersPaneView();
            if (t !== null) {
              const s = t.renderer(r);
              if (s !== null) {
                const t = s.hitTest(l, r);
                if (t) {
                  cr(i, t, e, s, false);
                }
              }
            }
          }
        }
        if (i.result === null) {
          this._hitTestSources(r, n.customSources(Eo.CustomSourceLayer.Background), l, a, true, o);
        }
        return i.result;
      }
      _sourceWasSelected(e) {
        return !!e && this._selectionBeforeMouseDown.has(e.source);
      }
      _hitTestSources(e, t, i, s, o, r) {
        const a = (0, n.ensureNotNull)(this._state);
        for (let n = t.length - 1; n >= 0; --n) {
          const l = t[n];
          if (r.has(l.id())) {
            continue;
          }
          const c = l.paneViews(a);
          if (c !== null && c.length !== 0) {
            for (let t = c.length - 1; t >= 0; --t) {
              const n = c[t].renderer(e);
              if (n && n.hitTest) {
                const t = n.hitTest(i, e);
                if (t !== null) {
                  s(t, l, n, o);
                }
              }
            }
          }
        }
      }
      _tryStartMovingLineTool(e, t, i, s) {
        if (t.source === null || !t.source.movable() || this._startTrackPoint !== null) {
          return false;
        }
        if (!this._preventSourceChange) {
          const o = this._chartUndoModel();
          const r = (0, n.ensureNotNull)((0, n.ensureNotNull)(this._state).mainDataSource()).firstValue();
          const a = (0, n.ensureNotNull)(t.source.priceScale());
          const l = r === null ? NaN : a.coordinateToPrice(e.localY, r);
          let c = (t.source.isSelectionEnabled() ? o.selection().allSources() : [t.source]).filter(jn);
          const h = c.filter(e => (0, eo.isLineTool)(e) && !e.isSourceHidden());
          c = h.length > 0 ? h : c.includes(t.source) ? [t.source] : [c[0]];
          const d = new At.Point(e.localX, e.localY);
          const u = {
            index: s,
            price: l
          };
          const _ = t.hittest.data()?.activeItem;
          this._startMoveSourceParams = {
            source: c,
            startPoint: {
              logical: u,
              screen: d
            },
            activeItem: _ === undefined ? null : _,
            envState: i
          };
          return true;
        }
        this._startMoveSourceParams = null;
        return false;
      }
      _chartModel() {
        return this._chart.model().model();
      }
      _chartUndoModel() {
        return this._chart.model();
      }
      _externalPaneXCoord(e, t) {
        t += this._div.getBoundingClientRect().left + document.body.scrollLeft;
        const i = (0, n.ensureNotNull)(this._chart.paneByState(e));
        const s = i._div.getBoundingClientRect().left + document.body.scrollLeft;
        return i._correctXCoord(t - s);
      }
      _externalPaneYCoord(e, t) {
        t += this._div.getBoundingClientRect().top + document.body.scrollTop;
        const i = (0, n.ensureNotNull)(this._chart.paneByState(e));
        const s = i._div.getBoundingClientRect().top + document.body.scrollTop;
        return i._correctYCoord(t - s);
      }
      _correctXCoord(e) {
        return Math.max(0, Math.min(e, this._size.width - 1));
      }
      _correctYCoord(e) {
        return Math.max(0, Math.min(e, this._size.height - 1));
      }
      _processScroll(e) {
        if (!this._chart.model().model().scrollEnabled()) {
          return;
        }
        const t = performance.now();
        if (!this._startScrollingPos && !this._preventScroll()) {
          this._startScrollingPos = {
            x: e.clientX,
            y: e.clientY,
            timestamp: t,
            localX: e.localX,
            localY: e.localY
          };
        }
        const i = this._chartUndoModel();
        let s = this.state().defaultPriceScale();
        if (this._startScrollingPos && !this._isScrolling && (this._startScrollingPos.x !== e.clientX || this._startScrollingPos.y !== e.clientY)) {
          i.beginUndoMacro(er);
          if (this._scrollXAnimation === null && this._options.useKineticScroll) {
            this._scrollXAnimation = new kn(0.2, 7, 0.997, 15);
            this._scrollXAnimation.addPosition(e.clientX, this._startScrollingPos.timestamp);
          }
          if (!i.selection().isEmpty()) {
            s = i.selection().allSources()[0].priceScale();
          }
          if (s !== null && !s.isEmpty()) {
            this._scrollPriceScale = s;
            i.startScrollPrice(this.state(), s, e.localY);
          }
          i.startScrollTime(e.localX);
          this._isScrolling = true;
          this.setCursorForTool();
          this._paneWidgetsSharedState.setScrollingPane(this);
          return;
        }
        if (this._isScrolling) {
          if (this._scrollPriceScale !== null) {
            i.scrollPriceTo(this.state(), this._scrollPriceScale, e.localY);
          }
          i.scrollTimeTo(e.localX);
          if (this._scrollXAnimation !== null) {
            this._scrollXAnimation.addPosition(e.clientX, t);
          }
        }
      }
      _finishScroll() {
        const e = this._chartUndoModel();
        e.endScrollTime();
        if (this._scrollPriceScale !== null) {
          e.endScrollPrice(this.state(), this._scrollPriceScale);
        }
        e.endUndoMacro();
        this._isScrolling = false;
        this._startScrollingPos = null;
        this._scrollPriceScale = null;
        this.setCursorForTool();
        this._paneWidgetsSharedState.setScrollingPane(null);
      }
      _endScroll(e) {
        if (!this._isScrolling) {
          return false;
        }
        this._finishScroll();
        const t = this._scrollUndoCommandInStack();
        const i = performance.now();
        if (this._scrollXAnimation !== null) {
          this._scrollXAnimation.start(e.clientX, i);
          if (!this._scrollXAnimation.finished(i)) {
            this._chartModel().stopTimeScaleAnimation();
            this._chartModel().setTimeScaleAnimation(this._scrollXAnimation);
            this._scrollXAnimation = null;
          }
        }
        return t;
      }
      _preventScroll() {
        return this._trackCrosshairOnlyAfterLongTap && this._longTap || this._contextMenuOpenedOnLastTap || (0, wt.isLineToolName)(lt.tool.value()) || Boolean(this._chartUndoModel().lineBeingCreated()) || this._startTrackPoint !== null || this._preventScrollUntilNextMouseDownOrTouchStart;
      }
      _isSelectPointModeEnabled() {
        return this._chartUndoModel().crosshairSource().selectPointMode().value() !== lt.SelectPointMode.None;
      }
      _preventCrossHairMove() {
        return !!this._trackCrosshairOnlyAfterLongTap && this._chart.trackingModePaneWidget() === null && (!!this._contextMenuOpenedOnLastTap || !this._crossHairShouldBeVisible() && this._startTrackPoint === null);
      }
      _finishTool(e, t = null) {
        const i = this._chartUndoModel();
        const s = e.toolname;
        if (s === lt.tool.value()) {
          (0, lt.resetToCursor)();
        }
        if (this._preventCrossHairMove()) {
          this._clearCursorPosition();
        }
        i.selectionMacro(i => {
          i.addSourceToSelection(e, lr(t, e));
        });
        if ((0, eo.isEditableTextLineTool)(e) && e.activateEditingOnCreation()) {
          e.activateTextEditingOn(this._div, true);
        } else if ((0, wt.isTextToolName)(s)) {
          const t = i.createUndoCheckpoint();
          this._chart.showChartPropertiesForSource(e, Zs.TabNames.text, undefined, t);
        }
        this._lastFinishedToolId = e.id();
        (0, W.emit)("drawing_event", e.id(), "create");
        Hn();
      }
      _alignSourcesThatBeingMoved(e, t, i, s, o) {
        const n = this._chartUndoModel();
        const r = o === 2 ? NaN : n.timeScale().coordinateToIndex(t);
        n.model().sourcesBeingMoved().forEach(e => {
          let a = r;
          let l = e.convertYCoordinateToPriceForMoving(i, this.state().mainDataSource());
          if (l === null) {
            if (o !== 1) {
              return;
            }
            l = NaN;
          }
          if ((0, Js.isStudy)(e)) {
            const e = n.mainSeries();
            const t = e.bars().firstIndex();
            const i = e.bars().lastIndex();
            if (t !== null && i !== null && o !== 2) {
              a = Math.min(Math.max(r, t), i);
            }
            if (o !== 1) {
              l = this._chartModel().magnet().align(l, r, this.state());
            }
          }
          if (this._currentMovingHitTest === null || this._currentMovingHitTest.sourceAtPoint.hittest.data()?.cursorType === undefined) {
            this.setCursorForTool();
          }
          n.moveSources({
            screen: new At.Point(t, i),
            logical: {
              index: a,
              price: l
            }
          }, s);
        });
      }
      _resetMeasureIfRequired() {
        if (this._needResetMeasureLater) {
          (0, lt.resetToCursor)();
          this._needResetMeasureLater = false;
        }
      }
      _makeSureIsUpdated(e) {
        const t = this.state();
        const i = [...t.dataSources(), ...t.customSources()];
        for (const s of i) {
          const i = s.paneViews(t);
          if (i !== null) {
            for (const t of i) {
              t.makeSureIsUpdated?.(e);
            }
          }
        }
      }
      _drawBackground(e, t) {
        const i = this._chartModel();
        const s = i.backgroundTopColor().value();
        const o = i.backgroundColor().value();
        if (this._state?.mode() === Bi.PaneMode.Widget) {
          const i = this._state?.model().panes().indexOf(this._state) ?? 0;
          const n = this._state?.model().mainPane();
          const r = i > (n ? this._state?.model().panes().indexOf(n) ?? 0 : 0) ? o : s;
          (0, Wt.clearRect)(e, 0, 0, t.bitmapSize.width, t.bitmapSize.height, r);
        } else if (s === o) {
          (0, Wt.clearRect)(e, 0, 0, t.bitmapSize.width, t.bitmapSize.height, o);
        } else {
          (0, Ft.clearRectWithGradient)(e, 0, 0, t.bitmapSize.width, t.bitmapSize.height, s, o);
        }
      }
      _drawWatermark(e, t) {
        const i = this._chartModel().watermarkSource();
        if (i === null) {
          return;
        }
        if (!this.state().containsMainSeries()) {
          return;
        }
        const s = i.paneViews();
        for (const i of s) {
          e.save();
          const s = i.renderer(t);
          if (s) {
            s.draw(e, t);
          }
          e.restore();
        }
      }
      _drawCrossHair(e, t) {
        const i = this._chartUndoModel().crosshairSource();
        i.invalidateLockPosition();
        if (!i.visible && lt.crosshairLock.value() !== null) {
          i.updateAllViews((0, Bt.sourceChangeEvent)(i.id()));
        }
        this._drawSourceImpl(e, t, or, sr, i);
      }
      _drawActiveLineTools(e, t) {
        const i = this._chartModel();
        const s = [i.lineBeingCreated(), i.lineBeingEdited(), ...i.sourcesBeingMoved(), i.customSourceBeingMoved()].filter(e => e);
        for (const o of s) {
          if (i.paneForSource(o) === this.state() || (0, Vo.isDataSource)(o) && o.isMultiPaneEnabled()) {
            this._drawSourceImpl(e, t, or, sr, o);
          }
        }
      }
      _drawTopViews(e, t) {
        for (const i of this.state().sourcesByGroup().all()) {
          if (i.topPaneViews) {
            this._drawSourceImpl(e, t, nr, sr, i);
          }
        }
      }
      _drawSources(e, t) {
        const i = this.state();
        const s = i.model();
        const o = i.sourcesByGroup();
        const n = o.tradingSources();
        const r = o.generalSources();
        const a = o.phantomSources();
        const l = i.customSources(Eo.CustomSourceLayer.Background).slice();
        const c = i.customSources(Eo.CustomSourceLayer.Foreground).slice();
        const h = i.customSources(Eo.CustomSourceLayer.Topmost).slice();
        const d = s.activeStrategySource().value();
        const u = s.replayStudyStrategy().value();
        {
          const e = s.panes();
          for (let t = e.length - 1; t >= 0; t--) {
            e[t].createDrawingsCaches();
          }
        }
        this._drawSourceImpl(e, t, or, sr, s.gridSource());
        this._drawWatermark(e, t);
        for (const i of l) {
          this._drawSourceImpl(e, t, or, ir, i);
        }
        for (const i of r) {
          this._drawSourceImpl(e, t, or, ir, i);
        }
        for (const i of c) {
          this._drawSourceImpl(e, t, or, ir, i);
        }
        for (const i of a) {
          this._drawSourceImpl(e, t, or, ir, i);
        }
        const _ = new Set();
        [s.lineBeingCreated(), s.lineBeingEdited(), ...s.sourcesBeingMoved(), s.customSourceBeingMoved()].filter(dt.notNull).forEach(e => _.add(e.id()));
        let p = s.hoveredSource();
        if (p !== null) {
          if ((0, Vo.isDataSource)(p) && !p.showOnTopOnHovering() || _.has(p.id()) || (0, Vo.isDataSource)(p) && !r.includes(p)) {
            p = null;
          } else {
            _.add(p.id());
          }
        }
        const m = s.selection().allSources().filter(e => (!(0, Vo.isDataSource)(e) || !!r.includes(e)) && !_.has(e.id()));
        m.forEach(e => _.add(e.id()));
        for (const i of l) {
          this._drawSourceImpl(e, t, or, sr, i, _);
        }
        for (const i of r) {
          this._drawSourceImpl(e, t, or, sr, i, _);
        }
        for (const i of c) {
          this._drawSourceImpl(e, t, or, sr, i, _);
        }
        if (d && this.containsMainSeries()) {
          this._drawSourceImpl(e, t, ar, sr, d, _);
        }
        if (u) {
          this._drawSourceImpl(e, t, ar, sr, u, _);
        }
        for (const i of n) {
          this._drawSourceImpl(e, t, or, ir, i);
        }
        for (const i of h) {
          this._drawSourceImpl(e, t, or, ir, i);
        }
        for (const i of r) {
          this._drawSourceImpl(e, t, rr, sr, i, _);
        }
        for (const i of c) {
          this._drawSourceImpl(e, t, rr, sr, i, _);
        }
        for (const i of n) {
          this._drawSourceImpl(e, t, or, sr, i, _);
        }
        for (const i of h) {
          this._drawSourceImpl(e, t, or, sr, i, _);
        }
        for (const i of m) {
          this._drawSourceImpl(e, t, or, sr, i);
          if (i === d && this.containsMainSeries()) {
            this._drawSourceImpl(e, t, ar, sr, d);
          }
        }
        for (const i of m) {
          this._drawSourceImpl(e, t, rr, sr, i);
        }
        if (p) {
          this._drawSourceImpl(e, t, or, sr, p);
          if (p === d && this.containsMainSeries()) {
            this._drawSourceImpl(e, t, ar, sr, d);
          }
          this._drawSourceImpl(e, t, rr, sr, p);
        }
        for (const i of a) {
          this._drawSourceImpl(e, t, or, sr, i, _);
        }
        {
          const e = s.panes();
          for (let t = e.length - 1; t >= 0; t--) {
            e[t].clearDrawingCaches();
          }
        }
      }
      _drawSourceImpl(e, t, i, s, o, n) {
        if (n && n.has(o.id())) {
          return;
        }
        const r = i(o, this.state());
        if (r) {
          for (const i of r) {
            const o = i.renderer(t);
            if (o) {
              e.save();
              s(o, e, t);
              e.restore();
            }
          }
        }
      }
      _updateByThemedColors() {
        if (this._legendWidget !== null) {
          this._legendWidget.updateThemedColors(this._themedTopColor);
        }
        if (this._paneControls !== null) {
          this._paneControls.updateThemedColors(this._themedTopColor);
        }
      }
      _scrollUndoCommandInStack() {
        const e = this._chartUndoModel().undoHistory().undoStack();
        if (e.isEmpty()) {
          return false;
        }
        const t = e.head();
        if (!(t instanceof ot)) {
          return false;
        }
        if (t.isEmpty()) {
          return false;
        }
        const i = t.commands()[0];
        return i instanceof Nn || i instanceof En;
      }
      _onStateDestroyed() {
        this.setState(null);
      }
      _onDataSourcesCollectionChanged() {
        this._startMoveSourceParams = null;
      }
      _processMouseEnterLeaveMoveHandlers(e, t) {
        if (this._prevHoveredHittest !== null && (this._prevHoveredHittest.renderer !== e?.renderer || this._prevHoveredHittest.hittest.data()?.activeItem !== e.hittest.data()?.activeItem)) {
          const e = this._sourceWasSelected(this._prevHoveredHittest);
          (0, Vt.tryCallHandler)(t, {
            sourceWasSelected: e
          }, this._prevHoveredHittest.hittest.data()?.mouseLeaveHandler);
          this._prevHoveredHittest = null;
        }
        if (!t.isTouch && e !== null) {
          const i = this._sourceWasSelected(e);
          if (this._prevHoveredHittest?.renderer !== e.renderer) {
            e.hittest.tryCallMouseEnterHandler(t, {
              sourceWasSelected: i
            });
            this._prevHoveredHittest = e;
          }
          e.hittest.tryCallMouseMoveHandler(t, {
            sourceWasSelected: i
          });
        }
      }
      _startChangeOrMoveLineToolIfNeeded() {
        if (this._startChangeLineToolParams !== null) {
          const e = this._startChangeLineToolParams;
          (0, ne.trackEvent)("chart_alert", "edit", "start_change_line_tool_params");
          this._chartUndoModel().startChangingLinetool(e.source, e.startPoint, e.pointIndex, e.envState);
        }
        if (this._startMoveSourceParams !== null) {
          const e = this._startMoveSourceParams;
          (0, ne.trackEvent)("chart_alert", "edit", "start_moving_sources");
          this._chartUndoModel().startMovingSources(e.source, e.startPoint, e.activeItem, e.envState);
        }
        this._startMoveSourceParams = null;
        this._startChangeLineToolParams = null;
      }
      _trackingModeShouldBeActive() {
        return !!this._trackCrosshairOnlyAfterLongTap && !this._contextMenuOpenedOnLastTap && !this._crossHairShouldBeVisible() && this._longTap;
      }
      _processOutsideClick(e, t) {
        let i = null;
        const s = this._chartModel();
        if (e !== null) {
          i = e.isCustom ? s.customSourceName(e.source) : e.source.id();
        }
        if (this._lastClickedSource !== null && this._lastClickedSource.id !== i) {
          const e = this._lastClickedSource.id;
          let i = this._lastClickedSource.isCustom ? s.customSourceForName(e) : s.dataSourceForId(e);
          if (i === null && !this._lastClickedSource.isCustom) {
            i = s.dataSourceForId(e);
          }
          if (i !== null && i.onClickOutside) {
            i.onClickOutside((0, Wt.getBindingRenderingInfo)(this._canvasBinding), t);
            this._chartModel().updateSource(i);
          }
        }
        this._lastClickedSource = i !== null ? {
          id: i,
          isCustom: e?.isCustom ?? false
        } : null;
      }
      async showConfetti(e, t) {
        0;
      }
      _mouseClickOrTapEvent(e) {
        if (!this.hasState()) {
          return;
        }
        let t = null;
        let i = null;
        if (!this._mouseTouchDownUpInfo || !this._mouseTouchDownUpInfo.toolCreation || !!this._mouseTouchDownUpInfo.mouseMove) {
          t = this._dataSourceAtPoint(e.localX, e.localY);
          i = t && t.source;
        }
        const s = this._chartUndoModel();
        const o = Boolean(t?.hittest.data()?.hideCrosshairLinesOnHover);
        this._processOutsideClick(t, e);
        if (!!this._isSelectPointModeEnabled() && !o && (!e.isTouch || !this.trackingModeEnabled() || !!this._exitTrackingModeOnNextTry)) {
          s.crosshairSource().trySelectCurrentPoint();
        }
        const r = this._sourceWasSelected(t);
        if (!(0, wt.isLineToolName)(lt.tool.value()) && t !== null && t.hittest.tryCallClickOrTapHandler(e, {
          sourceWasSelected: r
        })) {
          s.model().updateSource((0, n.ensureNotNull)(i));
        }
        if (!!e.isTouch && !this._isSelectPointModeEnabled() && (!t || t.source !== s.crosshairSource())) {
          this._tryExitTrackingMode();
        }
        if (i && (0, eo.isLineTool)(i) && this._lastFinishedToolId !== i.id()) {
          (0, W.emit)("drawing_event", i.id(), "click");
        }
        this._resetMeasureIfRequired();
        this._mouseTouchDownUpInfo = null;
      }
      _mouseDownOrTouchStartEvent(e, t) {
        this._pressedMoveStage = 1;
        this._preventScrollUntilNextMouseDownOrTouchStart = false;
        this._selectionBeforeMouseDown = new Set(this._chartModel().selection().allSources());
        if (e.isTouch) {
          this._longTap = false;
          this._exitTrackingModeOnNextTry = this._startTrackPoint !== null;
          this._paneWidgetsSharedState.clearDraggingSource();
        }
        this._contextMenuOpenedOnLastTap = false;
        this._lastFinishedToolId = null;
        const i = this._chartModel();
        i.stopTimeScaleAnimation();
        this._mouseTouchDownUpInfo = {
          mouseMove: false,
          toolCreation: Boolean(i.lineBeingCreated())
        };
        if (e.isTouch) {
          this._switchTrackingModeFromAnotherPaneIfNeeded(e);
        }
        if (document.activeElement !== document.body && document.activeElement !== document.documentElement) {
          if (document.activeElement && document.activeElement.blur) {
            document.activeElement.blur();
          } else {
            document.body.focus();
          }
        } else {
          const e = document.getSelection();
          if (e !== null) {
            e.removeAllRanges();
          }
        }
        (0, W.emit)("mouse_down", {
          clientX: e.clientX,
          clientY: e.clientY,
          pageX: e.pageX,
          pageY: e.pageY,
          screenX: e.screenX,
          screenY: e.screenY
        });
        this._updateCommonTooltip(null);
        const s = this._chartUndoModel();
        const o = new Bo.EnvironmentState(e);
        s.mainSeries().clearGotoDateResult();
        const r = this.state().defaultPriceScale();
        if (s.timeScale().isEmpty()) {
          return;
        }
        const a = s.crosshairSource();
        if (!e.isTouch && !(0, wt.isLineDrawnWithPressedButton)(lt.tool.value())) {
          const t = s.lineBeingCreated();
          const i = t !== null ? s.model().paneForSource(t) : null;
          if (i !== null && i !== this._state) {
            this._setCursorPositionOnExternalPane(i, e.localX, e.localY, o);
          } else {
            this.setCursorPosition(e.localX, e.localY, o);
          }
        }
        if (e.isTouch && (0, wt.isLineToolName)(lt.tool.value())) {
          if ((0, wt.isLineDrawnWithPressedButton)(lt.tool.value()) || a.pane !== null) {
            if ((0, wt.isLineDrawnWithPressedButton)(lt.tool.value())) {
              this._clearCursorPosition();
            }
          } else {
            this._chart.updateCrossHairPositionIfNeeded();
          }
        }
        const l = (0, n.ensureNotNull)(this.state().mainDataSource()).firstValue();
        let c = l == null ? null : r.coordinateToPrice(e.localY, l);
        let h = i.timeScale().coordinateToIndex(e.localX);
        if (a.startMeasurePoint() && a.endMeasurePoint()) {
          a.clearMeasure();
        }
        if (o.shift() && (0, lt.toolIsCursor)(lt.tool.value())) {
          const e = s.selection().isEmpty();
          if (t === null || e && !t.hittest.data()?.hasOwnShortcutsBehaviourFor?.shiftKey) {
            lt.tool.setValue("measure");
            if (!e) {
              s.selectionMacro(e => e.clearSelection());
            }
          }
        }
        if ((e.isTouch && !e.stylus || c === null || !this._tryStartMeasure(e, a, o, c, h)) && (e.isTouch && !e.stylus || !this._tryFinishMeasure(e, a)) && !this._tryFinishZoom(e) && (c === null || !this._tryStartZoom(e, c, h, o))) {
          if (e.isTouch) {
            if (this._startTrackPoint !== null) {
              this._initCrossHairPosition = a.currentPoint();
              this._startTrackPoint = new At.Point(e.localX, e.localY);
            } else if (this._isSelectPointModeEnabled() && this._chart.trackingModePaneWidget() === null) {
              this.startTrackingMode(new At.Point(e.localX, e.localY), new At.Point(e.localX, e.localY), new Bo.EnvironmentState(e));
            }
          }
          if (e.isTouch) {
            this._preventSourceChange = t === null || !s.selection().isSelected(t.source);
          }
          if (!this._isSelectPointModeEnabled() && !this._isScrolling) {
            if (e.isTouch && !e.stylus && ((0, lt.toolIsMeasure)(lt.tool.value()) || a.measurePane().value() !== null)) {
              this._initToolCreationModeParams(e);
              return;
            }
            if (c !== null && ((0, wt.isLineToolName)(lt.tool.value()) || s.lineBeingCreated())) {
              if (!o.shift()) {
                s.selectionMacro(e => e.clearSelection());
              }
              this._mouseDownEventForLineTool(e, o, h, c);
              return;
            }
          }
          if ((0, lt.toolIsDemonstration)(lt.tool.value()) && o.altOnly()) {
            if (e.isTouch && !this.trackingModeEnabled()) {
              this.startTrackingMode(new At.Point(e.localX, e.localY), new At.Point(e.localX, e.localY), new Bo.EnvironmentState(e));
            }
            const t = this._chartModel().crosshairSource().crosshairDemonstration();
            t.createHighlighter();
            const i = this._localCoordinatesToLineDataSourcePoint(a.originX(), a.originY(), (0, n.ensureNotNull)(this.state().mainDataSource()));
            if (i) {
              t.addHighlighterPosition(i);
            }
          } else {
            if (t !== null) {
              const i = this._sourceWasSelected(t);
              t.hittest.tryCallMouseDownOrTouchStartHandler(e, {
                sourceWasSelected: i
              });
            }
            if (!this._chart.readOnly()) {
              const r = this._handleSelectionMouseDownAndGetJustDeselectedSource(e, t, o);
              if (t !== null && !this._preventSourceChange) {
                const i = t.hittest.data();
                if (t.isCustom) {
                  if (t.hittest.hasPressedMoveHandler(e)) {
                    s.model().setMovingCustomSource(t.source, i);
                    this._preventScrollUntilNextMouseDownOrTouchStart = true;
                    this._currentMovingHitTest = {
                      sourceAtPoint: t,
                      cancelledContainer: s.model().customSourceMovingHitTestData() ?? undefined
                    };
                    s.selectionMacro(e => {
                      e.clearSelection();
                      e.addSourceToSelection((0, n.ensureNotNull)(t.source), (0, n.ensureNotNull)(i));
                    });
                    return;
                  }
                } else if (i?.areaName === Vt.AreaName.SourceItemMove) {
                  const o = i?.activeItem;
                  if (o !== undefined) {
                    s.startCustomMoving(t.source, o, e);
                    this._currentMovingHitTest = {
                      sourceAtPoint: t
                    };
                    s.selectionMacro(e => {
                      e.clearSelection();
                      e.addSourceToSelection((0, n.ensureNotNull)(t.source), (0, n.ensureNotNull)(i));
                    });
                    return;
                  }
                }
              }
              if (t !== null && this._tryHandleEraserMouseDown(t, o)) {
                return;
              }
              const a = t !== null && (0, eo.isLineTool)(t.source) && t.source.isLocked && t.source.isLocked();
              if (!(0, lt.lockDrawings)().value() && !a && t !== null && !t.isCustom) {
                if (!t.source.userEditEnabled()) {
                  return;
                }
                const s = t.hittest.data()?.snappingPrice;
                const a = t.hittest.data()?.snappingIndex;
                let u = e.localY;
                let _ = e.localX;
                if (s !== undefined && l !== null) {
                  u = (0, n.ensure)(t.source?.priceScale()).priceToCoordinate(s, l);
                  c = s;
                }
                if (a !== undefined) {
                  _ = i.timeScale().indexToCoordinate(a);
                  h = a;
                }
                if (u !== e.localY || _ !== e.localX) {
                  e = {
                    ...e,
                    localY: u,
                    localX: _
                  };
                  this.setCursorPosition(e.localX, e.localY, o);
                }
                if (this._tryStartChangingLineTool(e, t, o, h)) {
                  this._currentChangingLineToolHitTest = t;
                  return;
                }
                this._currentChangingLineToolHitTest = null;
                if ((d = t.hittest.target()) === Vt.HitTarget.MovePoint || d === Vt.HitTarget.MovePointBackground && (0, vo.lastMouseOrTouchEventInfo)().isTouch) {
                  if (this._tryStartCloning(e, t, o, r)) {
                    return;
                  }
                  if (this._tryStartMovingLineTool(e, t, o, h)) {
                    this._currentMovingHitTest = {
                      sourceAtPoint: t
                    };
                    return;
                  }
                  this._currentMovingHitTest = null;
                }
              }
              if (t !== null && (0, Fn.isPriceDataSource)(t.source) && t.source.isDraggable() && this._state?.hasDataSource(t.source) && this._paneWidgetsSharedState.trySetDraggingSource(t.source, this)) {
                return;
              }
            }
            var d;
            if (t === null || t.hittest.target() !== Vt.HitTarget.Regular) {
              this._processing = true;
            }
          }
        }
      }
      _mouseUpOrTouchEndEvent(e) {
        if (!this.hasState()) {
          return;
        }
        this._pressedMoveStage = 0;
        const t = e.isTouch && this._startTrackPoint !== null;
        const i = e.isTouch && this._wasPinched;
        if (e.isTouch) {
          this._wasPinched = false;
          this._longTap = false;
        }
        this._startMoveSourceParams = null;
        this._startChangeLineToolParams = null;
        this._currentChangingLineToolHitTest = null;
        this._currentMovingHitTest = null;
        const s = this._chartUndoModel();
        const o = s.model().customSourceMovingHitTestData();
        if (o === null && !s.customMoveBeingProcessed()) {
          this._processMouseUpOrTouchEndHandler(e);
        }
        this._isSelecting = false;
        const r = s.model();
        const a = r.crosshairSource();
        const l = this._dataSourceAtPoint(e.localX, e.localY);
        if (a.selection() && this._firstZoomPoint === null) {
          const e = this.state().lineToolsForArea(a.selection(), (0, Wt.getBindingRenderingInfo)(this._canvasBinding));
          s.selectionMacro(t => {
            let i = null;
            e.forEach(e => {
              if (i === null) {
                i = lr(l, e);
              }
              t.addSourceToSelection(e, i);
            });
          });
          a.clearSelection();
          (0, ne.trackEvent)("GUI", "Multiselect", "Area Select");
        }
        (0, W.emit)("mouse_up", {
          clientX: e.clientX,
          clientY: e.clientY,
          pageX: e.pageX,
          pageY: e.pageY,
          screenX: e.screenX,
          screenY: e.screenY
        });
        const c = e.isTouch && this._touchMove;
        if (e.isTouch) {
          this._touchMove = false;
        }
        const h = new Bo.EnvironmentState(e);
        const d = lt.tool.value();
        if (e.isTouch && ((0, lt.toolIsMeasure)(d) || a.measurePane().value() !== null)) {
          if (!c && !e.stylus && a.measurePane().value() === null && a.pane !== this._state) {
            this.setCursorPosition(e.localX, e.localY);
            return;
          }
          if (!c && !e.stylus && this._tryStartMeasure(e, a, h, a.price, a.index)) {
            return;
          }
          if ((!c || e.stylus) && this._tryFinishMeasure(e, a)) {
            return;
          }
        }
        if (e.isTouch && !c && !(0, wt.isLineDrawnWithPressedButton)(d) && (0, wt.isLineToolName)(d) && !s.lineBeingCreated()) {
          if (this._chart.justActivated()) {
            return;
          }
          if (a.pane !== this._state) {
            this.setCursorPosition(e.localX, e.localY, h);
            return;
          }
          const t = a.currentPoint();
          const i = this.state().defaultPriceScale();
          const o = (0, n.ensure)(this.state().mainDataSource()?.firstValue());
          const r = {
            index: Math.round(s.timeScale().coordinateToIndex(t.x)),
            price: i.coordinateToPrice(t.y, o)
          };
          const c = (0, n.ensureNotNull)(s.createLineTool({
            pane: this.state(),
            point: r,
            linetool: d
          }));
          if (this._mouseTouchDownUpInfo) {
            this._mouseTouchDownUpInfo.toolCreation = true;
          }
          s.selectionMacro(e => {
            e.addSourceToSelection(c);
          });
          if (!s.lineBeingCreated()) {
            this._finishTool(c, l);
            e.preventDefault();
          }
          this._startTouchPoint = null;
          return;
        }
        const u = s.lineBeingCreated();
        if (u && !(0, wt.isLineDrawnWithPressedButton)(u.toolname) && e.isTouch && (this._startTouchPoint || e.stylus)) {
          this._startTouchPoint = null;
          if (!c || e.stylus) {
            const t = (0, n.ensureNotNull)(u.lastPoint());
            const i = s.continueCreatingLine({
              index: t.index,
              price: t.price
            }, new Bo.EnvironmentState(e));
            this._initCrossHairPosition = null;
            if (i) {
              this._finishTool(u, l);
              e.preventDefault();
            }
          }
          return;
        }
        if (this._firstZoomPoint !== null && this._firstZoomPoint.draggingMode) {
          this._finishZoom(e);
          return;
        }
        this._processing = false;
        if (s.customMoveBeingProcessed()) {
          s.endCustomMoving();
          return;
        }
        if (o !== null) {
          if (o.beingMoved && !o.cancelled) {
            const t = this._sourceWasSelected(l);
            (0, Vt.tryCallHandler)(e, {
              sourceWasSelected: t
            }, o.mouseUpHandler, o.touchEndHandler);
            this.setCursorForTool();
          }
          r.setMovingCustomSource(null, null);
          if (mr(e, o)) {
            return;
          }
        }
        if (r.lineBeingEdited()) {
          s.endChangingLinetool(false);
          if (this._preventCrossHairMove()) {
            this._clearCursorPosition();
          }
          return;
        }
        if ((0, wt.isLineDrawnWithPressedButton)(d) && !this._isSelectPointModeEnabled()) {
          const t = s.lineBeingCreated();
          if (t !== null) {
            Hn();
            t.finish();
            if (t.toolname === "LineToolBrush") {
              (0, W.emit)("drawing_event", t.id(), "create");
            }
          }
          const i = this.state().defaultPriceScale();
          if (i.isEmpty()) {
            return;
          }
          if (!t) {
            return;
          }
          const o = (0, n.ensure)(t.ownerSource()?.firstValue());
          const r = i.coordinateToPrice(e.localY, o);
          const a = {
            index: Math.round(s.timeScale().coordinateToIndex(e.localX)),
            price: r
          };
          s.continueCreatingLine(a);
          return;
        }
        const _ = r.crosshairSource().crosshairDemonstration();
        if (_.isThereUnfinishedHighlighter()) {
          _.finishHighlighter();
          return;
        }
        if (r.sourcesBeingMoved().length) {
          s.endMovingSource(false, false);
          r.sourcesBeingMoved().filter(eo.isLineTool).forEach(e => {
            this.setCursorForTool(e);
          });
          r.invalidate(yo.InvalidationMask.cursor());
          return;
        }
        if (!this._chart.readOnly()) {
          const t = e.localX >= 0 && e.localX < this._size.width;
          if ((!l || l.source !== a) && t) {
            const t = this._chartModel().mainSeries().syncModel();
            if (t) {
              const i = this._chartModel().timeScale().points().roughTime(s.timeScale().coordinateToIndex(e.localX), (e, i) => t.projectTime(e, i));
              if (i !== null) {
                this._chart.chartWidgetCollection().syncScroll(i * 1000, this._chartModel());
              }
            }
          }
        }
        const p = this._isScrolling;
        const m = this._endScroll(e);
        const g = this._paneWidgetsSharedState.draggingSource();
        if (g !== null) {
          const t = e.target;
          const i = this._chart.paneByCanvas(t);
          if (i && i !== this && i.state().mode() === Bi.PaneMode.Regular) {
            if (m) {
              s.undoHistory().undo();
            }
            s.mergeToPane(g, i.state());
          }
          if (this._chart.timeAxisByCanvas(t)) {
            if (r.isUnmergeAvailableForSource(g)) {
              if (m) {
                s.undoHistory().undo();
              }
              s.unmergeToNewBottomPane(g);
            } else {
              const e = r.panes();
              const t = (0, n.ensureNotNull)(r.paneForSource(g));
              const i = e.indexOf(t);
              if (i !== e.length - 1) {
                if (m) {
                  s.undoHistory().undo();
                }
                if (t.maximized().value()) {
                  s.toggleMaximizedPane(t);
                }
                s.movePane(i, e.length - 1);
              }
            }
          }
          this._paneWidgetsSharedState.clearDraggingSource();
          const o = this._chart.getTimeScale();
          if (o) {
            o.restoreDefaultCursor();
          }
          const a = this._chart.paneWidgets();
          for (let e = 0; e < a.length; e++) {
            const t = a[e];
            if (t === this && l && !l.isCustom) {
              t.setCursorForTool(l.source || undefined);
            } else {
              t.setCursorForTool();
            }
            t.leftPriceAxisesContainer().restoreDefaultCursor();
            t.rightPriceAxisesContainer().restoreDefaultCursor();
          }
        }
        if (!this._chart.readOnly() && !t && !h.mod() && !p && !i && this._lastFinishedToolId === null) {
          if (l !== null && (l.hittest.target() > Vt.HitTarget.MovePointBackground || (0, vo.lastMouseOrTouchEventInfo)().isTouch)) {
            s.selectionMacro(e => {
              e.clearSelection();
              const t = (0, n.ensureNotNull)(l.source);
              e.addSourceToSelection(t, lr(l, t));
            });
          }
        }
        if (e.isTouch) {
          this._touchMove = false;
        }
      }
      _mouseOrTouchMoveEvent(e) {
        if (!this.hasState()) {
          return;
        }
        if (this._mouseTouchDownUpInfo) {
          this._mouseTouchDownUpInfo.mouseMove = true;
        }
        this._resetMeasureIfRequired();
        const t = this._dataSourceAtPoint(e.localX, e.localY);
        this._processMouseEnterLeaveMoveHandlers(t, e);
        const i = this._chartUndoModel();
        if (!i) {
          return;
        }
        const s = e.localX;
        const o = e.localY;
        this._prevMoveEventPosition = new At.Point(s, o);
        const n = new Bo.EnvironmentState(e);
        if (this._firstZoomPoint === null) {
          this._updateHoveredSource(t, n, e);
          if (!e.isTouch && i.lineBeingCreated()) {
            const e = i.lineBeingCreated();
            const t = e === null ? null : i.model().paneForSource(e);
            if (t !== null && t !== this._state) {
              this._setCursorPositionOnExternalPane(t, s, o, n);
              return;
            }
          }
          if (!e.isTouch) {
            this.setCursorPosition(s, o, n);
          }
        } else {
          this._processMouseMoveWhileZoom(e, n);
        }
      }
      _pressedMouseOrTouchMoveEvent(e) {
        if (!this.hasState() || this._pinching || e.isTouch && this._contextMenuOpenedOnLastTap) {
          return;
        }
        this._pressedMoveStage = 2;
        if (this._mouseTouchDownUpInfo) {
          this._mouseTouchDownUpInfo.mouseMove = true;
        }
        this._resetMeasureIfRequired();
        this._startChangeOrMoveLineToolIfNeeded();
        if (e.isTouch) {
          this._touchMove = true;
          this._preventSourceChange = false;
        }
        const t = new Bo.EnvironmentState(e);
        const i = this._chartUndoModel();
        const s = i.crosshairSource();
        const o = e.localX;
        const r = e.localY;
        this._prevMoveEventPosition = new At.Point(o, r);
        if (this._firstZoomPoint !== null) {
          this._processMouseMoveWhileZoom(e);
          this._firstZoomPoint.draggingMode = true;
          return;
        }
        const a = lt.tool.value();
        if (e.isTouch && this._startTouchPoint && (0, wt.isLineToolName)(a) && !(0, wt.isLineDrawnWithPressedButton)(a) && !i.lineBeingCreated() && !this._isSelectPointModeEnabled()) {
          this._updateCrosshairPositionInToolCreationMode(e, this.state());
          return;
        }
        const l = s.measurePane().value();
        if (e.isTouch && (this._startTouchPoint || e.stylus) && ((0, lt.toolIsMeasure)(a) || l !== null)) {
          if (e.stylus) {
            this.setCursorPosition(e.localX, e.localY, new Bo.EnvironmentState(e));
          } else {
            this._updateCrosshairPositionInToolCreationMode(e, l || this.state());
          }
          return;
        }
        const c = i.lineBeingCreated();
        if (e.isTouch && !e.stylus && c && !(0, wt.isLineDrawnWithPressedButton)(c.toolname)) {
          if (this._startTouchPoint) {
            const t = (0, n.ensureNotNull)(i.lineBeingCreated());
            const s = (0, n.ensureNotNull)(i.model().paneForSource(t));
            this._updateCrosshairPositionInToolCreationMode(e, s);
          }
          return;
        }
        if (e.isTouch && this._startTrackPoint !== null) {
          this._exitTrackingModeOnNextTry = false;
          const e = (0, n.ensureNotNull)(this._initCrossHairPosition);
          const i = new At.Point(o, r).subtract(this._startTrackPoint);
          const s = e.add(i);
          this.setCursorPosition(s.x, s.y, t);
        } else if (!e.isTouch || !this._preventCrossHairMove()) {
          this.setCursorPosition(o, r, t);
        }
        const h = this._isSelectPointModeEnabled();
        if ((0, wt.isLineToolName)(a) && !(0, wt.isLineDrawnWithPressedButton)(a) && !h && !t.mod()) {
          return;
        }
        if ((0, wt.isLineDrawnWithPressedButton)(a) && !h) {
          const t = i.lineBeingCreated();
          if (!t) {
            return;
          }
          const s = this._localCoordinatesToLineDataSourcePoint(e.localX, e.localY, (0, n.ensureNotNull)(t.ownerSource()));
          if (s) {
            i.continueCreatingLine(s);
          }
          return;
        }
        const d = i.crosshairSource().crosshairDemonstration();
        if (d.isThereUnfinishedHighlighter()) {
          const e = this._localCoordinatesToLineDataSourcePoint(s.originX(), s.originY(), (0, n.ensureNotNull)(this.state().mainDataSource()));
          if (e) {
            d.addHighlighterPosition(e);
          }
          return;
        }
        if (this._paneWidgetsSharedState.draggingSource() !== null) {
          const t = e.target;
          const i = this._chart.paneByCanvas(t);
          if (i) {
            if (i !== this) {
              i.setDragToAnotherPaneCursor();
            } else {
              i.setCursorForTool();
            }
          }
          const s = this._chart.timeAxisByCanvas(t);
          if (s) {
            s.setCursor("grabbing");
          }
        }
        if (i.timeScale().isEmpty()) {
          return;
        }
        const u = this._options.handleScroll;
        if ((!u.pressedMouseMove || e.isTouch) && (!u.horzTouchDrag && !u.vertTouchDrag || !e.isTouch)) {
          return;
        }
        if (this._chartModel().dragExportEnabled().value()) {
          return;
        }
        if (i.customMoveBeingProcessed()) {
          i.processCustomMove(e);
          return;
        }
        const _ = i.model().customSourceMovingHitTestData();
        if (_ !== null && (this._updateCommonTooltip(null, true), _.cancelled || (i.model().processingCustomSourceMove(), (0, Vt.tryCallHandler)(e, {
          sourceWasSelected: this._selectionBeforeMouseDown.has(i.model().customSourceBeingMoved())
        }, _.pressedMouseMoveHandler, _.touchMoveHandler)), mr(e, _))) {
          return;
        }
        if (i.model().lineBeingEdited()) {
          this.setCursorPosition(o, r, t);
          return;
        }
        if (i.model().sourcesBeingMoved().length) {
          this._alignSourcesThatBeingMoved(i.model().sourcesBeingMoved(), e.localX, e.localY, t, i.model().lastHittestData()?.possibleMovingDirections);
          return;
        }
        const p = this._dataSourceAtPoint(e.localX, e.localY);
        if (this._tryFinishClonning(e, new Bo.EnvironmentState(e), p)) {
          return;
        }
        const m = (0, lt.toolIsMeasure)(a) || s.startMeasurePoint() && s.endMeasurePoint();
        if (this._chart.readOnly() || !t.mod() || (0, wt.isLineToolName)(a) || m || h) {
          this._processScroll(e);
          if (this._preventScroll() && !this._preventCrossHairMove() && this._startTrackPoint === null) {
            this.setCursorPosition(e.localX, e.localY, new Bo.EnvironmentState(e));
          }
        } else if (!this._isSelecting) {
          s.startSelection(this.state());
          this._isSelecting = true;
        }
      }
      _mouseOrTouchLeaveEvent(e) {
        if (!this.hasState()) {
          return;
        }
        const t = this._chartUndoModel();
        if (!t) {
          return;
        }
        const i = t.crosshairSource();
        if (!e.isTouch && (i.measurePane().value() === null || i.endMeasurePoint() !== null)) {
          this._clearCursorPosition();
        }
        this._chartModel().setHoveredSource(null, null);
        if (this._prevHoveredHittest !== null) {
          const t = this._sourceWasSelected(this._prevHoveredHittest);
          (0, Vt.tryCallHandler)(e, {
            sourceWasSelected: t
          }, this._prevHoveredHittest.hittest.data()?.mouseLeaveHandler);
          this._prevHoveredHittest = null;
        }
        this._updateCommonTooltip(null);
        this._chart.unsetActivePaneWidget();
      }
      _mouseDoubleClickOrDoubleTapEvent(e) {
        if (!this.hasState()) {
          return;
        }
        const t = !this._chart.readOnly() && !(0, wt.isLineToolName)(lt.tool.value()) && this._dataSourceAtPoint(e.localX, e.localY) || null;
        const i = this._sourceWasSelected(t);
        if (t !== null && t.isCustom) {
          t.hittest.tryCallDblClickOrDblTapHandler(e, {
            sourceWasSelected: i
          });
        } else if (t !== null && (e.isTouch || t.hittest.target() > Vt.HitTarget.MovePointBackground)) {
          if (!t.hittest.tryCallDblClickOrDblTapHandler(e, {
            sourceWasSelected: i
          }) || !!(0, Vt.shouldDefaultActionBeExecuted)(e, (0, n.ensureNotNull)(t.hittest.data()), "doubleClickHandler", "doubleTapHandler")) {
            this.processDoubleClickOnSource(t.source, t.hittest ? t.hittest : undefined);
          }
        } else if (!this._chart.readOnly() && !(0, wt.isLineToolName)(lt.tool.value()) && !this._chartUndoModel().lineBeingCreated() && this._chartUndoModel().selection().isEmpty()) {
          const t = this.state();
          if (new Bo.EnvironmentState(e).mod() && !t.maximized().value()) {
            if (t.collapsed().value() || t.collapsingAvailable().value()) {
              this._chartUndoModel().toggleCollapsedPane(this.state());
            }
          } else {
            this._chartUndoModel().toggleMaximizedPane(this.state());
          }
        }
      }
      _contextMenuEvent(e) {
        const t = this._chartUndoModel();
        if (t.crosshairSource().startMeasurePoint() && !this._trackCrosshairOnlyAfterLongTap) {
          t.crosshairSource().clearMeasure();
          (0, lt.resetToCursor)(true);
          return;
        }
        if (this._pinching) {
          return;
        }
        if (this._firstZoomPoint !== null && !this._trackCrosshairOnlyAfterLongTap) {
          this.cancelZoom();
        }
        if (!(0, lt.toolIsCursor)(lt.tool.value()) || this._isSelectPointModeEnabled()) {
          if (e.isTouch) {
            return;
          }
          (0, lt.resetToCursor)(true);
          this.setCursorForTool();
          if (t.lineBeingCreated()) {
            t.cancelCreatingLine();
          }
          return;
        }
        if (!this._options.contextMenuEnabled) {
          return;
        }
        const i = this._dataSourceAtPoint(e.localX, e.localY);
        const s = i ? i.source : null;
        if (e.isTouch && this._startTrackPoint !== null) {
          if (this._preventSourceChange) {
            return;
          }
          this._clearCursorPosition();
        }
        if (e.isTouch) {
          this._contextMenuOpenedOnLastTap = true;
          this._startTrackPoint = null;
        }
        this._contextMenuX = e.localX;
        this._contextMenuY = e.localY;
        const o = i && i.hittest ? i.hittest.target() : 0;
        const n = o >= Vt.HitTarget.Regular || o >= Vt.HitTarget.MovePointBackground && e.isTouch;
        t.selectionMacro(t => {
          if (s !== null && n) {
            if (!t.selection().isSelected(s)) {
              t.clearSelection();
              t.addSourceToSelection(s, lr(i, s));
            }
          } else {
            if (this._options.contextMenu.general) {
              this._showContextMenu(e);
            }
            t.clearSelection();
          }
        });
        if (i !== null && n && s !== null) {
          if ((0, Vo.isDataSource)(s) && s.hasContextMenu()) {
            if (s.isSelectionEnabled()) {
              this.showContextMenuForSelection(e, undefined, i.hittest);
            } else {
              this.showContextMenuForSources([s], e, undefined, undefined, i.hittest);
            }
          } else {
            const t = this._sourceWasSelected(i);
            i.hittest.tryCallContextMenuHandler(e, {
              sourceWasSelected: t
            });
          }
        }
      }
      _onMouseEvent() {
        this._preventSourceChange = false;
        this._startTrackPoint = null;
        this._trackCrosshairOnlyAfterLongTap = false;
      }
      _onTouchEvent() {
        this._trackCrosshairOnlyAfterLongTap = true;
      }
      _localCoordinatesToLineDataSourcePoint(e, t, i) {
        const s = this.state().defaultPriceScale();
        if (s.isEmpty()) {
          return null;
        }
        const o = new At.Point(e, t);
        const r = (0, n.ensure)(i.firstValue());
        o.price = s.coordinateToPrice(t, r);
        o.index = Math.round(this._chartUndoModel().timeScale().coordinateToIndex(e));
        return o;
      }
      _switchTrackingModeFromAnotherPaneIfNeeded(e) {
        const t = this._chart.trackingModePaneWidget();
        if (t !== null && t !== this) {
          const i = this._chartModel().crosshairSource().currentPoint();
          t._exitTrackingModeOnNextTry = true;
          t._tryExitTrackingMode(true);
          this.startTrackingMode(new At.Point(e.localX, e.localY), new At.Point(i.x, e.localY), new Bo.EnvironmentState(e));
        }
      }
      async _showContextMenu(e) {
        const t = e => e instanceof Jo.Separator;
        const i = this._customActions();
        const s = (await this._initActions(e)).filter(e => e !== null);
        i.remove.forEach(e => {
          for (let t = 0; t < s.length; t++) {
            const i = s[t];
            if (i instanceof Jo.Action && i.getLabel() === e) {
              s.splice(t, 1);
              break;
            }
          }
        });
        const o = i.top.concat(s).concat(i.bottom);
        for (let e = o.length - 1; e > 0; e--) {
          if (t(o[e]) && t(o[e - 1])) {
            o.splice(e, 1);
          }
        }
        if (o.length && t(o[0])) {
          o.splice(0, 1);
        }
        if (o.length && t(o[o.length - 1])) {
          o.splice(o.length - 1, 1);
        }
        Oo.ContextMenuManager.showMenu(o, e, {
          statName: "ChartContextMenu"
        }, {
          menuName: "ChartContextMenu"
        });
      }
      async _initActions(e) {
        const t = this._chart.actions();
        const i = [];
        if (this._chart.model().model().resetScalesAvailable().value()) {
          i.push(t.chartReset);
          i.push(new Jo.Separator());
        }
        if (!this.state().isEmpty() && l.enabled("datasource_copypaste") && this.state().mode() === Bi.PaneMode.Regular) {
          const t = (0, sn.createActionCopyPrice)(this.state(), e.localY);
          const s = (0, sn.createPasteAction)(this._chart, this.state());
          if (t || s) {
            if (t) {
              i.push(t);
            }
            if (s) {
              i.push(s);
            }
            i.push(new Jo.Separator());
          }
        }
        if (!(i[i.length - 1] instanceof Jo.Separator)) {
          i.push(new Jo.Separator());
        }
        if (l.enabled("text_notes")) {
          i.push(t.addToTextNotes);
        }
        if (!(i[i.length - 1] instanceof Jo.Separator)) {
          i.push(new Jo.Separator());
        }
        i.push(this._createLockTimeAxisAction(e));
        i.push(new Jo.Separator());
        if (!(i[i.length - 1] instanceof Jo.Separator)) {
          i.push(new Jo.Separator());
        }
        if (this._chart.applyIndicatorsToAllChartsAvailable()) {
          i.push(t.applyStudiesToAllCharts);
          i.push(new Jo.Separator());
        }
        const s = t.paneRemoveAllDrawingTools.getState().disabled;
        if (!s) {
          i.push(t.paneRemoveAllDrawingTools);
        }
        const o = t.paneRemoveAllStudies.getState().disabled;
        if (!o) {
          i.push(t.paneRemoveAllStudies);
        }
        if (!s || !o) {
          i.push(new Jo.Separator());
        }
        i.push(t.hideAllMarks);
        i.push(new Jo.Separator());
        if (l.enabled("show_chart_property_page")) {
          i.push(t.chartProperties);
        }
        if (i[i.length - 1] instanceof Jo.Separator) {
          i.pop();
        }
        return i;
      }
      _loadAndCreateLegendWidget() {
        Promise.all([i.e(2199), i.e(4178), i.e(8985), i.e(6489), i.e(9753), i.e(4170), i.e(2227), i.e(7973), i.e(5093)]).then(i.bind(i, 60786)).then(e => {
          if (this._isDestroyed || !this._options.legendWidgetEnabled || this._legendWidget) {
            return;
          }
          const t = e.LegendWidget;
          const i = (0, ge.deepExtend)({}, this._options.legendWidget);
          i.canShowSourceCode = !this._chart.onWidget() && !ze.CheckMobile.any();
          i.readOnlyMode = i.readOnlyMode || this._chart.readOnly();
          i.statusesWidgets = {
            sourceStatusesEnabled: this._options.sourceStatusesWidgetEnabled,
            sourceStatuses: this._options.sourceStatusesWidget || {},
            marketStatusEnabled: this._options.marketStatusWidgetEnabled,
            dataUpdateModeEnabled: this._options.chartWarningWidgetEnabled,
            dataUpdateMode: this._options.chartWarningWidget || {},
            dataProblemEnabled: this._options.dataProblemWidgetEnabled,
            pineSourceStatusEnabled: this._options.pineSourceStatusEnabled
          };
          const s = (0, Ji.combine)((e, t) => ur && this._chart !== e && !t, this._chart.chartWidgetCollection().activeChartWidget.weakReference(), this._chart.chartWidgetCollection().lock.crosshair.weakReference());
          const o = (0, Ji.combine)((e, t) => e !== null ? e === this._state : (0, lt.toolIsMeasure)(t), this._chartModel().crosshairSource().measurePane().weakReference(), lt.tool.weakReference());
          this._legendWidget = new t(this._chartUndoModel(), this, this._chart.backgroundTopTheme().spawnOwnership(), s.ownership(), this._visuallyCollapsed.spawnOwnership(), o.ownership(), i, {
            showContextMenuForSelection: this.showContextMenuForSelection.bind(this),
            showContextMenuForSources: this.showContextMenuForSources.bind(this),
            showChartPropertiesForSource: this._chart.showChartPropertiesForSource.bind(this._chart),
            showGeneralChartProperties: this._chart.showGeneralChartProperties.bind(this._chart),
            showObjectsTreeDialog: this._chart.showObjectsTreeDialog.bind(this._chart),
            onLegendRowFocused: () => {
              this._chart.chartWidgetCollection().activeChartWidget.setValue(this._chart);
            }
          });
          this._div.prepend(this._legendWidget.getElement());
          this._legendWidget.updateLayout();
          this._legendWidget.updateWidgetModeBySize(this._size);
          this._legendWidget.updateThemedColors(this._themedTopColor);
          for (const e of Array.from(this._customLegendWidgetsFactoryMap.keys())) {
            this._legendWidget.addCustomWidgetToLegend(e, (0, n.ensureDefined)(this._customLegendWidgetsFactoryMap.get(e)));
          }
        });
      }
      _loadAndCreatePaneControlsWidget(e) {
        Promise.all([i.e(2199), i.e(4178), i.e(8985), i.e(6489), i.e(9753), i.e(4170), i.e(2227), i.e(7973), i.e(5093)]).then(i.bind(i, 61560)).then(t => {
          if (this._isDestroyed || this._state !== e) {
            return;
          }
          const i = t.PaneControlsWidget;
          this._paneControls = new i(this._chartUndoModel(), e, {
            backgroundThemeName: this._chart.backgroundTopTheme(),
            anySeparatorSelected: this._anySeparatorSelected.weakReference()
          }, this._div);
          this._paneControls.updateWidgetModeByWidth(this._size.width);
          this._paneControls.updateThemedColors(this._themedTopColor);
          this._paneControlsResizeObserver = new ResizeObserver(this._handleRestrictLegendWidth.bind(this));
          this._paneControlsResizeObserver.observe(this._paneControls.getElement());
          if (this._state?.collapsed().value()) {
            this._chartModel().fullUpdate();
          }
        });
      }
      _handleRestrictLegendWidth(e) {
        if (this._legendWidget === null || this._paneControls === null) {
          return;
        }
        const t = e[e.length - 1].contentRect.width;
        const i = t === 0 ? 0 : t + Zn + Xn;
        this._legendWidget.addMargin(i);
      }
      _onMagnetStateChanged() {
        if (this._chart.isActive().value() && (this._isSelectPointModeEnabled() || this._isToolActionActiveOnPane(true)) && this._chartModel().crosshairSource().visible) {
          this._updateLineToolUsingMagnetOrShift();
        }
      }
      _onShiftKeyStateChanged() {
        if (this._chart.isActive().value() && this._isToolActionActiveOnPane(false) && this._chartModel().crosshairSource().visible) {
          this._updateLineToolUsingMagnetOrShift(Bo.EnvironmentState.create((0, Gs.shiftPressed)().value()));
        }
      }
      _isToolActionActiveOnPane(e) {
        const t = this._chartModel();
        const i = t.lineBeingCreated() || t.lineBeingEdited() || t.sourcesBeingMoved().length > 0 && t.sourcesBeingMoved()[0];
        if (i) {
          return t.paneForSource(i) === this._state;
        } else {
          return e && (0, wt.isLineToolName)(lt.tool.value()) && t.crosshairSource().pane === this._state;
        }
      }
      _updateLineToolUsingMagnetOrShift(e) {
        if (this._prevMoveEventPosition === null) {
          return;
        }
        const {
          x: t,
          y: i
        } = this._prevMoveEventPosition;
        const s = this._chartModel().sourcesBeingMoved();
        if (s.length > 0) {
          if (lt.isStudyEditingNow.value()) {
            this.setCursorPosition(t, i, e);
          }
          this._alignSourcesThatBeingMoved(s, t, i, e);
        } else {
          this.setCursorPosition(t, i, e);
        }
      }
      _showEditDialogForSource(e, t) {
        if (this._options.propertyPagesEnabled && e.userEditEnabled()) {
          if (e === this._chartUndoModel().mainSeries()) {
            this._chart.showGeneralChartProperties(Zs.TabNames.symbol);
          } else if ((0, eo.isLineTool)(e) || (0, Js.isStudy)(e)) {
            let i;
            const s = t?.data();
            if (s != null) {
              const e = s.areaName;
              if (e !== undefined) {
                i = dr.get(e);
              }
            }
            this._chart.showChartPropertiesForSource(e, i).then(e => {
              this._editDialog = e;
            });
          }
        }
      }
      _initToolCreationModeParams(e) {
        this._startTouchPoint = new At.Point(e.pageX, e.pageY);
        this._initCrossHairPosition = this._chartModel().crosshairSource().currentPoint();
      }
      _updateCrosshairPositionInToolCreationMode(e, t) {
        if (t !== this._state) {
          const i = this._chart.paneByState(t);
          i._startTouchPoint = this._startTouchPoint;
          i._initCrossHairPosition = this._initCrossHairPosition;
          i._updateCrosshairPositionInToolCreationMode(e, t);
          return;
        }
        const i = this._chartModel().crosshairSource();
        if (this._chart.justActivated()) {
          this._initCrossHairPosition = i.currentPoint();
        }
        const s = e.pageX;
        const o = e.pageY;
        const r = (0, n.ensureNotNull)(this._initCrossHairPosition);
        const a = new At.Point(s, o).subtract((0, n.ensureNotNull)(this._startTouchPoint));
        const l = r.add(a);
        this.setCursorPosition(l.x, l.y, new Bo.EnvironmentState(e));
      }
      _priceAxisesContainer(e) {
        if (e === "left") {
          return this._lhsPriceAxisesContainer;
        } else {
          return this._rhsPriceAxisesContainer;
        }
      }
      _recalculatePriceScales(e) {
        const t = this.state();
        for (const i of t.leftPriceScales()) {
          t.recalculatePriceScale(i, e);
        }
        for (const i of t.rightPriceScales()) {
          t.recalculatePriceScale(i, e);
        }
        for (const i of t.sourcesByGroup().overlayPriceScaleSources()) {
          if (!(0, eo.isLineTool)(i)) {
            t.recalculatePriceScale(i.priceScale(), e);
          }
        }
      }
      _createLockTimeAxisAction(e) {
        const t = lt.crosshairLock.value()?.type === 0;
        return new Jo.Action({
          actionId: "Chart.Crosshair.LockVerticalCursor",
          options: {
            label: tr,
            statName: "LockCursorInTime",
            checkable: true,
            checked: t,
            onExecute: () => this._toggleLockTimeAxis(e.localX, !t)
          }
        });
      }
      _toggleLockTimeAxis(e, t) {
        if (t) {
          const t = this._chartUndoModel().timeScale();
          const i = t.coordinateToIndex(e);
          const s = t.points().roughTime(i);
          if (s !== null) {
            lt.crosshairLock.setValue({
              type: 0,
              time: s
            });
            return;
          }
        }
        lt.crosshairLock.setValue(null);
      }
      _preventTouchEventsExceptPinch() {
        return this._paneWidgetsSharedState.hasTouchesOnOtherPanes(this) || this._paneWidgetsSharedState.pinchingPane() !== null;
      }
      _updateHoveredSource(e, t, i) {
        const s = this._chartUndoModel();
        const o = s.model();
        let n = false;
        const r = e && e.source;
        const a = this._chart.readOnly();
        if (o.crosshairSource().isReplaySelection()) {
          this._setCursorClassName("none");
        } else if (!!a && (!e || !(0, eo.isLineTool)(e.source)) || this._editDialog && this._editDialog.visible().value()) {
          if (a) {
            o.setHoveredSource(null, null);
            this.setCursorForTool();
          }
        } else {
          const l = lt.tool.value();
          let c = null;
          if (!this._processing && ((0, lt.toolIsCursor)(l) || l === "eraser" && !a || t.mod() || !s.lineBeingCreated())) {
            const t = e?.hittest;
            n = Boolean(t?.data()?.hideCrosshairLinesOnHover);
            if (t && t.target() > Vt.HitTarget.MovePointBackground) {
              c = r;
              if (!r?.isHoveredEnabled() || l === "eraser" && r === s.mainSeries()) {
                o.setHoveredSource(null, null);
              } else {
                o.setHoveredSource(r, t.data(), 0);
              }
            } else {
              o.setHoveredSource(null, null);
            }
          }
          if (a) {
            this.setCursorForTool(c, t, qt.PaneCursorType.Default);
          } else if (this._options.sourceSelectionEnabled) {
            if (this._isSelectPointModeEnabled()) {
              this._setCursorClassName("pointer");
            } else {
              this.setCursorForTool(c, t, e?.hittest.data()?.cursorType);
            }
          }
          const h = o.customSourceBeingMoved();
          const d = h !== null ? [h] : o.sourcesBeingMoved();
          if (!d.length || e !== null && d.indexOf(e.source) === -1) {
            this._updateCommonTooltip(e);
          }
          if (!a && e !== null && i && e.hittest.hasPressedMoveHandler(i)) {
            switch ((e.hittest.data() || {}).cursorType) {
              case qt.PaneCursorType.VerticalResize:
                this._setCursorClassName("ns-resize");
                break;
              case qt.PaneCursorType.HorizontalResize:
                this._setCursorClassName("we-resize");
                break;
              case qt.PaneCursorType.DiagonalNeSwResize:
                this._setCursorClassName("nesw-resize");
                break;
              case qt.PaneCursorType.DiagonalNwSeResize:
                this._setCursorClassName("nwse-resize");
            }
          }
        }
        if (this._preventCrossHairMove()) {
          this._clearCursorPosition();
        }
        if (this._pressedMoveStage !== 1) {
          o.crosshairSource().setLinesShouldBeHidden(n);
        }
      }
      async _createErrorBlock() {
        const e = new (await no())();
        this._div.insertBefore(e.container, this._topCanvasBinding.canvasElement.nextSibling);
        return e;
      }
      _customActions() {
        const e = {
          top: [],
          bottom: [],
          remove: []
        };
        const t = this._chartUndoModel().timeScale();
        const i = this._state && this._state.defaultPriceScale();
        if (!l.enabled("custom_items_in_context_menu")) {
          return e;
        }
        const s = t.isEmpty() ? undefined : t.indexToUserTime(t.coordinateToIndex(this._contextMenuX));
        let o;
        if (i && !i.isEmpty()) {
          const e = (0, n.ensureNotNull)(this.state().mainDataSource()).firstValue();
          o = i.coordinateToPrice(this._contextMenuY, (0, n.ensureNotNull)(e));
        }
        (0, W.emit)("onContextMenu", {
          unixtime: s != null ? s.getTime() / 1000 : undefined,
          price: o,
          callback: t => {
            [...t].forEach(t => {
              if (t.text) {
                if (t.text.length > 1 && t.text[0] === "-") {
                  e.remove.push(t.text.slice(1));
                } else {
                  let i;
                  i = t.text === "-" ? new Jo.Separator() : new Jo.Action({
                    actionId: "Chart.ExternalActionId",
                    options: {
                      label: t.text,
                      onExecute: t.click
                    }
                  });
                  if (t.position && t.position === "top") {
                    e.top.push(i);
                  } else {
                    e.bottom.push(i);
                  }
                }
              }
            });
          }
        });
        return e;
      }
      _highlightPriceAxisByLabel(e) {
        if (this._state?.mode() === Bi.PaneMode.Regular) {
          this._lhsPriceAxisesContainer.highlightPriceAxisByLabel(e);
          this._rhsPriceAxisesContainer.highlightPriceAxisByLabel(e);
        }
      }
      _subscribeToState() {
        const e = this.state();
        e.onDestroyed().subscribe(this, this._onStateDestroyed, true);
        e.dataSourcesCollectionChanged().subscribe(this, this._onDataSourcesCollectionChanged);
        e.maximized().subscribe(this._updateVisuallyCollapsed, {
          callWithLast: true
        });
        e.collapsed().subscribe(this._updateVisuallyCollapsed, {
          callWithLast: true
        });
        e.maximized().subscribe(this._updateMaximized, {
          callWithLast: true
        });
      }
      _unsubscribeFromState() {
        const e = this.state();
        e.onDestroyed().unsubscribeAll(this);
        e.dataSourcesCollectionChanged().unsubscribeAll(this);
        e.maximized().unsubscribe(this._updateVisuallyCollapsed);
        e.collapsed().unsubscribe(this._updateVisuallyCollapsed);
        e.maximized().unsubscribe(this._updateMaximized);
        this._maximized.setValue(false);
      }
      _updateAccesibilityAttr() {
        if (this.hasState() && this.state().isMainPane().value()) {
          const e = this._chartModel().mainSeries();
          const t = e.symbol();
          const s = (0, es.getTranslatedResolutionModel)(e.interval()).hint;
          const o = a.t(null, {
            replace: {
              symbol: t,
              interval: s
            }
          }, i(1136));
          this._topCanvasBinding.canvasElement.setAttribute("aria-label", o);
        } else {
          this._topCanvasBinding.canvasElement.setAttribute("aria-hidden", "true");
        }
      }
      async _updateEndOfSeriesBanner() {
        0;
      }
      _paneDblClickOrTapEvent(e) {
        if (this._chart.readOnly()) {
          return;
        }
        const t = this._dataSourceAtPoint(e.localX, e.localY);
        if (t !== null && (0, eo.isEditableTextLineTool)(t.source)) {
          const e = t.source.textEditingActivationTime();
          if (e !== null && performance.now() - e < 500) {
            this.processDoubleClickOnSource(t.source, t.hittest);
          }
        }
      }
    }
    class yr {
      constructor() {
        this._draggingSource = null;
        this._activeTouchPanes = new Set();
        this._scrollingPane = null;
        this._pinchingPane = null;
      }
      onPaneDestroyed(e) {
        this._activeTouchPanes.delete(e);
        if (this._scrollingPane === e) {
          this._scrollingPane = null;
        }
        if (this._pinchingPane === e) {
          this._pinchingPane = null;
        }
      }
      startTouch(e) {
        this._activeTouchPanes.add(e);
      }
      endTouch(e) {
        this._activeTouchPanes.delete(e);
      }
      hasTouchesOnOtherPanes(e) {
        return this._activeTouchPanes.size > 1 || this._activeTouchPanes.size === 1 && !this._activeTouchPanes.has(e);
      }
      trySetDraggingSource(e, t) {
        return !this.hasTouchesOnOtherPanes(t) && ((0, n.assert)(this._draggingSource === null || this._draggingSource === e), this._draggingSource = e, true);
      }
      clearDraggingSource() {
        if (this._draggingSource !== null) {
          this._draggingSource = null;
        }
      }
      draggingSource() {
        return this._draggingSource;
      }
      setScrollingPane(e) {
        (0, n.assert)(e === null || this._scrollingPane === null || this._scrollingPane === e);
        this._scrollingPane = e;
      }
      scrollingPane() {
        return this._scrollingPane;
      }
      setPinchingPane(e) {
        (0, n.assert)(e === null || this._pinchingPane === null || this._pinchingPane === e);
        this._pinchingPane = e;
      }
      pinchingPane() {
        return this._pinchingPane;
      }
    }
    var vr;
    var Sr = i(55158);
    var br = i(95700);
    i(60070);
    (function (e) {
      e[e.BorderSize = 1] = "BorderSize";
      e[e.OffsetSize = 5] = "OffsetSize";
    })(vr ||= {});
    const wr = {
      contextMenuEnabled: true,
      timezoneMenuEnabled: true,
      pressedMouseMoveScale: true
    };
    const Cr = new Di.TranslatedString("change session", a.t(null, undefined, i(87041)));
    const Pr = a.t(null, undefined, i(94031));
    class Tr {
      constructor(e, t, i, s, o) {
        this._rendererOptions = null;
        this._onLabelHovered = new re.Delegate();
        this._mousedown = false;
        this._currentCursorClassName = "invalid";
        this._options = (0, dt.merge)((0, dt.clone)(wr), t || {});
        this.chart = e;
        this._properties = e.properties().childs().scalesProperties;
        this._element = document.createElement("div");
        this._element.style.display = "flex";
        this._backgroundBasedTheme = o;
        const n = e.model().model().rendererOptionsProvider();
        const r = () => this.backgroundColor();
        const a = () => {
          throw new Error("Time axis does not support real price scales");
        };
        const l = {
          titlesProvider: i,
          stubContextMenuProvider: (e, t) => {
            const i = s(e, t);
            const o = this.getContextMenuActions(true);
            if (o.length === 0) {
              return i;
            } else {
              return i.concat(new Jo.Separator(), o);
            }
          },
          backgroundBasedTheme: o.spawnOwnership(),
          onActiveOrHoveredChart: (0, Ji.combine)((e, t) => e || t, this.chart.isActive().weakReference(), this.chart.isHovered().weakReference()).ownership(),
          rendererOptionsProvider: n,
          getBackgroundTopColor: r,
          getBackgroundBottomColor: r,
          requestRepaint: () => this.chart.model().model().lightUpdate(),
          showHorizontalBorder: true
        };
        this._lhsStubContainer = new qo(this._properties, "left", a, l, this._options.priceAxisLabelsOptions, this);
        this._lhsStubContainer.onLabelHovered().subscribe(this, (e, t) => {
          this._onLabelHovered.fire(e, t);
        });
        this._rhsStubContainer = new qo(this._properties, "right", a, l, this._options.priceAxisLabelsOptions, this);
        this._rhsStubContainer.onLabelHovered().subscribe(this, (e, t) => {
          this._onLabelHovered.fire(e, t);
        });
        this._element.appendChild(this._lhsStubContainer.getElement());
        this._cell = document.createElement("div");
        this._element.appendChild(this._cell);
        this._cell.classList.add("chart-markup-table", "time-axis");
        this._cell.style.height = "25px";
        this._dv = document.createElement("div");
        this._dv.style.width = "100%";
        this._dv.style.height = "100%";
        this._dv.style.position = "relative";
        this._dv.style.overflow = "hidden";
        this._cell.appendChild(this._dv);
        this._canvasConfiguredHandler = () => this.chart.model().model().lightUpdate();
        this._canvasBinding = (0, Wt.createBoundCanvas)(this._dv, (0, Dt.size)({
          width: 16,
          height: 16
        }));
        this._canvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        const c = this._canvasBinding.canvasElement;
        c.style.position = "absolute";
        c.style.zIndex = "1";
        c.style.left = "0";
        c.style.top = "0";
        this._topCanvasBinding = (0, Wt.createBoundCanvas)(this._dv, (0, Dt.size)({
          width: 16,
          height: 16
        }));
        this._topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        const h = this._topCanvasBinding.canvasElement;
        h.style.position = "absolute";
        h.style.zIndex = "2";
        h.style.left = "0";
        h.style.top = "0";
        this._dv.setAttribute("aria-hidden", "true");
        this._element.appendChild(this._rhsStubContainer.getElement());
        this.restoreDefaultCursor();
        this.update();
        this._minVisibleSpan = Sr.MINUTE_SPAN;
        this._mouseEventHandler = new Et.MouseEventHandler(this._topCanvasBinding.canvasElement, this, {
          treatVertTouchDragAsPageScroll: true,
          treatHorzTouchDragAsPageScroll: false
        });
        this.size = (0, Dt.size)({
          width: 0,
          height: 0
        });
        (0, lt.hideMarksOnBars)().subscribe(this, () => this.chart.model().model().lightUpdate());
      }
      destroy() {
        this._mouseEventHandler.destroy();
        this._topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        this._topCanvasBinding.dispose();
        this._canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._canvasConfiguredHandler);
        this._canvasBinding.dispose();
        this._rhsStubContainer.onLabelHovered().unsubscribeAll(this);
        this._lhsStubContainer.onLabelHovered().unsubscribeAll(this);
        this._lhsStubContainer.destroy();
        this._rhsStubContainer.destroy();
        this.chart.properties().childs().paneProperties.childs().background.unsubscribeAll(this);
        this._backgroundBasedTheme.release();
        (0, lt.hideMarksOnBars)().unsubscribeAll(this);
      }
      setCursor(e) {
        let t = "";
        if (e === "grabbing" || e === "ew-resize") {
          t = "time-axis--cursor-" + e;
        }
        if (this._currentCursorClassName !== t) {
          if (this._currentCursorClassName) {
            this._cell.classList.remove(this._currentCursorClassName);
          }
          if (t) {
            this._cell.classList.add(t);
          }
          this._currentCursorClassName = t;
          this._cell.style.cursor;
        }
      }
      restoreDefaultCursor() {
        this.setCursor("");
      }
      getElement() {
        return this._element;
      }
      optimalHeight() {
        const e = this.rendererOptions();
        return Math.ceil(e.borderSize + e.offsetSize + e.fontSize + e.paddingTop + e.paddingBottom + e.labelBottomOffset);
      }
      setSizes(e, t, i) {
        if (!this.size || !(0, Dt.equalSizes)(this.size, e)) {
          this.size = e;
          this._canvasBinding.resizeCanvasElement(e);
          this._topCanvasBinding.resizeCanvasElement(e);
          this._cell.style.width = e.width + "px";
          this._cell.style.height = e.height + "px";
        }
        this._lhsStubContainer.setSizes(e.height, t);
        this._rhsStubContainer.setSizes(e.height, i);
      }
      rendererOptions() {
        if (!this._rendererOptions || this._rendererOptions.fontSize !== this.fontSize()) {
          const e = this.fontSize();
          this._rendererOptions = {
            borderSize: 1,
            offsetSize: 5,
            fontSize: e,
            font: (0, Yt.makeFont)(e, g.CHART_FONT_FAMILY, ""),
            widthCache: new Gt.TextWidthCache(),
            paddingTop: e * 3 / 12,
            paddingBottom: e * 3 / 12,
            paddingHorizontal: e * 9 / 12,
            labelBottomOffset: e * 4 / 12
          };
        }
        return this._rendererOptions;
      }
      backgroundColor() {
        return this.chart.model().model().backgroundColor().value();
      }
      lineColor() {
        const e = this._properties.childs().lineColor.value();
        if ((0, kt.parseRgba)(e)[3] === 0) {
          const e = this.chart.model().model().lastPane();
          if (e && e.collapsed().value()) {
            return this.chart.properties().childs().paneProperties.childs().separatorColor.value();
          }
        }
        return e;
      }
      textColor() {
        return this._properties.childs().textColor.value();
      }
      fontSize() {
        return this._properties.childs().fontSize.value();
      }
      baseFont() {
        return (0, Yt.makeFont)(this.fontSize(), g.CHART_FONT_FAMILY);
      }
      baseBoldFont() {
        return (0, Yt.makeFont)(this.fontSize(), g.CHART_FONT_FAMILY, "", "bold");
      }
      hasCanvas(e) {
        return this._canvasBinding.canvasElement === e || this._topCanvasBinding.canvasElement === e;
      }
      onLabelHovered() {
        return this._onLabelHovered;
      }
      getScreenshotData() {
        return {
          content: this._canvasBinding.canvasElement.toDataURL(),
          canvas: this._canvasBinding.canvasElement,
          contentWidth: this.size.width,
          contentHeight: this.size.height,
          lhsStub: this._lhsStubContainer.getScreenshotData(),
          rhsStub: this._rhsStubContainer.getScreenshotData()
        };
      }
      getContextMenuActions(e) {
        const t = this.chart;
        const i = t.actions();
        const s = [];
        if (!e) {
          if (t.model().timeScale().resetAvailable().value()) {
            s.push(i.timeScaleReset);
            s.push(new Jo.Separator());
          }
          if (this._options.timezoneMenuEnabled) {
            s.push(i.applyTimeZone);
          }
          s.push(i.sessionBreaks);
        }
        if (!t.model().mainSeries().isDWM()) {
          const e = t.model()?.mainSeries().symbolInfo();
          if (e) {
            const i = t.model().mainSeries().properties().childs().sessionId;
            const o = (e.subsessions || []).filter(e => !e.private);
            if (o.length > 1) {
              const e = o.map(e => new Jo.Action({
                actionId: "Chart.SetSession",
                options: {
                  label: (0, br.translateSessionDescription)(e.description),
                  checkable: true,
                  checked: i.value() === e.id,
                  statName: "SetSession",
                  onExecute: () => {
                    t.model().setProperty(i, e.id, Cr);
                  }
                }
              }));
              const n = new Jo.Action({
                actionId: "Chart.SetSession",
                options: {
                  label: Pr,
                  statName: "SetSession",
                  subItems: e
                }
              });
              s.push(n);
            }
          }
        }
        if (!t.onWidget() && l.enabled("show_chart_property_page") && l.enabled("chart_property_page_scales") && i.scalesProperties) {
          if (s.length) {
            s.push(new Jo.Separator());
          }
          s.push(i.scalesProperties);
        }
        return s;
      }
      update() {
        if (!this.chart.hasModel()) {
          return;
        }
        const e = this.chart.model().timeScale().marks();
        if (e) {
          this._minVisibleSpan = Sr.YEAR_SPAN;
          for (const t of e) {
            this._minVisibleSpan = Math.min(t.span, this._minVisibleSpan);
          }
        }
      }
      updatePriceAxisStubs() {
        const e = this.chart.model().model();
        const t = this.chart.hasMaximizedPane() ? (0, n.ensureNotNull)(this.chart.maximizedPaneWidget()).state() : e.paneForSource(e.mainSeries());
        if (!t) {
          return;
        }
        const i = e.priceScaleSlotsCount();
        this._lhsStubContainer.setScales([], i.left, t.leftPriceScales().length, i.left + i.right);
        this._rhsStubContainer.setScales([], i.right, t.rightPriceScales().length, i.left + i.right);
      }
      paint(e) {
        if (e === yo.InvalidationLevel.None || this.size.width === 0 || this.size.height === 0) {
          return;
        }
        (0, Wt.tryApplySuggestedCanvasBitmapSize)(this._canvasBinding);
        (0, Wt.tryApplySuggestedCanvasBitmapSize)(this._topCanvasBinding);
        const t = (0, Wt.getContext2D)(this._topCanvasBinding.canvasElement);
        if (e > yo.InvalidationLevel.Cursor) {
          const i = (0, Wt.getContext2D)(this._canvasBinding.canvasElement);
          const s = (0, Wt.getBindingRenderingInfo)(this._canvasBinding);
          this.drawBackground(i, s);
          if (this.chart.hasModel()) {
            this.drawBorder(i, s);
            this.drawTickMarks(i, s);
            this.drawBackLabels(i, s);
            this.drawCrossHairLabel(t, s);
          }
          this._lhsStubContainer.paintStubs(e);
          this._rhsStubContainer.paintStubs(e);
        }
        this.drawCrossHairLabel(t, (0, Wt.getBindingRenderingInfo)(this._topCanvasBinding));
      }
      drawBackground(e, t) {
        (0, Wt.clearRect)(e, 0, 0, t.bitmapSize.width, t.bitmapSize.height, this.backgroundColor());
        if (!this.chart.hasModel()) {
          return;
        }
        const i = this.chart.model();
        if (!i.timeScale().isEmpty()) {
          const s = i.model().selection().lineDataSources().filter(e => !e.isFixed()).reduce((e, t) => {
            const i = t.timeAxisPoints();
            if (i.length === 0) {
              return e;
            } else {
              return e.concat(i);
            }
          }, []);
          if (s.length > 0) {
            this._highlightBackground(e, s, t);
          }
        }
        const s = i.model().crosshairSource();
        if (s.startMeasurePoint()) {
          this._highlightBackground(e, s.measurePoints(), t);
        }
      }
      drawBorder(e, t) {
        e.save();
        e.fillStyle = this.lineColor();
        const i = Math.max(1, Math.floor(this.rendererOptions().borderSize * t.verticalPixelRatio));
        const s = t.bitmapSize.width;
        e.fillRect(0, 0, s, i);
        e.restore();
      }
      drawTickMarks(e, t) {
        const i = this.chart.model().timeScale().marks();
        if (!i || i.length === 0) {
          return;
        }
        let s = i.reduce((e, t) => e.span > t.span ? e : t, i[0]).span;
        if (s > 30 && s < 40) {
          s = 30;
        }
        e.save();
        e.strokeStyle = this.lineColor();
        const o = this.rendererOptions();
        const n = o.borderSize + o.offsetSize + o.paddingTop + o.fontSize / 2;
        e.textAlign = "center";
        e.textBaseline = "middle";
        e.fillStyle = this.textColor();
        (0, Wt.drawScaled)(e, t.horizontalPixelRatio, t.verticalPixelRatio, () => {
          e.font = this.baseFont();
          for (let t = 0; t < i.length; t++) {
            const o = i[t];
            if (o.span < s) {
              e.fillText(o.label, o.coord, n);
            }
          }
          e.font = this.baseBoldFont();
          for (let t = 0; t < i.length; t++) {
            const o = i[t];
            if (o.span >= s) {
              e.fillText(o.label, o.coord, n);
            }
          }
        });
        e.restore();
      }
      drawBackLabels(e, t) {
        e.save();
        const i = new Set();
        const s = this.chart.model().model();
        let o = s.dataSources();
        const n = s.selection().allSources();
        for (const e of n) {
          i.add(e);
        }
        if (s.hoveredSource()) {
          i.add(s.hoveredSource());
        }
        for (const e of s.sourcesBeingMoved()) {
          i.add(e);
        }
        const r = s.customSourceBeingMoved();
        if (r !== null) {
          i.add(r);
        }
        const a = s.lineBeingEdited() ?? s.lineBeingCreated();
        if (a) {
          i.add(a);
        }
        i.add(this.chart.model().crosshairSource());
        o = o.concat(s.customSources());
        const l = this.rendererOptions();
        for (let s = 0; s < o.length; s++) {
          const n = o[s];
          if (!i.has(n) && n.timeAxisViews) {
            const i = n.timeAxisViews();
            if (i) {
              for (let s = 0; s < i.length; s++) {
                i[s].renderer().draw(e, t, l);
              }
            }
          }
        }
        e.restore();
      }
      drawCrossHairLabel(e, t) {
        e.save();
        e.clearRect(0, 0, t.bitmapSize.width, t.bitmapSize.height);
        const i = this.chart.model().model();
        const s = [];
        const o = i.lineBeingEdited() ?? i.lineBeingCreated();
        if (o && o.timeAxisViews) {
          const e = o.timeAxisViews();
          if (e && e.length) {
            s.push(e);
          }
        }
        const n = i.customSourceBeingMoved();
        this._addViewsOrMaxMin(n === null ? [] : [n], s);
        this._addViewsOrMaxMin(i.sourcesBeingMoved(), s);
        this._addViewsOrMaxMin(i.selection().allSources(), s);
        const r = i.hoveredSource();
        if (r && (0, Vo.isDataSource)(r) && !i.selection().isSelected(r) && r.timeAxisViews) {
          const e = r.timeAxisViews();
          if (e && e.length) {
            s.push(e);
          }
        }
        const a = i.crosshairSource();
        const l = a.timeAxisViews && a.timeAxisViews();
        if (l && l.length) {
          s.push(l);
        }
        const c = this.rendererOptions();
        for (const i of s) {
          for (const s of i) {
            e.save();
            s.renderer().draw(e, t, c);
            e.restore();
          }
        }
        e.restore();
      }
      mouseDownEvent(e) {
        this._mouseDownOrTouchStartEvent(e);
      }
      touchStartEvent(e) {
        this._mouseOrTouchEnterEvent(e);
        this._mouseDownOrTouchStartEvent(e);
      }
      mouseDownOutsideEvent() {
        this._outsideMouseDownOrTouchStartEvent();
      }
      touchStartOutsideEvent() {
        this._outsideMouseDownOrTouchStartEvent();
      }
      pressedMouseMoveEvent(e) {
        this._pressedMouseOrTouchMoveEvent(e);
      }
      touchMoveEvent(e) {
        this._pressedMouseOrTouchMoveEvent(e);
      }
      mouseUpEvent(e) {
        this._mouseUpOrTouchEndEvent(e);
      }
      touchEndEvent(e) {
        this._mouseUpOrTouchEndEvent(e);
        this._mouseOrTouchLeaveEvent(e);
      }
      contextMenuEvent(e) {
        this._contextMenuOrTouchContextMenuEvent(e);
      }
      touchContextMenuEvent(e) {
        this._contextMenuOrTouchContextMenuEvent(e);
      }
      mouseEnterEvent(e) {
        this._mouseOrTouchEnterEvent(e);
      }
      mouseLeaveEvent(e) {
        this._mouseOrTouchLeaveEvent(e);
      }
      mouseDoubleClickEvent(e) {
        this._mouseDoubleClickOrDoubleTapEvent(e);
      }
      doubleTapEvent(e) {
        this._mouseDoubleClickOrDoubleTapEvent(e);
      }
      _outsideMouseDownOrTouchStartEvent() {
        if (this._zoomAvailable() && this._mousedown) {
          this._mousedown = false;
          this.chart.model().endScaleTime();
          this.restoreDefaultCursor();
        }
      }
      _highlightBackground(e, t, i) {
        const s = this.chart.model().timeScale();
        let o = t[0].index;
        let n = t[0].index;
        for (let e = 1; e < t.length; e++) {
          o = Math.min(o, t[e].index);
          n = Math.max(n, t[e].index);
        }
        const {
          horizontalPixelRatio: r
        } = i;
        const a = Math.floor(s.indexToCoordinate(o) * r);
        const l = Math.ceil(s.indexToCoordinate(n) * r);
        (0, Wt.fillRect)(e, a, 0, l - a, i.bitmapSize.height, this._properties.childs().axisHighlightColor.value());
      }
      _addViewsOrMaxMin(e, t) {
        if (e.length <= 1) {
          for (const i of e) {
            if (i.timeAxisViews) {
              const e = i.timeAxisViews();
              if (e && e.length) {
                t.push(e);
              }
            }
          }
        } else {
          t.push(this._minMaxViews(e));
        }
      }
      _minMaxViews(e) {
        const t = [];
        let i = Infinity;
        let s = -Infinity;
        let o = null;
        let n = null;
        for (const t of e) {
          if (t.timeAxisViews) {
            const e = t.timeAxisViews();
            if (e && e.length) {
              for (let t = 0; t < e.length; ++t) {
                const r = e[t];
                const a = r.coordinate();
                if (a >= s) {
                  s = a;
                  n = r;
                }
                if (a <= i) {
                  i = a;
                  o = r;
                }
              }
            }
          }
        }
        if (n) {
          t.push(n);
        }
        if (o) {
          t.push(o);
        }
        return t;
      }
      _zoomAvailable() {
        return !this.chart.model().timeScale().isEmpty() && this.chart.model().model().zoomEnabled() && this._options.pressedMouseMoveScale;
      }
      _mouseDownOrTouchStartEvent(e) {
        if (this._mousedown || !this._zoomAvailable()) {
          return;
        }
        this._mousedown = true;
        const t = this.chart.model();
        if (!t.timeScale().isEmpty()) {
          t.startScaleTime(e.localX);
        }
      }
      _pressedMouseOrTouchMoveEvent(e) {
        if (this._zoomAvailable()) {
          this.chart.model().scaleTimeTo(e.localX);
        }
      }
      _mouseUpOrTouchEndEvent(e) {
        if (this._zoomAvailable()) {
          this._mousedown = false;
          this.chart.model().endScaleTime();
          this.restoreDefaultCursor();
        }
      }
      _contextMenuOrTouchContextMenuEvent(e) {
        if (this._options.contextMenuEnabled) {
          Oo.ContextMenuManager.showMenu(this.getContextMenuActions(), e, {
            statName: "TimeScaleContextMenu"
          }, {
            menuName: "TimeScaleContextMenu"
          });
        }
      }
      _mouseOrTouchEnterEvent(e) {
        if (this._zoomAvailable()) {
          this.setCursor("ew-resize");
        }
      }
      _mouseOrTouchLeaveEvent(e) {
        this.restoreDefaultCursor();
      }
      _mouseDoubleClickOrDoubleTapEvent(e) {
        (0, ne.trackEvent)("GUI", "Double click time scale");
        this.chart.model().resetTimeScale();
      }
    }
    var xr = i(85459);
    var Ir = i.n(xr);
    var Mr = i(78871);
    var Ar = i(71885);
    var Lr = i(77148);
    var kr = i(82783);
    function Dr(e, t) {
      return !!Re.Interval.isEqual(e.res, t.res) && (0, kr.areEqualTimeFrames)(e.val, t.val);
    }
    var Er = i(61119);
    const Br = {
      duration: 250,
      easing: Mr.easingFunc.easeOutCubic
    };
    class Vr {
      constructor(e) {
        this._onFinishCalled = false;
        this._options = {
          ...Br,
          ...e
        };
        this._startTime = performance.now();
      }
      getStartPosition() {
        return this._options.from;
      }
      getPosition(e) {
        const t = this._calculateProgress(e);
        if (t === 1) {
          if (this._options.onFinish && !this._onFinishCalled) {
            this._options.onFinish(true);
            this._onFinishCalled = true;
          }
          return this._options.to;
        } else {
          return (0, Er.lerp)(this._options.from, this._options.to, this._options.easing(t));
        }
      }
      finished(e) {
        return this._calculateProgress(e) === 1;
      }
      onFinish(e) {
        if (!this._onFinishCalled) {
          this._options.onFinish?.(e);
          this._onFinishCalled = true;
        }
      }
      _calculateProgress(e) {
        const t = e - this._startTime;
        if (t >= this._options.duration) {
          return 1;
        } else {
          return t / this._options.duration;
        }
      }
    }
    var Rr = i(86920);
    var Nr = i(60074);
    function Or(e, t, i, s) {
      let o = null;
      if (i.currencyConversionEnabled() && (0, Nr.isActingAsSymbolSource)(e)) {
        const n = i.availableCurrencies();
        const r = t.currency(n);
        const a = e.currency();
        if (r !== null && r.selectedCurrency !== null && !r.allCurrenciesAreOriginal && r.selectedCurrency !== a && (s && a === null || a !== null && n.convertible(a))) {
          o = r.selectedCurrency;
        }
      }
      return o;
    }
    const Fr = new Di.TranslatedString("toggle collapsed pane state", a.t(null, undefined, i(46054)));
    class Wr extends tt.UndoCommand {
      constructor(e, t) {
        super(Fr);
        this._chartModel = e;
        this._paneIndex = t;
      }
      redo() {
        this._chartModel.toggleCollapsedPane(this._paneIndex);
      }
      undo() {
        this._chartModel.toggleCollapsedPane(this._paneIndex);
      }
    }
    const Hr = new Di.TranslatedString("toggle maximized pane state", a.t(null, undefined, i(63095)));
    class zr extends tt.UndoCommand {
      constructor(e, t) {
        super(Hr);
        this._model = e;
        const i = e.maximizedPane().value();
        const s = i === null ? null : e.panes().indexOf(i);
        this._maximizedPaneIndex = t === i ? null : e.panes().indexOf(t);
        this._prevMaximizedPaneIndex = s;
      }
      redo() {
        this._setMaximizedPane(this._maximizedPaneIndex);
      }
      undo() {
        this._setMaximizedPane(this._prevMaximizedPaneIndex);
      }
      _setMaximizedPane(e) {
        this._model.setMaximizedPane(e === null ? null : this._model.panes()[e]);
      }
    }
    const Ur = new Di.TranslatedString("move all scales to left", a.t(null, undefined, i(64077)));
    const jr = new Di.TranslatedString("move all scales to right", a.t(null, undefined, i(19013)));
    const Gr = (0, ae.getLogger)("Chart.MergeAllScales");
    class qr extends tt.UndoCommand {
      constructor(e, t, i, s, o, n) {
        super(n);
        this._model = e;
        this._paneIndex = e.panes().indexOf(t);
        this._targetPosition = s;
        this._targetIndex = o;
        this._scaleId = i.id();
        this._sourcePosition = t.priceScalePosition(i);
        if (this._sourcePosition !== "overlay") {
          this._sourceIndex = t.priceScaleIndex(i, this._sourcePosition);
        }
      }
      redo() {
        const e = this._model.panes()[this._paneIndex];
        const t = (0, n.ensureNotNull)(e.getPriceScaleById(this._scaleId));
        e.movePriceScale(t, this._targetPosition, this._targetIndex);
        this._model.fullUpdate();
      }
      undo() {
        const e = this._model.panes()[this._paneIndex];
        const t = (0, n.ensureNotNull)(e.getPriceScaleById(this._scaleId));
        e.movePriceScale(t, this._sourcePosition, this._sourceIndex);
        this._model.fullUpdate();
      }
    }
    var $r = i(85719);
    class Kr extends tt.UndoCommand {
      constructor(e, t, i, s) {
        super(s, undefined, !$r.lineToolsDoNotAffectChartInvalidation);
        this._createdIds = [];
        this._model = e;
        this._withoutShift = i;
        this._origStates = t.map(e => e.state(true));
        const o = e.lineToolsGroupModel();
        this._origGroups = t.map(e => {
          const t = o.groupForLineTool(e);
          return t && t.id;
        });
      }
      redo() {
        const e = this._model.lineToolsGroupModel();
        const t = this._origStates.map((t, i) => {
          const s = (0, n.ensureNotNull)(this._model.dataSourceForId(t.id));
          const o = this._createdIds.length === 0 ? undefined : (0, n.ensureDefined)(this._createdIds[i]);
          const r = (0, eo.cloneLineTool)(this._model, s, !this._withoutShift, o);
          if (t.sharingMode !== undefined) {
            r.share(t.sharingMode);
          }
          const a = (0, n.ensureNotNull)(s.priceScale());
          (0, n.ensureNotNull)(this._model.paneForSource(s)).addDataSource(r, a, false);
          const l = this._origGroups[i];
          if (l !== null) {
            const t = e.groupForId(l);
            if (t) {
              t.addLineTools([r]);
            }
          }
          this._model.updateSource(r);
          return r;
        });
        if (this._createdIds.length === 0) {
          this._createdIds = t.map(e => e.id());
        }
        this._model.selectionMacro(e => {
          e.clearSelection();
          t.forEach(t => {
            e.addSourceToSelection(t);
          });
        });
        this._model.setShouldBeSavedEvenIfHidden(true);
      }
      undo() {
        const e = this._model.lineToolsGroupModel();
        this._createdIds.forEach(t => {
          const i = (0, n.ensureNotNull)(this._model.dataSourceForId(t));
          const s = e.groupForLineTool(i);
          if (s !== null) {
            s.excludeLineTool(i);
          }
          this._model.removeSource(i);
        });
      }
      newIds() {
        return this._createdIds;
      }
    }
    var Yr = i(74174);
    var Zr = i(70618);
    var Xr = i(300);
    class Jr extends tt.UndoCommand {
      constructor(e, t, i, s = true) {
        super(i, s, (0, Xr.sourcesAffectState)(t));
        this._newStates = [];
        this._model = e;
        this._savedStates = t.map(e => e.state(false));
      }
      redo() {
        this._applyState(this._newStates);
      }
      undo() {
        if (this._newStates.length === 0) {
          this.saveNewState();
        }
        this._applyState(this._savedStates);
      }
      saveNewState() {
        const e = this._savedStates.filter(dt.notNull).map(e => (0, n.ensureNotNull)(this._model.dataSourceForId(e.id)));
        this._newStates = e.map(e => e.state(false));
      }
      _applyState(e) {
        for (const t of e) {
          if (t !== null) {
            const e = this._model.dataSourceForId(t.id);
            if (e !== null) {
              if ((0, Js.isStudy)(e)) {
                const i = t.state.inputs;
                const s = e.properties().childs().inputs.childs();
                for (const e in i) {
                  if (s[e]) {
                    s[e].setValue(i[e]);
                  }
                }
              } else {
                this._model.restoreLineToolState(e, t, true);
              }
            }
          }
        }
      }
    }
    class Qr extends tt.UndoCommand {
      constructor(e, t, i) {
        super(i);
        this._chartModel = e;
        this._sourceId = t.id();
        const s = (0, n.ensureNotNull)(t.priceScale());
        this._initialPriceScaleId = s.id();
        this._initialPriceScaleState = (0, n.ensureNotNull)(t.priceScale()).state();
        const o = (0, n.ensureNotNull)(e.paneForSource(t));
        this._initialPriceScalePosition = o.priceScalePosition(s);
        this._initialPriceScaleIndex = o.priceScaleIndex(s, this._initialPriceScalePosition);
        this._initialPaneIndex = e.panes().indexOf(o);
      }
      _newPriceScaleState(e) {
        const t = {
          ...this._initialPriceScaleState
        };
        delete t.m_isLockScale;
        delete t.id;
        delete t.m_topMargin;
        delete t.m_bottomMargin;
        delete t.hasCalculatedPriceRange;
        return t;
      }
      _originalPriceScaleState() {
        return this._initialPriceScaleState;
      }
    }
    class ea extends Qr {
      constructor(e, t, i) {
        super(e, t, i);
      }
      redo() {
        const e = (0, n.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId));
        const t = (0, n.ensureNotNull)(this._chartModel.paneForSource(e));
        const i = this._chartModel.children(e, true);
        t.bulkActionMacro(() => {
          i.forEach(e => this._chartModel.detachSource(e));
          this._chartModel.detachSource(e);
        });
        const s = this._chartModel.createPane(this.targetPaneIndex());
        const o = s.findSuitableScale(e);
        s.bulkActionMacro(() => {
          s.addDataSource(e, o, false);
          i.forEach(e => s.addDataSource(e, o, false));
        });
        const r = (0, n.ensureNotNull)(e.priceScale());
        r.restoreState(this._newPriceScaleState(s.isOverlay(e)));
        r.setHeight(s.height());
        this._chartModel.fullUpdate();
        this._chartModel.setShouldBeSavedEvenIfHidden(true);
      }
      undo() {
        const e = (0, n.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId));
        const t = (0, n.ensureNotNull)(this._chartModel.paneForSource(e));
        const i = this._chartModel.children(e, true);
        t.bulkActionMacro(() => {
          i.forEach(e => this._chartModel.detachSource(e));
          const t = this._chartModel.detachSource(e);
          (0, n.assert)(t, "Undo of detaching must remove pane");
        });
        const s = this._chartModel.panes()[this._initialPaneIndex];
        let o = s.getPriceScaleById(this._initialPriceScaleId);
        if (o === null) {
          o = s.createPriceScaleAtPosition(this._initialPriceScalePosition, this._initialPriceScaleIndex);
        }
        s.bulkActionMacro(() => {
          s.addDataSource(e, o, true);
          i.forEach(e => s.addDataSource(e, o, false));
        });
        const r = (0, n.ensureNotNull)(e.priceScale());
        r.restoreState(this._originalPriceScaleState());
        r.setHeight(s.height());
        this._chartModel.fullUpdate();
      }
    }
    class ta extends ea {
      constructor(e, t, i) {
        super(e, t, i);
      }
      targetPaneIndex() {
        const e = this._chartModel.panes();
        for (let t = this._initialPaneIndex + 1; t < e.length; t++) {
          if (e[t].mode() === Bi.PaneMode.Regular) {
            return t;
          }
        }
        return e.length;
      }
    }
    class ia extends ea {
      constructor(e, t, i) {
        super(e, t, i);
      }
      targetPaneIndex() {
        return this._initialPaneIndex;
      }
    }
    class sa extends ea {
      constructor(e, t, i) {
        super(e, t, i);
      }
      targetPaneIndex() {
        return this._chartModel.panes().length;
      }
    }
    class oa extends Qr {
      constructor(e, t, i, s) {
        super(e, t, i);
        this._restorePane = false;
        this._keepZOrder = s ?? false;
        this._initialZOrder = t.zorder();
      }
      redo() {
        const e = this._chartModel.panes().length;
        const t = this._chartModel.panes()[this._targetPaneIndex()];
        const i = (0, n.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId));
        const s = (0, n.ensureNotNull)(this._chartModel.paneForSource(i));
        const o = this._chartModel.children(i, true);
        s.bulkActionMacro(() => {
          o.forEach(e => this._chartModel.detachSource(e));
          this._restorePane = this._chartModel.detachSource(i);
        });
        const r = this._initialPriceScalePosition === "overlay" ? this._initialPriceScalePosition : undefined;
        const a = t.findSuitableScale(i, undefined, r);
        const l = a.dataSources().length === 0;
        t.bulkActionMacro(() => {
          t.addDataSource(i, a, this._keepZOrder);
          o.forEach(e => t.addDataSource(e, a, this._keepZOrder));
        });
        if (i === this._chartModel.mainSeries()) {
          const e = t.priceScalePosition(a);
          t.movePriceScale(a, e, 0);
        }
        if (l) {
          const e = (0, n.ensureNotNull)(i.priceScale());
          e.restoreState(this._newPriceScaleState(t.isOverlay(i)));
          e.setHeight(t.height());
        }
        this._chartModel.fullUpdate();
        if (e !== this._chartModel.panes().length) {
          this._chartModel.setShouldBeSavedEvenIfHidden(true);
        }
      }
      undo() {
        let e;
        e = this._restorePane ? this._chartModel.createPane(this._initialPaneIndex) : this._chartModel.panes()[this._initialPaneIndex];
        const t = (0, n.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId));
        const i = (0, n.ensureNotNull)(this._chartModel.paneForSource(t));
        const s = this._chartModel.children(t, true);
        i.bulkActionMacro(() => {
          s.forEach(e => this._chartModel.detachSource(e));
          this._chartModel.detachSource(t);
        });
        let o = e.getPriceScaleById(this._initialPriceScaleId);
        if (o === null) {
          o = e.createPriceScaleAtPosition(this._initialPriceScalePosition, this._initialPriceScaleIndex);
        }
        e.bulkActionMacro(() => {
          t.setZorder(this._initialZOrder);
          e.addDataSource(t, o, true);
          s.forEach(t => e.addDataSource(t, o, false));
        });
        const r = (0, n.ensureNotNull)(t.priceScale());
        r.restoreState(this._originalPriceScaleState());
        r.setHeight(e.height());
        this._chartModel.fullUpdate();
      }
    }
    class na extends oa {
      constructor(e, t, i) {
        super(e, t, i);
      }
      _targetPaneIndex() {
        const e = this._chartModel.panes();
        for (let t = this._initialPaneIndex - 1; t >= 0; t--) {
          if (e[t].mode() === Bi.PaneMode.Regular) {
            return t;
          }
        }
        throw new Error("No regular pane found above for merging");
      }
    }
    class ra extends oa {
      constructor(e, t, i) {
        super(e, t, i);
      }
      _targetPaneIndex() {
        const e = this._chartModel.panes();
        for (let t = this._initialPaneIndex + 1; t < e.length; t++) {
          if (e[t].mode() === Bi.PaneMode.Regular) {
            return t;
          }
        }
        throw new Error("No regular pane found below for merging");
      }
    }
    class aa extends oa {
      constructor(e, t, i, s, o) {
        super(e, t, s, o);
        this._targetPane = i;
      }
      _targetPaneIndex() {
        return this._targetPane;
      }
    }
    var la = i(69661);
    var ca = i(98523);
    const ha = new Di.TranslatedString("create {tool}", a.t(null, undefined, i(12898)));
    class da extends la.LineToolSynchronizeUndoCommand {
      constructor({
        model: e,
        pane: t,
        lineTool: i,
        ownerSource: s,
        drawOnAllChartsMode: o = 0,
        id: n
      }) {
        super(e, ha.format({
          tool: new Di.TranslatedString(i, ca.lineToolsLocalizedNames[i])
        }), false, !$r.lineToolsDoNotAffectChartInvalidation);
        this._lineId = null;
        this._lineState = null;
        this._paneIndex = e.panes().indexOf(t);
        this._lineTool = i;
        this._ownerSourceId = s.id();
        this._lineId = n ?? null;
        this._drawOnAllChartsMode = o;
      }
      startCreatingLine(e, t, i, s, o) {
        const n = this._chartModel.panes()[this._paneIndex];
        const r = this._chartModel.dataSourceForId(this._ownerSourceId) || undefined;
        const a = this._chartModel.createLineTool({
          pane: n,
          point: e,
          linetool: this._lineTool,
          properties: t,
          linkKey: i,
          sharingMode: s,
          ownerSource: r,
          id: this._lineId ?? undefined,
          fromExternalModel: o
        });
        this._lineId = a.id();
        this._fromExternalModel = o;
        return !this._chartModel.lineBeingCreated();
      }
      continueCreatingLine(e, t, i, s) {
        const o = this._chartModel.continueCreatingLine(e, t, i, s, this._fromExternalModel);
        if (o) {
          this._chartModel.setShouldBeSavedEvenIfHidden(true);
        }
        return o;
      }
      line() {
        if (this._lineId === null) {
          return null;
        } else {
          return this._chartModel.dataSourceForId(this._lineId);
        }
      }
      drawOnAllCharts() {
        return this._drawOnAllChartsMode !== 0;
      }
      _redo() {
        if (this._lineState === null) {
          return;
        }
        const e = this._chartModel.restoreSource(false, this._paneIndex, null, (0, n.ensureNotNull)(this._lineState), null);
        if (e !== null) {
          this._lineId = e.id();
          this._lineState = null;
          e.share(this._drawOnAllChartsMode);
        }
      }
      _undo() {
        const e = this.line();
        if (e !== null) {
          this._lineState = e.state(false);
          this._chartModel.removeSource(e);
          this._lineId = null;
        }
      }
    }
    var ua = i(19466);
    const _a = new Di.TranslatedString("bring {title} to front", a.t(null, undefined, i(53159)));
    const pa = new Di.TranslatedString("send {title} to back", a.t(null, undefined, i(5005)));
    const ma = new Di.TranslatedString("insert {title} after {targetTitle}", a.t(null, undefined, i(56307)));
    const ga = new Di.TranslatedString("insert {title} before {targetTitle}", a.t(null, undefined, i(46229)));
    const fa = new Di.TranslatedString("send {title} backward", a.t(null, undefined, i(40962)));
    const ya = new Di.TranslatedString("bring {title} forward", a.t(null, undefined, i(41966)));
    const va = new Di.TranslatedString("send group {title} backward", a.t(null, undefined, i(69546)));
    const Sa = new Di.TranslatedString("bring group {title} forward", a.t(null, undefined, i(1979)));
    function ba(e) {
      return new Di.TranslatedString(e.name(), e.title(ua.TitleDisplayTarget.StatusLine));
    }
    class wa extends tt.UndoCommand {
      constructor(e, t, i) {
        super(i, undefined, (0, Xr.sourcesAffectState)(t));
        this._sourcesByPanes = new Map();
        this._originalState = new Map();
        this._model = e;
        t.forEach(t => {
          const i = (0, n.ensureNotNull)(e.paneForSource(t));
          const s = e.panes().indexOf(i);
          const o = this._sourcesByPanes.get(s) || [];
          o.push(t.id());
          this._sourcesByPanes.set(s, o);
        });
        Array.from(this._sourcesByPanes.keys()).forEach(t => {
          const i = e.panes()[t];
          const s = new Map();
          const o = new Set(i.sourcesByGroup().multipaneSources());
          i.sourcesByGroup().allIncludingHidden().filter(e => !o.has(e)).forEach(e => {
            s.set(e.id(), e.zorder());
          });
          this._originalState.set(t, s);
        });
      }
      undo() {
        this._originalState.forEach((e, t) => {
          const i = this._model.panes()[t];
          const s = new Map();
          e.forEach((e, t) => {
            const o = (0, n.ensureNotNull)(i.dataSourceForId(t));
            s.set(o, e);
          });
          i.setZOrders(s);
        });
      }
      redo() {
        this._sourcesByPanes.forEach((e, t) => {
          const i = this._model.panes()[t];
          const s = e.map(e => (0, n.ensureNotNull)(i.dataSourceForId(e)));
          this._paneOperation(i, s);
        });
      }
    }
    class Ca extends wa {
      constructor(e, t) {
        super(e, t, _a.format({
          title: ba(t[0])
        }));
      }
      _paneOperation(e, t) {
        e.bringToFront(t);
      }
    }
    class Pa extends wa {
      constructor(e, t) {
        super(e, t, pa.format({
          title: ba(t[0])
        }));
      }
      _paneOperation(e, t) {
        e.sendToBack(t);
      }
    }
    class Ta extends wa {
      constructor(e, t, i, s) {
        super(e, t, s);
        this._targetSource = i;
      }
      _paneOperation(e, t) {
        e.insertAfter(t, this._targetSource);
      }
    }
    class xa extends Ta {
      constructor(e, t, i) {
        super(e, t, i, ma.format({
          title: ba(t[0]),
          targetTitle: ba(i)
        }));
      }
    }
    class Ia extends wa {
      constructor(e, t, i, s) {
        super(e, t, s);
        this._targetSource = i;
      }
      _paneOperation(e, t) {
        e.insertBefore(t, this._targetSource);
      }
    }
    class Ma extends Ia {
      constructor(e, t, i) {
        super(e, t, i, ga.format({
          title: ba(t[0]),
          targetTitle: ba(i)
        }));
      }
    }
    function Aa(e, t) {
      const i = t[0];
      const s = e.sourcesByGroup().all().filter(e => e.zorder() < i.zorder());
      if (s.length === 0) {
        throw new Error("Cannot move backward source that alreadt on back");
      }
      let o = s[s.length - 1];
      if ((0, eo.isLineTool)(o)) {
        const t = e.model().lineToolsGroupModel().groupForLineTool(o);
        if (t !== null) {
          o = t.lineTools()[0];
        }
      }
      return o;
    }
    class La extends Ia {
      constructor(e, t, i) {
        super(e, i, Aa(t, i), fa.format({
          title: ba(i[0])
        }));
      }
    }
    function ka(e, t) {
      const i = t[t.length - 1];
      const s = e.sourcesByGroup().allExceptSpecialSources().filter(e => e.zorder() > i.zorder());
      if (s.length === 0) {
        throw new Error("Cannot bring forward source that alreadt on back");
      }
      let o = s[0];
      if ((0, eo.isLineTool)(o)) {
        const t = e.model().lineToolsGroupModel().groupForLineTool(o);
        if (t !== null) {
          const e = t.lineTools();
          o = e[e.length - 1];
        }
      }
      return o;
    }
    class Da extends Ta {
      constructor(e, t, i) {
        super(e, i, ka(t, i), ya.format({
          title: ba(i[0])
        }));
      }
    }
    function Ea(e, t) {
      return (0, n.ensureNotNull)(e.paneForSource(t.lineTools()[0]));
    }
    class Ba extends Ia {
      constructor(e, t) {
        super(e, t.lineTools(), Aa(Ea(e, t), t.lineTools()), va.format({
          title: t.name().value()
        }));
      }
    }
    class Va extends Ta {
      constructor(e, t) {
        super(e, t.lineTools(), ka(Ea(e, t), t.lineTools()), Sa.format({
          title: t.name().value()
        }));
      }
    }
    const Ra = new Di.TranslatedString("rearrange panes", a.t(null, undefined, i(2618)));
    class Na extends tt.UndoCommand {
      constructor(e, t, i) {
        super(Ra);
        this._chartModel = e;
        this._index = t;
        if ((0, dt.isNumber)(i)) {
          this._dstIndex = i;
        } else {
          this._dstIndex = i === "up" ? t - 1 : t + 1;
        }
      }
      redo() {
        if (this._checkIndices()) {
          this._chartModel.movePane(this._index, this._dstIndex);
        }
      }
      undo() {
        if (this._checkIndices()) {
          this._chartModel.movePane(this._dstIndex, this._index);
        }
      }
      _checkIndices() {
        const e = this._chartModel.panes().length;
        return this._index >= 0 && this._index < e && this._dstIndex >= 0 && this._dstIndex < e;
      }
    }
    var Oa = i(7927);
    function Fa(e) {
      return {
        val: e.value(),
        dependenValues: e.dependents?.().map(Fa) ?? []
      };
    }
    function Wa(e) {
      return (e.dependents?.() ?? []).map(Fa);
    }
    function Ha(e, t) {
      (e.dependents?.() ?? []).forEach((e, i) => {
        e.setValue(t[i].val);
        (e.dependents?.() ?? []).forEach(e => Ha(e, t[i].dependenValues));
      });
    }
    function za(e, t) {
      if (typeof t == "string") {
        return (0, Oa.propertyByPath)(e, t);
      } else {
        return t;
      }
    }
    class Ua extends tt.UndoCommand {
      constructor(e, t, i, s, o = true) {
        super(i, undefined, o);
        const n = e.pathToRoot();
        this._targetObj = (0, Oa.isRootPath)(n) ? n : e;
        this._newValue = t;
        this._oldValue = e.value();
        this._dependentValues = Wa(e);
        this._model = s;
      }
      targetValue() {
        return this._newValue;
      }
      redo(e) {
        (0, li.allowSavingDefaults)(true);
        za(e.chartWidgetCollection, this._targetObj).setValue(this._newValue);
        (0, li.allowSavingDefaults)(false);
        this._model.recalculateAllPanes((0, Bt.globalChangeEvent)());
        this._model.lightUpdate();
      }
      undo(e) {
        (0, li.allowSavingDefaults)(true);
        const t = za(e.chartWidgetCollection, this._targetObj);
        t.setValue(this._oldValue);
        Ha(t, this._dependentValues);
        (0, li.allowSavingDefaults)(false);
        this._model.recalculateAllPanes((0, Bt.globalChangeEvent)());
        this._model.lightUpdate();
      }
    }
    class ja extends tt.UndoCommand {
      constructor(e, t, i, s, o, n) {
        super(s);
        this._prevPriceAxisProps = {};
        this._dependentValues = [];
        this._property = e;
        this._mainSeries = i;
        this._value = t;
        this._model = o;
        this._chartWidget = n;
      }
      redo() {
        const e = this._mainSeries;
        const t = e.properties().childs();
        this._dependentValues = Wa(this._property);
        this._prevResolution = t.interval.value();
        this._prevValue = this._property.value();
        this._storePriceAxisProps();
        (0, li.allowSavingDefaults)(true);
        const i = t.interval.value();
        const s = this._model.defaultResolutions();
        const o = (0, es.getResolutionByChartStyle)(this._value, i, s);
        de.linking.interval.setValue(o);
        e.setChartStyleWithIntervalIfNeeded(this._value, o);
        (0, yt.setLastUsedStyle)(this._value, e.symbolInfo());
        (0, yt.preparePriceAxisProperties)(t);
        (0, li.allowSavingDefaults)(false);
        this._invalidateModel();
        this._chartWidget.screen.show(true);
      }
      undo() {
        const e = this._mainSeries;
        (0, li.allowSavingDefaults)(true);
        e.setChartStyleWithIntervalIfNeeded(this._prevValue, this._prevResolution);
        this._restorePriceAxisProps();
        de.linking.interval.setValue(this._prevResolution);
        Ha(this._property, this._dependentValues);
        (0, li.allowSavingDefaults)(false);
        this._invalidateModel();
        this._chartWidget.screen.show(true);
      }
      _storePriceAxisProps() {
        const e = this._mainSeries.priceScale();
        this._prevPriceAxisProps = e.mode();
      }
      _restorePriceAxisProps() {
        this._mainSeries.priceScale().setMode(this._prevPriceAxisProps);
      }
      _invalidateModel() {
        if (this._model) {
          this._model.recalculateAllPanes((0, Bt.sourceChangeEvent)(this._model.mainSeries().id()));
          this._model.lightUpdate();
        }
      }
    }
    const Ga = new Di.TranslatedString("change date range", a.t(null, undefined, i(16979)));
    class qa extends tt.UndoCommand {
      constructor(e, t) {
        super(Ga);
        this._modelsData = [];
        this._rangeOptions = t;
        this._modelsData.push({
          model: e,
          prevResolution: e.mainSeries().properties().childs().interval.value(),
          barSpacing: e.timeScale().barSpacing(),
          rightOffset: e.timeScale().rightOffset(),
          rangeOptions: e.appliedTimeFrame().value()
        });
      }
      redo() {
        for (const e of this._modelsData) {
          const t = e.model.mainSeries();
          const i = t.properties().childs().interval;
          if (Re.Interval.isEqual(this._rangeOptions.res, i.value())) {
            t.loadDataTo(this._rangeOptions.val);
          } else {
            t.setDefaultTimeframe(this._rangeOptions.val);
            t.setSymbolParams({
              interval: this._rangeOptions.res
            });
          }
        }
      }
      undo() {
        for (const e of this._modelsData) {
          const t = e.model.mainSeries();
          const i = t.properties().childs().interval;
          if (e.prevResolution !== i.value()) {
            if (e.rangeOptions !== null) {
              t.setDefaultTimeframe(e.rangeOptions.val);
            }
            t.setSymbolParams({
              interval: e.prevResolution
            });
          } else if (e.rangeOptions !== null) {
            t.loadDataTo(e.rangeOptions.val);
          }
          const s = e.model.timeScale();
          s.setBarSpacing(e.barSpacing);
          s.setRightOffset(e.rightOffset);
        }
      }
      canMerge(e) {
        return e instanceof qa && Dr(e._rangeOptions, this._rangeOptions);
      }
      merge(e) {
        if (!(e instanceof qa)) {
          throw new Error("Invalid command to merge");
        }
        this._modelsData = this._modelsData.concat(e._modelsData);
      }
    }
    function $a(e) {
      return e.properties().visible.value();
    }
    function Ka(e) {
      return !$a(e);
    }
    class Ya {
      constructor(e, t, i) {
        this._instanceId = (0, fe.randomHashN)(6);
        this._onChanged = new re.Delegate();
        this._lineToolsSet = new Set();
        this._lineTools = [...e];
        this._lineToolsSet = new Set(this._lineTools);
        this._name = new F.WatchedValue(t);
        this.id = i || (0, fe.randomHashN)(6);
      }
      instanceId() {
        return this._instanceId;
      }
      lineTools() {
        return this._lineTools;
      }
      name() {
        return this._name;
      }
      setName(e) {
        this._doAndFireOnChange(() => {
          this._name.setValue(e);
        });
      }
      isActualSymbol() {
        return this._lineTools.length > 0 && this._lineTools[0].isActualSymbol() && this._lineTools[0].isActualCurrency() && this._lineTools[0].isActualUnit();
      }
      symbol() {
        return this._lineTools[0].symbol();
      }
      currencyId() {
        return this._lineTools[0].properties().childs().currencyId.value() ?? null;
      }
      unitId() {
        return this._lineTools[0].properties().childs().unitId.value() ?? null;
      }
      sharingMode() {
        return this._lineTools[0].sharingMode();
      }
      share(e) {
        this._lineTools.forEach(t => t.share(e));
      }
      containsLineTool(e) {
        return this._lineToolsSet.has(e);
      }
      addLineTools(e) {
        this._doAndFireOnChange(t => {
          e.forEach(e => this._lineToolsSet.add(e));
          this._lineTools.push(...e);
          t.push(...e.map(e => e.id()));
        });
      }
      excludeLineTool(e) {
        this._doAndFireOnChange(t => {
          this._lineToolsSet.delete(e);
          const i = this._lineTools.indexOf(e);
          this._lineTools.splice(i, 1);
          t.push(e.id());
        });
      }
      excludeLineTools(e) {
        this._doAndFireOnChange(t => {
          const i = new Set(e);
          e.forEach(e => this._lineToolsSet.delete(e));
          this._lineTools = this._lineTools.filter(e => !i.has(e));
          t.push(...e.map(e => e.id()));
        });
      }
      state() {
        return {
          id: this.id,
          name: this._name.value(),
          tools: this._lineTools.map(e => e.id())
        };
      }
      visibility() {
        const e = this._lineTools.some($a);
        const t = this._lineTools.some(Ka);
        if (e && !t) {
          return "Visible";
        } else if (t && !e) {
          return "Invisible";
        } else {
          return "Partial";
        }
      }
      locked() {
        const e = this._lineTools.some(e => e.properties().frozen.value());
        const t = this._lineTools.some(e => !e.properties().frozen.value());
        if (e && !t) {
          return "Locked";
        } else if (t && !e) {
          return "Unlocked";
        } else {
          return "Partial";
        }
      }
      isActualInterval() {
        const e = this._lineTools.some(e => e.isActualInterval());
        const t = this._lineTools.some(e => !e.isActualInterval());
        if (e && !t) {
          return "IsActualInterval";
        } else if (t && !e) {
          return "IsNotActualInterval";
        } else {
          return "Partial";
        }
      }
      onChanged() {
        return this._onChanged;
      }
      static fromState(e, t) {
        const i = [];
        for (const s of t.tools) {
          const t = e.dataSourceForId(s);
          if (t !== null) {
            i.push(t);
          }
        }
        if (i.length > 0) {
          return new Ya(i, t.name, t.id);
        } else {
          return null;
        }
      }
      _doAndFireOnChange(e) {
        const t = [];
        const i = this.visibility();
        const s = this.locked();
        const o = this.isActualInterval();
        e(t);
        this._onChanged.fire({
          affectedLineTools: t,
          visibilityChanged: i !== this.visibility(),
          lockedChanged: s !== this.locked(),
          isActualIntervalChanged: o !== this.isActualInterval()
        });
      }
    }
    class Za extends tt.UndoCommand {
      constructor(e, t, i) {
        super(i, undefined, !$r.lineToolsDoNotAffectChartInvalidation);
        this._model = e;
        this._groupId = t.id;
        this._groupName = t.name().value();
        this._lineToolsIds = t.lineTools().map(e => e.id());
      }
      redo() {
        const e = (0, n.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId));
        this._model.lineToolsGroupModel().removeGroup(e);
      }
      undo() {
        const e = this._lineToolsIds.map(e => this._model.dataSourceForId(e));
        const t = new Ya(e, this._groupName, this._groupId);
        this._model.lineToolsGroupModel().addGroup(t);
      }
    }
    const Xa = new Di.TranslatedString("create line tools group", a.t(null, undefined, i(46219)));
    class Ja extends tt.UndoCommand {
      constructor(e, t) {
        super(Xa, undefined, !$r.lineToolsDoNotAffectChartInvalidation);
        this._groupId = null;
        this._model = e;
        this._sourcesIds = t.map(e => e.id());
      }
      redo() {
        const e = this._sourcesIds.map(e => this._model.dataSourceForId(e));
        const t = this._groupId === null ? undefined : this._groupId;
        this._groupId = this._model.lineToolsGroupModel().createGroup(e, this._title, t).id;
      }
      undo() {
        const e = (0, n.ensureNotNull)(this._model.lineToolsGroupModel().groupForId((0, n.ensureNotNull)(this._groupId)));
        this._model.lineToolsGroupModel().removeGroup(e);
      }
      createdGroupId() {
        return this._groupId;
      }
    }
    const Qa = new Di.TranslatedString("add line tool(s) to group {group}", a.t(null, undefined, i(21162)));
    class el extends tt.UndoCommand {
      constructor(e, t, i) {
        super(Qa.format({
          group: t.name().value()
        }), undefined, !$r.lineToolsDoNotAffectChartInvalidation);
        this._model = e;
        this._groupId = t.id;
        this._lineToolsIds = i.map(e => e.id());
      }
      redo() {
        const e = (0, n.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId));
        const t = this._lineToolsIds.map(e => this._model.dataSourceForId(e));
        e.addLineTools(t);
      }
      undo() {
        const e = this._lineToolsIds.map(e => this._model.dataSourceForId(e));
        (0, n.ensureNotNull)(this._model.lineToolsGroupModel().groupForId(this._groupId)).excludeLineTools(e);
      }
    }
    class tl extends tt.UndoCommand {
      constructor(e, t, i, s) {
        super(s, undefined, !$r.lineToolsDoNotAffectChartInvalidation);
        this._chartModel = e;
        this._groupId = t.id;
        this._oldName = t.name().value();
        this._newName = i;
      }
      redo() {
        (0, n.ensureNotNull)(this._chartModel.lineToolsGroupModel().groupForId(this._groupId)).setName(this._newName);
      }
      undo() {
        (0, n.ensureNotNull)(this._chartModel.lineToolsGroupModel().groupForId(this._groupId)).setName(this._oldName);
      }
    }
    const il = new Di.TranslatedString("create line tools group from selection", a.t(null, undefined, i(95394)));
    const sl = new Di.TranslatedString("removing line tools group {name}", a.t(null, undefined, i(41430)));
    const ol = new Di.TranslatedString("add line tool {lineTool} to group {name}", a.t(null, undefined, i(12570)));
    const nl = new Di.TranslatedString("make group {group} visible", a.t(null, undefined, i(45987)));
    const rl = new Di.TranslatedString("make group {group} invisible", a.t(null, undefined, i(76709)));
    const al = new Di.TranslatedString("lock group {group}", a.t(null, undefined, i(20453)));
    const ll = new Di.TranslatedString("unlock group {group}", a.t(null, undefined, i(74590)));
    const cl = new Di.TranslatedString("rename group {group} to {newName}", a.t(null, undefined, i(80491)));
    class hl {
      constructor(e) {
        this._environment = e;
      }
      createGroupFromSelection() {
        const e = this._environment.model();
        (0, n.assert)(!e.selection().isEmpty(), "Cannot create group from empty selection");
        const t = (0, ci.sortSources)(e.selection().lineDataSources());
        (0, n.assert)(t.length === e.selection().allSources().length, "A group could contain line tools only");
        const i = t.length > 1 || this._environment.model().lineToolsGroupModel().groupForLineTool(t[0]) !== null;
        const s = t.reduce((e, t) => e.zorder() > t.zorder() ? e : t, t[0]);
        let o = s;
        const r = e.lineToolsGroupModel().groupForLineTool(s);
        if (r !== null) {
          const e = r.lineTools();
          o = e[e.length - 1];
        }
        this._environment.beginUndoMacro(il);
        const a = new Map();
        const l = new Set();
        t.forEach(t => {
          const i = this._groupForLineTool(t);
          if (i === null) {
            return;
          }
          const s = a.get(i) || [];
          s.push(t);
          a.set(i, s);
          const o = (0, n.ensureNotNull)(e.paneForSource(t));
          l.add(o);
        });
        (0, n.assert)(l.size <= 1, "All selected sources should be on the same pane");
        a.forEach((t, i) => {
          const s = new Zr.ExcludeLineToolsFromGroupUndoCommand(e, i, t);
          this._environment.pushUndoCommand(s);
        });
        const c = new Ja(e, (0, ci.sortSources)(t));
        this._environment.pushUndoCommand(c);
        if (i) {
          const i = new xa(e, t, o);
          this._environment.pushUndoCommand(i);
        }
        this._environment.endUndoMacro();
        const h = (0, n.ensureNotNull)(c.createdGroupId());
        return (0, n.ensureNotNull)(e.lineToolsGroupModel().groupForId(h));
      }
      removeGroup(e) {
        const t = this._environment.model();
        const i = e.lineTools();
        this._environment.beginUndoMacro(sl.format({
          name: e.name().value()
        }));
        const s = new Za(t, e, null);
        this._environment.pushUndoCommand(s);
        const o = new Yr.RemoveSourcesUndoCommand(t, i, null);
        this._environment.pushUndoCommand(o);
        const r = t.mainSeries().symbol();
        i.forEach(e => {
          if (e.linkKey().value() !== null) {
            (0, lt.removeLineTool)({
              withUndo: true,
              model: t,
              symbol: r,
              sourceTitle: new Di.TranslatedString(e.name(), e.title(ua.TitleDisplayTarget.DataWindow)),
              lineToolState: e.state(false),
              linkKey: (0, n.ensureNotNull)(e.linkKey().value())
            });
          }
        });
        this._environment.endUndoMacro();
      }
      groups() {
        return this._environment.model().lineToolsGroupModel().groups();
      }
      excludeLineToolFromGroup(e, t) {
        const i = this._environment.model();
        const s = new Zr.ExcludeLineToolsFromGroupUndoCommand(i, e, [t]);
        this._environment.pushUndoCommand(s);
      }
      addLineToolToGroup(e, t) {
        const i = this._environment.model();
        const s = i.lineToolsGroupModel().groupForLineTool(t);
        if (s === e) {
          return;
        }
        const o = ol.format({
          lineTool: new Di.TranslatedString(t.name(), t.title(ua.TitleDisplayTarget.StatusLine)),
          name: e.name().value()
        });
        this._environment.beginUndoMacro(o);
        if (s !== null) {
          this._environment.pushUndoCommand(new Zr.ExcludeLineToolsFromGroupUndoCommand(i, s, [t]));
        }
        if (l.enabled("saveload_separate_drawings_storage")) {
          const s = e.sharingMode().value();
          if (t.sharingMode().value() !== s) {
            this._environment.pushUndoCommand(new SetLineSharingModeUndoCommand(t, s, i, null));
          }
        }
        this._environment.pushUndoCommand(new el(i, e, [t]));
        this._environment.endUndoMacro();
      }
      bringToFront(e) {
        const t = this._environment.model();
        const i = new Ca(t, e.lineTools());
        this._environment.pushUndoCommand(i);
        this._environment.emitEvent("changeZOrder", [e.lineTools()]);
      }
      sendToBack(e) {
        const t = this._environment.model();
        const i = new Pa(t, e.lineTools());
        this._environment.pushUndoCommand(i);
        this._environment.emitEvent("changeZOrder", [e.lineTools()]);
      }
      bringForward(e) {
        const t = this._environment.model();
        const i = new Va(t, e);
        this._environment.pushUndoCommand(i);
        this._environment.emitEvent("changeZOrder", [e.lineTools()]);
      }
      sendBackward(e) {
        const t = this._environment.model();
        const i = new Ba(t, e);
        this._environment.pushUndoCommand(i);
        this._environment.emitEvent("changeZOrder", [e.lineTools()]);
      }
      insertAfter(e, t) {
        const i = this._environment.model();
        let s;
        if (t instanceof Ya) {
          const e = t.lineTools();
          s = e[e.length - 1];
        } else {
          s = t;
        }
        const o = new xa(i, e.lineTools(), s);
        this._environment.pushUndoCommand(o);
        this._environment.emitEvent("changeZOrder", [e.lineTools()]);
      }
      insertBefore(e, t) {
        const i = this._environment.model();
        let s;
        if (t instanceof Ya) {
          s = t.lineTools()[0];
        } else {
          s = t;
        }
        const o = new Ma(i, e.lineTools(), s);
        this._environment.pushUndoCommand(o);
        this._environment.emitEvent("changeZOrder", [e.lineTools()]);
      }
      availableZOrderOperations(e) {
        const t = this._environment.model();
        const i = e.lineTools();
        const s = i[0];
        const o = i[i.length - 1];
        const r = (0, n.ensureNotNull)(t.paneForSource(i[0])).sourcesByGroup().allExceptSpecialSources();
        const a = r[0];
        const l = r[r.length - 1];
        return {
          bringForwardEnabled: o !== l,
          bringToFrontEnabled: o !== l,
          sendBackwardEnabled: s !== a,
          sendToBackEnabled: s !== a
        };
      }
      setGroupVisibility(e, t) {
        const i = (t ? nl : rl).format({
          group: e.name().value()
        });
        const s = this._environment.model();
        this._environment.beginUndoMacro(i);
        e.lineTools().forEach(e => {
          const i = e.properties().visible;
          const o = new Ua(i, t, null, s, !$r.lineToolsDoNotAffectChartInvalidation);
          this._environment.pushUndoCommand(o);
        });
        this._environment.endUndoMacro();
      }
      setGroupLock(e, t) {
        const i = (t ? al : ll).format({
          group: e.name().value()
        });
        const s = this._environment.model();
        this._environment.beginUndoMacro(i);
        e.lineTools().forEach(e => {
          const i = e.properties().frozen;
          const o = new Ua(i, t, null, s, !$r.lineToolsDoNotAffectChartInvalidation);
          this._environment.pushUndoCommand(o);
        });
        this._environment.endUndoMacro();
      }
      setGroupName(e, t) {
        const i = this._environment.model();
        const s = cl.format({
          group: e.name().value(),
          newName: t
        });
        const o = new tl(i, e, t, s);
        this._environment.pushUndoCommand(o);
      }
      canBeGroupped(e) {
        const t = this._environment.model();
        return new Set(e.map(e => t.paneForSource(e))).size <= 1;
      }
      _groupForLineTool(e) {
        return this._environment.model().lineToolsGroupModel().groups().find(t => t.containsLineTool(e)) || null;
      }
    }
    var dl;
    var ul;
    var _l;
    var pl;
    var ml = i(96286);
    function gl(e) {
      return e.isSeries;
    }
    function fl(e) {
      return (0, eo.isLineTool)(e) && !e.isSpeciallyZOrderedSource();
    }
    function yl(e) {
      return (0, Js.isStudy)(e) && !e.isSpeciallyZOrderedSource() || (0, Js.isStudyStub)(e);
    }
    function vl(e, t) {
      return e.zorder - t.zorder;
    }
    function Sl(e, t) {
      if ((0, pt.isMainSeriesState)(e)) {
        e.zorder = 0;
      } else {
        e.zorder = t;
      }
    }
    function bl(e, t) {
      e.setZorder(t);
    }
    function wl(e) {
      return e.zorder();
    }
    function Cl(e) {
      return Math.round(e * 1000) / 1000;
    }
    function Pl(e, t) {
      const i = Math.max(e, t);
      const s = Math.min(e, t);
      return Math.max(0, Math.ceil(i) - Math.floor(s) - 1);
    }
    function Tl(e, t, i) {
      let s = 0;
      const o = function (e, t) {
        const i = 1000;
        return Math.abs(t * i - e * i) / i;
      }(t, e);
      var n;
      if (o > i) {
        e = Math.trunc(e);
        s = Math.floor(o / (i + 1));
      } else {
        n = o / (i + 1);
        s = Math.floor(n * 1000) / 1000;
      }
      return {
        startZOrder: e,
        zOrderStep: s
      };
    }
    function xl(e, t, i, s) {
      let o = e.length;
      let n = t;
      for (let t = e.length - 1; t >= -1; t--) {
        if (t === -1 || s(e[t])) {
          const s = t;
          let r = Dl(n);
          if (o - 1 === s) {
            if (s >= 0) {
              i(e[s], r);
            }
          } else {
            const t = Pl(o, s);
            let a = 0;
            while (a === 0) {
              const e = Tl(n, r, t);
              n = e.startZOrder;
              a = e.zOrderStep;
              if (a === 0) {
                r -= 10000;
                if (r === 0) {
                  r -= 10000;
                }
              }
            }
            let l = o - 1;
            while (l > s) {
              const t = Cl(n - a);
              i(e[l], t);
              n = t;
              l--;
            }
            if (s >= 0) {
              i(e[s], r);
            }
          }
          n = r;
          o = s;
        }
      }
    }
    function Il(e, t, i, s) {
      let o = -1;
      let n = t;
      for (let t = 0; t <= e.length; t++) {
        if (t === e.length || s(e[t])) {
          const s = t;
          let r = kl(n);
          if (o + 1 === s) {
            if (s <= e.length - 1) {
              i(e[s], r);
            }
          } else {
            const t = Pl(o, s);
            let a = 0;
            while (a === 0) {
              const e = Tl(n, r, t);
              n = e.startZOrder;
              a = e.zOrderStep;
              if (a === 0) {
                r += 10000;
                if (r === 0) {
                  r += 10000;
                }
              }
            }
            let l = o + 1;
            while (l <= s - 1) {
              const t = Cl(n + a);
              i(e[l], t);
              n = t;
              l++;
            }
            if (s <= e.length - 1) {
              i(e[s], r);
            }
          }
          n = r;
          o = s;
        }
      }
    }
    function Ml(e) {
      (function (e, t, i, s, o, n) {
        let r = null;
        const a = [];
        for (const o of e) {
          if (t(o)) {
            a.push(o);
            r = o;
          } else if (i(o) || s(o)) {
            a.push(o);
          }
        }
        a.sort(n);
        if (r !== null) {
          o(r, 0);
        }
        const l = r === null ? -1 : a.indexOf(r);
        if (l !== -1) {
          xl(a.slice(0, l), 0, o, i);
          Il(a.slice(l + 1), 0, o, i);
        } else {
          Il(a, 0, o, i);
        }
      })(e, pt.isMainSeriesState, pt.isStudyState, pt.isLineToolState, Sl, vl);
    }
    function Al(e, t) {
      const i = Math.floor(e / 10000);
      let s = t.get(i);
      if (s === undefined) {
        s = [];
        t.set(i, s);
      }
      return s;
    }
    function Ll(e, t, i, s, o, n) {
      let r = -Infinity;
      let a = Infinity;
      let l = -Infinity;
      let c = 0;
      const h = new Map();
      for (let s = 0; s < e.length; ++s) {
        const n = e[s];
        const d = o(n);
        if (t(n)) {
          r = Math.max(r, d);
          Al(d, h).push(n);
        } else if (i(n)) {
          if (d < 0) {
            a = Math.min(a, d);
            l = Math.max(l, d);
          }
          c = Math.max(c, d);
        }
      }
      if (n) {
        const e = Math.max(c, r);
        const t = Tl(e, kl(e), 1);
        return Cl(t.startZOrder + t.zOrderStep);
      }
      if (r === -Infinity) {
        const e = a === Infinity ? 0 : a;
        const t = Tl(Dl(e), e, 1);
        return Cl(t.startZOrder + t.zOrderStep);
      }
      const d = Tl(r, kl(r), 1);
      if (d.zOrderStep !== 0) {
        return Cl(d.startZOrder + d.zOrderStep);
      }
      const u = Al(r, h).sort((e, t) => o(e) - o(t));
      let _ = Dl(o(u[0]));
      const p = kl(_);
      const m = Tl(_, p, u.length + 1).zOrderStep;
      if (m !== 0) {
        u.forEach(e => {
          const t = Cl(_ + m);
          s(e, t);
          _ = t;
        });
        return Cl(_ + m);
      } else {
        return Cl(p + 5000);
      }
    }
    function kl(e) {
      const t = Math.ceil(e / 10000) * 10000;
      if (t === e) {
        return t + 10000;
      } else {
        return t;
      }
    }
    function Dl(e) {
      const t = Math.floor(e / 10000) * 10000;
      if (t === e) {
        return t - 10000;
      } else {
        return t;
      }
    }
    function El(e, t, i, s, o, n, r) {
      const a = t.length;
      const {
        newItems: l,
        movedItemsStartIndex: c
      } = i > 0 ? (0, ft.moveAfter)(e, t, i - 1) : (0, ft.moveBefore)(e, t, 0);
      let h = false;
      for (let t = c; t < c + a; t++) {
        if (l[t] !== e[t]) {
          h = true;
          break;
        }
      }
      if (!h) {
        return;
      }
      if (s(t[0])) {
        if (i < e.length && r(e[i]) < 0) {
          Il(l.slice(c + 1), 0, n, o);
        } else {
          xl(l.slice(0, c), 0, n, o);
        }
        return;
      }
      if (t.some(e => o(e))) {
        (function (e, t, i, s, o, n) {
          let r;
          let a;
          let l = -1;
          let c = -1;
          if (i === 0) {
            c = Bl(e, i + t, s);
            a = n(e[c]);
          } else if (i + t === e.length) {
            l = Vl(e, i - 1, s);
            r = n(e[l]);
          } else {
            l = Vl(e, i - 1, s);
            r = n(e[l]);
            c = Bl(e, i + t, s);
            a = n(e[c]);
          }
          if ((r === undefined || r < 0) && a !== undefined && a <= 0) {
            xl(e.slice(0, c), a, o, s);
          } else if ((a === undefined || a > 0) && r !== undefined && r >= 0) {
            Il(e.slice(l + 1), r, o, s);
          } else if (i + t < e.length - i) {
            xl(e.slice(0, i + t), n(e[i + t]), o, s);
          } else {
            Il(e.slice(i), n(e[i - 1]), o, s);
          }
        })(l, a, c, o, n, r);
      } else {
        (function (e, t, i, s, o, n, r) {
          let a;
          let l;
          if (i === 0) {
            l = r(e[i + t]);
          } else if (i + t === e.length) {
            a = r(e[i - 1]);
          } else {
            a = r(e[i - 1]);
            l = r(e[i + t]);
          }
          let c = 0;
          let h = 0;
          let d = 0;
          let u = 0;
          let _ = 0;
          if ((a === undefined || a < 0) && l !== undefined && l <= 0) {
            c = l;
            const e = Tl(c, a !== undefined ? a : Dl(l), t);
            c = e.startZOrder;
            _ = e.zOrderStep;
            d = i + t - 1;
            u = d - t;
            h = -1;
          } else if ((l === undefined || l > 0) && a !== undefined && a >= 0) {
            c = a;
            const e = Tl(c, l !== undefined ? l : kl(a), t);
            c = e.startZOrder;
            _ = e.zOrderStep;
            d = i;
            u = d + t;
            h = 1;
          }
          if (_ !== 0) {
            while (d !== u) {
              const t = Cl(c + h * _);
              n(e[d], t);
              c = t;
              d += h;
            }
          } else {
            const t = e.findIndex(e => o(e));
            if (t !== -1) {
              xl(e.slice(0, t), 0, n, s);
              Il(e.slice(t + 1), 0, n, s);
            } else {
              Il(e, 0, n, s);
            }
          }
        })(l, a, c, o, s, n, r);
      }
    }
    function Bl(e, t, i) {
      while (t < e.length && i(e[t])) {
        t++;
      }
      return Math.min(t, e.length - 1);
    }
    function Vl(e, t, i) {
      while (t >= 0 && i(e[t])) {
        t--;
      }
      return Math.max(0, t);
    }
    function Rl(e, t, i, s, o, n, r) {
      const a = e.indexOf(i) + 1;
      El(e, t, a, s, o, n, r);
    }
    function Nl(e, t, i, s, o, n, r) {
      const a = e.indexOf(i);
      El(e, t, a, s, o, n, r);
    }
    function Ol(e, t, i) {
      Rl(e, t, i, gl, yl, bl, wl);
    }
    function Fl(e, t, i) {
      Nl(e, t, i, gl, yl, bl, wl);
    }
    (function (e) {
      e[e.Bars = 0] = "Bars";
      e[e.Candles = 1] = "Candles";
      e[e.Line = 2] = "Line";
      e[e.Area = 3] = "Area";
      e[e.HeikenAshi = 8] = "HeikenAshi";
      e[e.HollowCandles = 9] = "HollowCandles";
      e[e.Baseline = 10] = "Baseline";
      e[e.HiLo = 12] = "HiLo";
      e[e.Column = 13] = "Column";
      e[e.LineWithMarkers = 14] = "LineWithMarkers";
      e[e.Stepline = 15] = "Stepline";
      e[e.HLCArea = 16] = "HLCArea";
      e[e.VolCandle = 19] = "VolCandle";
      e[e.HLCBars = 21] = "HLCBars";
      e[e.Renko = 4] = "Renko";
      e[e.Kagi = 5] = "Kagi";
      e[e.PointAndFigure = 6] = "PointAndFigure";
      e[e.LineBreak = 7] = "LineBreak";
    })(dl ||= {});
    (function (e) {
      e.Value = "_seriesId";
    })(ul ||= {});
    (function (e) {
      e[e.InvalidSymbol = 0] = "InvalidSymbol";
      e[e.ReplayUnsupported = 1] = "ReplayUnsupported";
      e[e.UnsupportedDepth = 2] = "UnsupportedDepth";
      e[e.UnsupportedIntradyReplay = 3] = "UnsupportedIntradyReplay";
    })(_l ||= {});
    (function (e) {
      e[e.MainSeriesZOrder = 0] = "MainSeriesZOrder";
      e[e.StudyBaseZOrder = 10000] = "StudyBaseZOrder";
      e[e.MaxFractionLength = 3] = "MaxFractionLength";
    })(pl ||= {});
    const Wl = new Di.TranslatedString("apply study template {template}", a.t(null, undefined, i(69604)));
    function Hl(e) {
      for (const t of e.panes) {
        for (const e of t.sources) {
          if ((0, pt.isMainSeriesState)(e)) {
            return e.id;
          }
        }
      }
      return null;
    }
    class zl extends tt.UndoCommand {
      constructor(e, t, i) {
        super(Wl.format({
          template: i
        }));
        this._newSymbolParams = {};
        this._model = e;
        this._templateContent = function (e, t) {
          const i = (0, Qe.default)({}, e);
          const s = (0, n.ensureNotNull)(Hl(i));
          for (const e of i.panes) {
            if (e.mainSourceId === s) {
              e.mainSourceId = t;
            }
            for (const i of e.sources) {
              if (i.id === s) {
                i.id = t;
                const o = e => {
                  const i = e.indexOf(s);
                  if (i !== -1) {
                    e.splice(i, 1, t);
                  }
                };
                if (e.leftAxisesState && e.rightAxisesState) {
                  e.leftAxisesState.forEach(e => o(e.sources));
                  e.rightAxisesState.forEach(e => o(e.sources));
                } else {
                  o(e.leftAxisSources);
                  o(e.rightAxisSources);
                }
                if (e.overlayPriceScales) {
                  const i = e.overlayPriceScales[s];
                  if (i) {
                    delete e.overlayPriceScales[s];
                    e.overlayPriceScales[t] = i;
                  }
                }
              } else if (i.ownerSource === s) {
                i.ownerSource = t;
              }
            }
          }
          return i;
        }(t, e.mainSeries().id());
        this._initialState = e.studyTemplate(true, true, true);
        const s = e.mainSeries();
        if (t.symbol) {
          this._newSymbolParams = {
            symbol: t.symbol,
            currency: t.currency ?? null,
            unit: t.unit ?? null
          };
        }
        if (t.interval) {
          this._newSymbolParams.interval = t.interval;
          this._newSymbolParams.style = (0, yt.getChartStyleByResolution)(t.interval, s.style());
        }
        this._initialSymbolParams = {
          symbol: s.symbol(),
          currency: s.currency(),
          unit: s.unit(),
          interval: s.interval(),
          style: s.style()
        };
        this._initialState = e.studyTemplate();
        this._initialGroupsState = e.lineToolsGroupModel().state();
      }
      redo() {
        this._model.mainSeries().setSymbolParams(this._newSymbolParams);
        const e = this._merge(this._templateContent).filter(eo.isLineTool);
        this._model.lineToolsGroupModel().removeLineTools(e);
        const t = this._model.mainSeries().properties();
        (0, yt.preparePriceAxisProperties)(t);
        this._model.recalcVisibleRangeStudies(Eo.RecalcVisibleRangeStudiesReason.StudyCreation);
        this._model.setShouldBeSavedEvenIfHidden(true);
      }
      undo() {
        this._model.mainSeries().setSymbolParams(this._initialSymbolParams);
        this._merge(this._initialState);
      }
      _merge(e) {
        const t = e.version || 0;
        const i = this._model;
        const s = i.mainSeries();
        (0, n.assert)(s.id() === Hl(e));
        s.priceScale().properties().childs().lockScale.setValue(false);
        const o = i.panes();
        const r = [];
        const a = e.panes.reduce((e, t) => {
          const i = t.sources.find(e => (0, pt.isMainSeriesState)(e));
          if (i && i.state && i.state.style === 18) {
            const e = i.state.tpoStyle.summary.visible;
            i.state.tpoStyle.summary.visible = false;
            return e;
          }
          return e;
        }, undefined) ?? false;
        if (s.style() === 18) {
          s.properties().childs().tpoStyle.childs().summary.childs().visible.setValue(false);
        }
        for (let e = o.length; e--;) {
          const t = o[e];
          const i = t.containsMainSeries();
          const s = t.dataSources();
          for (let e = s.length; e--;) {
            const t = s[e];
            if (!i || ((0, Js.isStudy)(t) || (0, Js.isStudyStub)(t)) && t.isRemovedByStudyTemplates()) {
              r.push(t);
            }
          }
        }
        i.resetDeferredStudies();
        const l = (0, ml.closeSourcesSet)(i, r);
        for (let e = 0; e < l.length; ++e) {
          i.removeSource(l[e]);
        }
        const c = e.panes;
        for (let e = 0; e < c.length; e++) {
          let s = -1;
          const n = (0, dt.clone)(c[e]);
          n.sources.sort((e, t) => e.zorder - t.zorder);
          for (let e = 0; e < n.sources.length; e++) {
            const t = n.sources[e];
            if ((0, pt.isMainSeriesState)(t)) {
              delete t.state;
              s = e;
              break;
            }
          }
          const r = s > -1;
          const a = r ? o[e] : i.createPane(e);
          if (r && t < 3) {
            Ml(n.sources);
          }
          a.restoreState({
            state: n,
            withData: false,
            version: t
          });
          if (a.mainDataSource() === null) {
            i.removePane(a);
          }
        }
        i.syncLollipopSources();
        s.priceScale().setMode({
          autoScale: true
        });
        if (s.style() === 18) {
          s.properties().childs().tpoStyle.childs().summary.childs().visible.setValue(a);
        }
        i.startNotStartedStudies();
        i.recalculateAllPanes((0, Bt.globalChangeEvent)());
        i.fullUpdate();
        return l;
      }
    }
    const Ul = (0, ae.getLogger)("Chart.ChartUndoModel");
    var jl;
    (function (e) {
      e[e.PasteYCoordOffset = -40] = "PasteYCoordOffset";
    })(jl ||= {});
    const Gl = new Di.TranslatedString("paste drawing", a.t(null, undefined, i(62192)));
    class ql extends tt.UndoCommand {
      constructor(e, t, i, s, o) {
        super(Gl, undefined, !$r.lineToolsDoNotAffectChartInvalidation);
        this._needCopyToOtherCharts = false;
        this._sourceState = null;
        this._model = e;
        this._clipboardData = t;
        this._paneIndex = this._model.panes().indexOf(i || (0, n.ensureNotNull)(this._model.paneForSource(this._model.mainSeries())));
        this._pasteWithData = !!s;
        this._keepZIndex = !!o;
      }
      redo() {
        const e = this._model.panes()[this._paneIndex];
        const t = (0, n.ensureNotNull)(e.clipboardLineToolOwnerSource(this._clipboardData.source.id));
        const i = t === this._model.mainSeries();
        if (this._sourceState === null) {
          this._sourceState = this._getSourceState(t, i);
        }
        const s = (0, n.ensureNotNull)(e.restoreLineTool(this._sourceState, this._pasteWithData, this._keepZIndex, undefined, t));
        (0, n.ensureNotNull)(t.priceScale()).addDataSource(s);
        if (this._clipboardData.centeredOnChart && s.centerPosition) {
          s.centerPosition();
        }
        s.restoreFixedPoint();
        s.createServerPoints();
        this._needCopyToOtherCharts = Boolean(i && s.isSynchronizable() && s.sharingMode().value() !== 0);
        this._model.setShouldBeSavedEvenIfHidden(true);
      }
      undo() {
        if (!this._sourceState) {
          Ul.logError("This command was never executed - nothing to undo");
          return;
        }
        const e = this.source();
        if (this._clipboardData.centeredOnChart) {
          this._clipboardData.centeredOnChart = false;
          this._sourceState.points = e.normalizedPoints();
        }
        this._model.removeSource(e);
      }
      source() {
        return (0, n.ensureNotNull)(this._model.dataSourceForId((0, n.ensureNotNull)(this._sourceState).id));
      }
      needCopyToOtherCharts() {
        return this._needCopyToOtherCharts;
      }
      _getSourceState(e, t) {
        const i = (0, dt.clone)(this._clipboardData.source);
        delete i.state.symbol;
        if (t) {
          if (i.linkKey != null || i.sharingMode !== undefined && i.sharingMode !== 0) {
            i.linkKey = (0, fe.randomHash)();
          }
        } else {
          i.linkKey = null;
          i.sharingMode = 0;
        }
        const s = (0, n.ensureNotNull)(e.priceScale());
        const o = this._model;
        const {
          symbol: r,
          currencyId: a,
          unitId: l
        } = this._clipboardData.source.state;
        const c = (0, n.ensureNotNull)(e.symbolSource());
        let h = false;
        if (!!c.symbolSameAsCurrent(r) && !(a !== null ? a !== (0, yt.symbolCurrency)(c.symbolInfo(), undefined, true) : c.isConvertedToOtherCurrency()) && !(l !== null ? l !== (0, yt.symbolUnit)(c.symbolInfo(), this._model.unitConversionEnabled()) : c.isConvertedToOtherUnit())) {
          if ((0, Nr.isActingAsSymbolSource)(e)) {
            h = true;
          } else if ((0, Js.isStudy)(e)) {
            h = Boolean(e.metaInfo().is_price_study);
          }
        }
        i.state.currencyId = o.currencyConversionEnabled() && c.isConvertedToOtherCurrency() ? c.currency() : null;
        i.state.unitId = o.unitConversionEnabled() && c.isConvertedToOtherUnit() ? c.unit() : null;
        const d = e => {
          const t = e.x * o.timeScale().width();
          const i = e.y * s.height() - 40;
          return new At.Point(t, i);
        };
        const u = (0, n.ensureNotNull)(e.firstValue());
        if (this._model.id() === this._clipboardData.modelId || !h) {
          for (let e = 0; e < this._clipboardData.geometry.length; ++e) {
            const t = d(this._clipboardData.geometry[e]);
            const n = o.timeScale().coordinateToIndex(t.x);
            const r = o.timeScale().normalizeBarIndex(n);
            if (h) {
              const t = s.priceToCoordinate(i.points[e].price, u) + -40;
              r.price = s.coordinateToPrice(t, u);
            } else {
              r.price = s.coordinateToPrice(t.y, u);
            }
            i.points[e] = r;
          }
          i.state.interval = o.mainSeries().interval();
        }
        i.id = (0, fe.randomHashN)(6);
        return i;
      }
    }
    class $l extends tt.UndoCommand {
      constructor(e, t, i, s) {
        super(s);
        this._newSourcesCurrencies = new Map();
        this._oldSourcesCurrencies = new Map();
        this._showFade = false;
        this._chartModel = e;
        const o = e.mainSeries();
        for (const e of t.seriesLikeSources()) {
          if (!e.isVisible() || !e.isActingAsSymbolSource().value()) {
            continue;
          }
          const t = i || (0, yt.symbolOriginalCurrency)((0, n.ensureNotNull)(e.symbolInfo()));
          this._newSourcesCurrencies.set(e.id(), t);
          this._oldSourcesCurrencies.set(e.id(), e.currency());
          this._showFade = this._showFade || e === o && e.currency() !== t;
        }
      }
      redo() {
        this._applyCurrencies(this._newSourcesCurrencies);
      }
      undo() {
        this._applyCurrencies(this._oldSourcesCurrencies);
      }
      _applyCurrencies(e) {
        e.forEach((e, t) => {
          (0, n.ensureNotNull)(this._chartModel.dataSourceForId(t)).setCurrency(e);
        });
        this._chartModel.selectionMacro(e => {
          e.clearSelection();
        });
        if (this._showFade) {
          this._chartModel.undoModel().loadingScreen().show(true);
        }
      }
    }
    class Kl extends tt.UndoCommand {
      constructor(e, t, i, s) {
        super(s);
        this._newSourcesUnits = new Map();
        this._oldSourcesUnits = new Map();
        this._showFade = false;
        this._chartModel = e;
        const o = e.mainSeries();
        for (const e of t.seriesLikeSources()) {
          if (!e.isVisible() || !e.isActingAsSymbolSource().value()) {
            continue;
          }
          const t = i || (0, yt.symbolOriginalUnit)((0, n.ensureNotNull)(e.symbolInfo()), this._chartModel.unitConversionEnabled());
          this._newSourcesUnits.set(e.id(), t);
          this._oldSourcesUnits.set(e.id(), e.unit());
          this._showFade = this._showFade || e === o && e.unit() !== t;
        }
      }
      redo() {
        this._applyUnits(this._newSourcesUnits);
      }
      undo() {
        this._applyUnits(this._oldSourcesUnits);
      }
      _applyUnits(e) {
        e.forEach((e, t) => {
          (0, n.ensureNotNull)(this._chartModel.dataSourceForId(t)).setUnit(e);
        });
        this._chartModel.selectionMacro(e => {
          e.clearSelection();
        });
        if (this._showFade) {
          this._chartModel.undoModel().loadingScreen().show(true);
        }
      }
    }
    class Yl extends Qr {
      constructor(e, t, i, s) {
        super(e, t, s);
        this._sourcePaneRemoved = false;
        this._targetPaneIndex = e.panes().indexOf(i);
      }
      redo() {
        const e = this._chartModel.panes()[this._initialPaneIndex];
        const t = this._chartModel.panes()[this._targetPaneIndex];
        const i = e !== t;
        const s = this._targetPriceScale(t);
        const o = (0, n.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId));
        const r = this._chartModel.children(o, true);
        for (const e of r) {
          if (i) {
            this._chartModel.detachSource(e);
            t.addDataSource(e, s, false);
          } else {
            t.move(e, s);
          }
        }
        if (i) {
          this._sourcePaneRemoved = this._chartModel.detachSource(o);
          t.addDataSource(o, s, false);
        } else {
          t.move(o, s);
        }
        const a = t.priceScalePosition(s);
        t.movePriceScale(s, a, this._targetPriceScaleIndex(o));
        this._chartModel.fullUpdate();
      }
      undo() {
        if (this._sourcePaneRemoved) {
          this._chartModel.createPane(this._initialPaneIndex);
        }
        const e = this._chartModel.panes()[this._initialPaneIndex];
        const t = e !== this._chartModel.panes()[this._targetPaneIndex];
        const i = (0, n.ensureNotNull)(this._chartModel.dataSourceForId(this._sourceId));
        let s = e.getPriceScaleById(this._initialPriceScaleId);
        if (s === null) {
          s = e.createPriceScaleAtPosition(this._initialPriceScalePosition, this._initialPriceScaleIndex);
        }
        const o = this._chartModel.children(i, true);
        for (const i of o) {
          if (t) {
            this._chartModel.detachSource(i);
            e.addDataSource(i, s, false);
          } else {
            e.move(i, s);
          }
        }
        if (t) {
          this._chartModel.detachSource(i);
          e.addDataSource(i, s, false);
        } else {
          e.move(i, s);
        }
        const r = (0, n.ensureNotNull)(i.priceScale());
        r.restoreState(this._originalPriceScaleState());
        r.setHeight(e.height());
        this._chartModel.fullUpdate();
      }
    }
    class Zl extends Yl {
      constructor(e, t, i, s, o) {
        super(e, t, i, o);
        this._targetPriceScalePosition = s;
      }
      _targetPriceScale(e) {
        const t = e.createPriceScaleAtPosition(this._targetPriceScalePosition);
        t.restoreState(this._newPriceScaleState(this._targetPriceScalePosition === "overlay"));
        t.setHeight(e.height());
        return t;
      }
      _targetPriceScaleIndex(e) {
        if (e === this._chartModel.mainSeries()) {
          return 0;
        } else {
          return undefined;
        }
      }
    }
    class Xl extends Yl {
      constructor(e, t, i, s, o) {
        super(e, t, i, o);
        this._targetPriceScaleId = s.id();
      }
      _targetPriceScale(e) {
        return (0, n.ensureNotNull)(e.getPriceScaleById(this._targetPriceScaleId));
      }
      _targetPriceScaleIndex(e) { }
    }
    class Jl extends tt.UndoCommand {
      constructor(e, t, i, s) {
        super(e);
        this._charts = new Map();
        this._firstRedo = true;
        this._creationTime = performance.now();
        this._linkingGroupIndex = s.linkingGroupIndex().value();
        this._charts.set(s, {
          sourceId: t.id(),
          newSymbolParams: i,
          prevSymbolParams: t.symbolParams(),
          showFade: this._showFade(t, s),
          chartWidget: s
        });
      }
      redo() {
        if (!this._firstRedo) {
          (0, ki.muteLinkingGroup)(this._linkingGroupIndex, true);
        }
        this._charts.forEach(e => {
          const t = this._symbolSource(e).setSymbolParams(e.newSymbolParams);
          if (e.showFade) {
            e.chartWidget.screen.show(true, t);
          }
        });
        if (!this._firstRedo) {
          (0, ki.muteLinkingGroup)(this._linkingGroupIndex, false);
        }
        this._firstRedo = false;
      }
      undo() {
        (0, ki.muteLinkingGroup)(this._linkingGroupIndex, true);
        this._charts.forEach(e => {
          const t = this._symbolSource(e).setSymbolParams(e.prevSymbolParams);
          if (e.showFade) {
            e.chartWidget.screen.show(true, t);
          }
        });
        (0, ki.muteLinkingGroup)(this._linkingGroupIndex, false);
      }
      canMerge(e) {
        if (!(e instanceof Jl) || e._linkingGroupIndex !== this._linkingGroupIndex || !this._containsMainSeriesOnly() || !e._containsMainSeriesOnly() || e._creationTime - this._creationTime > 500) {
          return false;
        }
        for (const [t] of e._charts) {
          if (this._charts.has(t)) {
            return false;
          }
        }
        return true;
      }
      merge(e) {
        if (e instanceof Jl) {
          for (const [t, i] of e._charts) {
            this._charts.set(t, i);
          }
        }
      }
      _showFade(e, t) {
        return e === t.model().mainSeries();
      }
      _symbolSource(e) {
        return (0, n.ensureNotNull)(e.chartWidget.model().model().dataSourceForId(e.sourceId));
      }
      _containsMainSeriesOnly() {
        for (const [e, t] of this._charts) {
          if (t.sourceId !== e.model().mainSeries().id()) {
            return false;
          }
        }
        return true;
      }
    }
    const Ql = new Di.TranslatedString("change symbol", a.t(null, undefined, i(35400)));
    class ec extends Jl {
      constructor(e, t, i) {
        super(Ql, e, {
          symbol: t,
          currency: null,
          unit: null
        }, i);
        this._symbol = t;
      }
      canMerge(e) {
        return e instanceof ec && e._symbol === this._symbol && super.canMerge(e);
      }
    }
    const tc = (0, ae.getLogger)("Chart.ChartUndoModel");
    const ic = new Di.TranslatedString("paste indicator", a.t(null, undefined, i(1064)));
    class sc extends tt.UndoCommand {
      constructor(e, t, i) {
        super(ic);
        this._sourceState = null;
        this._model = e;
        this._clipboardData = t;
        this._paneId = i;
      }
      redo() {
        if (!this._sourceState) {
          const e = (0, dt.clone)(this._clipboardData.source);
          e.id = (0, fe.randomHashN)(6);
          this._sourceState = e;
        }
        let e;
        let t;
        e = this._paneId ? (0, n.ensureNotNull)(this._model.paneForId(this._paneId)) : this._sourceState.metaInfo.is_price_study ? (0, n.ensureNotNull)(this._model.paneForSource(this._model.mainSeries())) : this._model.createPane();
        const i = !e.mainDataSource();
        this._sourceState.zorder = e.newStudyZOrder();
        const s = (0, n.ensureNotNull)(e.restoreStudy(this._sourceState, false));
        if (!i) {
          t = this._sourceState.metaInfo.is_price_study ? t = this._model.mainSeries().priceScale() : this._paneId ? e.findSuitableScale(s) : e.defaultPriceScale();
          if (t !== s.priceScale()) {
            e.move(s, t);
          }
        }
        if ((0, Js.isStudy)(s)) {
          s.start();
        }
      }
      undo() {
        if (this._sourceState === null) {
          tc.logError("This command was never executed - nothing to undo");
          return;
        }
        const e = (0, n.ensureNotNull)(this._model.dataSourceForId(this._sourceState.id));
        this._model.removeSource(e);
      }
      state() {
        return this._sourceState;
      }
    }
    class oc extends tt.UndoCommand {
      constructor(e, t, i, s, o) {
        super(null, false);
        this._model = e;
        this._paneA = t;
        this._paneB = i;
        this._prevStretchA = s;
        this._currStretchA = o;
      }
      redo() {
        const e = this._paneA.stretchFactor() + this._paneB.stretchFactor();
        this._paneA.setStretchFactor(this._currStretchA);
        this._paneB.setStretchFactor(e - this._currStretchA);
        this._model.fullUpdate();
      }
      undo() {
        const e = this._paneA.stretchFactor() + this._paneB.stretchFactor();
        this._paneA.setStretchFactor(this._prevStretchA);
        this._paneB.setStretchFactor(e - this._prevStretchA);
        this._model.fullUpdate();
      }
    }
    const nc = new Di.TranslatedString("move", a.t(null, undefined, i(98277)));
    class rc extends tt.UndoCommand {
      constructor(e, t, i, s) {
        super(nc, false);
        this._endEvent = null;
        this._model = e;
        this._sourceId = t.id();
        this._itemIndex = i;
        this._startEvent = s;
      }
      move(e) {
        this._endEvent = e;
        this._move(e);
      }
      hasChanges() {
        return this._endEvent !== null;
      }
      undo() {
        this._move(this._startEvent);
      }
      redo() {
        this._move((0, n.ensureNotNull)(this._endEvent));
      }
      _move(e) {
        const t = (0, n.ensureNotNull)(this._model.dataSourceForId(this._sourceId));
        (0, n.assert)(t.moveItem !== undefined, "The method \"moveItem\" is not defined");
        if (t.moveItem) {
          t.moveItem(new At.Point(e.localX, e.localY), this._itemIndex, new Bo.EnvironmentState(e));
        }
      }
    }
    class ac extends tt.UndoCommand {
      constructor(e) {
        const {
          chartModel: t,
          studyMetaInfo: i,
          inputs: s,
          props: o,
          addAsOverlay: n,
          parentSources: r,
          preferredPriceScale: a,
          allowChangeCurrency: l,
          allowChangeUnit: c,
          paneSize: h,
          targetZOrder: d,
          studyId: u,
          targetScaleMode: _,
          undoText: p
        } = e;
        super(p ?? null);
        this._paneState = null;
        this._studyInserResult = null;
        this._additionalStudiesInsertResults = [];
        this._chartModel = t;
        this._studyMetaInfo = i;
        this._props = o;
        this._addAsOverlay = n;
        this._parentIds = r.map(e => e.id());
        this._inputs = s;
        this._targetZOrder = d;
        this._preferredPriceScale = a;
        this._allowChangeCurrency = l;
        this._allowChangeUnit = c;
        this._paneSize = h;
        this._studyId = u ?? null;
        this._targetScaleMode = _ ?? null;
      }
      redo() {
        const e = this._parentIds.map(e => this._chartModel.dataSourceForId(e));
        this._studyInserResult = this._chartModel.insertStudyWithParams(this._studyMetaInfo, this._inputs, this._targetZOrder, this._props, this._addAsOverlay, e, this._preferredPriceScale, this._allowChangeCurrency, this._allowChangeUnit, this._paneSize, this._targetScaleMode ?? undefined, this._studyId ?? undefined);
        this._studyInserResult.study.then(e => {
          this._studyId = e.id();
          e.childStudyByRebind().subscribe(null, () => (0, ne.trackEvent)("SOS", "Apply SOS", "Rebind SOS"));
          this._chartModel.setShouldBeSavedEvenIfHidden(true);
          if (this._paneState !== null) {
            (0, n.ensureNotNull)(this._chartModel.paneForSource(e)).restoreState({
              state: this._paneState,
              withData: false,
              version: this._chartModel.version()
            });
            this._paneState = null;
          }
        });
      }
      undo() {
        const e = (0, n.ensureNotNull)(this._studyInserResult);
        const t = e.entityId();
        let i = null;
        let s = null;
        if (t !== null) {
          i = (0, n.ensureNotNull)(this._chartModel.dataSourceForId(t));
          const o = e.originalScaleMode();
          if (o !== null) {
            i.priceScale()?.setMode(o);
          }
          if ((0, Nr.isSymbolSource)(i)) {
            i.symbolResolved().unsubscribeAll(this);
          }
          s = (0, n.ensureNotNull)(this._chartModel.paneForSource(i)).state();
        } else {
          e.cancel();
        }
        this._studyInserResult?.cancel();
        for (const e of this._additionalStudiesInsertResults) {
          const t = e.entityId();
          if (t !== null) {
            this._chartModel.removeSource((0, n.ensureNotNull)(this._chartModel.dataSourceForId(t)));
          } else {
            e.cancel();
          }
        }
        this._additionalStudiesInsertResults = [];
        if (i !== null && this._chartModel.removeSource(i)) {
          this._paneState = s;
        }
      }
      insertedStudy() {
        return (0, n.ensureNotNull)(this._studyInserResult);
      }
      _createCopiesOfNewFundamentalForAllStocks(e) { }
      _createCopiesOfExistingFundamentalsForNewStock(e) { }
    }
    class lc extends tt.UndoCommand {
      constructor(e, t, i, s) {
        super(i);
        this._newMode = e;
        this._priceScaleId = t.id();
        this._model = s;
        this._oldMode = t.mode();
      }
      redo() {
        this._applyMode(this._newMode);
      }
      undo() {
        this._applyMode(this._oldMode);
      }
      _applyMode(e) {
        const t = this._findPriceScaleById();
        if (t !== null) {
          (0, li.allowSavingDefaults)(true);
          t.setMode(e);
          (0, li.allowSavingDefaults)(false);
          if (this._model) {
            this._model.recalculateAllPanes((0, Bt.viewportChangeEvent)());
            this._model.lightUpdate();
          }
        }
      }
      _findPriceScaleById() {
        const e = this._model.panes();
        for (let t = 0; t < e.length; t++) {
          const i = e[t].getPriceScaleById(this._priceScaleId);
          if (i !== null) {
            return i;
          }
        }
        return null;
      }
    }
    var cc = i(90484);
    var hc = i(90054);
    var dc = i(11417);
    var uc = i(59769);
    const _c = ["color-sky-blue-400", "color-banana-yellow-700", "color-deep-blue-500", "color-grapes-purple-a700", "color-iguana-green-500", "color-minty-green-a600", "color-ripe-red-a200", "color-berry-pink-200", "color-tv-blue-a100", "color-tan-orange-a200", "color-sky-blue-a400", "color-deep-blue-a100", "color-grapes-purple-400", "color-iguana-green-a700", "color-minty-green-200", "color-ripe-red-200", "color-berry-pink-a200", "color-ripe-red-500", "color-grapes-purple-500", "color-deep-blue-400", "color-tv-blue-a200", "color-sky-blue-500", "color-iguana-green-400", "color-minty-green-400", "color-banana-yellow-600", "color-tan-orange-500", "color-berry-pink-400", "color-ripe-red-300", "color-grapes-purple-300", "color-deep-blue-300", "color-tv-blue-300", "color-sky-blue-300", "color-iguana-green-300", "color-minty-green-300", "color-banana-yellow-400", "color-tan-orange-300", "color-berry-pink-300", "color-tan-orange-a700"];
    const pc = ["color-berry-pink-a700", "color-grapes-purple-a700", "color-deep-blue-a400", "color-iguana-green-a700", "color-ripe-red-a400", "color-minty-green-a400", "color-berry-pink-a200", "color-tv-blue-a100", "color-tan-orange-a200", "color-sky-blue-a400", "color-deep-blue-a200", "color-grapes-purple-a100", "color-iguana-green-a400", "color-ripe-red-a100"];
    class mc {
      constructor(e, t = _c) {
        this._userDefaultUsed = false;
        this._calcColorOffset = e;
        this._colors = t;
      }
      getColor(e, t = false) {
        const i = this._calcColorOffset();
        if (i === 0) {
          this._userDefaultUsed = false;
        }
        if (i === 0 && !t) {
          this._userDefaultUsed = true;
          return e;
        }
        const s = this._colors[(i - (this._userDefaultUsed ? 1 : 0)) % this._colors.length];
        const o = Lt.colorsPalette[s];
        const n = (0, Is.isHexColor)(e) ? 1 : (0, kt.parseRgba)(e)[3];
        return (0, Is.generateColor)(o, (0, Is.alphaToTransparency)(n));
      }
    }
    class gc {
      constructor(e, t) {
        this._calcColorOffset = e;
        this._modelStartOffset = t;
      }
      getColor(e) {
        const t = this._calcColorOffset();
        if ((0, Is.isHexColor)(e)) {
          const i = (0, kt.parseRgb)(e);
          return (0, kt.rgbToHexString)((0, kt.shiftRgb)(i, t, this._modelStartOffset));
        }
        {
          const i = (0, kt.parseRgba)(e);
          return (0, kt.rgbaToString)((0, kt.shiftRgba)(i, t, this._modelStartOffset));
        }
      }
    }
    class fc {
      constructor(e) {
        this._rotators = new WeakMap();
        this._calcDefaultColorsOffset = e => {
          const t = (0, Js.useSameColorRotationComparator)(e);
          return this._chartModel.dataSources().filter(i => (0, Js.isStudy)(i) && t(e, i.metaInfo())).length;
        };
        this._chartModel = e;
      }
      getColorRotator(e) {
        if (this._rotators.has(e)) {
          const t = this._rotators.get(e);
          if (t !== undefined) {
            return t;
          }
        }
        const t = this._createColorRotator(e);
        this._rotators.set(e, t);
        return t;
      }
      _createColorRotator(e) {
        const t = () => this._calcDefaultColorsOffset(e);
        switch ((0, Js.studyColorRotationMode)(e)) {
          case "sexyColors":
            return new mc(t, pc);
          case "loop":
            return new mc(t);
          case "shift":
            return new gc(t, this._chartModel.getStudyShiftColorStartOffset());
          case null:
          case "noRotations":
            return null;
        }
      }
    }
    function yc(e) {
      return (0, eo.isLineTool)(e) && e.boundToSymbol() || false;
    }
    class vc {
      constructor() {
        this._items = [];
        this._set = new Set();
        this._dataSourcesCache = null;
        this._customSourcesCache = null;
        this._lineSourcesCache = null;
      }
      isEmpty() {
        return this._items.length === 0;
      }
      add(e) {
        if (this._items.length > 0 && !yc(this._items[0])) {
          this.clear();
        }
        if (yc(e)) {
          const t = (0, ft.lowerbound)(this._items, e, (e, t) => e.zorder() < t.zorder());
          this._items.splice(t, 0, e);
        } else {
          this.clear();
          this._items = [e];
        }
        this._set.add(e);
        this._invalidateCache();
      }
      canBeAddedToSelection(e) {
        return this._items.length === 0 || yc(this._items[0]) && yc(e);
      }
      isSelected(e) {
        return this._set.has(e);
      }
      allSources() {
        return this._items.slice(0);
      }
      dataSources() {
        if (this._dataSourcesCache === null) {
          this._dataSourcesCache = this._items.filter(Vo.isDataSource);
        }
        return this._dataSourcesCache;
      }
      lineDataSources() {
        if (this._lineSourcesCache === null) {
          this._lineSourcesCache = this._items.filter(eo.isLineTool);
        }
        return this._lineSourcesCache;
      }
      customSources() {
        if (this._customSourcesCache === null) {
          this._customSourcesCache = this._items.filter(e => !(0, Vo.isDataSource)(e));
        }
        return this._customSourcesCache;
      }
      checkLineToolSelection() {
        this._items.forEach(e => (0, eo.isLineTool)(e) && e.calcIsActualSymbol());
        this._items = this._items.filter(e => !(0, eo.isLineTool)(e) || e.isActualSymbol());
        this._invalidateCache();
      }
      remove(e) {
        this._items = this._items.filter(t => t !== e);
        this._set.delete(e);
        this._invalidateCache();
      }
      clear() {
        this._items = [];
        this._set.clear();
        this._invalidateCache();
      }
      _invalidateCache() {
        this._customSourcesCache = null;
        this._dataSourcesCache = null;
        this._lineSourcesCache = null;
      }
    }
    var Sc;
    var bc;
    var wc = i(21239);
    var Cc = i(17534);
    (function (e) {
      e[e.BorderSize = 1] = "BorderSize";
    })(Sc ||= {});
    (function (e) {
      e[e.AdditionalInnerPadding = 4] = "AdditionalInnerPadding";
      e[e.HorzPadding = 4] = "HorzPadding";
      e[e.VertPadding = 2.5] = "VertPadding";
      e[e.LineSpacing = 2] = "LineSpacing";
    })(bc ||= {});
    class Pc {
      constructor(e) {
        this._rendererOptions = {
          borderSize: 1,
          additionalPaddingInner: 0,
          fontSize: NaN,
          font: "",
          color: "",
          paneBackgroundColor: "",
          paddingBottom: 0,
          paddingInner: 0,
          paddingOuter: 0,
          paddingTop: 0,
          lineSpacing: 0
        };
        this._chartModel = e;
      }
      options() {
        const e = this._rendererOptions;
        const t = this._chartModel.properties().childs();
        const i = t.scalesProperties.childs().fontSize.value();
        if (e.fontSize !== i) {
          e.fontSize = i;
          e.font = (0, Yt.makeFont)(i, g.CHART_FONT_FAMILY, "");
          e.paddingTop = i / 12 * 2.5;
          e.paddingBottom = i / 12 * 2.5;
          e.paddingInner = i / 12 * 4;
          e.additionalPaddingInner = i / 12 * 4;
          e.paddingOuter = i / 12 * 4;
          e.lineSpacing = i / 12 * 2;
        }
        e.color = t.scalesProperties.childs().textColor.value();
        e.paneBackgroundColor = t.paneProperties.childs().background.value();
        return this._rendererOptions;
      }
    }
    class Tc {
      constructor(e, t) {
        this._destroyed = false;
        this._callbacks = [];
        this._resource = {
          pendingResource: e
        };
        e.then(e => {
          if (this._destroyed) {
            this._destroyFn?.(e);
          } else {
            for (const t of this._callbacks) {
              t(e);
            }
            this._resource.resource = e;
          }
        }).finally(() => {
          this._callbacks = [];
        });
      }
      destroy() {
        if (this._resource.resource) {
          this._destroyFn?.(this._resource.resource);
        }
        this._resource = {
          pendingResource: Promise.reject("Resource is destroyed").catch(() => { })
        };
        this._callbacks = [];
        this._destroyed = true;
      }
      callFunction(e) {
        if (!this._destroyed) {
          if (this._resource.resource) {
            e(this._resource.resource);
          } else {
            this._callbacks.push(e);
          }
        }
      }
      get() {
        if (this._destroyed || !this._resource.resource) {
          return null;
        } else {
          return this._resource.resource;
        }
      }
      promise() {
        return this._resource.pendingResource;
      }
    }
    var xc = i(6290);
    const Ic = (0, li.extractThemedColors)(xs.lightTheme.content.sessions, xs.darkTheme.content.sessions);
    class Mc extends li.DefaultProperty {
      constructor(e) {
        super({
          defaultName: "sessions",
          themedColors: Ic,
          excludedDefaultsKeys: ["graphics"],
          excludedStateKeys: ["graphics"],
          excludedTemplateKeys: ["graphics"]
        });
        this._symbolInfo = e;
        this._symbolInfo.subscribe(() => this._updateGraphicsProps());
        if (!this.hasChild("graphics")) {
          this.addProperty("graphics", {});
        }
        this._updateGraphicsProps();
        this.childs().sessionHighlight.subscribe(this, () => {
          this._updateGraphicsProps();
        });
      }
      destroy() {
        this._symbolInfo.release();
        super.destroy();
      }
      restoreState(e) {
        const t = e.properties;
        (function (e) {
          const t = "graphics" in e ? e.graphics.backgrounds : undefined;
          if (t !== undefined) {
            const i = (0, n.ensureDefined)(t.outOfSession);
            if (i.color === xc.sessionsPreferencesDefault.sessionHighlight.backgrounds.outOfSession.color || "postMarket" in t) {
              e.sessionHighlight = e.sessionHighlight ?? {};
              e.sessionHighlight.backgrounds = t;
            } else {
              const t = "visible" in i ? i.visible : undefined;
              e.sessionHighlight = e.sessionHighlight ?? {};
              e.sessionHighlight.backgrounds = {
                ...(e.sessionHighlight?.backgrounds ?? {}),
                postMarket: {
                  color: i.color,
                  transparency: i.transparency,
                  visible: t ?? e.sessionHighlight.backgrounds.preMarket.visible
                },
                preMarket: {
                  color: i.color,
                  transparency: i.transparency,
                  visible: t ?? e.sessionHighlight.backgrounds.postMarket.visible
                }
              };
              if ("visible" in i) {
                e.sessionHighlight.backgrounds.preMarket.visible = i.visible;
                e.sessionHighlight.backgrounds.postMarket.visible = i.visible;
              }
            }
          }
          const i = "graphics" in e ? e.graphics.vertlines : undefined;
          if (i) {
            e.sessionHighlight = e.sessionHighlight ?? {};
            e.sessionHighlight.vertlines = i;
          }
        })(t);
        if ("graphics" in e.properties) {
          (0, Qe.default)(e.properties.sessionHighlight, e.properties.graphics);
          delete e.properties.graphics;
        }
        this.mergeAndFire(t);
        this.removeDuplicateProperties();
      }
      loadThemeState(e) {
        if ("graphics" in e) {
          (0, Qe.default)(e.sessionHighlight, e.graphics);
          delete e.graphics;
        }
        this.mergeAndFire(e);
      }
      removeDuplicateProperties() {
        if (this.hasChild("properties")) {
          this.removeProperty("properties");
          (0, li.allowSavingDefaults)(true);
          this.fireChanged();
          (0, li.allowSavingDefaults)(false);
        }
      }
      _userSettings() {
        const e = super._userSettings();
        if (e && !e.sessionHighlight) {
          e.sessionHighlight = e.graphics;
        }
        delete e?.graphics;
        return e;
      }
      _updateGraphicsProps() {
        this.childs().graphics.mergeAndFire(this.childs().sessionHighlight.state());
        if (this._symbolInfo.value()?.type === "futures") {
          (0, n.ensureDefined)(this.childs().graphics.childs().backgrounds).childs().preMarket.mergeAndFire(this.childs().sessionHighlight.childs().backgrounds.childs().electronic.state());
        }
      }
    }
    class Ac extends Tc {
      constructor(e, t, i) {
        super(e, e => e.destroy());
        this._sessionsStateData = null;
        this._model = t;
        this._properties = i;
        t.mainSeries().sessionIdProxyProperty().subscribe(this, this._updateVisibleOfPreAndPostMarketBackground);
        t.mainSeries().dataEvents().symbolResolved().subscribe(this, this._updateVisibleOfPreAndPostMarketBackground);
        this._updateVisibleOfPreAndPostMarketBackground();
        e.then(e => {
          if (!this._destroyed && this._sessionsStateData) {
            e.restoreStateData(this._sessionsStateData);
            this._sessionsStateData = null;
          }
        });
      }
      destroy() {
        this._model.mainSeries().sessionIdProxyProperty().unsubscribeAll(this);
        this._model.mainSeries().dataEvents().symbolResolved().unsubscribeAll(this);
        super.destroy();
      }
      properties() {
        return this._properties;
      }
      applyOverrides(e) {
        (0, h.applyPropertiesOverrides)(this._properties.childs().sessionHighlight, undefined, false, e, "sessions");
        const t = this.get();
        if (t) {
          this._model.updateSource(t);
        }
      }
      state(e) {
        const t = {
          properties: this._properties.state()
        };
        if (e) {
          t.data = this.get()?.stateData() ?? this._sessionsStateData ?? undefined;
        }
        return t;
      }
      restoreState(e, t) {
        if (e.oldState) {
          e = function (e, t) {
            const i = {
              properties: {
                graphics: e.state.graphics
              }
            };
            if (e.data !== undefined && e.metaInfo !== undefined && t) {
              i.data = {
                metaInfo: e.metaInfo,
                graphics: e.data.graphics
              };
            }
            return i;
          }(e, t);
        }
        this._properties.restoreState(e);
        this._updateVisibleOfPreAndPostMarketBackground();
        this._sessionsStateData = null;
        if (e.data !== undefined && t) {
          const t = this.get();
          if (t) {
            t.restoreStateData(e.data);
          } else {
            this._sessionsStateData = e.data;
          }
        }
      }
      _updateVisibleOfPreAndPostMarketBackground() {
        const e = this._model.mainSeries().sessionIdProxyProperty().value();
        const t = this._model.mainSeries().symbolInfo();
        if (t) {
          const i = !(0, yt.isRegularSessionId)(e, t) && t.type !== "futures";
          const s = this._properties.childs().sessionHighlight.childs().backgrounds.childs();
          s.electronic.childs().visible.setValue(i);
          s.outOfSession.childs().visible.setValue(i);
          s.preMarket.childs().visible.setValue(i);
          s.postMarket.childs().visible.setValue(i);
        }
      }
    }
    const Lc = "symbolWatermark";
    const kc = {
      visibility: false,
      color: "rgba(80, 83, 94, 0.25)"
    };
    function Dc() {
      const e = d.getJSON(Lc);
      return Object.assign({}, kc, e);
    }
    const Ec = (0, s.default)(() => {
      const e = new Rs.Property(Dc());
      d.onSync.subscribe(null, () => e.mergeAndFire(Dc()));
      e.subscribe(null, () => d.setJSON(Lc, e.state()));
      return e;
    });
    var Bc = i(22365);
    var Vc = i(24708);
    var Rc = i(75919);
    class Nc extends Rc.MediaCoordinatesPaneRenderer {
      constructor() {
        super(...arguments);
        this._data = null;
        this._widthCache = new Gt.TextWidthCache();
      }
      setData(e) {
        this._data = e;
      }
      hitTest(e) {
        return null;
      }
      _drawImpl(e) {
        if (!this._data) {
          return;
        }
        const {
          lines: t,
          color: i
        } = this._data;
        const {
          context: s,
          mediaSize: {
            width: o,
            height: n
          }
        } = e;
        s.fillStyle = i;
        let r = 0;
        const a = [];
        for (const e of t) {
          if (!e.text) {
            continue;
          }
          s.font = e.font;
          const t = this._widthCache.measureText(s, e.text);
          const i = t > o ? o / t : 1;
          a.push(i);
          r += e.lineHeight * i;
        }
        let l = Math.max((n - r) / 2, 0);
        let c = -1;
        for (const e of t) {
          if (!e.text) {
            continue;
          }
          c += 1;
          const t = a[c];
          s.save();
          s.translate(o / 2, l);
          s.textBaseline = "top";
          s.textAlign = "center";
          s.font = e.font;
          s.scale(t, t);
          s.fillText(e.text, 0, e.vertOffset);
          s.restore();
          l += e.lineHeight * t;
        }
      }
    }
    class Oc {
      constructor(e, t) {
        this._renderer = new Nc();
        this._invalidated = true;
        this._model = e;
        this._watermark = t;
      }
      update() {
        this._invalidated = true;
      }
      renderer() {
        if (this._invalidated) {
          this._updateImpl();
        }
        return this._renderer;
      }
      _updateImpl() {
        const e = this._watermark.properties().childs();
        const t = this._model.mainSeries();
        const i = t.symbolInfo();
        if (!i || !e.visibility.value()) {
          this._renderer.setData(null);
          return;
        }
        let s;
        {
          const e = this._model.watermarkContentProvider();
          const o = e ? e({
            symbolInfo: i,
            interval: t.interval()
          }) : null;
          s = o ? o.map(e => ({
            text: e.text,
            font: (0, Yt.makeFont)(e.fontSize, g.CHART_FONT_FAMILY),
            lineHeight: e.lineHeight,
            vertOffset: e.vertOffset
          })) : null;
        }
        let o = i.name;
        if (/QUANDL/.test(i.exchange)) {
          const e = o.split(/\//);
          if (e.length) {
            o = e[e.length - 1];
          }
        }
        const n = {
          description: i.description,
          short_description: i.short_description,
          pro_name: i.pro_name,
          short_name: i.name,
          local_description: i.local_description,
          language: i.language
        };
        const r = s || [{
          text: o ? `${o}, ${(0, Vc.translatedIntervalString)(t.interval())}` : "",
          font: (0, Yt.makeFont)(96, g.CHART_FONT_FAMILY),
          lineHeight: 117,
          vertOffset: 0
        }, {
          text: (0, Bc.getTranslatedSymbolDescription)(n) || "",
          font: (0, Yt.makeFont)(48, g.CHART_FONT_FAMILY),
          lineHeight: 58,
          vertOffset: 5
        }];
        this._renderer.setData({
          color: e.color.value(),
          lines: r
        });
      }
    }
    const Fc = "symbolWatermark";
    class Wc extends di.DataSource {
      constructor(e) {
        super();
        this._model = e;
        this._properties = Ec();
        (0, h.applyDefaultsOverrides)(this._properties, undefined, false, Fc);
        this._properties.subscribe(this, () => e.updateSource(this));
        this._paneView = new Oc(e, this);
      }
      destroy() {
        this._properties.unsubscribeAll(this);
        super.destroy();
      }
      model() {
        return this._model;
      }
      name() {
        return "watermark";
      }
      properties() {
        return this._properties;
      }
      restorePropertiesDefaults() {
        Ec().mergeAndFire(kc);
      }
      applyOverrides(e) {
        (0, h.applyPropertiesOverrides)(this._properties, undefined, false, e, Fc);
      }
      paneViews() {
        return [this._paneView];
      }
      updateAllViews(e) {
        super.updateAllViews(e);
        this._paneView.update();
      }
    }
    var Hc;
    var zc = i(34776);
    var Uc = i(23073);
    (function (e) {
      e[e.StepForChangeValue = 0.1] = "StepForChangeValue";
      e[e.MinValue = 1e-7] = "MinValue";
      e[e.MaxValue = 99999999] = "MaxValue";
    })(Hc ||= {});
    class jc extends Uc.PropertyBase {
      constructor(e) {
        super();
        this._model = e;
      }
      destroy() {
        this._listeners.destroy();
      }
      getStepChangeValue() {
        return 0.1;
      }
      getMinValue() {
        return 1e-7;
      }
      getMaxValue() {
        return 99999999;
      }
      value() {
        return this._model.mainSeriesScaleRatio();
      }
      setValue(e, t) {
        if (e !== this.value() || t) {
          this._model.setMainSeriesScaleRatio(e);
          this.fireChanged();
        }
      }
      setValueSilently(e) {
        if (e !== this.value()) {
          this._model.setMainSeriesScaleRatio(e);
        }
      }
      state() {
        return null;
      }
      clone() {
        return new jc(this._model);
      }
      storeStateIfUndefined() {
        return true;
      }
      weakReference() {
        return (0, zc.weakReference)(this);
      }
      ownership() {
        return (0, zc.ownership)(this);
      }
    }
    var Gc = i(18112);
    var qc = i(34391);
    class $c {
      constructor(e, t) {
        this._map1 = new Map();
        this._map2 = new Map();
        this._getter1 = e;
        this._getter2 = t;
      }
      add(e) {
        const t = this._getter1(e);
        const i = this._getter2(e);
        this._map1.set(t, e);
        this._map2.set(i, t);
      }
      getByKey1(e) {
        return this._map1.get(e) ?? null;
      }
      getByKey2(e) {
        const t = this._map2.get(e);
        if (t === undefined) {
          return null;
        } else {
          return this._map1.get(t) ?? null;
        }
      }
      removeByKey1(e) {
        const t = this._map1.get(e);
        if (t !== undefined) {
          this._map1.delete(e);
          this._map2.delete(this._getter2(t));
        }
      }
      removeByKey2(e) {
        const t = this._map2.get(e);
        if (t !== undefined) {
          this._map2.delete(e);
          this._map1.delete(t);
        }
      }
    }
    var Kc;
    var Yc = i(56991);
    function Zc(e, t, i) {
      if (i.hasDataSource(t)) {
        return Qc(t, i) === e;
      } else {
        return !!i.isMainPane().value() && Qc(i.model().mainSeries(), i) === e;
      }
    }
    (function (e) {
      e.Trading = "trading";
      e.Drawing = "drawing";
      e.DrawingForAllSymbols = "drawingsForAllSymbols";
      e.Phantom = "phantom";
      e.RestRowSources = "restRowSources";
      e.LegendViewSources = "legendViewSources";
      e.LeftPriceScale = "leftPriceScale";
      e.RightPriceScale = "rightPriceScale";
      e.OverlayPriceScale = "overlayPriceScale";
      e.MultipaneSources = "multipane";
      e.AllWithoutMultipane = "allWithoutMultipane";
      e.AllWithoutMultipaneWithHidden = "allWithoutMultipaneWithHidden";
      e.HitTest = "hitTest";
      e.General = "general";
      e.Price = "price";
      e.ExceptSpecial = "exceptSpecial";
      e.AllSorted = "allSorted";
      e.VisibleSorted = "visibleSorted";
    })(Kc ||= {});
    const Xc = new Map([["price", e => (0, Fn.isPriceDataSource)(e)], ["trading", e => (0, eo.isTrading)(e)], ["drawing", e => (0, eo.isLineTool)(e) && !(0, eo.isTrading)(e) && !e.isPhantom()], ["drawingsForAllSymbols", e => (0, eo.isLineTool)(e) && !(0, eo.isTrading)(e) && !e.isPhantom()], ["phantom", e => (0, eo.isLineTool)(e) && e.isPhantom()], ["restRowSources", e => !(0, eo.isLineTool)(e) && !(0, eo.isTrading)(e)], ["legendViewSources", (e, t) => t.hasDataSource(e) && ((0, Fn.isPriceDataSource)(e) || (0, eo.isStudyLineTool)(e))], ["leftPriceScale", Zc.bind(null, "left")], ["rightPriceScale", Zc.bind(null, "right")], ["overlayPriceScale", Zc.bind(null, "overlay")], ["multipane", (e, t) => !t.hasDataSource(e)], ["allWithoutMultipane", (e, t) => t.hasDataSource(e)], ["allWithoutMultipaneWithHidden", (e, t) => t.hasDataSource(e)]]);
    const Jc = new Map([["price", "visibleSorted"], ["trading", "visibleSorted"], ["drawing", "visibleSorted"], ["drawingsForAllSymbols", "allSorted"], ["phantom", "visibleSorted"], ["restRowSources", "visibleSorted"], ["legendViewSources", "visibleSorted"], ["leftPriceScale", "visibleSorted"], ["rightPriceScale", "visibleSorted"], ["overlayPriceScale", "visibleSorted"], ["multipane", "visibleSorted"], ["allWithoutMultipane", "visibleSorted"], ["allWithoutMultipaneWithHidden", "allSorted"]]);
    function Qc(e, t) {
      const i = e.priceScale();
      if (i === null) {
        return "overlay";
      } else {
        return t.priceScalePosition(i);
      }
    }
    class eh {
      constructor(e) {
        this._groupedSources = new Map();
        this._sources = null;
        this._pane = e;
      }
      clear() {
        this._groupedSources.clear();
        this._sources = null;
      }
      destroy() {
        this.clear();
      }
      all() {
        if (!this._groupedSources.has("visibleSorted")) {
          this._sortSources();
        }
        return (0, n.ensureDefined)(this._groupedSources.get("visibleSorted"));
      }
      allIncludingHidden() {
        if (!this._groupedSources.has("allSorted")) {
          this._sortSources();
        }
        return (0, n.ensureDefined)(this._groupedSources.get("allSorted"));
      }
      allWithoutMultipane() {
        return this._getSourcesByGroupType("allWithoutMultipane");
      }
      allWithoutMultipaneWithHidden() {
        return this._getSourcesByGroupType("allWithoutMultipaneWithHidden");
      }
      allExceptSpecialSources() {
        if (!this._groupedSources.has("exceptSpecial")) {
          const e = this.allIncludingHidden().filter(e => !e.isSpeciallyZOrderedSource());
          this._groupedSources.set("exceptSpecial", e);
        }
        return (0, n.ensureDefined)(this._groupedSources.get("exceptSpecial"));
      }
      tradingSources() {
        return this._getSourcesByGroupType("trading");
      }
      priceSources() {
        return this._getSourcesByGroupType("price");
      }
      lineSources() {
        return this._getSourcesByGroupType("drawing");
      }
      lineSourcesForAllSymbols() {
        return this._getSourcesByGroupType("drawingsForAllSymbols");
      }
      phantomSources() {
        return this._getSourcesByGroupType("phantom");
      }
      allExceptLineAndTradingSources() {
        return this._getSourcesByGroupType("restRowSources");
      }
      hitTestSources() {
        if (!this._groupedSources.has("hitTest")) {
          const e = this.allExceptLineAndTradingSources().concat(this.lineSources());
          this._groupedSources.set("hitTest", (0, ci.sortSources)(e, this._pane));
        }
        return (0, n.ensureDefined)(this._groupedSources.get("hitTest"));
      }
      generalSources() {
        if (!this._groupedSources.has("general")) {
          const e = this.allExceptLineAndTradingSources().concat(this.lineSources());
          this._groupedSources.set("general", (0, ci.sortSources)(e, this._pane));
        }
        return (0, n.ensureDefined)(this._groupedSources.get("general"));
      }
      leftPriceScalesSources() {
        return this._getSourcesByGroupType("leftPriceScale");
      }
      rightPriceScalesSources() {
        return this._getSourcesByGroupType("rightPriceScale");
      }
      overlayPriceScaleSources() {
        return this._getSourcesByGroupType("overlayPriceScale");
      }
      multipaneSources() {
        return this._getSourcesByGroupType("multipane");
      }
      legendViewSources() {
        return this._getSourcesByGroupType("legendViewSources");
      }
      _getSourcesByGroupType(e) {
        const t = (0, n.ensureDefined)(Jc.get(e));
        if (this._groupedSources.has(t)) {
          if (!this._groupedSources.has(e)) {
            this._groupSources(e);
          }
        } else {
          this._sortSources();
          this._groupSources(e);
        }
        return (0, n.ensureDefined)(this._groupedSources.get(e));
      }
      _sortSources() {
        if (this._sources === null) {
          this._sources = this._pane.dataSources();
        }
        const e = this._pane.model().multiPaneSources(this._pane);
        const t = (0, ci.sortSources)(this._sources.concat(e), this._pane);
        const i = t.filter(e => !(0, eo.isLineTool)(e) || e.isActualSymbol() && e.isActualCurrency() && e.isActualUnit());
        this._groupedSources.set("allSorted", t);
        this._groupedSources.set("visibleSorted", i);
      }
      _groupSources(e) {
        const t = (0, n.ensureDefined)(Jc.get(e));
        const i = Xc.get(e);
        if (i !== undefined) {
          const s = (0, n.ensureDefined)(this._groupedSources.get(t)).filter(e => i(e, this._pane));
          this._groupedSources.set(e, s);
        }
      }
    }
    var th = i(93280);
    var ih = i(49256);
    function sh(e, t, i) {
      const s = (0, yt.symbolUnitConvertibleGroupsIfExist)(e, true);
      if (s !== null) {
        return s;
      }
      const o = i.unitGroupById(t);
      if (o === null) {
        return [];
      } else {
        return [o];
      }
    }
    function oh(e, t, i, s) {
      let o = null;
      if (i.unitConversionEnabled() && (0, Nr.isSymbolSource)(e)) {
        const n = i.availableUnits();
        const r = t.unit(n);
        const a = e.unit();
        const l = a === null ? [] : sh(e.symbolInfo(), a, n);
        if (r !== null && r.selectedUnit !== null && !r.allUnitsAreOriginal && r.selectedUnit !== a && (s && a === null || a !== null && n.convertible(a, l))) {
          o = r.selectedUnit;
        }
      }
      return o;
    }
    var nh = i(60521);
    function rh(e, t, i) {
      const s = e.div(t).toNumber();
      return Math.abs(Math.round(s) - s) < i;
    }
    const ah = [2, 5];
    const lh = [5, 2];
    class ch {
      constructor(e, t, i) {
        this._base = e;
        this._integralDividers = t;
        if ((0, Io.isBaseDecimal)(e)) {
          this._fractionalDividers = [2, 2.5, 2];
        } else {
          this._fractionalDividers = [];
          const e = i ? ah : lh;
          for (let t = this._base; t !== 1;) {
            if (t % e[0] == 0) {
              this._fractionalDividers.push(e[0]);
              t /= e[0];
            } else {
              if (t % e[1] != 0) {
                throw new Error("unexpected base");
              }
              this._fractionalDividers.push(e[1]);
              t /= e[1];
            }
            if (this._fractionalDividers.length > 100) {
              throw new Error("something wrong with base");
            }
          }
        }
      }
      tickSpan(e, t, i) {
        const s = this._base === 0 ? 0 : 1 / this._base;
        const o = Math.min(1e-14, (e - t) / 1000);
        let n = Math.pow(10, Math.max(0, Math.ceil((0, Io.log10)(e - t))));
        if (!isFinite(n)) {
          return 1e+305;
        }
        let r = 0;
        let a = this._integralDividers[0];
        while (true) {
          const e = (0, Io.greaterOrEqual)(n, s, o) && n > s + o;
          const t = (0, Io.greaterOrEqual)(n, i * a, o);
          const l = (0, Io.greaterOrEqual)(n, 1, o);
          const c = new nh.Big(n).div(a);
          const h = s === 0 || rh(c, s, o);
          if (!e || !t || !l || !h) {
            break;
          }
          n = c.toNumber();
          a = this._integralDividers[++r % this._integralDividers.length];
        }
        if (n <= s + o) {
          n = s;
        }
        n = Math.max(1, n);
        if (this._fractionalDividers.length > 0 && (0, Io.equal)(n, 1, o)) {
          r = 0;
          a = this._fractionalDividers[0];
          while (true) {
            const e = (0, Io.greaterOrEqual)(n, i * a, o) && n > s + o;
            const t = new nh.Big(n).div(a);
            const l = s === 0 || rh(t, s, o);
            if (!e || !l) {
              break;
            }
            n = t.toNumber();
            a = this._fractionalDividers[++r % this._fractionalDividers.length];
          }
        }
        return n;
      }
    }
    class hh {
      constructor(e, t, i, s) {
        this._marks = null;
        this._priceScale = e;
        this._base = t;
        this._coordinateToLogicalFunc = i;
        this._logicalToCoordinateFunc = s;
      }
      base() {
        return this._base;
      }
      setBase(e) {
        if (e < 0) {
          throw new Error("base < 0");
        }
        this._base = e;
      }
      tickSpan(e, t, i = 0) {
        if (e < t) {
          throw new Error("high < low");
        }
        const s = this._priceScale.height();
        const o = this._tickMarkHeight();
        const n = (e - t) * o / s;
        const r = [new ch(this._base, [2, 2.5, 2], true), new ch(this._base, [2, 2, 2.5], true), new ch(this._base, [2.5, 2, 2], true), new ch(this._base, [2, 2.5, 2], false), new ch(this._base, [2, 2, 2.5], false), new ch(this._base, [2.5, 2, 2], false)].reduce((s, o) => {
          const r = o.tickSpan(e, t, n);
          if (r > i) {
            return Math.min(r, s);
          } else {
            return s;
          }
        }, Infinity);
        if (r > 0 && isFinite(r)) {
          return r;
        } else {
          return e - t;
        }
      }
      rebuildTickMarks() {
        this._marks = null;
      }
      marks() {
        if (this._marks === null) {
          this._marks = this._rebuildTickMarksImpl();
        }
        return this._marks;
      }
      _fontHeight() {
        return this._priceScale.fontSize();
      }
      _tickMarkHeight() {
        return Math.ceil(this._fontHeight() * 2.5);
      }
      _rebuildTickMarksImpl() {
        const e = this._priceScale;
        const t = [];
        const i = e.mainSource();
        if (e.isEmpty() || !e.hasCalculatedPriceRange() || i === null) {
          return t;
        }
        let s = i.firstValue();
        if (s === null) {
          s = 0;
        }
        const o = e.height();
        const n = this._coordinateToLogicalFunc(o - 1, s);
        const r = this._coordinateToLogicalFunc(0, s);
        const a = Math.max(n, r);
        const l = Math.min(n, r);
        if (a === l) {
          return t;
        }
        let c = this.tickSpan(a, l);
        let h = a % c;
        h += h < 0 ? c : 0;
        const d = a >= l ? 1 : -1;
        let u = null;
        const _ = e.formatter();
        let p = NaN;
        for (let i = a - h; i > l; i -= c) {
          if (i === p) {
            c = this.tickSpan(a, l, c);
          }
          p = i;
          const o = this._logicalToCoordinateFunc(i, s);
          if (u === null || !(Math.abs(o - u) < this._tickMarkHeight())) {
            t.push({
              coord: o,
              label: _.format(i)
            });
            u = o;
            if (e.isLog()) {
              c = this.tickSpan(i * d, l);
            }
          }
        }
        return t;
      }
    }
    var dh = i(725);
    var uh = i(74079);
    const _h = l.enabled("hide_price_scale_if_all_sources_hidden");
    const ph = (0, uh.getPercentageFormatter)();
    const mh = new dh.PriceFormatter({
      priceScale: 100,
      minMove: 1
    });
    const gh = {
      autoScale: true,
      autoScaleDisabled: false,
      lockScale: false,
      percentage: false,
      percentageDisabled: false,
      log: false,
      logDisabled: false,
      alignLabels: true,
      isInverted: false,
      indexedTo100: false
    };
    class fh {
      constructor(e, t) {
        this._marksCache = null;
        this._onMarksChanged = new re.Delegate();
        this.m_dataSources = [];
        this._sourcesForAutoscale = null;
        this._sourcesThatAffectVisibility = [];
        this._hasSeries = false;
        this._studiesCount = 0;
        this._drawingCount = 0;
        this._seriesLikeSources = [];
        this._priceDataSources = [];
        this._mainSource = null;
        this._lastSourceRemoved = new re.Delegate();
        this._scaleSeriesOnly = false;
        this._invalidatedForRange = {
          isValid: true,
          visibleBars: null
        };
        this._priceRange = null;
        this._hasCalculatedPriceRange = false;
        this._logFormula = (0, ih.logFormulaForBase)(null);
        this.m_height = 0;
        this._margins = {
          top: 0,
          bottom: 0
        };
        this._correctedMarginsCache = null;
        this._topPixelMargin = 0;
        this._bottomPixelMargin = 0;
        this._internalHeightCache = null;
        this._internalHeightChanged = new re.Delegate();
        this._priceRangeSnapshot = null;
        this._scrollStartPoint = null;
        this._currencyCache = null;
        this._unitCache = null;
        this._measureUnitIdCache = null;
        this._recalculatePriceRangeOnce = false;
        this._cachedOrderedSoruces = null;
        this._scaleStartPoint = null;
        this._twoPointsScaleStartPosition = null;
        this._maxPriceRange = null;
        this._minPriceRange = null;
        this._priceRangeChanged = new re.Delegate();
        this._priceRangeAnimationRequested = new re.Delegate();
        this._modeChanged = new re.Delegate();
        this._sourcesToUpdateViews = null;
        this._markBuilder = new hh(this, 100, this._coordinateToLogical.bind(this), this._logicalToCoordinate.bind(this));
        this._formatter = null;
        this._resetScaleAvailable = new F.WatchedValue(false);
        this._priceRangeAnimation = null;
        this._id = "";
        this._isVisible = new F.WatchedValue(true);
        t = Object.assign({}, gh, t);
        this._properties = new Rs.Property(t);
        this._boundOnSourceIsActingAsSymbolSourceChanged = this._onSourceIsActingAsSymbolSourceChanged.bind(this);
        this._scalesProperties = e;
        this._properties.childs().isInverted.subscribe(this, this._onIsInvertedChanged);
        this._properties.subscribe(null, () => {
          const e = this.mainSource();
          if (e && e.model()) {
            const t = e.model().paneForSource(e);
            if (t) {
              e.model().updatePane(t);
            }
          }
        });
        this._scalesProperties.subscribe(this, () => {
          this._marksCache = null;
        });
        this._properties.childs().lockScale.subscribe(this, this._updateResetAvailableValue);
        this._properties.childs().autoScale.subscribe(this, this._updateResetAvailableValue);
        this._updateResetAvailableValue();
        this.setId((0, fe.randomHash)());
      }
      id() {
        return this._id;
      }
      setId(e) {
        this._id = e;
      }
      isLog() {
        return this._properties.childs().log.value();
      }
      isPercentage() {
        return this._properties.childs().percentage.value();
      }
      isInverted() {
        return this._properties.childs().isInverted.value();
      }
      isIndexedTo100() {
        return this._properties.childs().indexedTo100.value();
      }
      isAutoScale() {
        return this._properties.childs().autoScale.value() && !this.isLockScale();
      }
      isLockScale() {
        return this._properties.childs().lockScale.value();
      }
      isRegular() {
        return !this.isPercentage() && !this.isLog() && !this.isIndexedTo100();
      }
      isScaleSeriesOnly() {
        return this._scaleSeriesOnly;
      }
      properties() {
        return this._properties;
      }
      height() {
        return this.m_height;
      }
      setHeight(e) {
        if (this.m_height !== e) {
          this.m_height = e;
          this._invalidateInternalHeightCache();
          this._marksCache = null;
        }
      }
      internalHeight() {
        if (this._internalHeightCache) {
          return this._internalHeightCache;
        }
        const e = this.height() - this.topPixelMargin() - this.bottomPixelMargin();
        this._internalHeightCache = e;
        return e;
      }
      fontSize() {
        return this._scalesProperties.childs().fontSize.value();
      }
      priceRange() {
        this._makeSureItIsValid();
        return this._priceRange;
      }
      setPriceRange(e, t, i) {
        if (!(e instanceof th.PriceRange)) {
          throw new TypeError("incorrect price range");
        }
        const s = this._priceRange;
        if (!t && th.PriceRange.compare(s, e)) {
          return;
        }
        const o = this._maxPriceRange !== null && this._maxPriceRange.containsStrictly(e);
        const n = this._minPriceRange !== null && e.containsStrictly(this._minPriceRange);
        if (!this.isLockScale() || !!t || !o && !n) {
          this._marksCache = null;
          this._priceRange = e;
          if (!i) {
            this._priceRangeChanged.fire(s, e);
          }
          this.updateAllViews((0, Bt.viewportChangeEvent)());
        }
      }
      setMinPriceRange(e) {
        this._minPriceRange = e;
      }
      setMaxPriceRange(e) {
        this._maxPriceRange = e;
      }
      recalculatePriceRangeOnce() {
        this._recalculatePriceRangeOnce = true;
      }
      priceRangeShouldBeRecalculatedOnce() {
        if (!this._recalculatePriceRangeOnce || this.isLockScale()) {
          return false;
        }
        const e = this.mainSource();
        return e !== null && e.priceRangeReady();
      }
      priceRangeChanged() {
        return this._priceRangeChanged;
      }
      priceRangeAnimationRequested() {
        return this._priceRangeAnimationRequested;
      }
      mode() {
        const e = this._properties.childs();
        return {
          autoScale: e.autoScale.value(),
          lockScale: e.lockScale.value(),
          percentage: e.percentage.value(),
          indexedTo100: e.indexedTo100.value(),
          log: e.log.value()
        };
      }
      setMode(e) {
        const t = {};
        const i = this.mode();
        const s = this._properties.state();
        let o = null;
        if (e.autoScale !== undefined && e.autoScale !== s.autoScale) {
          t.autoScale = e.autoScale;
          this._setAutoScaleValueWithDependentProperties(e.autoScale);
        }
        if (e.lockScale !== undefined && e.lockScale !== s.lockScale) {
          t.lockScale = e.lockScale;
          this._setLockScaleValueWithDependentProperties(e.lockScale);
        }
        if (e.percentage !== undefined && e.percentage !== s.percentage) {
          t.percentage = e.percentage;
          this._setPercentageValueWithDependentProperties(e.percentage);
          this._invalidatedForRange.isValid = false;
        }
        if (e.indexedTo100 !== undefined && e.indexedTo100 !== s.indexedTo100) {
          t.indexedTo100 = e.indexedTo100;
          this._setIndexedTo100ValueWithDependentProperties(e.indexedTo100);
          this._invalidatedForRange.isValid = false;
        }
        if (e.log !== undefined && e.log !== s.log) {
          t.log = e.log;
          this._setLogValueWithDependentProperties(e.log);
        }
        const n = this._properties.childs();
        if (s.log && !n.log.value()) {
          if (this._canConvertPriceRangeFromLog(this._priceRange)) {
            o = this._convertPriceRangeFromLog(this._priceRange);
            if (o !== null) {
              this.setPriceRange(o);
            }
          } else {
            n.autoScale.setValue(true);
          }
        }
        if (!s.log && n.log.value()) {
          o = this._convertPriceRangeToLog(this._priceRange);
          if (o !== null) {
            this.setPriceRange(o);
          }
        }
        if (s.autoScale !== n.autoScale.value()) {
          n.autoScale.fireChanged();
        }
        if (s.autoScaleDisabled !== n.autoScaleDisabled.value()) {
          n.autoScaleDisabled.fireChanged();
        }
        if (s.lockScale !== n.lockScale.value()) {
          n.lockScale.fireChanged();
        }
        if (s.percentage !== n.percentage.value()) {
          n.percentage.fireChanged();
          this.updateFormatter();
        }
        if (s.indexedTo100 !== n.indexedTo100.value()) {
          n.indexedTo100.fireChanged();
          this.updateFormatter();
        }
        if (s.percentageDisabled !== n.percentageDisabled.value()) {
          n.percentageDisabled.fireChanged();
        }
        if (s.log !== n.log.value()) {
          n.log.fireChanged();
        }
        if (s.logDisabled !== n.logDisabled.value()) {
          n.logDisabled.fireChanged();
        }
        if (t.log !== undefined || t.percentage !== undefined || t.lockScale !== undefined || t.autoScale !== undefined || t.indexedTo100 !== undefined) {
          this._modeChanged.fire(i, this.mode());
        }
      }
      modeChanged() {
        return this._modeChanged;
      }
      isEmpty() {
        this._makeSureItIsValid();
        return this.m_height === 0 || !this._priceRange || this._priceRange.isEmpty();
      }
      hasCalculatedPriceRange() {
        return this._hasCalculatedPriceRange;
      }
      canDetachSource(e) {
        return this.m_dataSources.some(t => t !== e && (0, Fn.isPriceDataSource)(t) && (!(0, Js.isStudy)(t) || !t.isLinkedToSeries()));
      }
      updateAllViews(e) {
        const t = this._getSourcesToUpdateViews();
        for (const i of t) {
          i.updateAllViews(e);
        }
      }
      logFormula() {
        return this._logFormula;
      }
      state() {
        const e = this._properties.childs();
        return {
          id: this._id,
          m_priceRange: this.isAutoScale() ? null : this.priceRange()?.serialize() || null,
          m_isAutoScale: this.isAutoScale(),
          m_isPercentage: e.percentage.value(),
          m_isIndexedTo100: e.indexedTo100.value(),
          m_isLog: e.log.value(),
          m_isLockScale: this.isLockScale(),
          m_isInverted: this.isInverted(),
          m_topMargin: this._margins.top,
          m_bottomMargin: this._margins.bottom,
          alignLabels: e.alignLabels.value(),
          logFormula: (0, dt.clone)(this._logFormula),
          hasCalculatedPriceRange: this._hasCalculatedPriceRange
        };
      }
      restoreState(e) {
        let t = e.m_priceRange;
        if (t === undefined) {
          throw new TypeError("invalid state");
        }
        if (e.m_isAutoScale === undefined) {
          throw new TypeError("invalid state");
        }
        if (e.id !== undefined) {
          this._id = e.id;
        }
        const i = {
          autoScale: e.m_isAutoScale
        };
        if (e.m_isPercentage !== undefined) {
          i.percentage = e.m_isPercentage;
        }
        if (e.m_isIndexedTo100 !== undefined) {
          i.indexedTo100 = e.m_isIndexedTo100;
        }
        if (e.m_isLog !== undefined) {
          i.log = e.m_isLog;
        }
        if (e.m_isLockScale !== undefined) {
          i.lockScale = e.m_isLockScale;
        }
        if (e.m_isInverted !== undefined) {
          this._properties.childs().isInverted.setValue(e.m_isInverted);
        }
        this.setMode(i);
        this._hasCalculatedPriceRange = e.hasCalculatedPriceRange ?? t !== null;
        if (t) {
          if (!(t instanceof th.PriceRange)) {
            t = new th.PriceRange(t);
          }
          this.setPriceRange(t, true);
        } else {
          this.clearPriceRange();
        }
        if (e.logFormula) {
          this._logFormula = e.logFormula;
        }
        if (e.m_topMargin !== undefined) {
          this._margins.top = e.m_topMargin;
        }
        if (e.m_bottomMargin !== undefined) {
          this._margins.bottom = e.m_bottomMargin;
        }
        if (e.alignLabels !== undefined) {
          this._properties.childs().alignLabels.setValue(e.alignLabels);
        }
        this._mainSource = null;
        this._scaleSeriesOnly = false;
      }
      priceToLogical(e) {
        if (this.isLog() && e) {
          return (0, ih.toLog)(e, this._logFormula);
        } else {
          return e;
        }
      }
      logicalToPrice(e) {
        if (this.isLog()) {
          return (0, ih.fromLog)(e, this._logFormula);
        } else {
          return e;
        }
      }
      positionPercentToCoordinate(e) {
        return this.height() * e;
      }
      priceToCoordinate(e, t) {
        const i = this._priceToPercentOrIndexedTo100IfNeeded(e, t);
        return this._logicalToCoordinate(i);
      }
      coordinateToPrice(e, t) {
        let i = this._coordinateToLogical(e);
        if (this.isPercentage()) {
          i = (0, ih.fromPercent)(i, t);
        } else if (this.isIndexedTo100()) {
          i = (0, ih.fromIndexedTo100)(i, t);
        }
        return i;
      }
      mainSource() {
        if (this._mainSource !== null) {
          return this._mainSource;
        }
        let e;
        for (const t of this._priceDataSources) {
          if (gl(t)) {
            e = t;
            break;
          }
          e ||= t;
        }
        this._mainSource = e || null;
        this._correctedMarginsCache = null;
        return this._mainSource;
      }
      priceToCoordinateFn(e) {
        this._makeSureItIsValid();
        const t = this.bottomPixelMargin();
        const i = (0, n.ensureNotNull)(this.priceRange());
        const s = i.minValue();
        const o = i.maxValue();
        const r = this.internalHeight() - 1;
        const a = this.isInverted();
        const l = r / (o - s);
        const c = this.m_height;
        const h = e => {
          const i = t + l * (e - s);
          if (a) {
            return i;
          } else {
            return c - 1 - i;
          }
        };
        if (this.isPercentage()) {
          return t => h((0, ih.toPercent)(t, e));
        } else if (this.isIndexedTo100()) {
          return t => h((0, ih.toIndexedTo100)(t, e));
        } else if (this.isLog()) {
          return e => h((0, ih.toLog)(e, this._logFormula));
        } else {
          return e => h(e);
        }
      }
      pricesArrayToCoordinates(e, t, i) {
        this._makeSureItIsValid();
        const s = this.bottomPixelMargin();
        const o = (0, n.ensureNotNull)(this.priceRange());
        const r = o.minValue();
        const a = o.maxValue();
        const l = this.internalHeight() - 1;
        const c = this.isInverted();
        const h = l / (a - r);
        if (i === undefined) {
          i = e.length;
        }
        const d = this.isPercentage();
        const u = this.isIndexedTo100();
        const _ = this.isLog();
        const p = this.m_height;
        let m;
        let g;
        for (let o = 0; o < i; o++) {
          m = e[o];
          if (Number.isFinite(m)) {
            if (d) {
              m = (0, ih.toPercent)(m, t);
            } else if (u) {
              m = (0, ih.toIndexedTo100)(m, t);
            } else if (_) {
              m = (0, ih.toLog)(m, this._logFormula);
            }
            g = s + h * (m - r);
            e[o] = c ? g : p - 1 - g;
          }
        }
      }
      pointsArrayToCoordinates(e, t, i) {
        this._makeSureItIsValid();
        const s = (0, n.ensureNotNull)(this.priceRange());
        const o = this.bottomPixelMargin();
        const r = s.minValue();
        const a = s.maxValue();
        const l = this.internalHeight() - 1;
        const c = this.isInverted();
        const h = l / (a - r);
        const d = e;
        const u = i?.startItemIndex ?? 0;
        const _ = i?.endItemIndex ?? d.length;
        if (this.isPercentage()) {
          for (let e = u; e < _; e++) {
            d[e].y = (0, ih.toPercent)(d[e].y, t);
          }
        }
        if (this.isIndexedTo100()) {
          for (let e = u; e < _; e++) {
            d[e].y = (0, ih.toIndexedTo100)(d[e].y, t);
          }
        }
        if (this.isLog()) {
          for (let e = u; e < _; e++) {
            d[e].y = this.priceToLogical(d[e].y);
          }
        }
        for (let e = u; e < _; e++) {
          const t = d[e].y;
          if (isNaN(t) || t == null) {
            continue;
          }
          const i = o + h * (t - r);
          const s = c ? i : this.m_height - 1 - i;
          d[e].y = s;
        }
      }
      barPricesToCoordinates(e, t) {
        this._makeSureItIsValid();
        const i = (0, n.ensureNotNull)(this.priceRange());
        const s = e;
        const o = this.bottomPixelMargin();
        const r = i.minValue();
        const a = i.maxValue();
        const l = this.internalHeight() - 1;
        let c = null;
        if (this.isPercentage()) {
          c = ih.toPercent;
        } else if (this.isIndexedTo100()) {
          c = ih.toIndexedTo100;
        } else if (this.isLog()) {
          c = (e, t) => e ? (0, ih.toLog)(e, this._logFormula) : e;
        }
        if (s.length === 0) {
          return;
        }
        const h = "open" in s[0];
        const d = "close" in s[0];
        if (c !== null) {
          for (let e = 0; e < s.length; e++) {
            if (!s[e]) {
              continue;
            }
            const i = s[e];
            if (h) {
              i.open = c(i.open, t);
            }
            i.high = c(i.high, t);
            i.low = c(i.low, t);
            if (d) {
              i.close = c(i.close, t);
            }
            if (i.additionalPrice !== undefined) {
              i.additionalPrice = c(i.additionalPrice, t);
            }
          }
        }
        const u = l / (a - r);
        const _ = this.isInverted();
        for (let e = 0; e < s.length; e++) {
          const t = s[e];
          if (!t) {
            continue;
          }
          if (h) {
            const e = o + u * (t.open - r);
            const i = _ ? e : this.m_height - 1 - e;
            t.open = i;
          }
          const i = o + u * (t.high - r);
          const n = _ ? i : this.m_height - 1 - i;
          t.high = n;
          const a = o + u * (t.low - r);
          const l = _ ? a : this.m_height - 1 - a;
          t.low = l;
          if (d) {
            const e = o + u * (t.close - r);
            const i = _ ? e : this.m_height - 1 - e;
            t.close = i;
          }
          if (t.additionalPrice !== undefined) {
            const e = o + u * (t.additionalPrice - r);
            t.additionalPrice = _ ? e : this.m_height - 1 - e;
          }
        }
      }
      formatter() {
        if (this._formatter === null) {
          this.updateFormatter();
        }
        return (0, n.ensureNotNull)(this._formatter);
      }
      updateFormatter() {
        this._marksCache = null;
        const e = this.mainSource();
        let t = 100;
        if (e) {
          t = e.base();
        }
        this._formatter = null;
        if (this.isPercentage()) {
          this._formatter = ph;
          t = 100;
        } else if (this.isIndexedTo100()) {
          this._formatter = mh;
          t = 100;
        } else {
          this._formatter = e ? e.formatter() : mh;
        }
        this._markBuilder = new hh(this, t, this._coordinateToLogical.bind(this), this._logicalToCoordinate.bind(this));
        this._markBuilder.rebuildTickMarks();
      }
      formatPrice(e, t, i) {
        if (this.isPercentage()) {
          return this.formatPricePercentage(e, t, i);
        } else if (this.isIndexedTo100()) {
          return this.formatPriceIndexedTo100(e, t, i);
        } else {
          return this.formatter().format(e, i);
        }
      }
      formatPriceAbsolute(e, t) {
        return this._mainSourceFormatter().format(e, t);
      }
      formatPricePercentage(e, t, i) {
        e = (0, ih.toPercent)(e, t);
        return ph.format(e, i);
      }
      formatPriceIndexedTo100(e, t, i) {
        const s = (0, ih.toIndexedTo100)(e, t);
        return this.formatter().format(s, i);
      }
      getFormattedValues(e, t, i, s) {
        s ??= this.formatPriceAbsolute(e);
        const o = this.formatPricePercentage(e, t, {
          signPositive: i
        });
        const n = this.formatPriceIndexedTo100(e, t);
        return {
          formattedPriceAbsolute: s,
          formattedPricePercentage: o,
          formattedPriceIndexedTo100: n,
          text: (0, ih.getCurrentModePriceText)(this, {
            formattedPriceAbsolute: s,
            formattedPricePercentage: o,
            formattedPriceIndexedTo100: n
          })
        };
      }
      resetScale() {
        this.setMode({
          autoScale: true
        });
      }
      resetScaleAvailable() {
        return this._resetScaleAvailable.readonly();
      }
      dataSources() {
        return this.m_dataSources;
      }
      seriesLikeSources() {
        return this._seriesLikeSources;
      }
      addDataSource(e, t) {
        this._addDataSourceImpl(e, t);
      }
      removeDataSource(e) {
        const t = this.m_dataSources.indexOf(e);
        (0, n.assert)(t !== -1, "Source is not attached to scale");
        this.m_dataSources.splice(t, 1);
        if ((0, Fn.isPriceDataSource)(e)) {
          const t = this._priceDataSources.indexOf(e);
          (0, n.assert)(t !== -1, "Source is not found");
          this._priceDataSources.splice(t, 1);
          if ((0, Nr.isSymbolSource)(e)) {
            const t = this._seriesLikeSources.indexOf(e);
            (0, n.assert)(t !== -1, "Source is not found");
            this._seriesLikeSources.splice(t, 1);
            e.symbolResolved().unsubscribeAll(this);
            e.isActingAsSymbolSource().unsubscribe(this._boundOnSourceIsActingAsSymbolSourceChanged);
            if (gl(e)) {
              this._hasSeries = false;
            }
          }
          e.currencyChanged().unsubscribeAll(this);
          e.unitChanged().unsubscribeAll(this);
        }
        if (!this.mainSource()) {
          this.setMode({
            autoScale: true
          });
        }
        if ((0, Js.isStudy)(e)) {
          e.onIsActualIntervalChange().unsubscribe(this, this._dropScaleCache);
          e.onHibernationStateChange().unsubscribe(this, this._dropScaleCache);
          e.properties().childs().styles.unsubscribe(this, this._dropScaleCache);
          this._studiesCount--;
          if (this._studiesCount === 0) {
            (0, lt.hideAllIndicators)().unsubscribe(this, this._dropScaleCache);
          }
        }
        if ((0, eo.isLineTool)(e)) {
          this._drawingCount--;
          if (this._drawingCount === 0) {
            (0, lt.hideAllDrawings)().unsubscribe(this, this._dropScaleCache);
          }
        }
        const i = this._sourcesThatAffectVisibility.indexOf(e);
        if (i !== -1) {
          this._sourcesThatAffectVisibility.splice(i, 1);
          e.properties().childs().visible.unsubscribe(this, this._onSourceVisibilityChanged);
        }
        if (e === this._mainSource) {
          this._correctedMarginsCache = null;
          this._internalHeightCache = null;
          this._marksCache = null;
        }
        this._mainSource = null;
        this._dropScaleCache();
        this.updateFormatter();
        this.invalidateSourcesCache();
        this._updateIsVisible();
        this._updateLogFormula();
        if (this.m_dataSources.length === 0) {
          this._lastSourceRemoved.fire();
        }
      }
      replaceSource(e, t) {
        const i = (0, Fn.isPriceDataSource)(e) ? this._priceDataSources.indexOf(e) : undefined;
        this._addDataSourceImpl(t, undefined, i === -1 ? undefined : i);
        this.removeDataSource(e);
        return i !== -1;
      }
      currency(e) {
        if (this._currencyCache !== null && e.size() === this._currencyCache.availableCurrenciesCount) {
          return this._currencyCache.value;
        }
        let t;
        const i = new Set();
        const s = new Set();
        const o = new Set();
        const r = new Map();
        const a = new Set();
        let l;
        let c = this._seriesLikeSources.length === 0;
        let h = true;
        let d = 0;
        let u = 0;
        const _ = this._seriesLikeSources.filter(Nr.isActingAsSymbolSource);
        for (const u of _) {
          if (!u.isVisible()) {
            continue;
          }
          const _ = u.symbolInfo();
          if (_ === null) {
            t = null;
            break;
          }
          const p = (0, yt.symbolOriginalCurrency)(_);
          if (p === null) {
            t = null;
            break;
          }
          r.set(p, (0, n.ensureNotNull)((0, yt.symbolOriginalCurrency)(_, true)));
          const m = u.currency();
          if (m === null) {
            t = null;
            break;
          }
          r.set(m, (0, n.ensureNotNull)((0, yt.symbolCurrency)(_, true)));
          const g = (0, yt.symbolBaseCurrency)(_);
          if (g !== null) {
            s.add(g);
          }
          h = h && p === m;
          o.add(m);
          i.add(p);
          if (l === undefined) {
            l = m;
          } else if (l !== null && l !== m) {
            l = null;
          }
          if (!c && (!e.convertible(m) || !(0, yt.symbolCurrencyConvertible)(_))) {
            c = true;
          }
          d += 1;
          a.add((0, yt.proSymbol)(_, u.symbol()));
        }
        if (t !== null) {
          for (const i of this._priceDataSources) {
            if (_.includes(i)) {
              continue;
            }
            const s = i;
            if (!s.isCurrencySource() || !s.isVisible()) {
              continue;
            }
            const a = s.currency();
            if (a === null) {
              t = null;
              break;
            }
            o.add(a);
            u += 1;
            const h = (0, n.ensureNotNull)(s.symbolSource());
            const d = s.currencySourceSymbolInfo();
            if (d === null) {
              t = null;
              break;
            }
            if (!c && (!e.convertible(a) || !(0, yt.symbolCurrencyConvertible)(d))) {
              c = true;
            }
            r.set(a, (0, n.ensureNotNull)((0, yt.symbolCurrency)(d, true)));
            if (!_.includes(h)) {
              c = true;
            }
            if (l === undefined) {
              l = a;
            } else if (l !== null && l !== a) {
              l = null;
              break;
            }
          }
        }
        if (t === undefined) {
          t = d === 0 && u === 0 ? null : {
            readOnly: c,
            selectedCurrency: l || null,
            currencies: o,
            originalCurrencies: i,
            baseCurrencies: s,
            symbolSourceCount: d,
            allCurrenciesAreOriginal: h,
            displayedValues: r,
            symbols: a
          };
        }
        this._currencyCache = {
          value: t,
          availableCurrenciesCount: e.size()
        };
        return t;
      }
      unit(e) {
        if (this._unitCache !== null && e.size() === this._unitCache.availableUnitsCount) {
          return this._unitCache.value;
        }
        let t;
        const i = new Set();
        const s = new Set();
        const o = new Map();
        const r = new Map();
        const a = new Set();
        let l;
        let c = this._seriesLikeSources.length === 0 ? new Set() : e.allGroups();
        let h = true;
        let d = 0;
        let u = 0;
        const _ = this._seriesLikeSources.filter(Nr.isActingAsSymbolSource);
        for (const n of _) {
          if (!n.isVisible()) {
            continue;
          }
          const u = n.symbolInfo();
          if (u === null) {
            t = null;
            break;
          }
          const _ = (0, yt.symbolOriginalUnit)(u, n.model().unitConversionEnabled());
          if (_ === null) {
            t = null;
            break;
          }
          o.set(_, e.name(_));
          r.set(_, e.description(_));
          const p = n.unit();
          if (p === null) {
            t = null;
            break;
          }
          o.set(p, e.name(p));
          r.set(p, e.description(p));
          h = h && _ === p;
          s.add(p);
          i.add(_);
          if (l === undefined) {
            l = p;
          } else if (l !== null && l !== p) {
            l = null;
          }
          if (c.size > 0) {
            const t = sh(u, p, e);
            c = (0, ft.intersect)(c, new Set(t));
          }
          d += 1;
          a.add((0, yt.proSymbol)(u, n.symbol()));
        }
        if (t !== null) {
          for (const i of this._priceDataSources) {
            if (_.includes(i)) {
              continue;
            }
            const a = i;
            if (!a.isUnitSource() || !a.isVisible()) {
              continue;
            }
            const h = a.unit();
            if (h === null) {
              t = null;
              break;
            }
            s.add(h);
            u += 1;
            const d = (0, n.ensureNotNull)(a.symbolSource());
            const p = d.symbolInfo();
            if (p === null) {
              t = null;
              break;
            }
            if (c.size > 0) {
              const t = sh(p, h, e);
              c = (0, ft.intersect)(c, new Set(t));
            }
            o.set(h, e.name(h));
            r.set(h, e.description(h));
            if (!_.includes(d)) {
              c = new Set();
            }
            if (l === undefined) {
              l = h;
            } else if (l !== null && l !== h) {
              l = null;
              break;
            }
          }
        }
        if (t === undefined) {
          if (d === 0 && u === 0) {
            t = null;
          } else {
            t = {
              availableGroups: c,
              selectedUnit: l || null,
              units: s,
              originalUnits: i,
              symbolSourceCount: d,
              allUnitsAreOriginal: h,
              names: o,
              descriptions: r,
              symbols: a
            };
          }
        }
        this._unitCache = {
          value: t,
          availableUnitsCount: e.size()
        };
        return t;
      }
      measureUnitId(e) {
        if (this._measureUnitIdCache !== null && e.size() === this._measureUnitIdCache.availableUnitsCount) {
          return this._measureUnitIdCache.value;
        }
        let t;
        let i;
        const s = new Map();
        const o = new Map();
        const n = new Set();
        let r = 0;
        const a = this._seriesLikeSources.filter(Nr.isActingAsSymbolSource);
        for (const l of a) {
          if (!l.isVisible()) {
            continue;
          }
          const a = l.measureUnitId();
          if (a === null) {
            t = null;
            break;
          }
          n.add(a);
          s.set(a, e.name(a));
          o.set(a, e.description(a));
          if (i === undefined) {
            i = a;
          } else if (i !== null && i !== a) {
            i = null;
          }
          r += 1;
        }
        if (t === undefined) {
          t = r === 0 ? null : {
            selectedMeasureUnitId: i || null,
            measureUnitIds: n,
            names: s,
            descriptions: o,
            symbolSourceCount: r
          };
        }
        this._measureUnitIdCache = {
          value: t,
          availableUnitsCount: e.size()
        };
        return t;
      }
      setMargins(e) {
        if (!(0, dt.isNumber)(e.top) || !(0, dt.isNumber)(e.bottom)) {
          throw new TypeError("invalid margin");
        }
        if (e.top < 0 || e.top > 30 || e.bottom < 0 || e.bottom > 30) {
          throw new RangeError("invalid margin");
        }
        if (this._margins.top !== e.top || this._margins.bottom !== e.bottom) {
          this._margins = e;
          this._correctedMarginsCache = null;
          this._invalidateInternalHeightCache();
          this._marksCache = null;
        }
      }
      topMargin() {
        return this._correctedMargins().top;
      }
      bottomMargin() {
        return this._correctedMargins().bottom;
      }
      invalidateMargins() {
        this._correctedMarginsCache = null;
      }
      topPixelMargin() {
        if (this.isInverted()) {
          return this.bottomMargin() * this.height() + this._bottomPixelMargin;
        } else {
          return this.topMargin() * this.height() + this._topPixelMargin;
        }
      }
      bottomPixelMargin() {
        if (this.isInverted()) {
          return this.topMargin() * this.height() + this._topPixelMargin;
        } else {
          return this.bottomMargin() * this.height() + this._bottomPixelMargin;
        }
      }
      marks() {
        if (this.isEmpty()) {
          this._marksCache = null;
          return [];
        } else {
          if (this._marksCache === null) {
            this._markBuilder.rebuildTickMarks();
            this._marksCache = this._markBuilder.marks();
            this._onMarksChanged.fire();
          }
          return this._marksCache;
        }
      }
      onMarksChanged() {
        return this._onMarksChanged;
      }
      priceRangeInPrice() {
        if (this.isEmpty()) {
          return null;
        }
        const e = this.mainSource()?.firstValue() ?? null;
        if (e === null) {
          return null;
        }
        const t = this.height();
        return {
          from: this.coordinateToPrice(t - 1, e),
          to: this.coordinateToPrice(0, e)
        };
      }
      setPriceRangeInPrice(e) {
        if (this.isPercentage() || this.isIndexedTo100()) {
          return;
        }
        const t = this.isInverted();
        const i = t ? this.bottomMargin() : this.topMargin();
        const s = t ? this.topMargin() : this.bottomMargin();
        const o = this.isLog();
        let n = o ? (0, ih.toLog)(e.from, this._logFormula) : e.from;
        let r = o ? (0, ih.toLog)(e.to, this._logFormula) : e.to;
        const a = r - n;
        n += s * a;
        r -= i * a;
        this.setMode({
          autoScale: false
        });
        this.setPriceRange(new th.PriceRange(n, r));
        this._marksCache = null;
        this._onMarksChanged.fire();
      }
      hasMainSeries() {
        return this._hasSeries;
      }
      getStudies() {
        return this.dataSources().filter(Js.isStudy);
      }
      lastSourceRemoved() {
        return this._lastSourceRemoved;
      }
      sourcesForAutoscale() {
        if (this._mainSource && this._scaleSeriesOnly !== this._scalesProperties.childs().scaleSeriesOnly.value()) {
          this._sourcesForAutoscale = null;
        }
        this._sourcesForAutoscale ||= this._recalculateSourcesForAutoscale();
        return this._sourcesForAutoscale;
      }
      recalculatePriceRange(e) {
        this._invalidatedForRange = {
          visibleBars: e,
          isValid: false
        };
      }
      internalHeightChanged() {
        return this._internalHeightChanged;
      }
      orderedSources() {
        if (this._cachedOrderedSoruces) {
          return this._cachedOrderedSoruces;
        }
        let e = this.m_dataSources.slice();
        e = (0, ci.sortSources)(e);
        this._cachedOrderedSoruces = e;
        return this._cachedOrderedSoruces;
      }
      invalidateSourcesCache() {
        this._cachedOrderedSoruces = null;
        this._sourcesToUpdateViews = null;
      }
      startScale(e) {
        if (!this.isEmpty() && !this.isPercentage() && !this.isIndexedTo100() && this._scaleStartPoint === null && this._priceRangeSnapshot === null) {
          this._scaleStartPoint = this.m_height - e;
          this._priceRangeSnapshot = this.priceRange()?.clone() ?? null;
        }
      }
      scaleTo(e) {
        if (this.isPercentage() || this.isIndexedTo100() || this._scaleStartPoint === null) {
          return;
        }
        this.setMode({
          autoScale: false
        });
        if ((e = this.m_height - e) < 0) {
          e = 0;
        }
        let t = (this._scaleStartPoint + (this.m_height - 1) * 0.2) / (e + (this.m_height - 1) * 0.2);
        const i = (0, n.ensureNotNull)(this._priceRangeSnapshot).clone();
        t = Math.max(t, 0.1);
        i.scaleAroundCenter(t);
        this.setPriceRange(i);
      }
      endScale() {
        if (!this.isPercentage() && !this.isIndexedTo100()) {
          if (this._scaleStartPoint !== null) {
            this._scaleStartPoint = null;
            this._priceRangeSnapshot = null;
          }
        }
      }
      startTwoPointsScale(e, t) {
        if (this.isEmpty() || this.isPercentage() || this.isIndexedTo100() || this._twoPointsScaleStartPosition !== null) {
          return;
        }
        const i = Math.min(e, t);
        const s = Math.max(e, t);
        this._twoPointsScaleStartPosition = {
          topLogical: this._coordinateToLogical(i),
          bottomLogical: this._coordinateToLogical(s)
        };
      }
      twoPointsScale(e, t) {
        if (this.isPercentage() || this.isIndexedTo100() || this._twoPointsScaleStartPosition === null) {
          return;
        }
        this.setMode({
          autoScale: false
        });
        const i = Math.min(e, t);
        const s = Math.max(e, t);
        const {
          topLogical: o,
          bottomLogical: n
        } = this._twoPointsScaleStartPosition;
        const r = this.bottomPixelMargin();
        const a = this.internalHeight() - 1;
        const l = (this._invertedCoordinate(i) - r) / a;
        const c = (n - o) / ((this._invertedCoordinate(s) - r) / a - l);
        if (!Number.isFinite(c)) {
          return;
        }
        const h = o - c * l;
        const d = h + c;
        this.setPriceRange(new th.PriceRange(this.priceToLogical(h), this.priceToLogical(d)));
      }
      endTwoPointsScale() {
        this._twoPointsScaleStartPosition = null;
      }
      startScroll(e) {
        if (!this.isAutoScale()) {
          if (this._scrollStartPoint === null && this._priceRangeSnapshot === null) {
            if (!this.isEmpty()) {
              this._scrollStartPoint = e;
              this._priceRangeSnapshot = this.priceRange()?.clone() ?? null;
            }
          }
        }
      }
      scrollTo(e) {
        if (this.isAutoScale()) {
          return;
        }
        if (this._scrollStartPoint === null || this._priceRangeSnapshot === null) {
          return;
        }
        const t = this.priceRange();
        if (t === null) {
          return;
        }
        let i = e - this._scrollStartPoint;
        if (this.isInverted()) {
          i *= -1;
        }
        const s = i * (t.length() / (this.internalHeight() - 1));
        const o = this._priceRangeSnapshot.clone();
        o.shift(s);
        this.setPriceRange(o, true);
        this._marksCache = null;
      }
      endScroll() {
        if (!this.isAutoScale()) {
          if (this._scrollStartPoint !== null) {
            this._scrollStartPoint = null;
            this._priceRangeSnapshot = null;
          }
        }
      }
      clearPriceRange() {
        this._priceRange = null;
        this.recalculatePriceRangeOnce();
      }
      isVisible() {
        return this._isVisible;
      }
      _addDataSourceImpl(e, t, i) {
        if (t || this.m_dataSources.indexOf(e) === -1) {
          if ((0, Fn.isPriceDataSource)(e)) {
            if (i === undefined) {
              this._priceDataSources.push(e);
            } else {
              this._priceDataSources.splice(i, 0, e);
            }
            e.currencyChanged().subscribe(this, () => this._currencyCache = null);
            e.unitChanged().subscribe(this, () => this._unitCache = null);
            if ((0, Nr.isSymbolSource)(e) && (this._seriesLikeSources.push(e), e.symbolResolved().subscribe(this, () => {
              this._currencyCache = null;
              this._unitCache = null;
              this._measureUnitIdCache = null;
              this._updateLogFormula();
            }), e.isActingAsSymbolSource().subscribe(this._boundOnSourceIsActingAsSymbolSourceChanged), gl(e))) {
              const t = e.properties();
              if (!this._hasSeries) {
                if (t.childs().lockScale) {
                  this.setMode({
                    lockScale: t.childs().lockScale.value()
                  });
                  t.removeProperty("lockScale");
                }
                if (t.childs().pnfStyle.hasChild("lockScale")) {
                  t.childs().pnfStyle.removeProperty("lockScale");
                }
              }
              this._hasSeries = true;
            }
            if (!e.isSpeciallyZOrderedSource()) {
              this._sourcesThatAffectVisibility.push(e);
              e.properties().childs().visible.subscribe(this, this._onSourceVisibilityChanged);
            }
          }
          if ((0, Js.isStudy)(e)) {
            e.onIsActualIntervalChange().subscribe(this, this._dropScaleCache);
            e.onHibernationStateChange().subscribe(this, this._dropScaleCache);
            e.properties().childs().styles.subscribe(this, this._dropScaleCache);
            if (this._studiesCount === 0) {
              (0, lt.hideAllIndicators)().subscribe(this, this._dropScaleCache);
            }
            this._studiesCount++;
          }
          if ((0, eo.isLineTool)(e)) {
            if (this._drawingCount === 0) {
              (0, lt.hideAllDrawings)().subscribe(this, this._dropScaleCache);
            }
            this._drawingCount++;
          }
          this.m_dataSources.push(e);
          this._mainSource = null;
          if (this.mainSource() === e) {
            this._correctedMarginsCache = null;
            this._internalHeightCache = null;
            this._marksCache = null;
          }
          this._dropScaleCache();
          this.updateFormatter();
          this._initScaleProperties();
          this.invalidateSourcesCache();
          this._updateIsVisible();
          this._updateLogFormula();
        }
      }
      _recalculateSourcesForAutoscale() {
        if (this._mainSource) {
          this._scaleSeriesOnly = this._scalesProperties.childs().scaleSeriesOnly.value();
        }
        const e = this._scaleSeriesOnly && this._hasSeries;
        return this.m_dataSources.filter(t => (!!t.properties().visible.value() || !!gl(t)) && (e ? gl(t) : (0, Js.isStudy)(t) ? !t.isSourceHidden() && t.isIncludedInAutoScale() : t.isIncludedInAutoScale()));
      }
      _updateAutoScaleDisabledProperty(e) {
        const t = this._properties.childs();
        const i = t.indexedTo100.value() || t.percentage.value() || t.lockScale.value();
        if (e) {
          t.autoScaleDisabled.setValueSilently(i);
        } else {
          t.autoScaleDisabled.setValue(i);
        }
      }
      _setAutoScaleValueWithDependentProperties(e) {
        const t = this._properties.childs();
        t.autoScale.setValueSilently(e);
        if (e) {
          t.percentage.setValueSilently(false);
          t.indexedTo100.setValueSilently(false);
          t.lockScale.setValueSilently(false);
          t.logDisabled.setValueSilently(false);
        }
        this._updateAutoScaleDisabledProperty(true);
      }
      _setLockScaleValueWithDependentProperties(e) {
        const t = this._properties.childs();
        t.lockScale.setValueSilently(e);
        if (e) {
          t.autoScale.setValueSilently(false);
          t.percentage.setValueSilently(false);
          t.indexedTo100.setValueSilently(false);
          t.log.setValueSilently(false);
        }
        t.percentageDisabled.setValueSilently(e);
        t.logDisabled.setValueSilently(e);
        this._updateAutoScaleDisabledProperty(true);
      }
      _setPercentageValueWithDependentProperties(e) {
        const t = this._properties.childs();
        t.percentage.setValueSilently(e);
        if (e) {
          t.autoScale.setValueSilently(true);
          t.log.setValueSilently(false);
          t.lockScale.setValueSilently(false);
          t.indexedTo100.setValueSilently(false);
        }
        this._updateAutoScaleDisabledProperty(true);
      }
      _setIndexedTo100ValueWithDependentProperties(e) {
        const t = this._properties.childs();
        t.indexedTo100.setValueSilently(e);
        if (e) {
          t.autoScale.setValueSilently(true);
          t.log.setValueSilently(false);
          t.lockScale.setValueSilently(false);
          t.percentage.setValueSilently(false);
        }
        this._updateAutoScaleDisabledProperty(true);
      }
      _setLogValueWithDependentProperties(e) {
        const t = this._properties.childs();
        t.log.setValueSilently(e);
        if (e) {
          t.lockScale.setValueSilently(false);
          t.percentage.setValueSilently(false);
          t.indexedTo100.setValueSilently(false);
        }
        this._updateAutoScaleDisabledProperty(true);
      }
      _recalculatePriceRangeImpl() {
        const e = this._invalidatedForRange.visibleBars;
        if (e === null) {
          return;
        }
        let t = null;
        const i = this.sourcesForAutoscale();
        const s = this.isPercentage();
        const o = this.isIndexedTo100();
        let n = 0;
        let r = 0;
        const a = {
          targetPriceScale: this,
          scaleSeriesOnly: this._scaleSeriesOnly
        };
        for (const l of i) {
          if (!l.properties().visible.value()) {
            continue;
          }
          const i = l.firstValue();
          if (i === null || s && i === 0) {
            continue;
          }
          const c = e.firstBar();
          const h = e.lastBar();
          const d = l.autoScaleInfo(c, h, a);
          let u = d.range;
          if (u) {
            if (s) {
              u = (0, ih.toPercentRange)(u, i);
            } else if (o) {
              u = (0, ih.toIndexedTo100Range)(u, i);
            }
            t = t === null ? u : t.merge(u);
          }
          if (d.topPixelMargin !== undefined) {
            n = Math.max(n, d.topPixelMargin);
          }
          if (d.bottomPixelMargin !== undefined) {
            r = Math.max(r, d.bottomPixelMargin);
          }
        }
        if (Math.abs(n - this._topPixelMargin) > 0 || Math.abs(r - this._bottomPixelMargin) > 0) {
          this._bottomPixelMargin = r;
          this._topPixelMargin = n;
          this._marksCache = null;
          this._invalidateInternalHeightCache();
        }
        if (t) {
          this._hasCalculatedPriceRange = true;
          if (t.minValue() === t.maxValue()) {
            t = new th.PriceRange(t.minValue() - 0.5, t.maxValue() + 0.5);
          }
          this.setPriceRange(t);
        } else if (!this._priceRange) {
          this.setPriceRange(new th.PriceRange(-0.5, 0.5));
        }
        this._invalidatedForRange.isValid = true;
        const l = this.mainSource();
        if (l !== null && this._recalculatePriceRangeOnce) {
          this._recalculatePriceRangeOnce = !l.priceRangeReady();
        }
      }
      _makeSureItIsValid() {
        if (!this._invalidatedForRange.isValid) {
          this._invalidatedForRange.isValid = true;
          this._recalculatePriceRangeImpl();
        }
      }
      _invalidateInternalHeightCache() {
        this._internalHeightCache = null;
        this._internalHeightChanged.fire();
      }
      _coordinateToLogical(e) {
        this._makeSureItIsValid();
        if (this.isEmpty()) {
          return 0;
        }
        const t = this._invertedCoordinate(e);
        const i = (0, n.ensureNotNull)(this.priceRange());
        const s = i.minValue() + (i.maxValue() - i.minValue()) * ((t - this.bottomPixelMargin()) / (this.internalHeight() - 1));
        return this.logicalToPrice(s);
      }
      _logicalToCoordinate(e) {
        this._makeSureItIsValid();
        if (this.isEmpty()) {
          return 0;
        }
        e = this.priceToLogical(e);
        const t = (0, n.ensureNotNull)(this.priceRange());
        const i = this.bottomPixelMargin() + (this.internalHeight() - 1) * (e - t.minValue()) / (t.maxValue() - t.minValue());
        return this._invertedCoordinate(i);
      }
      _convertPriceRangeFromLog(e) {
        if (e === null) {
          return null;
        }
        const t = (0, ih.fromLog)(e.minValue(), this._logFormula);
        const i = (0, ih.fromLog)(e.maxValue(), this._logFormula);
        return new th.PriceRange(t, i);
      }
      _convertPriceRangeToLog(e) {
        if (e === null) {
          return null;
        }
        const t = (0, ih.toLog)(e.minValue(), this._logFormula);
        const i = (0, ih.toLog)(e.maxValue(), this._logFormula);
        return new th.PriceRange(t, i);
      }
      _canConvertPriceRangeFromLog(e) {
        if (e === null) {
          return false;
        }
        const t = (0, ih.fromLog)(e.minValue(), this._logFormula);
        const i = (0, ih.fromLog)(e.maxValue(), this._logFormula);
        return isFinite(t) && isFinite(i);
      }
      _onSourceVisibilityChanged() {
        this._dropScaleCache();
        this._updateIsVisible();
      }
      _dropScaleCache() {
        this._sourcesForAutoscale = null;
        this._currencyCache = null;
        this._unitCache = null;
        this._measureUnitIdCache = null;
      }
      _updateIsVisible() {
        if (!_h) {
          this._isVisible.setValue(true);
          return;
        }
        const e = this._sourcesThatAffectVisibility.some(e => e.isVisible());
        this._isVisible.setValue(e);
      }
      _updateLogFormula() {
        const e = this.isLog() ? this._convertPriceRangeFromLog(this.priceRange()) : null;
        const t = this.mainSource();
        if (t === null) {
          this._logFormula = (0, ih.logFormulaForBase)(null);
        } else {
          const e = t.base() || null;
          const i = (0, ih.logFormulaForBase)(e);
          if (!(0, ih.logFormulasAreSame)(i, this._logFormula)) {
            this._logFormula = i;
          }
        }
        if (e) {
          this.setPriceRange(this._convertPriceRangeToLog(e));
        }
      }
      _invertedCoordinate(e) {
        if (this.isInverted()) {
          return e;
        } else {
          return this.height() - 1 - e;
        }
      }
      _initScaleProperties() {
        const e = this.isLockScale();
        const t = this.properties().childs();
        if (e) {
          t.percentage.setValue(false);
          t.indexedTo100.setValue(false);
          t.log.setValue(false);
          t.autoScale.setValue(false);
        }
        t.percentageDisabled.setValue(e);
        t.logDisabled.setValue(e);
        this._updateAutoScaleDisabledProperty(false);
        if (t.percentage.value()) {
          t.log.setValue(false);
          t.indexedTo100.setValue(false);
        }
        if (t.indexedTo100.value()) {
          t.log.setValue(false);
          t.percentage.setValue(false);
        }
      }
      _correctedMargins() {
        if (this._correctedMarginsCache === null) {
          const e = this.mainSource();
          this._correctedMarginsCache = e !== null ? e.correctScaleMargins(this._margins) : this._margins;
        }
        return this._correctedMarginsCache;
      }
      _getSourcesToUpdateViews() {
        this._sourcesToUpdateViews ||= this.m_dataSources.filter(e => !(0, eo.isLineTool)(e) || e.isActualSymbol() && e.isActualCurrency());
        return this._sourcesToUpdateViews;
      }
      _mainSourceFormatter() {
        const e = this.mainSource();
        return e?.formatter() || mh;
      }
      _priceToPercentOrIndexedTo100IfNeeded(e, t) {
        if (this.isPercentage()) {
          return (0, ih.toPercent)(e, t);
        } else if (this.isIndexedTo100()) {
          return (0, ih.toIndexedTo100)(e, t);
        } else {
          return e;
        }
      }
      _onSourceIsActingAsSymbolSourceChanged() {
        this._dropScaleCache();
      }
      _onIsInvertedChanged() {
        this._marksCache = null;
        this._markBuilder.rebuildTickMarks();
      }
      _updateResetAvailableValue() {
        this._resetScaleAvailable.setValue(!this.isLockScale() && !this.isAutoScale());
      }
    }
    var yh = i(678);
    const vh = [];
    const Sh = [];
    class bh {
      constructor(e) {
        this._studies = {};
        this._deferreds = {};
        this._container = e;
        vh.push(e);
        Sh.push(this);
      }
      add(e, t) {
        if (this._deferreds[e]) {
          this._deferreds[e].resolve(t);
          delete this._deferreds[e];
        }
        this._studies[e] = t;
      }
      get(e) {
        if (this._studies[e]) {
          return Promise.resolve(this._studies[e]);
        } else {
          this._deferreds[e] ||= (0, me.createDeferredPromise)();
          return this._deferreds[e].promise;
        }
      }
      delete(e) {
        delete this._studies[e];
        delete this._deferreds[e];
      }
      reset() {
        const e = vh.indexOf(this._container);
        if (~e) {
          vh.splice(e, 1);
          Sh.splice(e, 1);
        }
      }
      static instance(e) {
        const t = vh.indexOf(e);
        if (~t) {
          return Sh[t];
        } else {
          return new bh(e);
        }
      }
      static ready() {
        for (const e of Sh) {
          if (Object.keys(e._deferreds).length > 0) {
            return false;
          }
        }
        return true;
      }
    }
    var wh = i(65365);
    var Ch = i(10892);
    var Ph = i(42989);
    var Th = i(79303);
    function xh(e) {
      e.wickUpColor = e.wickUpColor ?? e.wickColor;
      e.wickDownColor = e.wickDownColor ?? e.wickColor;
      delete e.wickColor;
    }
    function Ih(e) {
      if (e) {
        e.colorType ??= So.ColorType.Solid;
      }
    }
    const Mh = l.enabled("clear_price_scale_on_error_or_empty_bars");
    const Ah = (0, ae.getLogger)("Chart.Pane");
    var Lh;
    function kh(e, t, i) {
      e.setMargins({
        top: t,
        bottom: i
      });
    }
    (function (e) {
      e[e.DefaultStretchFactor = 1000] = "DefaultStretchFactor";
      e[e.LargePaneSizeRatio = 1] = "LargePaneSizeRatio";
      e[e.MediumPaneSizeRatio = 0.6] = "MediumPaneSizeRatio";
      e[e.SmallPaneSizeRatio = 0.3] = "SmallPaneSizeRatio";
      e[e.TinyPaneSizeRatio = 0.15] = "TinyPaneSizeRatio";
    })(Lh ||= {});
    const Dh = "chart.pane";
    class Eh {
      constructor(e, t, i, s, o) {
        this.m_dataSources = [];
        this._sourceWatchedValuesSubscriptions = new Map();
        this.m_mainDataSource = null;
        this._cachedOrderedSources = new eh(this);
        this._sourcesById = new Map();
        this._priceSourcesById = new Map();
        this._sourcePropertiesChanged = new re.Delegate();
        this._sourcesZOrderChanged = new re.Delegate();
        this._tagsChanged = new re.Delegate();
        this._stretchFactor = 1000;
        this._isInInsertManyDataSourcesState = false;
        this._lastLineDataSourceZOrder = null;
        this._rightPriceScales = [];
        this._leftPriceScales = [];
        this._allPriceScalesIncludingOverlays = [];
        this._lockedPriceScale = null;
        this._currentPriceScaleRatio = null;
        this._onPriceScalesChanged = new re.Delegate();
        this._isRecalculatingScales = false;
        this._priceDataSources = [];
        this._symbolSources = [];
        this._lollipopDataSources = [];
        this._symbolSourceResolved = new re.Delegate();
        this._symbolSourceResolvingActive = new F.WatchedValue(false);
        this._bulkActions = {
          activeCounter: 0
        };
        this._height = 0;
        this._width = 0;
        this._sizeChanged = new re.Delegate();
        this._dataSourcesCollectionChanged = new re.Delegate();
        this._symbolSourceCollectionChanged = new re.Delegate();
        this._priceSourcesCollectionChanged = new re.Delegate();
        this._isMainPane = new F.WatchedValue(false);
        this._collapsed = new F.WatchedValue(false);
        this._resetPriceScalesAvailable = new F.WatchedValue(false);
        this._destroyed = new re.Delegate();
        this._executionsPositionController = null;
        this._seriesDisplayError = null;
        this._onPriceScaleIsVisibleChanged = () => {
          this._model.fullUpdate();
        };
        this._recalcSymbolSourceResolvingActive = () => {
          for (const e of this._symbolSources) {
            if (e.symbolResolvingActive().value()) {
              this._symbolSourceResolvingActive.setValue(true);
              return;
            }
          }
          this._symbolSourceResolvingActive.setValue(false);
        };
        this._onSymbolSourceCollectionChanged = () => {
          if (this._bulkActions.activeCounter === 0) {
            this._symbolSourceCollectionChanged.fire();
          } else {
            this._bulkActions.symbolSourceCollectionChanged = true;
          }
        };
        this._onSeriesDisplayError = e => {
          if (e !== null) {
            for (const e of this._leftPriceScales) {
              e.clearPriceRange();
            }
            for (const e of this._rightPriceScales) {
              e.clearPriceRange();
            }
          }
        };
        this._updateResetPriceScalesAvailableValue = () => {
          const e = e => e.resetScaleAvailable().value();
          const t = this._leftPriceScales.some(e) || this._rightPriceScales.some(e);
          this._resetPriceScalesAvailable.setValue(t);
        };
        this._priceScaleSelectionStrategy = (0, qc.createPriceScaleSelectionStrategy)(i.properties().childs().priceScaleSelectionStrategyName.value());
        this._id = s ?? (0, fe.randomHashN)(6);
        this._mode = o ?? Bi.PaneMode.Regular;
        this._timeScale = e;
        this.m_mainDataSource = null;
        this._properties = t;
        this._model = i;
        this._maximized = (0, Ji.combine)(e => e === this, i.maximizedPane().spawnOwnership());
        this._collapsingAvailable = (0, Ji.combine)((e, t) => t, this._isMainPane.weakReference(), i.paneCollapsingAvailable().weakReference());
        i.properties().childs().priceScaleSelectionStrategyName.subscribe(null, e => {
          this._priceScaleSelectionStrategy = (0, qc.createPriceScaleSelectionStrategy)(e.value());
          this._priceScaleSelectionStrategy.apply(this);
        });
        this._timeScale.barSpacingChanged().subscribe(this, () => {
          if (this.m_mainDataSource === this._model.mainSeries()) {
            this._recalculatePriceScaleByScaleRatio(this.m_mainDataSource.priceScale());
          }
        });
        if (Mh) {
          this._seriesDisplayError = (0, yt.getSeriesDisplayErrorWV)(this._model.mainSeries());
          this._seriesDisplayError.subscribe(this._onSeriesDisplayError);
        }
        i.onMultipaneSourcesCollectionChanged().subscribe(this, this._invalidateSourcesCache);
        i.panesCollectionChanged().subscribe(this, this._invalidateSourcesCache);
        t.childs().topMargin.subscribe(this, this._updateMargins);
        t.childs().bottomMargin.subscribe(this, this._updateMargins);
        this._lineToolsByLinkKey = new $c(e => e.linkKey().value(), e => e.id());
        this._updateMargins();
      }
      destroy() {
        this._properties.childs().topMargin.unsubscribeAll(this);
        this._properties.childs().bottomMargin.unsubscribeAll(this);
        this._model.properties().childs().priceScaleSelectionStrategyName.unsubscribeAll(this);
        this._timeScale.barSpacingChanged().unsubscribeAll(this);
        this._leftPriceScales.concat(this._rightPriceScales).forEach(e => {
          e.modeChanged().unsubscribeAll(this);
          e.priceRangeChanged().unsubscribeAll(this);
          e.internalHeightChanged().unsubscribeAll(this);
          e.isVisible().unsubscribe(this._onPriceScaleIsVisibleChanged);
          e.resetScaleAvailable().unsubscribe(this._updateResetPriceScalesAvailableValue);
        });
        if (this._mode === Bi.PaneMode.Regular) {
          for (const e of this.m_dataSources) {
            this.removeSourceFromPriceScale(e);
            if (e.destroy) {
              e.destroy();
            }
          }
        }
        this._seriesDisplayError?.destroy();
        this._model.onMultipaneSourcesCollectionChanged().unsubscribeAll(this);
        this._model.panesCollectionChanged().unsubscribeAll(this);
        this._maximized.destroy();
        this._collapsingAvailable.destroy();
        this._destroyed.fire();
      }
      id() {
        return this._id;
      }
      mode() {
        return this._mode;
      }
      bulkActionMacro(e) {
        this.beginBulkAction();
        e();
        this.endBulkAction();
      }
      beginBulkAction() {
        this._bulkActions.activeCounter += 1;
      }
      endBulkAction() {
        this._bulkActions.activeCounter -= 1;
        this._processAfterBulkAction();
      }
      defaultPriceScale() {
        const e = this.m_mainDataSource?.priceScale() ?? null;
        if (e !== null) {
          return e;
        }
        const t = this.properties().childs().axisProperties.state();
        t.autoScale = true;
        return new fh(this._model.properties().childs().scalesProperties, t);
      }
      leftPriceScales() {
        return this._leftPriceScales;
      }
      rightPriceScales() {
        return this._rightPriceScales;
      }
      visibleLeftPriceScales() {
        const e = this._model.priceScaleSlotsCount();
        const t = this._leftPriceScales.filter(e => e.isVisible().value());
        const i = this.mainDataSource()?.priceScale();
        if (t.length > e.left && i?.isVisible().value()) {
          const s = (0, ft.moveToHead)(t, i);
          s.splice(e.left);
          return s;
        }
        return t;
      }
      visibleRightPriceScales() {
        const e = this._model.priceScaleSlotsCount();
        const t = this._rightPriceScales.filter(e => e.isVisible().value());
        const i = this.mainDataSource()?.priceScale();
        if (t.length > e.right && i?.isVisible().value()) {
          const s = (0, ft.moveToHead)(t, i);
          s.splice(e.right);
          return s;
        }
        return t;
      }
      clearSeries(e) {
        const t = this._model.mainSeries();
        for (let i = this.m_dataSources.length - 1; i >= 0; i--) {
          if (this.m_dataSources[i] === t) {
            this._removeSourceFromCollections(i, e);
          }
        }
      }
      sourcesByGroup() {
        return this._cachedOrderedSources;
      }
      dataSourceForId(e) {
        return this._sourcesById.get(e) || null;
      }
      lineToolByLinkKey(e) {
        return this._lineToolsByLinkKey.getByKey1(e);
      }
      changeSourceId(e, t) {
        if (e === this._model.mainSeries()) {
          (0, Gc.getPersistentLogger)()?.addPersistentLogEntry(`changeSourceId for series from ${e.id()} to ${t}`, ae.LOGLEVEL.INFO, Dh);
        }
        (0, n.assert)(this.hasDataSource(e));
        const i = e.id();
        e.setId(t);
        this._sourcesById.delete(i);
        this._sourcesById.set(t, e);
        if ((0, Fn.isPriceDataSource)(e)) {
          this._priceSourcesById.delete(i);
          this._priceSourcesById.set(t, e);
        }
      }
      movePriceScale(e, t, i) {
        const s = this.priceScalePosition(e);
        if (s !== t) {
          this.removePriceScale(e);
          this._placePriceScale(e, t, i);
          e.invalidateMargins();
          this._invalidateSourcesCache();
        } else if (i !== undefined && s !== "overlay") {
          const t = s === "left" ? this._leftPriceScales : this._rightPriceScales;
          const o = t.indexOf(e);
          t.splice(o, 1);
          t.splice(i, 0, e);
        }
      }
      mainDataSource() {
        return this.m_mainDataSource;
      }
      isEmpty() {
        return this.m_mainDataSource === null;
      }
      recalculatePriceScale(e, t) {
        if (!e) {
          return;
        }
        let i = e.sourcesForAutoscale();
        if (e === this._model.mainSeries().priceScale()) {
          i = [...i, ...this._cachedOrderedSources.multipaneSources()];
        }
        if ((e.isAutoScale() || e.priceRangeShouldBeRecalculatedOnce() || e.priceRange() === null) && i.length > 0 && !this.timeScale().isEmpty()) {
          const i = e.priceRange();
          const s = this.timeScale().visibleBarsStrictRange();
          e.recalculatePriceRange(s);
          if (!th.PriceRange.compare(i, e.priceRange())) {
            e.updateAllViews(t);
          }
        }
      }
      onSourceTagsChanged() {
        this._tagsChanged.fire();
      }
      insertDataSource(e, t, i, s) {
        e.setZorder(i);
        if (!t) {
          s = false;
          t = this.findSuitableScale(e);
        }
        this._addSourceToCollections(e);
        let o = false;
        if (e === this.model().mainSeries()) {
          this.m_mainDataSource = this.model().mainSeries();
          o = true;
        } else if (this.m_mainDataSource === null && (0, Fn.isPriceDataSource)(e)) {
          this.m_mainDataSource = e;
          o = true;
        }
        if (!s) {
          t.addDataSource(e, this._isInInsertManyDataSourcesState);
        }
        e.setPriceScale(t);
        t.invalidateMargins();
        if (e.onTagsChanged) {
          e.onTagsChanged().subscribe(this, this.onSourceTagsChanged);
        }
        if (o && this._mode === Bi.PaneMode.Regular) {
          this._processMainSourceChange();
        }
        this._tagsChanged.fire();
        if ((0, Fn.isPriceDataSource)(e)) {
          this.recalculatePriceScale(t, (0, Bt.sourceChangeEvent)(e.id()));
        }
        this._invalidateSourcesCache();
      }
      addDataSource(e, t, i) {
        let s = e.zorder();
        if (!i) {
          if ((0, eo.isLineTool)(e) && !e.isSpeciallyZOrderedSource()) {
            s = this._lastLineDataSourceZOrder !== null ? this._lastLineDataSourceZOrder + 1 : this.newLineToolZOrder();
            if (this._isInInsertManyDataSourcesState) {
              this._lastLineDataSourceZOrder = s;
            }
          } else if ((0, Js.isStudy)(e) && !e.isSpeciallyZOrderedSource()) {
            s = this.newStudyZOrder();
          }
        }
        this.insertDataSource(e, t, s);
      }
      removeDataSource(e, t = false, i = false, s = false) {
        const o = this.m_dataSources.indexOf(e);
        if (o === -1) {
          Ah.logDebug("removeDataSource: invalid data source");
          return;
        }
        this._removeSourceFromCollections(o, i);
        if (e === this.m_mainDataSource && !t) {
          this.m_mainDataSource = null;
        }
        const n = e.priceScale();
        if (!s) {
          this.removeSourceFromPriceScale(e);
        }
        if (e.onTagsChanged) {
          e.onTagsChanged().unsubscribe(this, this.onSourceTagsChanged);
        }
        if ((0, Fn.isPriceDataSource)(e) && !t) {
          this._processMainSourceChange();
        }
        if ((0, Js.isStudy)(e) && e.metaInfo().hasForceOverlayPlots()) {
          this._model.removeMultiPaneSource(e);
        }
        this._tagsChanged.fire();
        if (n && (0, Fn.isPriceDataSource)(e)) {
          this.recalculatePriceScale(n, (0, Bt.sourceChangeEvent)(e.id()));
        }
        this._invalidateSourcesCache();
      }
      hasDataSource(e) {
        return this._sourcesById.has(e.id());
      }
      hasPriceDataSource(e) {
        return this._priceSourcesById.has(e.id());
      }
      dataSources() {
        return this.m_dataSources;
      }
      priceDataSources() {
        return this._priceDataSources;
      }
      lollipopDataSources() {
        return this._lollipopDataSources;
      }
      symbolSources() {
        return this._symbolSources;
      }
      replaceSource(e, t, i) {
        const s = this.m_mainDataSource === e;
        const o = i?.replaceSource(e, t);
        this.removeDataSource(e, s, undefined, o);
        this.insertDataSource(t, i, e.zorder(), o);
        this._sourcesById.set(t.id(), t);
        if ((0, Fn.isPriceDataSource)(t)) {
          this._priceSourcesById.set(t.id(), t);
        }
        if (s) {
          this.m_mainDataSource = t;
          this._processMainSourceChange();
        }
      }
      findSuitableScale(e, t, i) {
        return this._priceScaleSelectionStrategy.findSuitableScale(this, e, t, i);
      }
      createNewPriceScaleIfPossible() {
        return this._priceScaleSelectionStrategy.createNewPriceScaleIfPossible(this);
      }
      canCreateNewPriceScale() {
        return this._priceScaleSelectionStrategy.canCreateNewPriceScale(this);
      }
      isOverlay(e) {
        const t = e.priceScale();
        return t === null || this.priceScalePosition(t) === "overlay";
      }
      recalculate(e) {
        this._leftPriceScales.forEach(t => this.recalculatePriceScale(t, e));
        this._rightPriceScales.forEach(t => this.recalculatePriceScale(t, e));
        for (const t of this.m_dataSources) {
          if (this.isOverlay(t) && !(0, eo.isLineTool)(t)) {
            this.recalculatePriceScale(t.priceScale(), e);
          }
        }
        this.updateAllViews(e);
        this._model.updatePane(this);
      }
      updateAllViews(e) {
        const t = this._cachedOrderedSources.all();
        for (const i of t) {
          i.updateAllViews(e);
        }
        for (const t of this.model().customSources()) {
          t.updateViewsForPane(this, e);
        }
      }
      updateLollipopViews(e) { }
      priceScalePosition(e) {
        if (this._leftPriceScales.includes(e)) {
          return "left";
        } else if (this._rightPriceScales.includes(e)) {
          return "right";
        } else {
          return "overlay";
        }
      }
      createPriceScaleAtPosition(e, t) {
        const i = this.properties().childs().axisProperties.state();
        i.autoScale = true;
        const s = new fh(this.model().properties().childs().scalesProperties, i);
        s.setHeight(this.height());
        kh(s, this._defaultTopMargin(), this._defaultBottomMargin());
        this._placePriceScale(s, e, t);
        return s;
      }
      removePriceScale(e) {
        e.modeChanged().unsubscribeAll(this);
        e.priceRangeChanged().unsubscribeAll(this);
        e.internalHeightChanged().unsubscribeAll(this);
        e.isVisible().unsubscribe(this._onPriceScaleIsVisibleChanged);
        e.resetScaleAvailable().unsubscribe(this._updateResetPriceScalesAvailableValue);
        if (e === this._lockedPriceScale) {
          this._lockedPriceScale = null;
          this._currentPriceScaleRatio = null;
        }
        const t = this._leftPriceScales.indexOf(e);
        if (t !== -1) {
          this._leftPriceScales[t].invalidateMargins();
          this._leftPriceScales.splice(t, 1);
        }
        const i = this._rightPriceScales.indexOf(e);
        if (i !== -1) {
          this._rightPriceScales[i].invalidateMargins();
          this._rightPriceScales.splice(i, 1);
        }
        if (e.mainSource() === null) {
          const t = e.dataSources().length;
          if (t !== 0) {
            Ah.logError("Invalid priceScale state: empty mainSource but non-empty data sources=" + t);
          }
        }
        this._onPriceScalesChanged.fire();
        this._updateResetPriceScalesAvailableValue();
      }
      priceScaleIndex(e, t) {
        switch (t) {
          case "left":
            return this.leftPriceScales().indexOf(e);
          case "right":
            return this.rightPriceScales().indexOf(e);
        }
      }
      move(e, t, i) {
        const s = e.priceScale();
        this.removeSourceFromPriceScale(e);
        t.addDataSource(e);
        e.setPriceScale(t);
        t.invalidateMargins();
        this._processMainSourceChange();
        this._invalidateSourcesCache();
        if (e.isIncludedInAutoScale()) {
          if (s !== null) {
            this.recalculatePriceScale(s, (0, Bt.sourceChangeEvent)(e.id()));
          }
          this.recalculatePriceScale(t, (0, Bt.sourceChangeEvent)(e.id()));
        }
        this._onPriceScalesChanged.fire();
      }
      setZOrders(e) {
        e.forEach((e, t) => {
          t.setZorder(e);
        });
        this._invalidateSourcesCache();
        if (this._bulkActions.activeCounter === 0) {
          this._dataSourcesCollectionChanged.fire();
        }
        this.model().fullUpdate();
      }
      isMainPane() {
        return this._isMainPane.readonly();
      }
      isLast() {
        const e = this.model().panes();
        return e[e.length - 1] === this;
      }
      newStudyZOrder() {
        return function (e) {
          let t = -10000;
          for (const i of e) {
            if (yl(i)) {
              t = Math.min(t, i.zorder() - 10000);
            }
          }
          if (t === 0) {
            return -10000;
          } else {
            return t;
          }
        }(this._priceDataSources);
      }
      newLineToolZOrder(e) {
        return function (e, t) {
          return Ll(e, fl, yl, bl, wl, t);
        }(this.m_dataSources, e);
      }
      model() {
        return this._model;
      }
      containsMainSeries() {
        return this._sourcesById.has(this.model().mainSeries().id());
      }
      applyPriceScaleRatio(e, t) {
        if ((this._lockedPriceScale === null || this._lockedPriceScale === e) && this._currentPriceScaleRatio !== t && !!this.isMainPane().value() && (this._lockedPriceScale !== null || e === this.mainDataSource()?.priceScale())) {
          this._setNewPriceRangeByScaleRatio(e, t, this._mainSourceVisiblePriceRange(e), true, true);
          if (this._lockedPriceScale !== null) {
            this._tryToApplyNewPriceScaleRatio();
          } else if (!e.isLog()) {
            this.model().mainSeriesScaleRatioPropertyOnChanged();
          }
        }
      }
      sendToBack(e) {
        const t = this.sourcesByGroup().allExceptSpecialSources();
        this._batchReorder(e, t[0], Fl);
      }
      bringToFront(e) {
        const t = this.sourcesByGroup().allExceptSpecialSources();
        this._batchReorder(e, t[t.length - 1], Ol);
      }
      sendBackward(e) {
        const t = this.sourcesByGroup().allIncludingHidden();
        const i = t.indexOf(e[0]);
        if (i === 0) {
          this.bringToFront(e);
        } else {
          const s = t[i - 1];
          this.insertBefore(e, s);
        }
      }
      bringForward(e) {
        const t = this.sourcesByGroup().allExceptSpecialSources();
        const i = t.indexOf(e[e.length - 1]);
        if (i === t.length - 1) {
          this.sendToBack(e);
        } else {
          const s = t[i + 1];
          this.insertAfter(e, s);
        }
      }
      insertAfter(e, t) {
        this._batchReorder(e, t, Ol);
      }
      insertBefore(e, t) {
        this._batchReorder(e, t, Fl);
      }
      maximized() {
        return this._maximized;
      }
      collapsed() {
        return this._collapsed;
      }
      collapsingAvailable() {
        return this._collapsingAvailable;
      }
      getPriceScaleById(e) {
        const t = this.m_dataSources.find(t => t.priceScale()?.id() === e);
        if (t === undefined) {
          return null;
        } else {
          return t.priceScale();
        }
      }
      priceScaleSelectionStrategy() {
        return this._priceScaleSelectionStrategy;
      }
      setPriceScaleSelectionStrategy(e) {
        this._priceScaleSelectionStrategy = e;
        e.apply(this);
      }
      findTargetPriceAxisViews(e, t, i, s) {
        if ((0, Vo.isDataSource)(e) && this.model().paneForSource(e) !== this) {
          return [];
        }
        const o = e.priceScale();
        if (t === o) {
          return i;
        }
        if (o === null) {
          return [];
        }
        if (this.priceScalePosition(o) === "overlay") {
          if (t === this.defaultPriceScale()) {
            return i;
          } else {
            return [];
          }
        }
        const n = this.priceScalePosition(t);
        if (n !== this.priceScalePosition(o)) {
          return [];
        }
        const r = n === "left" ? this.leftPriceScales() : this.rightPriceScales();
        if (r.indexOf(t) < r.indexOf(o)) {
          return s;
        } else {
          return [];
        }
      }
      actionNoScaleIsEnabled(e) {
        return !!this.isOverlay(e) || !(0, Fn.isPriceDataSource)(e) || this._nonOverlayPricesSourcesCount() > 1;
      }
      properties() {
        return this._properties;
      }
      setPriceAutoScale(e, t) {
        e.setMode({
          autoScale: t
        });
        if (!this.timeScale().isEmpty()) {
          this.recalculatePriceScale(e, (0, Bt.viewportChangeEvent)());
        }
      }
      state(e, t, i, s, o, n) {
        const r = {
          sources: [],
          mainSourceId: this.m_mainDataSource?.id(),
          stretchFactor: this._stretchFactor,
          leftAxisesState: [],
          rightAxisesState: [],
          overlayPriceScales: {},
          priceScaleRatio: this._currentPriceScaleRatio,
          isCollapsed: this._collapsed.value(),
          isMaximized: this._maximized.value(),
          mode: this._mode
        };
        const a = new Map();
        const l = e => {
          if (a.has(e)) {
            return a.get(e);
          }
          let r = null;
          const l = i && !e.isSavedInStudyTemplates() || !e.state || (0, eo.isLineTool)(e) && n || !e.isSavedInChart(Boolean(t)) || !(r = e.state(t, o)) || s && (0, eo.isLineTool)(e) && e.isActualSymbol && !e.isActualSymbol() || e.isPhantom() ? null : r;
          a.set(e, l);
          return l;
        };
        if (e) {
          r.sources = [];
          for (let e = 0; e < this.m_dataSources.length; e++) {
            const t = l(this.m_dataSources[e]);
            if (t !== null) {
              r.sources.push(t);
            }
          }
        }
        const c = e => a.get(e) !== null;
        const h = e => !n || !(0, eo.isLineTool)(e);
        r.leftAxisesState = this._leftPriceScales.map(e => ({
          state: e.state(),
          sources: e.dataSources().filter(c).filter(h).map(e => e.id())
        }));
        r.rightAxisesState = this._rightPriceScales.map(e => ({
          state: e.state(),
          sources: e.dataSources().filter(c).filter(h).map(e => e.id())
        }));
        r.overlayPriceScales = {};
        for (const e of this.m_dataSources) {
          if (this.isOverlay(e) && e.isSavedInChart(Boolean(t))) {
            const t = e.priceScale();
            r.overlayPriceScales[e.id()] = t?.state() ?? null;
          }
        }
        return r;
      }
      restoreState(e) {
        const {
          state: t,
          withData: i,
          version: s,
          seriesId: o = this._model.mainSeries().id(),
          settingsMigration: r = {},
          contentOverrides: a,
          restoreSilently: l,
          reason: c = 0,
          targetSeriesStyle: d = this._model.mainSeries().style()
        } = e;
        (0, Gc.getPersistentLogger)()?.addPersistentLogEntry(`Restoring pane with seriesId ${o}`, ae.LOGLEVEL.INFO, Dh);
        this._mode = t.mode ?? Bi.PaneMode.Regular;
        if (t.stretchFactor) {
          this._stretchFactor = t.stretchFactor;
        }
        const u = {};
        if (t.sources) {
          const e = t.sources.filter(e => !!e && (e.type === "MainSeries" || !e.points?.some(e => e.time_t === null || !isFinite(e.time_t)) || (Ah.logNormal("Dropped invalid " + e.type + ". Reason: non-numeric point time"), false)));
          const n = e.findIndex(pt.isMainSeriesState);
          if (n !== -1) {
            this.model().mainSeries().setObsoleteZOrder(e[n].zorder);
          }
          if (s < 3) {
            Ml(e);
          }
          const h = this.m_dataSources.indexOf(this._model.mainSeries()) !== -1;
          this.clearSeries(Boolean(l));
          this.m_mainDataSource = null;
          if (h) {
            this._addSourceToCollections(this._model.mainSeries(), l);
          }
          (() => {
            const i = e.find(e => e.id === t.mainSourceId);
            if (i === undefined) {
              Ah.logWarn("There is no main source with id " + t.mainSourceId + ", total sources=" + e.length);
              return;
            }
            if (!window.TradingView[i.type] || !(0, wt.isLineToolName)(i.type)) {
              Ah.logNormal("The type of main source is not line tool - fix is unnecessary");
              return;
            }
            let s = null;
            for (const t of e) {
              if (!window.TradingView[i.type] || !(0, wt.isLineToolName)(t.type)) {
                if (s !== null) {
                  Ah.logWarn("Pane contains more than 1 possibly main sources - auto fix cannot be applied");
                  return;
                }
                s = t;
              }
            }
            if (s === null) {
              Ah.logWarn("Pane contains only line tools - possible we need to remove this pane?");
              return;
            }
            const o = t.mainSourceId;
            let n = 0;
            t.mainSourceId = s.id;
            e.forEach(e => {
              if (e.ownerSource === o) {
                e.ownerSource = s?.id;
                n += 1;
              }
            });
            Ah.logNormal("Auto fix broken pane is applied, changed line tools=" + n + ", changed from=" + o + " to=" + s.id);
          })();
          for (const t of e) {
            if (t.type === "study_Sessions") {
              const e = t;
              e.oldState = true;
              this.model().sessions().restoreState(e, i);
              break;
            }
          }
          for (const t of e) {
            if (t.type !== "study_Sessions") {
              if (this._model.dataSourceForId(t.id) === null || t.type === "MainSeries") {
                u[t.id] = t.ownerSource;
                if ((0, pt.isMainSeriesState)(t)) {
                  this._restoreMainSeries(t, i, h, r, a, l);
                } else if ((0, pt.isStudyState)(t)) {
                  this.restoreStudy(t, i, o, r, l, c);
                } else if ((0, pt.isLineToolState)(t)) {
                  if (t.state) {
                    t.state.zOrderVersion = 2;
                  }
                  this.restoreLineTool(t, i, undefined, l);
                } else if (t.type === ChartEventsSourceId.Value) {
                  this._restoreSpecialSource(t, i, l);
                } else if (t.type === "TpoSummaryDataSource" && d === 18) {
                  this.restoreTpoSummaryDataSource(t, i, l);
                }
              } else {
                Ah.logError("Duplicate id while restoring pane: " + t.type + "," + t.id);
              }
            }
          }
        }
        const _ = new Set();
        const p = (e, t) => {
          if (e.priceScale() !== t) {
            this.removeSourceFromPriceScale(e);
            e.setPriceScale(t);
            t.addDataSource(e);
          }
        };
        const m = (e, i, s) => {
          if (_.has(e)) {
            return;
          }
          _.add(e);
          const o = s.m_showSymbolLabels;
          if (o !== undefined && e === this.model().mainSeries()) {
            this.model().properties().childs().scalesProperties.childs().showSymbolLabels.setValue(o);
          }
          this._model.children(e, true).forEach(e => {
            if (!t.overlayPriceScales?.[e.id()]) {
              m(e, i, s);
            }
          });
          p(e, i);
        };
        const g = e => {
          const t = (0, h.defaults)("chartproperties").paneProperties.axisProperties;
          const i = new fh(this.model().properties().childs().scalesProperties, t);
          i.restoreState(e.state);
          i.setHeight(this._height);
          e.sources.forEach(e => {
            const s = this.dataSourceForId(e);
            if (s) {
              m(s, i, t);
            }
          });
          if (i.dataSources().length === 0) {
            return null;
          } else {
            return i;
          }
        };
        const f = e => e.map(g).filter(e => e !== null);
        let y;
        if (t.leftAxisesState) {
          y = f(t.leftAxisesState);
        } else {
          const e = g({
            state: t.leftAxisState,
            sources: t.leftAxisSources
          });
          y = e !== null ? [e] : [];
        }
        let v;
        this._leftPriceScales.slice().forEach(e => this.removePriceScale(e));
        this._leftPriceScales = [];
        y.forEach(e => this._placePriceScale(e, "left"));
        if (t.rightAxisesState) {
          v = f(t.rightAxisesState);
        } else {
          const e = g({
            state: t.rightAxisState,
            sources: t.rightAxisSources
          });
          v = e !== null ? [e] : [];
        }
        this._rightPriceScales.slice().forEach(e => this.removePriceScale(e));
        this._rightPriceScales = [];
        v.forEach(e => this._placePriceScale(e, "right"));
        this._currentPriceScaleRatio = t.priceScaleRatio || t.leftPriceScaleRatio || t.rightPriceScaleRatio || null;
        const S = new Map();
        for (const e of this.m_dataSources) {
          if (_.has(e)) {
            continue;
          }
          let i;
          if (t.overlayPriceScales && t.overlayPriceScales[e.id()]) {
            let s = t.overlayPriceScales[e.id()];
            if (S.has(s?.id)) {
              i = S.get(s?.id);
            } else {
              s = (0, n.ensure)(s);
              i = new fh(this._model.properties().childs().scalesProperties);
              i.setHeight(this._height);
              s.m_isAutoScale = true;
              s.m_isLog = false;
              s.m_isPercentage = false;
              s.m_isLockScale = false;
              i.restoreState(s);
              S.set(s.id, i);
            }
          } else {
            i = new fh(this._model.properties().childs().scalesProperties);
            i.setHeight(this._height);
          }
          p(e, i);
        }
        for (const e of Object.keys(u)) {
          const t = u[e];
          const i = this.dataSourceForId(e);
          if (t && i && i.ownerSource() === null) {
            i.setOwnerSource(this.dataSourceForId(t));
          }
        }
        if (t.mainSourceId && !this.containsMainSeries()) {
          this.m_mainDataSource = this.dataSourceForId(t.mainSourceId);
        }
        if (!this.m_mainDataSource) {
          for (const e of this.m_dataSources) {
            if ((0, Fn.isPriceDataSource)(e)) {
              this.m_mainDataSource = e;
              break;
            }
          }
        }
        for (const e of this.m_dataSources) {
          if ((0, eo.isLineTool)(e)) {
            if (!e.ownerSource()) {
              e.setOwnerSource(this.mainDataSource());
            }
            if (e.isFixed()) {
              e.restoreFixedPoint();
            }
          } else if ((0, Js.isStudy)(e) && !e.ownerSource() && e.isLinkedToSeries()) {
            e.setOwnerSource(this.model().mainSeries());
          }
        }
        this._collapsed.setValue(t.isCollapsed ?? false);
        if (t.isMaximized) {
          this._model.setMaximizedPane(this);
        }
        this._updateMargins();
        this._cachedOrderedSources.clear();
      }
      onPriceScalesChanged() {
        return this._onPriceScalesChanged;
      }
      setPaneSize(e) {
        let t;
        switch (e) {
          case "large":
            t = 1;
            break;
          case "medium":
            t = 0.6;
            break;
          case "small":
            t = 0.3;
            break;
          case "tiny":
            t = 0.15;
            break;
          default:
            throw new Error("Unknown size enum value: " + e);
        }
        this._stretchFactor = t * 1000;
      }
      stretchFactor() {
        return this._stretchFactor;
      }
      setStretchFactor(e) {
        this._stretchFactor = e;
      }
      customSources(e) {
        return this.model().customSources(e);
      }
      createDrawingsCaches() {
        Yc.ExecutionsPositionController.recreateOrderedByBarsSourcesCache(this);
      }
      clearDrawingCaches() {
        Yc.ExecutionsPositionController.clearOrderedByBarsSourcesCache();
      }
      executionsPositionController() {
        this._executionsPositionController ||= new Yc.ExecutionsPositionController(this);
        return this._executionsPositionController;
      }
      width() {
        return this._width;
      }
      height() {
        return this._height;
      }
      setHeight(e) {
        if (this._height !== e && (this._height = e, this._mode === Bi.PaneMode.Regular)) {
          this._leftPriceScales.forEach(t => t.setHeight(e));
          this._rightPriceScales.forEach(t => t.setHeight(e));
          for (let t = 0; t < this.m_dataSources.length; t++) {
            const i = this.m_dataSources[t];
            if (this.isOverlay(i) && i.priceScale()) {
              (0, n.ensureNotNull)(i.priceScale()).setHeight(e);
            }
          }
          this.updateAllViews((0, Bt.viewportChangeEvent)());
          this._sizeChanged.fire();
        }
      }
      setWidth(e) {
        return this._width !== e && (this._width = e, this.updateAllViews((0, Bt.viewportChangeEvent)()), this._sizeChanged.fire(), true);
      }
      onSizeChanged() {
        return this._sizeChanged;
      }
      onTagsChanged() {
        return this._tagsChanged;
      }
      onDestroyed() {
        return this._destroyed;
      }
      dataSourcesCollectionChanged() {
        return this._dataSourcesCollectionChanged;
      }
      symbolSourceCollectionChanged() {
        return this._symbolSourceCollectionChanged;
      }
      priceSourcesCollectionChanged() {
        return this._priceSourcesCollectionChanged;
      }
      symbolSourceResolved() {
        return this._symbolSourceResolved;
      }
      symbolSourceResolvingActive() {
        return this._symbolSourceResolvingActive;
      }
      sourcePropertiesChanged() {
        return this._sourcePropertiesChanged;
      }
      sourceZOrderChanged() {
        return this._sourcesZOrderChanged;
      }
      lineToolsForArea(e, t) {
        const i = this.logicalRectToPixels(e);
        return [...this.m_dataSources, ...this.model().multiPaneSources(this)].filter(eo.isLineTool).filter(e => (e.paneViews(this) || []).some(e => {
          const s = e.renderer(t);
          return s && s.doesIntersectWithBox && s.doesIntersectWithBox(i, t);
        }));
      }
      logicalRectToPixels(e) {
        const t = this.defaultPriceScale();
        const i = this.timeScale();
        const s = (0, n.ensureNotNull)((0, n.ensureNotNull)(t.mainSource()).firstValue());
        const o = t.priceToCoordinate(e.p1.price, s);
        const r = i.indexToCoordinate(e.p1.index);
        const a = t.priceToCoordinate(e.p2.price, s);
        const l = i.indexToCoordinate(e.p2.index);
        const c = new At.Point(Math.min(r, l), Math.min(o, a));
        const h = new At.Point(Math.max(r, l), Math.max(o, a));
        return (0, At.box)(c, h);
      }
      timeScale() {
        return this._timeScale;
      }
      restoreLineTool(e, t, i, s, o) {
        if ((0, wt.isMtpPredictorToolName)(e.type)) {
          Ah.logWarn(`No longer supported tool ${e.type} is skipped while restoring state`);
          return null;
        }
        var r;
        delete e.state.lastUpdateTime;
        e.state.intervalsVisibilities = (0, Ch.mergeIntervalVisibilitiesDefaults)(e.state.intervalsVisibilities);
        i = i === undefined || i;
        wh.LineToolElliott.migrateState(e);
        if ((r = e).type === "LineToolGannComplex" && (r.version === undefined || r.version === 1)) {
          r.type = "LineToolGannFixed";
        }
        if (Array.isArray(e.positionPercents)) {
          e.positionPercents = e.positionPercents[0];
        }
        const a = e.type;
        const l = e.id;
        const c = e.state;
        const h = i ? e.zorder : this.newLineToolZOrder();
        (0, n.assert)((0, wt.isLineToolName)(a), "invalid data source type:" + a + " (expected to be a Line Tool)");
        let d;
        let u;
        let _ = null;
        if ((0, pt.isStudyLineToolState)(e)) {
          _ = this._model.isSnapshot() ? new Th.StudyVersioning([], []) : (0, ts.studyMetaInfoRepository)().studyVersioning();
          const t = Th.StudyVersioning.patchPointsBasedStudyState(e);
          e = t;
          const i = new is.StudyMetaInfo(t.metaInfo);
          0;
          const s = _.updateMetaInfo(i) ?? i;
          u = (0, eo.createStudyLineToolProperties)(this._model.backgroundTheme().spawnOwnership(), a, i, s, c, _);
          d = (0, eo.createLineTool)(a, this._model, u, s, true);
        } else {
          u = (0, eo.createLineToolProperties)(this._model.backgroundTheme().spawnOwnership(), a, !this._model.readOnly(), c);
          d = (0, eo.createLineTool)(a, this._model, u, null, true);
        }
        d.setId(l);
        d.linkKey().setValue(e.linkKey || null);
        if (e.alertId) {
          d.canHasAlert();
        }
        let p = e.indexes ?? [];
        p = p.slice(0, e.points?.length ?? p.length);
        if (d.isFixed()) {
          if (e.positionPercents !== undefined) {
            d.restorePositionPercents(e.positionPercents);
          } else {
            d.restorePositionPercents({
              x: 0.5,
              y: 0.5
            });
          }
        } else if (e.points) {
          d.restorePoints(e.points, p, t);
        }
        if ((0, eo.isLineTool)(d) && ["LineToolBarsPattern", "LineToolCallout", "LineToolTrendAngle", "LineToolGhostFeed", "LineToolParallelChannel"].includes(d.toolname)) {
          d.restoreData?.(e);
        } else if (t && (0, pt.isStudyLineToolState)(e) && d.restoreData) {
          const t = e;
          if (_) {
            t.graphics = Th.StudyVersioning.patchPointsBasedStudyData(new is.StudyMetaInfo(t.metaInfo), t.graphics);
          }
          d.restoreData?.(t);
        }
        const m = e.version == null ? 1 : e.version;
        const g = d.version == null ? 1 : d.version;
        if (m !== g) {
          d.migrateVersion?.(m, g, {
            pane: this,
            model: this._model,
            properties: u
          });
        }
        if (h !== undefined) {
          d.setZorder(h);
        }
        if (o) {
          (0, eo.prepareLineToolPropertiesByOwnerSource)(d.properties(), o);
          d.setOwnerSource(o);
        } else {
          const t = e.ownerSource ? this.dataSourceForId(e.ownerSource) : null;
          d.setOwnerSource(t);
        }
        if (d.isFixed()) {
          d.restoreFixedPoint();
        }
        if (e.userEditEnabled !== undefined) {
          d.setUserEditEnabled(e.userEditEnabled);
        }
        if (e.isSelectionEnabled !== undefined) {
          d.setSelectionEnabled(e.isSelectionEnabled);
        }
        this._addSourceToCollections(d, s);
        this._cachedOrderedSources.clear();
        return d;
      }
      restoreStudy(e, t, s, o, n, r) {
        if (t && e.data === undefined && e.nonSeriesData === undefined && e.indexes === undefined) {
          Ah.logError("Cannot restore (skipping) study without data " + e.id + ", " + e.metaInfo.id);
          return null;
        }
        const l = e.id;
        const c = e.state;
        const h = e.zorder;
        s = s ?? this._model.mainSeries().id();
        const d = (e.parentSources ?? (e.ownerSource ? [e.ownerSource] : [])).filter(e => e !== s);
        let u = new is.StudyMetaInfo(e.metaInfo);
        if (function (e) {
          return e === "Script$TV_EARNINGS@tv-scripting" || e === "Script$TV_DIVIDENDS@tv-scripting" || e === "Script$TV_SPLITS@tv-scripting" || e === "ESD$TV_EARNINGS@tv-scripting" || e === "ESD$TV_DIVIDENDS@tv-scripting" || e === "ESD$TV_SPLITS@tv-scripting" || e === "Earnings@tv-basicstudies" || e === "Dividends@tv-basicstudies" || e === "Splits@tv-basicstudies" || e === "BarSetContinuousRollDates@tv-corestudies";
        }(u.id) && !t) {
          Ah.logNormal("Skipping study " + u.id);
          return null;
        }
        let _ = c;
        const p = new wc.StudyStub(this._model, e, u.shortDescription ?? u.name);
        p.setId(l);
        p.setZorder(h);
        const m = bh.instance(this._model);
        m.get(l);
        let g = false;
        const f = (i, s) => {
          if (g && this._model.dataSourceForId(l) !== p) {
            return;
          }
          p.setStatus({
            type: yh.StudyStatusType.Undefined
          });
          const o = i ?? u;
          const n = async n => {
            const a = (0, Cc.prepareStudyPropertiesForLoadChart)(u, i, _, s);
            const c = await (0, Js.createStudy)(this._model, a, n, o, undefined, r);
            c.setId(l);
            c.setOwnFirstValue(e.ownFirstValue ?? null);
            if (e.customFields) {
              c.restoreStateCustomFields(e.customFields);
            }
            if (t) {
              const t = e;
              const {
                data: i,
                nsData: s,
                indexes: o
              } = Th.StudyVersioning.patchStudyData(u, t.data, t.nonSeriesData, t.indexes);
              c.restoreData(i, s, o);
            }
            this._model.replaceStudyStub(p, c);
            m.add(l, c);
          };
          if (d.length > 0) {
            const e = d.map(e => m.get(e));
            Promise.all(e).then(n);
          } else {
            n([]);
          }
        };
        let y;
        if (t) {
          const e = Th.StudyVersioning.patchPropsStateAndMetaInfo(c, u, {
            oldShowStudyLastValueProperty: !o?.showStudyLastValueProperty
          });
          y = Promise.resolve(new is.StudyMetaInfo(e.metaInfo));
        } else {
          y = (0, ts.studyMetaInfoRepository)().requestMetaInfo().then(() => {
            const e = Th.StudyVersioning.patchPropsStateAndMetaInfo(c, u, {
              oldShowStudyLastValueProperty: t && !o?.showStudyLastValueProperty
            });
            _ = e.propsState;
            return new is.StudyMetaInfo(e.metaInfo);
          });
        }
        y.then(e => {
          const t = this._model.isSnapshot() ? new Th.StudyVersioning([], []) : (0, ts.studyMetaInfoRepository)().studyVersioning();
          if (e === null || this._model.isSnapshot()) {
            f(e, t);
            return;
          }
          const i = t.updateMetaInfoAsync(e);
          if (i.sync) {
            f(i.result ?? e, t);
          } else {
            i.result.then(e => f(e, t)).catch(e => p.setFailed("error: " + e));
          }
        }).catch(() => p.setFailed(a.t(null, undefined, i(11768))));
        p.setZorder(h);
        const v = e.metaInfo.linkedToSeries ? this._model.mainSeries() : d.length ? this.dataSourceForId(d[0]) : null;
        p.setOwnerSource(v);
        this._addSourceToCollections(p, n);
        g = true;
        this._processMainSourceChange();
        this._cachedOrderedSources.clear();
        return p;
      }
      restoreTpoSummaryDataSource(e, t, i) {
        const s = new TpoSummaryDataSource(this._model);
        this._addSourceToCollections(s, i);
        this._cachedOrderedSources.clear();
        return s;
      }
      clipboardLineToolOwnerSource(e) {
        const t = this.dataSourceForId(e);
        if (t !== null) {
          const e = t.ownerSource();
          if (e !== null && e.firstValue() !== null) {
            return e;
          }
        }
        const i = this.mainDataSource();
        if (i !== null && i.firstValue() !== null) {
          return i;
        }
        for (const e of this.dataSources()) {
          if ((0, Fn.isPriceDataSource)(e) && e.firstValue() !== null) {
            return e;
          }
        }
        return null;
      }
      realignLineTools(e) {
        let t = false;
        for (const i of this.m_dataSources) {
          if (!!(0, eo.isLineTool)(i) && (e === undefined || i?.ownerSource()?.symbolSource() === e || !(0, Nr.isActingAsSymbolSource)(e))) {
            i.realign();
            i.updateAllViews((0, Bt.sourceChangeEvent)(i.id()));
            t = true;
          }
        }
        if (t) {
          this._invalidateSourcesCache();
        }
        return t;
      }
      startScalePrice(e, t) {
        e.startScale(t);
      }
      scalePriceTo(e, t) {
        e.scaleTo(t);
        this.updateAllViews((0, Bt.viewportChangeEvent)());
      }
      endScalePrice(e) {
        e.endScale();
      }
      startScrollPrice(e, t) {
        e.startScroll(t);
      }
      scrollPriceTo(e, t) {
        e.scrollTo(t);
        this.updateAllViews((0, Bt.viewportChangeEvent)());
      }
      endScrollPrice(e) {
        e.endScroll();
      }
      resetPriceScale(e) {
        const t = this.timeScale().visibleBarsStrictRange();
        if (e.resetScaleAvailable().value()) {
          e.resetScale();
        }
        e.recalculatePriceRange(t);
        this.updateAllViews((0, Bt.viewportChangeEvent)());
      }
      resetPriceScalesAvailable() {
        return this._resetPriceScalesAvailable.readonly();
      }
      restorePriceScaleState(e, t) {
        e.restoreState(t);
        this.updateAllViews((0, Bt.viewportChangeEvent)());
      }
      beginInsertManyLineDataSources() {
        this._isInInsertManyDataSourcesState = true;
        this._lastLineDataSourceZOrder = null;
      }
      endInsertManyLineDataSources() {
        this._isInInsertManyDataSourcesState = false;
        this._lastLineDataSourceZOrder = null;
      }
      removeSourceFromPriceScale(e) {
        const t = e.priceScale();
        if (t !== null) {
          const i = t.dataSources();
          if (i.indexOf(e) >= 0) {
            t.removeDataSource(e);
          }
          if (i.length === 0) {
            this.removePriceScale(t);
          }
        }
      }
      setPriceScaleRangeAnimation(e, t) {
        const i = yo.InvalidationMask.cursor();
        const s = this._model.panes().indexOf(this);
        const o = this.priceScalePosition(e);
        i.setPriceScaleRangeAnimation(s, e.id(), t);
        if (o !== "overlay") {
          i.invalidatePriceScale(s, o, (0, n.ensureDefined)(this.priceScaleIndex(e, o)), yo.InvalidationLevel.Light);
        }
        this._model.invalidate(i);
      }
      _invalidateSourcesCache() {
        this._cachedOrderedSources.clear();
        this._leftPriceScales.forEach(e => e.invalidateSourcesCache());
        this._rightPriceScales.forEach(e => e.invalidateSourcesCache());
      }
      _processMainSourceChange() {
        let e = false;
        if (this.m_mainDataSource === null) {
          for (const t of this.m_dataSources) {
            if ((0, Fn.isPriceDataSource)(t) && !this.isOverlay(t) && (!(0, Js.isStudy)(t) || !t.isLinkedToSeries())) {
              this.m_mainDataSource = t;
              e = true;
              break;
            }
          }
        }
        if (this.m_mainDataSource && e) {
          let e = this.m_dataSources.filter(eo.isLineTool);
          e = (0, ci.sortSources)(e);
          for (const t of e) {
            this.move(t, (0, n.ensureNotNull)(this.m_mainDataSource.priceScale()), true);
          }
        } else if (!this.m_mainDataSource || this.isOverlay(this.m_mainDataSource) && this._nonOverlayPricesSourcesCount() === 0) {
          let e = null;
          if (this.m_dataSources.includes(this._model.mainSeries())) {
            e = this._model.mainSeries();
          } else {
            for (const t of this.m_dataSources) {
              if ((0, Fn.isPriceDataSource)(t) && this.isOverlay(t) && t.showInObjectTree()) {
                e = t;
                break;
              }
            }
          }
          if (e !== null) {
            const t = this.m_mainDataSource === e;
            this.m_mainDataSource = e;
            const i = this.createNewPriceScaleIfPossible();
            if (t && e === this._model.mainSeries()) {
              const t = (0, n.ensureNotNull)(e.priceScale());
              this._model.children(e, true).forEach(e => {
                this.removeSourceFromPriceScale(e);
                i.addDataSource(e);
                e.setPriceScale(i);
              });
              this.removePriceScale(t);
            }
            this.move(e, i, true);
            this.recalculatePriceScale(e.priceScale(), (0, Bt.globalChangeEvent)());
          }
        }
      }
      _addSourceToCollections(e, t) {
        this.m_dataSources.push(e);
        this._sourcesById.set(e.id(), e);
        this._invalidateSourcesCache();
        const i = () => {
          this._sourcePropertiesChanged.fire(e);
        };
        e.properties().subscribe(this, i);
        e.zOrderChanged().subscribe(this, t => this._sourcesZOrderChanged.fire(e, t));
        if ((0, eo.isLineTool)(e)) {
          e.normalizedPointsChanged().subscribe(this, i);
          e.fixedPointChanged().subscribe(this, i);
          e.hasAlert().subscribe(i);
          e.sharingMode().subscribe(i);
          const t = () => {
            this._lineToolsByLinkKey.removeByKey2(e.id());
            this._lineToolsByLinkKey.add(e);
          };
          e.linkKey().subscribe(t);
          this._sourceWatchedValuesSubscriptions.set(e.id(), {
            linkKeyCallback: t,
            commonCallback: i
          });
          this._lineToolsByLinkKey.add(e);
        }
        const s = (0, Nr.isSymbolSource)(e) ? e : null;
        if ((0, Fn.isPriceDataSource)(e)) {
          this._priceSourcesById.set(e.id(), e);
          e.currencyChanged().subscribe(this, () => this._invalidateSourcesCache());
          e.unitChanged().subscribe(this, () => this._invalidateSourcesCache());
          e.priceScaleChanged().subscribe(this, () => this._onPriceScalesCollectionIncludingOverlaysMayChange());
          this._priceDataSources.push(e);
          this._onPriceSourcesCollectionChanged();
          this._onPriceScalesCollectionIncludingOverlaysMayChange();
          if (s !== null) {
            this._symbolSources.push(s);
            s.symbolResolved().subscribe(this, () => this._symbolSourceResolved.fire(e));
            s.symbolResolvingActive().subscribe(this._recalcSymbolSourceResolvingActive);
            s.symbolHibernated().subscribe(this._onSymbolSourceCollectionChanged);
            this._recalcSymbolSourceResolvingActive();
            this._onSymbolSourceCollectionChanged();
            if (s === this._model.mainSeries()) {
              this._isMainPane.setValue(true);
            }
          }
        }
        if (e.isMultiPaneAvailable()) {
          this.model().addMultiPaneSource(e);
        }
        if (!t && this._bulkActions.activeCounter === 0) {
          this._dataSourcesCollectionChanged.fire();
        }
      }
      _removeSourceFromCollections(e, t) {
        const i = this.m_dataSources[e];
        const s = i.id();
        i.properties().unsubscribeAll(this);
        i.zOrderChanged().unsubscribeAll(this);
        this.m_dataSources.splice(e, 1);
        this._sourcesById.delete(i.id());
        if ((0, eo.isLineTool)(i)) {
          i.normalizedPointsChanged().unsubscribeAll(this);
          i.fixedPointChanged().unsubscribeAll(this);
          if (this._sourceWatchedValuesSubscriptions.has(s)) {
            const e = this._sourceWatchedValuesSubscriptions.get(s);
            if (e) {
              i.hasAlert().unsubscribe(e.commonCallback);
              i.linkKey().unsubscribe(e.linkKeyCallback);
            }
          }
          this._lineToolsByLinkKey.removeByKey2(i.id());
        }
        this._invalidateSourcesCache();
        const o = (0, Nr.isSymbolSource)(i) ? i : null;
        if ((0, Fn.isPriceDataSource)(i)) {
          this._priceSourcesById.delete(i.id());
          i.currencyChanged().unsubscribeAll(this);
          i.unitChanged().unsubscribeAll(this);
          i.priceScaleChanged().unsubscribeAll(this);
          (0, ft.removeItemFromArray)(this._priceDataSources, i);
          this._onPriceSourcesCollectionChanged();
          if (o !== null) {
            (0, ft.removeItemFromArray)(this._symbolSources, o);
            o.symbolResolved().unsubscribeAll(this);
            o.symbolResolvingActive().unsubscribe(this._recalcSymbolSourceResolvingActive);
            o.symbolHibernated().unsubscribe(this._onSymbolSourceCollectionChanged);
            this._recalcSymbolSourceResolvingActive();
            this._onSymbolSourceCollectionChanged();
            if (o === this._model.mainSeries()) {
              this._isMainPane.setValue(false);
            }
          }
        }
        if (i.isMultiPaneAvailable()) {
          this.model().removeMultiPaneSource(i);
        }
        if (!t && this._bulkActions.activeCounter === 0) {
          this._dataSourcesCollectionChanged.fire();
        }
      }
      _recalculatePriceScaleByScaleRatio(e) {
        if (this.isMainPane().value() && e === this._lockedPriceScale) {
          if (this._currentPriceScaleRatio !== null) {
            this._applyOldScaleRatioToPriceScale();
          } else {
            this._tryToApplyNewPriceScaleRatio();
          }
        }
      }
      _defaultBottomMargin() {
        return this.properties().childs().bottomMargin.value() * 0.01;
      }
      _defaultTopMargin() {
        return this.properties().childs().topMargin.value() * 0.01;
      }
      _updateMargins() {
        const e = this._defaultTopMargin();
        const t = this._defaultBottomMargin();
        for (const i of this._leftPriceScales) {
          kh(i, e, t);
        }
        for (const i of this._rightPriceScales) {
          kh(i, e, t);
        }
        for (const i of this.m_dataSources) {
          if (this.isOverlay(i)) {
            const s = i.priceScale();
            if (s !== null) {
              kh(s, e, t);
              this.recalculatePriceScale(s, (0, Bt.viewportChangeEvent)());
            }
          }
        }
        for (const e of this._leftPriceScales) {
          this.recalculatePriceScale(e, (0, Bt.viewportChangeEvent)());
        }
        for (const e of this._rightPriceScales) {
          this.recalculatePriceScale(e, (0, Bt.viewportChangeEvent)());
        }
        this.updateAllViews((0, Bt.viewportChangeEvent)());
      }
      _batchReorder(e, t, i) {
        i(this.sourcesByGroup().allExceptSpecialSources(), e, t);
        this._invalidateSourcesCache();
        this._dataSourcesCollectionChanged.fire();
        this.model().fullUpdate();
      }
      _placePriceScale(e, t, i) {
        if (t === "overlay") {
          e.invalidateMargins();
          return;
        }
        const s = t === "left" ? this._leftPriceScales : this._rightPriceScales;
        const o = i === undefined ? s.length : i;
        s.splice(o, 0, e);
        e.modeChanged().subscribe(this, this._onPriceScaleModeChanged.bind(this, e));
        e.internalHeightChanged().subscribe(this, this._recalculatePriceScaleByScaleRatio.bind(this, e));
        e.priceRangeChanged().subscribe(this, this._recalculateTimeScaleByScaleRatio.bind(this, e));
        e.priceRangeChanged().subscribe(this, this._onPriceScaleSetMinMaxPriceRange.bind(this, e));
        e.isVisible().subscribe(this._onPriceScaleIsVisibleChanged);
        e.resetScaleAvailable().subscribe(this._updateResetPriceScalesAvailableValue);
        if (e.isLockScale()) {
          (0, n.assert)(this._lockedPriceScale === null);
          this._lockedPriceScale = e;
          this._currentPriceScaleRatio = null;
        }
        e.invalidateMargins();
        this._onPriceScalesChanged.fire();
        this._updateResetPriceScalesAvailableValue();
      }
      _onPriceScaleModeChanged(e, t, i) {
        if (i.lockScale) {
          if (this._lockedPriceScale !== e && this._lockedPriceScale !== null) {
            this._lockedPriceScale.setMode({
              lockScale: false
            });
          }
          this._lockedPriceScale = e;
          this._currentPriceScaleRatio = (0, uc.scaleRatio)(this.timeScale(), e);
        }
        if (t.lockScale && !i.lockScale) {
          this._lockedPriceScale = null;
          this._currentPriceScaleRatio = null;
        }
        if (t.percentage === i.percentage && t.indexedTo100 === i.indexedTo100) {
          return;
        }
        const s = this.timeScale().visibleBarsStrictRange();
        if (s !== null) {
          e.recalculatePriceRange(s);
          e.updateAllViews((0, Bt.viewportChangeEvent)());
        }
      }
      _applyOldScaleRatioToPriceScale() {
        if (!this._isRecalculatingScales && this._currentPriceScaleRatio !== null && this._lockedPriceScale !== null) {
          this._isRecalculatingScales = true;
          this._setNewPriceRangeByScaleRatio(this._lockedPriceScale, this._currentPriceScaleRatio, this._mainSourceVisiblePriceRange(this._lockedPriceScale));
          this._isRecalculatingScales = false;
        }
      }
      _setNewPriceRangeByScaleRatio(e, t, i, s, o) {
        const n = (0, uc.priceRangeByScaleRatio)(e, this.timeScale().barSpacing(), t);
        e.setPriceRange(n !== null ? n : i, s, o);
      }
      _applyOldScaleRatioToTimeScale() {
        if (!this._isRecalculatingScales && this._currentPriceScaleRatio !== null) {
          this._isRecalculatingScales = true;
          this._setNewBarSpacingByScaleRatio();
          this._isRecalculatingScales = false;
        }
      }
      _tryToApplyNewPriceScaleRatio() {
        const e = (0, n.ensureNotNull)(this._lockedPriceScale);
        const t = (0, uc.scaleRatio)(this.timeScale(), e);
        if (this._currentPriceScaleRatio !== t && !e.isLog()) {
          this._currentPriceScaleRatio = t;
          this.model().mainSeriesScaleRatioPropertyOnChanged();
        }
      }
      _recalculateTimeScaleByScaleRatio(e) {
        if (e === this._lockedPriceScale) {
          if (this._currentPriceScaleRatio !== null) {
            this._applyOldScaleRatioToTimeScale();
          } else {
            this._tryToApplyNewPriceScaleRatio();
          }
        }
      }
      _setNewBarSpacingByScaleRatio() {
        const e = this.timeScale().getValidBarSpacing((0, uc.barSpacingByScaleRatio)((0, n.ensureNotNull)(this._lockedPriceScale), this._currentPriceScaleRatio));
        if (this.timeScale().isValidBarSpacing(e)) {
          this.timeScale().setBarSpacing(e);
        }
      }
      _mainSourceVisiblePriceRange(e) {
        const t = this.timeScale().visibleBarsStrictRange();
        if (t !== null) {
          return (0, n.ensureNotNull)((0, n.ensureNotNull)(e.mainSource()).priceRange(t.firstBar(), t.lastBar(), {
            targetPriceScale: e,
            scaleSeriesOnly: e.isScaleSeriesOnly()
          }));
        } else {
          return new th.PriceRange(-0.5, 0.5);
        }
      }
      _setMinMaxPriceRange() {
        const e = (0, n.ensureNotNull)(this._lockedPriceScale);
        const t = (0, uc.priceRangeByScaleRatio)(e, this.timeScale().maxBarSpacing(), this._currentPriceScaleRatio);
        const i = (0, uc.priceRangeByScaleRatio)(e, this.timeScale().minBarSpacing(), this._currentPriceScaleRatio);
        if (t !== null) {
          e.setMaxPriceRange(t);
        }
        if (i !== null) {
          e.setMinPriceRange(i);
        }
      }
      _onPriceScaleSetMinMaxPriceRange(e) {
        if (e === this._lockedPriceScale) {
          this._setMinMaxPriceRange();
        }
      }
      _onPriceSourcesCollectionChanged() {
        if (this._bulkActions.activeCounter === 0) {
          this._priceSourcesCollectionChanged.fire();
        } else {
          this._bulkActions.priceSourcesCollectionChanged = true;
        }
      }
      _nonOverlayPricesSourcesCount() {
        return this.m_dataSources.filter(e => (!(0, Js.isStudy)(e) || !e.isLinkedToSeries()) && (0, Fn.isPriceDataSource)(e) && e.showInObjectTree() && !this.isOverlay(e)).length;
      }
      _restoreMainSeries(e, t, i, s, o, r) {
        const a = e.id;
        const l = e.state;
        if (l && o) {
          l.style = o.style ?? l.style;
          l.interval = o.interval || l.interval;
          if (o.symbol && o.symbol !== l.symbol) {
            l.symbol = o.symbol;
            delete l.currencyId;
            delete l.unitId;
          }
        }
        if (l) {
          ["candleStyle", "hollowCandleStyle", "haStyle"].forEach(e => {
            if (l[e]) {
              l[e].wickUpColor = l[e].wickUpColor || l[e].wickColor;
              l[e].wickDownColor = l[e].wickDownColor || l[e].wickColor;
            }
          });
        }
        if (l && (l.statusViewStyle = l.statusViewStyle || {}, !l.statusViewStyle.symbolTextSource)) {
          const e = !!l.statusViewStyle.showSymbolAsDescription;
          l.statusViewStyle.symbolTextSource = e ? "ticker" : "description";
        }
        if (l) {
          if (l.extendedHours) {
            l.sessionId = "extended";
          } else {
            l.sessionId ||= "regular";
          }
          delete l.extendedHours;
          if (!(0, Ph.allChartStyles)().includes(l.style)) {
            l.style = 2;
          }
          const e = l.lineStyle.styleType;
          let t;
          delete l.lineStyle.styleType;
          if (e === 0) {
            t = 14;
            l.lineWithMarkersStyle = (0, dt.clone)(l.lineStyle);
          }
          if (e === 1) {
            t = 15;
            l.steplineStyle = (0, dt.clone)(l.lineStyle);
          }
          if (t !== undefined && l.style === 2) {
            l.style = t;
          }
        }
        if (l) {
          for (const e of ["lineStyle", "lineWithMarkersStyle", "steplineStyle"]) {
            Ih(l[e]);
          }
        }
        if (!i) {
          const e = this._model.mainSeries();
          (0, n.ensureNotNull)(this._model.mainPane()).removeDataSource(e, false, r);
          this._addSourceToCollections(e, r);
        }
        const c = this.model().mainSeries();
        const h = c.properties().childs();
        this.m_mainDataSource = c;
        const d = l && l.style ? l.style : undefined;
        if (d === 6 && h.pnfStyle.childs().inputs.childs().style.value() === "ATR") {
          h.pnfStyle.childs().inputs.childs().style.setValueSilently("Traditional");
        } else if (d === 4 && h.renkoStyle.childs().inputs.childs().style.value() === "ATR") {
          h.renkoStyle.childs().inputs.childs().style.setValueSilently("Traditional");
        }
        if (l && !l.hasOwnProperty("showSessions")) {
          l.showSessions = false;
        }
        if (l && l.settlementAsClose === undefined) {
          l.settlementAsClose = false;
        }
        if (l && t) {
          l.showCountdown = false;
        }
        if (l) {
          if (t && !("showSeriesLastValueProperty" in s) && "showLastValue" in l) {
            this._model.properties().childs().scalesProperties.childs().showSeriesLastValue.setValue(l.showLastValue);
          }
          delete l.showLastValue;
        }
        if (l) {
          this._restoreMainSeriesStudyInputs(e, c.styleStudyInfos());
        }
        const u = c.sessionId();
        (0, Gc.getPersistentLogger)()?.addPersistentLogEntry(`Restore series. source.id: ${e.id} id: ${a}`, ae.LOGLEVEL.INFO, Dh);
        c.restoreState(e, t);
        this.changeSourceId(c, a);
        (0, Gc.getPersistentLogger)()?.addPersistentLogEntry(`Series has been successfully restored. id: ${c.id()}`, ae.LOGLEVEL.INFO, Dh);
        if (c.sessionId() !== u) {
          h.sessionId.fireChanged();
        }
      }
      async _restoreMainSeriesStudyInputs(e, t) {
        await (0, ts.studyMetaInfoRepository)().requestMetaInfo();
        const i = (0, ts.studyMetaInfoRepository)().studyVersioning();
        const s = {
          haStyle: (0, yt.chartStyleStudyId)(8, true),
          renkoStyle: (0, yt.chartStyleStudyId)(4, true),
          pbStyle: (0, yt.chartStyleStudyId)(7, true),
          kagiStyle: (0, yt.chartStyleStudyId)(5, true),
          pnfStyle: (0, yt.chartStyleStudyId)(6, true),
          rangeStyle: (0, yt.chartStyleStudyId)(11, true),
          volFootprintStyle: (0, yt.chartStyleStudyId)(17, true),
          tpoStyle: (0, yt.chartStyleStudyId)(18, true),
          svpStyle: (0, yt.chartStyleStudyId)(20, true)
        };
        const o = {};
        const r = (0, n.ensureDefined)(e.state);
        for (const [n] of Object.entries(_t.SYMBOL_STRING_DATA)) {
          const a = `${_t.STYLE_SHORT_NAMES[n]}Style`;
          const l = r[a]?.inputs;
          if (l == null) {
            continue;
          }
          const c = a in e ? e[a].studyId : s[a];
          const h = is.StudyMetaInfo.parseIdString(c);
          const d = t[a].studyId;
          const u = is.StudyMetaInfo.parseIdString(d);
          const _ = i.updateStudyInputs(h.id, h.version, u.version, l.inputs, null);
          o[a] = {
            inputs: _
          };
        }
        this.model().mainSeries().properties().mergeAndFire(o);
      }
      _restoreSpecialSource(e, t, i) { }
      _processAfterBulkAction() {
        const e = this._bulkActions;
        if (e.activeCounter === 0) {
          this._dataSourcesCollectionChanged.fire();
          if (e.symbolSourceCollectionChanged) {
            this._symbolSourceCollectionChanged.fire();
            e.symbolSourceCollectionChanged = false;
          }
          if (e.priceSourcesCollectionChanged) {
            this._priceSourcesCollectionChanged.fire();
            e.priceSourcesCollectionChanged = false;
          }
        }
      }
      _onPriceScalesCollectionIncludingOverlaysMayChange() {
        const e = Array.from(new Set(this._priceDataSources.map(e => e.hasPriceScale() ? e.priceScale() : null).filter(dt.notNull)));
        const t = e.filter(e => !this._allPriceScalesIncludingOverlays.includes(e));
        const i = this._allPriceScalesIncludingOverlays.filter(t => !e.includes(t));
        for (const e of t) {
          e.priceRangeAnimationRequested().subscribe(this, this.setPriceScaleRangeAnimation.bind(this, e));
        }
        for (const e of i) {
          e.priceRangeAnimationRequested().unsubscribeAll(this);
        }
        this._allPriceScalesIncludingOverlays = e;
      }
    }
    var Bh;
    var Vh = i(91988);
    (function (e) {
      e[e.Contains = 0] = "Contains";
      e[e.PlacedBefore = 1] = "PlacedBefore";
      e[e.PlacedAfter = 2] = "PlacedAfter";
    })(Bh ||= {});
    class Rh {
      constructor(e, t) {
        (0, n.assert)(e <= t, "The left value should be greater than or equal to the right value");
        this._left = e;
        this._right = t;
      }
      left() {
        return this._left;
      }
      right() {
        return this._right;
      }
      length() {
        return this._right - this._left + 1;
      }
      contains(e, t) {
        if (e < this._left - 0.5) {
          return t === true && 1;
        } else if (e > this._right + 0.5) {
          return t === true && 2;
        } else {
          return t !== true || 0;
        }
      }
      before(e) {
        return e < this._left - 0.5;
      }
      after(e) {
        return e > this._right + 0.5;
      }
      intersects(e) {
        return !this.after(e.left()) && !this.before(e.right());
      }
      equals(e) {
        return this._left === e.left() && this._right === e.right();
      }
      static compare(e, t) {
        if (e === null || t === null) {
          return e === t;
        } else {
          return e.equals(t);
        }
      }
    }
    const Nh = (0, ae.getLogger)("Chart.TimePoints");
    function Oh(e, t) {
      if (e === null || t === null) {
        return e === t;
      } else {
        return e.firstIndex === t.firstIndex && e.lastIndex === t.lastIndex;
      }
    }
    var Fh;
    (function (e) {
      e[e.Left = 0] = "Left";
      e[e.Right = 1] = "Right";
      e[e.Nearest = 2] = "Nearest";
    })(Fh ||= {});
    class Wh {
      constructor() {
        this._zoffset = 0;
        this._items = [];
        this._range = new ht.WatchedObject(null, Oh);
      }
      clear() {
        this._zoffset = 0;
        this._items = [];
        this._range.setValue(null);
      }
      size() {
        return this._items.length;
      }
      range() {
        return this._range.readonly();
      }
      merge(e, t, i) {
        const s = this._mergeImpl(e, t, i);
        this._updateFirstAndLastIndex();
        return s;
      }
      addTail(e, t) {
        for (let i = t ? 1 : 0; i < e.length; i++) {
          this._items.push(e[i]);
        }
        this._updateFirstAndLastIndex();
      }
      remove(e) {
        const t = this._indexToOffset(e);
        if (t === null) {
          return [];
        }
        const i = this._items.splice(t);
        const s = [];
        for (let t = 0; t < i.length; t++) {
          s.push({
            change: "remove",
            index: e + t,
            value: i[t]
          });
        }
        this._updateFirstAndLastIndex();
        return s;
      }
      valueAt(e) {
        const t = this._indexToOffset(e);
        if (t !== null) {
          return this._items[t];
        } else {
          return null;
        }
      }
      indexOf(e, t) {
        if (this._items.length < 1) {
          return null;
        }
        if (e > this._items[this._items.length - 1]) {
          if (t) {
            return this._validOffsetToIndex(this._items.length - 1);
          } else {
            return null;
          }
        }
        for (let i = 0; i < this._items.length; ++i) {
          if (e === this._items[i]) {
            return this._validOffsetToIndex(i);
          }
          if (e < this._items[i]) {
            if (t) {
              return this._validOffsetToIndex(i);
            } else {
              return null;
            }
          }
        }
        return null;
      }
      state(e) {
        let t = 0;
        let i = this._items.length;
        if (e !== null) {
          t = this._indexToOffset(e.firstBar()) ?? 0;
          i = (this._indexToOffset(e.lastBar()) ?? i - 1) + 1;
        }
        return {
          items: this._items.slice(t, i),
          zoffset: this._zoffset - t
        };
      }
      restoreState(e) {
        if (e !== null) {
          this._items = e.items;
          this._zoffset = e.zoffset;
          this._updateFirstAndLastIndex();
        }
      }
      roughTime(e, t = null) {
        e = Math.round(e);
        const i = this.valueAt(e);
        if (i !== null) {
          return i;
        }
        const s = this._items;
        if (!s.length || s.length < 2) {
          return null;
        }
        const o = s.length - 1;
        const n = this._validOffsetToIndex(0);
        const r = this._validOffsetToIndex(o);
        const a = s[0];
        const l = s[o];
        const c = (l - a) / (r - n);
        if (e < n) {
          return a - (n - e) * c;
        }
        if (e > r) {
          const i = e - r;
          if (i < 500 && t != null) {
            return t(l, i);
          }
          return l + i * c;
        }
        return null;
      }
      roughIndex(e, t = null, i = 0) {
        const s = this._items;
        if (!s.length || s.length < 2) {
          return null;
        }
        const o = s.length - 1;
        const n = this._validOffsetToIndex(0);
        const r = this._validOffsetToIndex(o);
        const a = s[0];
        const l = s[o];
        if (e >= a && e <= l) {
          return this._closestIndex(e, i);
        }
        const c = (l - a) / (r - n);
        if (e < a) {
          const t = a - e;
          return n - Math.round(t / c);
        }
        if (e > l) {
          const i = e - l;
          let s = Math.trunc(i / c);
          if (s < 500 && t !== null) {
            const i = t(l, e);
            if (i.success) {
              s = i.result;
            }
          }
          return r + s;
        }
        return null;
      }
      closestIndexLeft(e) {
        return this._closestIndex(e, 0);
      }
      firstPoint() {
        if (this._items.length === 0) {
          return null;
        } else {
          return this._items[0];
        }
      }
      lastPoint() {
        if (this._items.length === 0) {
          return null;
        } else {
          return this._items[this._items.length - 1];
        }
      }
      _closestIndex(e, t) {
        const i = this._items;
        if (!i.length) {
          return null;
        }
        if (Number.isNaN(e)) {
          return null;
        }
        const s = i.length - 1;
        if (e >= i[s]) {
          return this._validOffsetToIndex(s);
        }
        const o = (0, ft.lowerbound)(this._items, e, (e, t) => e < t);
        if (o <= s && this._items[o] === e) {
          return this._validOffsetToIndex(o);
        }
        if (t === 0) {
          if (o === 0) {
            return null;
          } else {
            return this._validOffsetToIndex(o - 1);
          }
        }
        if (t === 1) {
          if (o > s) {
            return null;
          } else {
            return this._validOffsetToIndex(o);
          }
        }
        const n = e - (this._items[o - 1] ?? -Infinity);
        const r = (this._items[o] ?? Infinity) - e;
        return this._validOffsetToIndex(n < r ? o - 1 : o);
      }
      _mergeImpl(e, t, i) {
        if (i.length === 0) {
          Nh.logError("merge: 'values' does not contain any time points");
          return [];
        }
        if (t > this._zoffset && e + t > 0) {
          Nh.logError("merge: when the first time point index is updated, we should fill the time points starting from the first one");
          return [];
        }
        if (this._items.length === 0) {
          this._items = i.slice();
          this._zoffset = t;
          return [{
            change: "rebuild",
            index: this._validOffsetToIndex(0)
          }];
        }
        const s = e + this._zoffset;
        if (s < 0) {
          const o = Math.abs(s);
          if (i.length < o) {
            Nh.logError("merge: 'values' does not contain enough time points to fill in the new items. 'index': " + e.toString() + ", previous 'zoffset': " + this._zoffset.toString() + ", new 'zoffset': " + t.toString() + ", 'values.length': " + i.length);
            return [];
          }
          this._items = new Array(o).concat(this._items);
          this._zoffset = t;
          for (let s = 0; s < i.length; ++s) {
            this._items[e + s + t] = i[s];
          }
          return [{
            change: "rebuild",
            index: this._validOffsetToIndex(0)
          }];
        }
        const o = [];
        let n = s;
        for (; n < this._items.length && n - s < i.length; ++n) {
          this._items[n] = i[n - s];
          o.push({
            change: "update",
            index: this._validOffsetToIndex(n),
            value: i[n - s]
          });
        }
        const r = s + i.length;
        if (r > this._items.length) {
          const e = r - this._items.length;
          for (let t = n; t < n + e; ++t) {
            const e = this._items.length;
            this._items.push(i[t - s]);
            o.push({
              change: "append",
              index: this._validOffsetToIndex(e),
              value: i[t - s]
            });
          }
        } else {
          for (let e = r; e < this._items.length; ++e) {
            o.push({
              change: "remove",
              index: this._validOffsetToIndex(e),
              value: this._items[e]
            });
          }
          this._items.length = r;
        }
        this._zoffset = t;
        return o;
      }
      _updateFirstAndLastIndex() {
        const e = this._offsetToIndex(0);
        const t = this._offsetToIndex(this._items.length - 1);
        this._range.setValue(e === null || t === null ? null : {
          firstIndex: e,
          lastIndex: t
        });
      }
      _validOffsetToIndex(e) {
        return e - this._zoffset;
      }
      _offsetToIndex(e) {
        if (e >= 0 && e < this.size()) {
          return this._validOffsetToIndex(e);
        } else {
          return null;
        }
      }
      _indexToOffset(e) {
        const t = e + this._zoffset;
        if (t >= 0 && t < this.size()) {
          return t;
        } else {
          return null;
        }
      }
    }
    var Hh = i(50503);
    const zh = new Map([[0, 0.1], [11, 0.1], [1, 0.35], [9, 0.35], [12, 0.35], [8, 0.35]]);
    class Uh {
      constructor(e, t) {
        this._styleSpecificRanges = new Map();
        this._logicalRange = e;
        this._defaultStyle = t;
      }
      strictRange(e) {
        if (this._logicalRange === null) {
          return null;
        }
        if (e === undefined) {
          e = this._defaultStyle;
        }
        let t = this._styleSpecificRanges.get(e);
        if (t === undefined) {
          const i = (zh.get(e) || 0) / 2;
          t = new Vh.BarsRange(Math.floor(this._logicalRange.left() + i), Math.ceil(this._logicalRange.right() - i));
          this._styleSpecificRanges.set(e, t);
        }
        return t;
      }
      logicalRange() {
        return this._logicalRange;
      }
      isValid() {
        return this._logicalRange !== null;
      }
      static invalid() {
        return new Uh(null, 1);
      }
    }
    class jh {
      constructor() {
        this._marksByIndex = new Map();
        this._marksBySpan = [];
        this._changed = new re.Delegate();
      }
      reset() {
        this._resetImpl();
        this._changed.fire();
      }
      indexToTime(e) {
        const t = this._marksByIndex.get(e);
        if (t) {
          return new Date(t.time * 1000);
        } else {
          return null;
        }
      }
      nearestIndex(e) {
        let t = this.minIndex ?? 0;
        let i = this.maxIndex ?? 0;
        while (i - t > 2) {
          if ((0, n.ensureDefined)(this._marksByIndex.get(t)).time * 1000 === e) {
            return t;
          }
          if ((0, n.ensureDefined)(this._marksByIndex.get(i)).time * 1000 === e) {
            return i;
          }
          const s = Math.round((t + i) / 2);
          if ((0, n.ensureDefined)(this._marksByIndex.get(s)).time * 1000 > e) {
            i = s;
          } else {
            t = s;
          }
        }
        return t;
      }
      estimateLeft(e) {
        const t = this._density();
        if (this.minIndex === undefined || !t) {
          return 0;
        }
        return ((0, n.ensureDefined)(this._marksByIndex.get(this.minIndex)).time * 1000 - e) / t;
      }
      merge(e) {
        if (e.length === 0) {
          return;
        }
        const t = e[0].index;
        const i = e[e.length - 1].index;
        if (t <= (this.minIndex ?? 0) && i >= (this.maxIndex ?? 0)) {
          this._resetImpl();
        }
        const s = this._marksBySpan;
        const o = new Set();
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          const s = i.index;
          const o = i.span;
          const n = this._marksByIndex.get(s);
          if (n) {
            if (n.index === s && n.span === o) {
              n.time = i.time;
              continue;
            }
            this._removeTickmark(n);
          }
        }
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          const n = i.index;
          const r = i.span;
          if (this._marksByIndex.has(i.index)) {
            continue;
          }
          this._marksByIndex.set(n, i);
          let a = s[r];
          if (a === undefined) {
            a = [];
            s[r] = a;
          }
          const l = a.length === 0 || a[a.length - 1].index < i.index;
          s[r].push(i);
          if (!l) {
            o.add(r);
          }
        }
        this.minIndex = this.minIndex === undefined ? t : Math.min(this.minIndex, t);
        this.maxIndex = this.maxIndex === undefined ? i : Math.max(this.maxIndex, i);
        for (let e = s.length; e--;) {
          if (s[e]) {
            if (!s[e].length) {
              delete s[e];
            }
            if (o.has(e)) {
              s[e].sort((e, t) => e.index - t.index);
            }
          }
        }
        this._cache = undefined;
        this._changed.fire();
      }
      build(e, t) {
        const i = Math.ceil(t / e);
        if (this._maxbar === i && this._cache) {
          return this._cache;
        }
        this._maxbar = i;
        let s = [];
        for (let e = this._marksBySpan.length; e--;) {
          if (!this._marksBySpan[e]) {
            continue;
          }
          const t = s;
          s = [];
          const o = t.length;
          let n = 0;
          const r = this._marksBySpan[e];
          const a = r.length;
          let l = Infinity;
          let c = -Infinity;
          for (let e = 0; e < a; e++) {
            const a = r[e];
            const h = a.index;
            while (n < o) {
              const e = t[n];
              const i = e.index;
              if (!(i < h)) {
                l = i;
                break;
              }
              n++;
              s.push(e);
              c = i;
              l = Infinity;
            }
            if (l - h >= i && h - c >= i) {
              s.push(a);
              c = h;
            }
          }
          for (; n < o; n++) {
            s.push(t[n]);
          }
        }
        this._cache = s;
        return this._cache;
      }
      state(e) {
        let t = [];
        for (let e = this._marksBySpan.length; e--;) {
          if (this._marksBySpan[e]) {
            t = t.concat(this._marksBySpan[e]);
          }
        }
        if (e !== null) {
          const i = e.firstBar();
          const s = e.lastBar();
          t = t.filter(e => e.index >= i && e.index <= s);
        }
        return {
          marks: t.map(e => [e.span, e.time, e.index]),
          version: 2
        };
      }
      restoreState(e) {
        this._marksByIndex = new Map();
        this._marksBySpan = [];
        this.maxIndex = undefined;
        this.minIndex = undefined;
        if (e && e.marks && e.marks.length) {
          if (e.version === 2) {
            const t = e.marks.map(e => ({
              span: e[0],
              time: e[1],
              index: e[2]
            }));
            this.merge(t);
          } else {
            this.merge(e.marks);
          }
        }
      }
      removeTail(e) {
        const t = new Map();
        this.maxIndex = this.minIndex;
        this._marksByIndex.forEach((i, s) => {
          if (i.time < e) {
            t.set(s, i);
            this.maxIndex = Math.max(this.maxIndex ?? 0, s);
          }
        });
        this._marksByIndex = t;
      }
      addTail(e) {
        for (let t = 0; t < e.length; t++) {
          e[t].index = (this.maxIndex ?? 0) + t + 1;
        }
        this.merge(e);
      }
      _resetImpl() {
        this._marksByIndex = new Map();
        this._marksBySpan = [];
        this.minIndex = undefined;
        this.maxIndex = undefined;
        this._cache = undefined;
      }
      _removeTickmark(e) {
        if (this.minIndex === undefined || this.maxIndex === undefined) {
          return;
        }
        const t = e.index;
        if (this._marksByIndex.get(t) !== e) {
          return;
        }
        this._marksByIndex.delete(t);
        if (t <= this.minIndex) {
          this.minIndex++;
        }
        if (t >= this.maxIndex) {
          this.maxIndex--;
        }
        if (this.maxIndex < this.minIndex) {
          this.minIndex = undefined;
          this.maxIndex = undefined;
        }
        const i = this._marksBySpan[e.span];
        const s = i.indexOf(e);
        if (s !== -1) {
          i.splice(s, 1);
        }
      }
      _density() {
        if (this.minIndex === undefined || this.maxIndex === undefined) {
          return 0;
        }
        const e = this.maxIndex - this.minIndex;
        if (e === 0) {
          return 0;
        }
        return ((0, n.ensureDefined)(this._marksByIndex.get(this.maxIndex)).time - (0, n.ensureDefined)(this._marksByIndex.get(this.minIndex)).time) * 1000 / e;
      }
    }
    class Gh {
      constructor(e, t = 50) {
        this._actualSize = 0;
        this._usageTick = 1;
        this._oldestTick = 1;
        this._cache = new Map();
        this._tick2Labels = new Map();
        this._format = e;
        this._maxSize = t;
      }
      format(e) {
        const t = this._cache.get(e.valueOf());
        if (t !== undefined) {
          return t.string;
        }
        if (this._actualSize === this._maxSize) {
          const e = this._tick2Labels.get(this._oldestTick);
          this._tick2Labels.delete(this._oldestTick);
          this._cache.delete((0, n.ensureDefined)(e));
          this._oldestTick++;
          this._actualSize--;
        }
        const i = this._format(e);
        this._cache.set(e.valueOf(), {
          string: i,
          tick: this._usageTick
        });
        this._tick2Labels.set(this._usageTick, e.valueOf());
        this._actualSize++;
        this._usageTick++;
        return i;
      }
    }
    let qh;
    var $h = i(15344);
    var Kh = i(63146);
    var Yh = i(8025);
    class Zh {
      constructor() {
        this._baseIndex = 0;
      }
      setBaseIndex(e) {
        this._baseIndex = e;
      }
      indexToTotalWeight(e) {
        return e - this._baseIndex;
      }
      totalWeightToIndex(e) {
        return this._baseIndex + e;
      }
      indexRangeToWeights(e, t, i) {
        const s = e - this._baseIndex;
        return [{
          left: s - 0.5,
          center: s,
          right: s + 0.5,
          timePointIndex: e
        }];
      }
      state(e) {
        return {
          type: "constant",
          state: {
            baseIndex: this._baseIndex
          }
        };
      }
      restoreState(e) {
        this._baseIndex = e.state.baseIndex;
      }
      needAdjustingOnDataRestoring() {
        return false;
      }
    }
    const Xh = {
      preserveBarSpacing: false,
      lockVisibleTimeRangeOnResize: false,
      rightBarStaysOnScroll: true,
      minBarSpacing: 0.5
    };
    const Jh = l.enabled("low_density_bars");
    const Qh = Jh ? 1 : 2;
    const ed = (0, ae.getLogger)("Chart.TimeScale");
    var td;
    (function (e) {
      e[e.DefaultRightOffset = 10] = "DefaultRightOffset";
      e[e.DefaultBarSpacing = 6] = "DefaultBarSpacing";
      e[e.UnplottableIndexCoord = -500] = "UnplottableIndexCoord";
      e[e.DefaultRightOffsetPercentage = 5] = "DefaultRightOffsetPercentage";
      e[e.MaxIterationsForDynamicBarSpacingAdjust = 20] = "MaxIterationsForDynamicBarSpacingAdjust";
    })(td ||= {});
    class id {
      constructor(e, t) {
        this._width = 0;
        this._widthChanged = new re.Delegate();
        this._rightOffset = 10;
        this._rightOffsetChanged = new re.Delegate();
        this._maxRightOffsetChanged = new re.Delegate();
        this._defaultRightOffset = new F.WatchedValue(10);
        this._defaultRightOffsetPercentage = new F.WatchedValue(5);
        this._usePercentageRightOffset = new F.WatchedValue(false);
        this._lastDefaultRightOffset = undefined;
        this._baseIndex = null;
        this._leftEdgeIndex = null;
        this._barSpacingChanged = new re.Delegate();
        this._barSpacing = 6;
        this._snapshotBarSpacing = null;
        this._visibleBars = Uh.invalid();
        this._visibleBarsInvalidated = true;
        this._visibleBarsChanged = new re.Delegate();
        this._logicalRangeChanged = new re.Delegate();
        this._points = new Wh();
        this._tickMarks = new jh();
        this._onScroll = new re.Delegate();
        this._resetDelegate = new re.Delegate();
        this._scrollData = null;
        this._scaleStartPoint = null;
        this._commonTransitionStartState = null;
        this._formattedBySpan = new Map();
        this._requestingMoreData = false;
        this._requestedTickmarksCount = 0;
        this._endOfData = false;
        this._lockBarsAndLogicalRangeEvents = false;
        this._resetAvailable = new F.WatchedValue(false);
        this._pointWeights = new Zh();
        this._weightedPointsCache = [];
        this._options = (0, ge.deepExtend)({}, Xh, t);
        this._model = e;
        this._scalesProperties = e.properties().childs().scalesProperties;
        this._defaultRightOffset.subscribe(() => {
          this._usePercentageRightOffset.setValue(false);
          this._defaultRightOffsetOptionsUpdated();
        });
        this._defaultRightOffsetPercentage.subscribe(e => {
          if (e >= 100 || e < 0) {
            const t = Math.max(0, Math.min(e, 99));
            this._defaultRightOffsetPercentage.setValue(t);
          } else {
            this._usePercentageRightOffset.setValue(true);
            this._defaultRightOffsetOptionsUpdated();
          }
        });
        this._usePercentageRightOffset.subscribe(() => {
          this._defaultRightOffsetOptionsUpdated();
        });
        if (this._options.preserveBarSpacing) {
          this._barSpacing = this._scalesProperties.childs().barSpacing.value() || 6;
        }
        this._barSpacingChanged.subscribe(this, this._maxRightOffsetOnChanged);
        this._barSpacingChanged.subscribe(this, this._updateResetAvailableValue);
        this._rightOffsetChanged.subscribe(this, this._updateResetAvailableValue);
        this._widthChanged.subscribe(this, this._maxRightOffsetOnChanged);
        this._updateResetAvailableValue();
      }
      destroy() {
        this._barSpacingChanged.unsubscribeAll(this);
        this._barSpacingChanged.destroy();
        this._widthChanged.unsubscribeAll(this);
        this._widthChanged.destroy();
      }
      isEmpty() {
        return this._width === 0 || !this.canNormalize();
      }
      canNormalize() {
        return this._points.size() > 0;
      }
      update(e, t, i, s) {
        this._visibleBarsInvalidated = true;
        if (i.length > 0) {
          this._points.merge(e, t, i);
        }
        this._tickMarks.merge(s);
        this.correctOffset();
      }
      addTail(e, t, i) {
        this._tickMarks.removeTail(t);
        const s = e.params;
        const o = (0, n.ensureDefined)(this._tickMarks.maxIndex) + (i ? 0 : 1);
        for (let e = 0; e < s.marks.length; e++) {
          s.marks[e].index = o + e;
        }
        this._tickMarks.addTail(s.marks);
        this._points.addTail(s.changes, i);
        const r = this._rightOffset - s.changes.length;
        this._updateRightOffset(r);
      }
      state(e) {
        const t = {
          m_barSpacing: this.barSpacing(),
          m_rightOffset: this._defaultRightOffset.value(),
          rightOffsetPercentage: this._defaultRightOffsetPercentage.value(),
          usePercentageRightOffset: this._usePercentageRightOffset.value()
        };
        if (e) {
          t.m_rightOffset = Math.max(0, this._rightOffset);
          const e = this.visibleBarsStrictRange();
          const i = this.visibleExtendedDataRange(this._model.mainSeries().data(), 0);
          const s = e ? e.unite(i) : i;
          t.points = this._points.state(s);
          t.tickmarks = this._tickMarks.state(s);
          t.width = this._width;
          t.weights = this._pointWeights.state(s);
          t.baseIndex = this._baseIndex;
        }
        return t;
      }
      restoreState(e, t) {
        if (e.m_barSpacing === undefined) {
          ed.logDebug("restoreState: invalid state");
          return;
        }
        if (e.m_rightOffset === undefined) {
          ed.logDebug("restoreState: invalid state");
          return;
        }
        if (e.weights) {
          this._pointWeights = function (e) {
            let t;
            switch (e.type) {
              case "constant":
                t = new Zh();
                t.restoreState(e);
                return t;
              case "computed":
                t = new ComputedTimePointWeights();
                t.restoreState(e);
                return t;
            }
            throw new Error(`Unexpected time point weigths type ${e.type}`);
          }(e.weights);
        }
        let i = e.m_barSpacing;
        this._snapshotBarSpacing = t ? i : null;
        const s = e.m_rightOffset < 0 && !t ? this.rightOffsetDefaultValue() : e.m_rightOffset;
        const o = s < 0 ? this.rightOffsetDefaultValue() : Math.round(s);
        this._defaultRightOffset.setValue(o);
        if (e.rightOffsetPercentage !== undefined && Number.isFinite(e.rightOffsetPercentage)) {
          this._defaultRightOffsetPercentage.setValue(e.rightOffsetPercentage);
        }
        this._usePercentageRightOffset.setValue(Boolean(e.usePercentageRightOffset));
        this._rightOffset = s;
        this._baseIndex = e.baseIndex ?? this._baseIndex;
        if (t) {
          this._requestedTickmarksCount = Infinity;
          this._endOfData = true;
          this._points.restoreState(e.points || null);
          this._tickMarks.restoreState(e.tickmarks || null);
          if (e.width && this._width > 0) {
            i *= this._width / e.width;
          }
        }
        if (t && this._pointWeights.needAdjustingOnDataRestoring()) {
          this._tryToUpdateBarSpacing(this._barSpacing, i);
          const e = this._points.range().value();
          if (e) {
            const t = e.firstIndex;
            let s = i;
            let o = i;
            let n = 0;
            (() => {
              n = this.indexToCoordinate(t);
              if (n < 0) {
                o = i;
                s = i / 10;
              } else {
                s = i;
                o = i * 10;
              }
            })();
            for (let e = 0; e < 20 && Math.abs(n) > 2; e++) {
              const e = (o + s) / 2;
              this._tryToUpdateBarSpacing(this._barSpacing, e);
              n = this.indexToCoordinate(t);
              if (n < 0) {
                o = e;
              } else {
                s = e;
              }
            }
          }
        } else {
          this._tryToUpdateBarSpacing(this._barSpacing, i);
        }
        this.correctOffset();
        if (this._usePercentageRightOffset.value()) {
          this._rightOffset = this.percentsToBarIndexLength(this._defaultRightOffsetPercentage.value());
        }
        this._rightOffsetChanged.fire(this._rightOffset);
      }
      marks() {
        if (this.isEmpty()) {
          return null;
        }
        const e = this._barSpacing;
        const t = ((this._scalesProperties.childs().fontSize.value() || 0) + 4) * 5;
        const i = Math.round(t / e);
        const s = (0, n.ensureNotNull)(this.visibleBarsStrictRange());
        const o = Math.max(s.firstBar(), s.firstBar() - i);
        const r = Math.max(s.lastBar(), s.lastBar() - i);
        const a = this._tickMarks.build(e, t);
        const l = [];
        for (const e of a) {
          if (!(o <= e.index) || !(e.index <= r)) {
            continue;
          }
          const t = this._tickMarks.indexToTime(e.index);
          if (t !== null) {
            l.push({
              coord: this.indexToCoordinate(e.index),
              label: this.formatLabel(t, e.span),
              span: e.span,
              major: false
            });
          }
        }
        return l;
      }
      visibleBarsStrictRange() {
        if (this._visibleBarsInvalidated) {
          this._visibleBarsInvalidated = false;
          this._updateVisibleBars();
        }
        return this._visibleBars.strictRange();
      }
      visibleBarsStrictRangeChanged() {
        return this._visibleBarsChanged;
      }
      visibleStrictDataRange(e) {
        const t = this.visibleBarsStrictRange();
        if (t === null) {
          return null;
        }
        const i = e.search(t.firstBar(), Yh.PlotRowSearchMode.NearestRight);
        const s = e.search(t.lastBar(), Yh.PlotRowSearchMode.NearestLeft);
        if (i === null || s === null) {
          return null;
        } else {
          return new Vh.BarsRange(i.index, s.index);
        }
      }
      visibleExtendedDataRange(e, t) {
        const i = this.visibleBarsStrictRange();
        if (i === null) {
          return null;
        }
        let s = t === 1 ? null : e.search(i.firstBar() - 1, Yh.PlotRowSearchMode.NearestLeft);
        let o = t === 0 ? null : e.search(i.lastBar() + 1, Yh.PlotRowSearchMode.NearestRight);
        if (s === null) {
          s = e.search(i.firstBar(), Yh.PlotRowSearchMode.NearestRight);
        }
        if (o === null) {
          o = e.search(i.lastBar(), Yh.PlotRowSearchMode.NearestLeft);
        }
        if (s === null || o === null) {
          return null;
        } else {
          return new Vh.BarsRange(s.index, o.index);
        }
      }
      logicalRangeChanged() {
        return this._logicalRangeChanged;
      }
      tickMarks() {
        return this._tickMarks;
      }
      points() {
        return this._points;
      }
      width() {
        return this._width;
      }
      setWidth(e, t) {
        if (!Number.isFinite(e) || e <= 0) {
          ed.logWarn(`setWidth: invalid argument: ${e}`);
          return;
        }
        if (this._width === e) {
          return;
        }
        const i = this._usePercentageRightOffset.value() && this._rightOffset > 0 ? this.barIndexLengthToPercents(this._rightOffset) : -1;
        this._visibleBarsInvalidated = true;
        if ((t || this._options.lockVisibleTimeRangeOnResize) && this._width) {
          const t = this._barSpacing * e / this._width;
          this._tryToUpdateBarSpacing(this._barSpacing, t);
        } else if (this._width) {
          this.setBarSpacing(this._barSpacing);
        }
        if (this._leftEdgeIndex !== null) {
          if ((0, n.ensureNotNull)(this.visibleBarsStrictRange()).firstBar() <= this._leftEdgeIndex) {
            const t = this._width - e;
            this._rightOffset -= Math.round(t / this._barSpacing) + 1;
          }
        }
        this._width = e;
        this._widthChanged.fire(e);
        const s = this._rightOffset;
        if (i > 0) {
          this._rightOffset = this.percentsToBarIndexLength(i);
        } else {
          this.correctOffset();
        }
        if (this._rightOffset !== s) {
          this._rightOffsetChanged.fire(this._rightOffset);
        }
        this._requestMoreData();
      }
      setLeftEdgeFix(e) {
        this._leftEdgeIndex = e;
        const t = this.visibleBarsStrictRange();
        if (t === null) {
          return;
        }
        const i = t.firstBar() - e;
        if (i < 0) {
          const e = this._rightOffset - i - 1;
          this.scrollToOffsetAnimated(e, 500);
        }
      }
      positionPercentToCoordinate(e) {
        return this.width() * e;
      }
      indexToCoordinate(e) {
        if (this.isEmpty()) {
          return 0;
        }
        const t = this.baseIndex();
        const i = this._pointWeights.indexToTotalWeight(t + this._rightOffset + 0.5) - this._pointWeights.indexToTotalWeight(e);
        return this._width - i * this._barSpacing;
      }
      indexToUserTime(e) {
        return this._tickMarks.indexToTime(e);
      }
      timePointToIndex(e, t) {
        switch (t) {
          case 0:
            return this._points.indexOf(e, false);
          case 1:
            return this._points.closestIndexLeft(e);
          default:
            return this._points.indexOf(e, true);
        }
      }
      indexToTimePoint(e) {
        return this._points.valueAt(e);
      }
      timeToCoordinate(e) {
        const t = this._points.closestIndexLeft(e);
        if (t === null) {
          return null;
        }
        const i = (0, n.ensureNotNull)(this._points.valueAt(t));
        const s = this.indexToCoordinate(t);
        if (s <= 0 || s >= this._width) {
          return null;
        }
        const o = this.barSpacing();
        const r = this.baseIndex();
        let a;
        a = r === 0 ? this._model.mainSeries().intervalObj().inMilliseconds() / 1000 : (0, n.ensureNotNull)(this._points.valueAt(r)) - (0, n.ensureNotNull)(this._points.valueAt(r - 1));
        const l = s + (e - i) / a * o + 1;
        if (l <= 0 || l >= this._width) {
          return null;
        } else {
          return l;
        }
      }
      barBorders(e) {
        const t = {
          timePointIndex: e,
          left: NaN,
          center: NaN,
          right: NaN
        };
        this.fillBarBorders([t]);
        return t;
      }
      fillBarBorders(e, t, i) {
        if (e.length === 0) {
          return;
        }
        let s = t?.startItemIndex ?? 0;
        const o = (t?.endItemIndex ?? e.length) - 1;
        if (i === true) {
          s = (0, ft.upperbound)(e, Hh.UNPLOTTABLE_TIME_POINT_INDEX, (e, t) => e < t.timePointIndex, s, o + 1);
        }
        if (s > o) {
          return;
        }
        const r = this._pointWeights.indexToTotalWeight(this.baseIndex() + this._rightOffset + 0.5);
        const a = this._pointWeights.indexRangeToWeights(e[s].timePointIndex, e[o].timePointIndex, this._weightedPointsCache);
        let l = 0;
        let c = a[l];
        const h = c;
        const d = a[a.length - 1];
        let u = NaN;
        let _ = NaN;
        let p = NaN;
        let m = true;
        for (let t = s; t <= o; t += 1) {
          const i = e[t];
          if (i.timePointIndex < h.timePointIndex) {
            u = h.left - (h.timePointIndex - i.timePointIndex);
            _ = u + 0.5;
            p = u + 1;
          } else if (i.timePointIndex > d.timePointIndex) {
            p = d.right + (i.timePointIndex - d.timePointIndex);
            _ = p - 0.5;
            u = p - 1;
          } else {
            for (m && (u = c.left, _ = c.center, p = c.right, m = false); c.timePointIndex < i.timePointIndex;) {
              l += 1;
              (0, n.assert)(l < a.length, "Bar borders coordinates are not correct");
              c = a[l];
              u = c.left;
              _ = c.center;
              p = c.right;
            }
          }
          i.left = this._width - (r - u) * this._barSpacing;
          i.center = this._width - (r - _) * this._barSpacing;
          i.right = this._width - (r - p) * this._barSpacing;
        }
      }
      timedValuesToCoordinates(e, t, i) {
        const s = this._pointWeights.indexToTotalWeight(this.baseIndex() + this._rightOffset + 0.5);
        const o = t?.startItemIndex ?? 0;
        let n = o;
        const r = t?.endItemIndex ?? e.length;
        if (i === true) {
          n = (0, ft.upperbound)(e, Hh.UNPLOTTABLE_TIME_POINT_INDEX, (e, t) => e < t.x, o, r);
        }
        for (let t = n; t < r; ++t) {
          const i = e[t];
          const o = s - this._pointWeights.indexToTotalWeight(i.x);
          i.x = this._width - o * this._barSpacing;
        }
        for (let t = o; t < n; ++t) {
          e[t].x = -500;
        }
      }
      rightOffsetForTimePoint(e) {
        const t = this.timeToCoordinate(e);
        if (t === null) {
          return null;
        }
        const i = (t - this._baseIndexBarCenterCoordinate()) / this._barSpacing;
        return this._pointWeights.totalWeightToIndex(i);
      }
      scrollToRealtime(e, t) {
        let i = this.targetDefaultRightOffset();
        if (i < 0) {
          i = this.rightOffsetDefaultValue();
        }
        const s = () => {
          if (t !== undefined) {
            t();
          }
          this._requestMoreData();
        };
        if (e) {
          const e = this.logicalRange();
          const t = this._model.mainSeries().bars().lastIndex();
          if (e === null || t === null) {
            return;
          }
          const i = this.indexToCoordinate(e.right() + 0.5);
          const o = this.indexToCoordinate(t + this._defaultRightOffset.value() + 0.5);
          this._model.stopTimeScaleAnimation();
          this._model.setTimeScaleAnimation(new Vr({
            from: 0,
            to: i - o,
            duration: 1000,
            easing: Mr.easingFunc.easeInOutQuint,
            onFinish: s
          }));
          return;
        }
        this._visibleBarsInvalidated = true;
        this._updateRightOffset(i);
        this._onScroll.fire();
        s();
      }
      scrollToFirstBar(e = () => { }) {
        this._model.gotoTime(new Date("1800-01-01").getTime()).then(e);
        this._onScroll.fire();
      }
      scrollToOffsetAnimated(e, t) {
        if (!isFinite(e)) {
          throw new RangeError("offset is required and must be finite number");
        }
        const i = t === undefined ? 400 : t;
        if (!isFinite(i) || i <= 0) {
          throw new RangeError("animationDuration (optional) must be finite positive number");
        }
        const s = this._rightOffset;
        const o = Date.now();
        const n = () => {
          this._visibleBarsInvalidated = true;
          const t = (Date.now() - o) / i;
          if (t >= 1) {
            this._updateRightOffset(e);
            this._visibleBarsInvalidated = true;
            this._model.recalculateAllPanes((0, Bt.viewportChangeEvent)());
            this._model.lightUpdate();
            return;
          }
          const r = s + (e - s) * t;
          this._updateRightOffset(r);
          this._model.recalculateAllPanes((0, Bt.viewportChangeEvent)());
          setTimeout(n, 20);
        };
        n();
      }
      defaultRightOffset() {
        return this._defaultRightOffset;
      }
      rightOffsetDefaultValue() {
        return 10;
      }
      defaultRightOffsetPercentage() {
        return this._defaultRightOffsetPercentage;
      }
      usePercentageRightOffset() {
        return this._usePercentageRightOffset;
      }
      barSpacing() {
        return this._barSpacing;
      }
      barSpacingScaleRatio() {
        if (this._snapshotBarSpacing === null) {
          return 1;
        } else {
          return this._barSpacing / this._snapshotBarSpacing;
        }
      }
      setBarSpacing(e) {
        if (!Number.isFinite(e)) {
          ed.logWarn(`setBarSpacing: invalid argument: ${e}`);
          return;
        }
        e = this.getValidBarSpacing(e);
        const t = this._barSpacing > e;
        if (this._tryToUpdateBarSpacing(this._barSpacing, e)) {
          this.correctOffset();
          if (this._options.preserveBarSpacing) {
            (0, li.allowSavingDefaults)(true);
            this._scalesProperties.childs().barSpacing.setValue(this._barSpacing);
            (0, li.allowSavingDefaults)(false);
          }
          this._model.recalculateAllPanes((0, Bt.viewportChangeEvent)());
          this._model.lightUpdate();
          if (t) {
            this.requestHistoryPointsIfNeeded();
          }
        }
      }
      barSpacingChanged() {
        return this._barSpacingChanged;
      }
      getValidBarSpacing(e) {
        if (e == null) {
          e = this.barSpacing();
        }
        if (e < this.minBarSpacing()) {
          return this.minBarSpacing();
        } else if (e > this.maxBarSpacing()) {
          return this.maxBarSpacing();
        } else {
          return e;
        }
      }
      isValidBarSpacing(e) {
        return e >= this.minBarSpacing() && e <= this.maxBarSpacing();
      }
      preserveBarSpacing() {
        return this._options.preserveBarSpacing;
      }
      normalizeBarIndex(e) {
        let t = 0;
        let i = 0;
        const s = this.baseIndex();
        const o = (0, n.ensureNotNull)(this._points.range().value()).firstIndex;
        if (e < o) {
          t = (0, n.ensureNotNull)(this._points.valueAt(o));
          i = e - o;
        } else if (e > s) {
          t = (0, n.ensureNotNull)(this._points.valueAt(s));
          i = e - s;
        } else {
          t = (0, n.ensureNotNull)(this._points.valueAt(e));
          i = 0;
        }
        return {
          time_t: t,
          offset: i
        };
      }
      denormalizeTimePoint(e) {
        const t = this._points.indexOf(e.time_t, false);
        if (t !== null) {
          return t + e.offset;
        }
      }
      rightOffset() {
        return this._rightOffset;
      }
      rightOffsetChanged() {
        return this._rightOffsetChanged;
      }
      minRightOffset() {
        const e = this.points().range().value()?.firstIndex;
        const t = this._baseIndex;
        if (e === undefined || t === null) {
          return null;
        }
        if (this._leftEdgeIndex !== null) {
          const e = this.width() / this._barSpacing;
          return this._leftEdgeIndex - t + e - 1;
        }
        return e - t - 1 + Qh;
      }
      maxRightOffset() {
        return this.width() / this._barSpacing - Qh;
      }
      maxRightOffsetChanged() {
        return this._maxRightOffsetChanged;
      }
      onReset() {
        return this._resetDelegate;
      }
      baseIndex() {
        return this._baseIndex || 0;
      }
      zoom(e, t, i) {
        if (!Number.isFinite(e) || !Number.isFinite(t)) {
          ed.logWarn(`zoom: invalid arguments: ${e}, ${t}, ${i}`);
          return;
        }
        const s = this.rightOffset();
        const o = i !== undefined ? !i : this._options.rightBarStaysOnScroll;
        const n = o && this.usePercentageRightOffset().value() && s >= 0;
        const r = n ? this.barIndexLengthToPercents(s) : undefined;
        const a = this.coordinateToIndex(e);
        const l = this.barSpacing();
        const c = l + t * (l / 10);
        this.setBarSpacing(c);
        if (!o) {
          this.startScroll(this.indexToCoordinate(a));
          this.scrollTo(e);
          this.endScroll();
        }
        if (n && r !== undefined) {
          this.setRightOffset(this.percentsToBarIndexLength(r));
        }
        this._requestMoreData();
      }
      zoomToBarsRange(e, t) {
        if (this._leftEdgeIndex !== null) {
          e = Math.max(e, this._leftEdgeIndex);
        }
        if (t < e) {
          return;
        }
        const i = this.baseIndex();
        const s = this._rightOffset;
        this._rightOffset = t - i;
        const o = e - 0.5;
        const n = t + 0.5;
        const r = Math.max(this._pointWeights.indexToTotalWeight(n) - this._pointWeights.indexToTotalWeight(o), Qh);
        this.setBarSpacing(this.width() / r);
        this._visibleBarsInvalidated = true;
        this.correctOffset();
        if (this._rightOffset !== s) {
          this._rightOffsetChanged.fire(this._rightOffset);
        }
        this._requestMoreData();
      }
      scrollToBar(e) {
        if (this._leftEdgeIndex !== null) {
          e = Math.max(e, this._leftEdgeIndex);
        }
        const t = (0, n.ensureNotNull)(this.logicalRange()).length() + e - 1;
        this._rightOffset = t - this.baseIndex();
        this._visibleBarsInvalidated = true;
        this.correctOffset();
        this._rightOffsetChanged.fire(this._rightOffset);
        this._requestMoreData();
      }
      coordinateToIndex(e) {
        return Math.round(this.coordinateToFloatIndex(e));
      }
      coordinateToFloatIndex(e) {
        const t = (e - this._baseIndexBarCenterCoordinate()) / this._barSpacing;
        const i = this._pointWeights.totalWeightToIndex(t);
        return Math.round(i * 1000000) / 1000000;
      }
      coordinateToVisibleIndex(e) {
        let t = this.coordinateToIndex(e);
        const i = this.visibleBarsStrictRange();
        if (i !== null && !i.contains(t)) {
          t = Math.min(Math.max(i.firstBar(), t), i.lastBar());
        }
        return t;
      }
      canZoomIn() {
        return this.barSpacing() < this.maxBarSpacing();
      }
      canZoomOut() {
        return this.barSpacing() > this._options.minBarSpacing;
      }
      minBarSpacing() {
        return this._options.minBarSpacing;
      }
      maxBarSpacing() {
        const e = this.width();
        if (Jh) {
          return e;
        } else {
          return e / Qh;
        }
      }
      minVisibleBarCount() {
        return Qh;
      }
      resetRightOffset() {
        this.setRightOffset(this.targetDefaultRightOffset());
      }
      reset() {
        this._visibleBarsInvalidated = true;
        this._points.clear();
        this._scrollData = null;
        this._scaleStartPoint = null;
        this._clearCommonTransitionsStartState();
        this._tickMarks.reset();
        this._leftEdgeIndex = null;
        this._resetDelegate.fire();
        this.disconnect();
      }
      resetAvailable() {
        return this._resetAvailable.readonly();
      }
      disconnect() {
        this._requestingMoreData = false;
        this._requestedTickmarksCount = 0;
        this._endOfData = false;
      }
      setBaseIndex(e) {
        if (!Number.isFinite(e)) {
          ed.logDebug(`setBaseIndex: invalid argument: ${e}`);
          return;
        }
        const t = this._baseIndex !== e;
        this._visibleBarsInvalidated = true;
        this._baseIndex = e;
        this._pointWeights.setBaseIndex(this._baseIndex);
        this.correctOffset();
        if (t) {
          this._model.recalculateAllPanes((0, Bt.viewportChangeEvent)());
          this._model.lightUpdate();
        }
      }
      resetBaseIndex() {
        this._visibleBarsInvalidated = true;
        this._baseIndex = null;
      }
      setRightOffset(e) {
        if (Number.isFinite(e)) {
          this._visibleBarsInvalidated = true;
          this._updateRightOffset(e);
        } else {
          ed.logWarn(`setRightOffset: invalid argument: ${e}`);
        }
      }
      correctBarSpacing() {
        if (!this.isEmpty()) {
          if (this.points().size() < this.width() / this.barSpacing()) {
            this.setRightOffset(this.targetDefaultRightOffset());
            this.setBarSpacing(this.width() / (this.points().size() + this.rightOffset()));
          }
        }
      }
      setTimePointWeights(e) {
        this._weightedPointsCache = [];
        this._pointWeights = e ?? new Zh();
        this._pointWeights.setBaseIndex(this.baseIndex());
        this._visibleBarsInvalidated = true;
      }
      correctOffset() {
        const e = this.maxRightOffset();
        if (this._rightOffset > e) {
          this._rightOffset = e;
          this._visibleBarsInvalidated = true;
        }
        const t = this.minRightOffset();
        if (t !== null && this._rightOffset < t) {
          this._rightOffset = t;
          this._visibleBarsInvalidated = true;
        }
      }
      logicalRange() {
        if (this._visibleBarsInvalidated) {
          this._visibleBarsInvalidated = false;
          this._updateVisibleBars();
        }
        return this._visibleBars.logicalRange();
      }
      restoreDefault() {
        this._visibleBarsInvalidated = true;
        this._lockBarsAndLogicalRangeEvents = true;
        const e = this._visibleBars;
        this.setBarSpacing(6);
        this.resetRightOffset();
        this._lockBarsAndLogicalRangeEvents = false;
        this._fireVisibleBarsChangedIfRequired(e, this._visibleBars);
        this._requestMoreData();
      }
      startScale(e) {
        if (this._scrollData) {
          this.endScroll();
        }
        if (this._scaleStartPoint === null && this._commonTransitionStartState === null) {
          if (!this.isEmpty()) {
            this._scaleStartPoint = e;
            this._saveCommonTransitionsStartState();
          }
        }
      }
      scaleTo(e) {
        if (this._commonTransitionStartState === null) {
          return;
        }
        const t = (0, Io.clamp)(this._width - e, 0, this._width);
        const i = (0, Io.clamp)(this._width - (0, n.ensureNotNull)(this._scaleStartPoint), 0, this._width);
        if (t === 0 || i === 0) {
          return;
        }
        const s = this.barIndexLengthToPercents(this.rightOffset());
        this.setBarSpacing(this._commonTransitionStartState.barSpacing * t / i);
        if (this.usePercentageRightOffset().value() && this.rightOffset() >= 0) {
          this.setRightOffset(this.percentsToBarIndexLength(s));
        }
      }
      endScale() {
        if (this._scaleStartPoint !== null) {
          this._scaleStartPoint = null;
          this._clearCommonTransitionsStartState();
          this._requestMoreData();
        }
      }
      startScroll(e) {
        if (this._scrollData === null && this._commonTransitionStartState === null) {
          if (!this.isEmpty()) {
            this._scrollData = {
              startCoordinate: e,
              startRightEdgeLogical: this.baseIndex() + this._rightOffset + 0.5,
              startBaseIndex: this.baseIndex()
            };
            this._saveCommonTransitionsStartState();
          }
        }
      }
      scrollTo(e) {
        this._visibleBarsInvalidated = true;
        if (this._scrollData === null) {
          return;
        }
        const {
          startCoordinate: t,
          startRightEdgeLogical: i,
          startBaseIndex: s
        } = this._scrollData;
        const o = e - t;
        const n = i + (this.baseIndex() - s);
        const r = this.indexToCoordinate(n);
        const a = this.coordinateToFloatIndex(r - o) - 0.5 - this.baseIndex();
        this._updateRightOffset(a);
        this._onScroll.fire();
      }
      endScroll() {
        if (this._scrollData !== null) {
          this._scrollData = null;
          this._clearCommonTransitionsStartState();
          this._requestMoreData();
        }
      }
      formatLabel(e, t) {
        const i = we.timeHoursFormatProperty.value() === "24-hours" ? t.toString() : `${t}_ampm`;
        let s = this._formattedBySpan.get(i);
        if (s === undefined) {
          s = new Gh(e => this.formatLabelImpl(e, t));
          this._formattedBySpan.set(i, s);
        }
        return s.format(new Date(e));
      }
      formatLabelImpl(e, t) {
        if (!e || !(e instanceof Date)) {
          return "incorrect time";
        }
        const s = function (e, t) {
          if (e === Sr.MILLISECOND_SPAN && t) {
            return "TimeWithMilliseconds";
          }
          if (e < Sr.MINUTE_SPAN && t) {
            return "TimeWithSeconds";
          }
          if (e < Sr.DAY_SPAN && t) {
            return "Time";
          }
          if (e < Sr.WEEK_SPAN) {
            return "DayOfMonth";
          }
          if (e < Sr.MONTH_SPAN) {
            return "DayOfMonth";
          }
          if (e < Sr.YEAR_SPAN) {
            return "Month";
          }
          return "Year";
        }(t, !this._model.mainSeries().isDWM());
        if (_e.customFormatters.tickMarkFormatter !== null) {
          return _e.customFormatters.tickMarkFormatter(e, s);
        } else {
          return function (e, t) {
            switch (t) {
              case "TimeWithMilliseconds":
                return new $h.TimeFormatter($h.hourMinuteSecondMillisecFormat).format(e);
              case "TimeWithSeconds":
              case "Time":
                const s = t === "TimeWithSeconds" ? (0, Kh.getHourMinuteSecondFormat)(we.timeHoursFormatProperty.value()) : (0, Kh.getHourMinuteFormat)(we.timeHoursFormatProperty.value());
                return new $h.TimeFormatter(s).format(e);
              case "DayOfMonth":
                return e.getUTCDate().toString();
              case "Month":
                return (qh === undefined && (qh = [a.t(null, undefined, i(62310)), a.t(null, undefined, i(2507)), a.t(null, undefined, i(92767)), a.t(null, undefined, i(27072)), a.t(null, {
                  context: "short"
                }, i(13132)), a.t(null, undefined, i(429)), a.t(null, undefined, i(53786)), a.t(null, undefined, i(46450)), a.t(null, undefined, i(6816)), a.t(null, undefined, i(12179)), a.t(null, undefined, i(26899)), a.t(null, undefined, i(32084))]), qh)[e.getUTCMonth()];
              case "Year":
                return e.getUTCFullYear().toString();
            }
          }(e, s);
        }
      }
      onScroll() {
        return this._onScroll;
      }
      invalidateVisibleBars() {
        this._visibleBarsInvalidated = true;
      }
      onTimeScaleCompleted(e) {
        this._requestingMoreData = false;
        this._endOfData = e;
        if (l.enabled("fix_left_edge") && this._endOfData) {
          const e = this._points.range().value()?.firstIndex;
          if (e !== undefined) {
            this.setLeftEdgeFix(e);
          }
        }
        this._requestMoreData();
      }
      requestMoreHistoryPoints(e) {
        this._requestHistoryPoints(e);
      }
      targetDefaultRightOffset() {
        if (this.usePercentageRightOffset().value()) {
          return this.percentsToBarIndexLength(this._defaultRightOffsetPercentage.value());
        } else {
          return this._defaultRightOffset.value();
        }
      }
      percentsToBarIndexLength(e) {
        return e * 0.01 * this._width / this._barSpacing;
      }
      barIndexLengthToPercents(e) {
        return e * 100 * this._barSpacing / this._width;
      }
      requestHistoryPointsIfNeeded() {
        if (this.isEmpty()) {
          return;
        }
        if (this._endOfData) {
          ed.logNormal("Skipping loading more data due end of data state");
          return;
        }
        const e = this.visibleBarsStrictRange();
        if (e === null) {
          return;
        }
        const t = (0, n.ensureNotNull)(this._points.range().value()).firstIndex - e.firstBar();
        if (!(t <= 0)) {
          this._requestHistoryPoints(t);
        }
      }
      _requestMoreData() {
        this._requestFutureTickmarksIfNeeded();
        this.requestHistoryPointsIfNeeded();
      }
      _requestFutureTickmarksIfNeeded() {
        if (this.isEmpty() || !this._model.chartApi().isConnected().value()) {
          return;
        }
        const e = this.visibleBarsStrictRange();
        if (e === null) {
          return;
        }
        const t = e.lastBar() - (0, n.ensureNotNull)(this._points.range().value()).lastIndex;
        if (t <= this._requestedTickmarksCount) {
          return;
        }
        const i = t - this._requestedTickmarksCount;
        this._requestedTickmarksCount = t;
        this._model.chartApi().requestMoreTickmarks((0, n.ensureNotNull)(this._model.mainSeries().seriesSource().instanceId()), i);
      }
      _requestHistoryPoints(e) {
        if (this._model.chartApi().isConnected().value()) {
          if (this._requestingMoreData) {
            ed.logNormal("Skipping loading more data due active loading");
          } else {
            this._requestingMoreData = true;
            this._model.chartApi().requestMoreData(e);
          }
        }
      }
      _updateVisibleBars() {
        const e = this._visibleBars;
        if (this.isEmpty()) {
          if (this._visibleBars.isValid()) {
            this._visibleBars = Uh.invalid();
            this._visibleBarsChanged.fire(null, e.strictRange());
            this._logicalRangeChanged.fire(null, e.logicalRange());
          }
          return;
        }
        const t = this.width() / this.barSpacing();
        const i = this.baseIndex();
        const s = i + this._rightOffset;
        const o = s + 0.5;
        const n = this._pointWeights.indexToTotalWeight(o) - t;
        const r = Math.min(o - 1, this._pointWeights.totalWeightToIndex(n)) + 0.5;
        if (Number.isFinite(r) && Number.isFinite(s)) {
          this._visibleBars = new Uh(new Rh(r, s), this._model.mainSeries().style());
          if (!this._lockBarsAndLogicalRangeEvents) {
            this._fireVisibleBarsChangedIfRequired(e, this._visibleBars);
          }
        } else {
          ed.logWarn(`updateVisibleBars error: baseIndex: ${i}, barSpacing: ${this._barSpacing}, rightOffset: ${this._rightOffset}`);
        }
      }
      _fireVisibleBarsChangedIfRequired(e, t) {
        if (!Vh.BarsRange.compare(e.strictRange(), t.strictRange())) {
          this._visibleBarsChanged.fire(t.strictRange(), e.strictRange());
        }
        if (!Rh.compare(e.logicalRange(), t.logicalRange())) {
          this._logicalRangeChanged.fire(t.logicalRange(), e.logicalRange());
        }
      }
      _baseIndexBarCenterCoordinate() {
        const e = this.baseIndex() + this._rightOffset + 0.5;
        const t = this._pointWeights.indexToTotalWeight(e);
        return this._width - t * this._barSpacing;
      }
      _tryToUpdateBarSpacing(e, t) {
        return e !== t && (this._visibleBarsInvalidated = true, this._barSpacing = t, this._barSpacingChanged.fire(t), true);
      }
      _saveCommonTransitionsStartState() {
        this._commonTransitionStartState = {
          barSpacing: this.barSpacing(),
          rightOffset: this.rightOffset()
        };
      }
      _clearCommonTransitionsStartState() {
        this._commonTransitionStartState = null;
      }
      _maxRightOffsetOnChanged() {
        this._maxRightOffsetChanged.fire(this.maxRightOffset());
      }
      _updateRightOffset(e) {
        const t = this._rightOffset;
        this._rightOffset = e;
        this.correctOffset();
        if (this._rightOffset !== t) {
          this._rightOffsetChanged.fire(this._rightOffset);
        }
        this._model.recalculateAllPanes((0, Bt.viewportChangeEvent)());
        this._model.lightUpdate();
      }
      _defaultRightOffsetOptionsUpdated() {
        const e = this.rightOffset();
        if (l.enabled("lock_visible_range_when_adjusting_percentage_right_margin") && e >= 0) {
          const e = this._defaultRightOffsetPercentage.value();
          const t = this._usePercentageRightOffset.value() && this._rightOffset >= 0 ? Math.round(this.barIndexLengthToPercents(this._rightOffset)) : -1;
          if (this._lastDefaultRightOffset !== e && t === this._lastDefaultRightOffset) {
            const t = this._barSpacing * (100 - e) / (100 - this._lastDefaultRightOffset);
            this._tryToUpdateBarSpacing(this._barSpacing, t);
          }
        }
        this.setRightOffset(this.targetDefaultRightOffset());
        this._updateResetAvailableValue();
        this._lastDefaultRightOffset = this._defaultRightOffsetPercentage.value();
      }
      _updateResetAvailableValue() {
        this._resetAvailable.setValue(this.barSpacing() !== 6 || this.rightOffset() !== this.targetDefaultRightOffset());
      }
    }
    var sd = i(52388);
    var od = i(82826);
    class nd {
      constructor(e) {
        this._onChanged = new re.Delegate();
        this._groups = [];
        this._groups = e || [];
        this._groups.forEach(e => {
          e.onChanged().subscribe(null, t => this._onChanged.fire(e.id, t));
        });
      }
      groups() {
        return this._groups.filter(e => e.isActualSymbol());
      }
      groupsForAllSymbols() {
        return this._groups;
      }
      createGroup(e, t, i) {
        t = t || this._generateNextName();
        const s = new Ya(e, t, i);
        this._groups.push(s);
        s.onChanged().subscribe(null, e => this._onChanged.fire(s.id, e));
        const o = {
          visibilityChanged: false,
          lockedChanged: false,
          isActualIntervalChanged: false,
          affectedLineTools: e.map(e => e.id())
        };
        this._onChanged.fire(s.id, o);
        return s;
      }
      addGroup(e) {
        this._groups.push(e);
        e.onChanged().subscribe(null, t => this._onChanged.fire(e.id, t));
        this._onChanged.fire(e.id);
      }
      removeGroup(e) {
        const t = this._groups.findIndex(t => t.id === e.id);
        this._groups.splice(t, 1);
        this._onChanged.fire(e.id);
      }
      groupForId(e) {
        return this._groups.find(t => t.id === e) || null;
      }
      groupForLineTool(e) {
        return this._groups.find(t => t.containsLineTool(e)) || null;
      }
      removeLineTools(e) {
        const t = new Set();
        this._groups.forEach(i => {
          const s = e.filter(i.containsLineTool.bind(i));
          if (s.length) {
            i.excludeLineTools(s);
            t.add(i.id);
          }
        });
        this._groups.filter(e => e.lineTools().length === 0).forEach(e => this.removeGroup(e));
        return Array.from(t);
      }
      state(e) {
        return {
          groups: (e ? this._groups.filter(e => e.isActualSymbol()) : this._groups).map(e => e.state())
        };
      }
      onChanged() {
        return this._onChanged;
      }
      fireChangedAll() {
        this._groups.forEach(e => {
          this._onChanged.fire(e.id);
        });
      }
      static fromState(e, t) {
        const i = [];
        for (const s of t.groups) {
          const t = Ya.fromState(e, s);
          if (t !== null) {
            i.push(t);
          }
        }
        return new nd(i);
      }
      _generateNextName() {
        const e = new Set(this.groups().map(e => e.name().value()));
        for (let t = 1; ; t++) {
          const i = `Group ${t}`;
          const s = `Group_${t}`;
          if (!e.has(i) && !e.has(s)) {
            return i;
          }
        }
      }
    }
    var rd = i(14381);
    function ad(e) {
      return Boolean(e.session.timezone) && Boolean(e.session.spec);
    }
    class ld {
      constructor(e, t) {
        var i;
        var s;
        this._sourceTargetBarBuilder = null;
        this._cache = new Map();
        this._source = e;
        this._target = t;
        this._sourceSession = rd.SessionInfo.fromState(e.session);
        this._targetSession = rd.SessionInfo.fromState(t.session);
        this._isResolutionTheSame = Re.Interval.isEqual(e.resolution, t.resolution) || Re.Interval.isTicks(e.resolution) && Re.Interval.isTicks(t.resolution);
        this._isSessionTheSame = (i = e.session, s = t.session, i.timezone === s.timezone && i.spec === s.spec && i.holidays === s.holidays && i.corrections === s.corrections);
      }
      sourceTimeToTargetTime(e) {
        if (this._isSessionTheSame && this._isResolutionTheSame) {
          return e;
        }
        if (!ad(this._source) || !ad(this._target)) {
          return e;
        }
        let t = this._cache.get(e);
        if (t === undefined) {
          const i = e * 1000;
          const s = this._sourceTargetBuilder();
          s.moveTo(i);
          const o = s.indexOfBar(i);
          t = s.startOfBar(Math.max(0, o)) / 1000;
          this._cache.set(e, t);
        }
        return t;
      }
      _sourceTargetBuilder() {
        if (this._sourceTargetBarBuilder === null) {
          this._sourceTargetBarBuilder = (0, rd.newBarBuilder)(this._target.resolution, this._targetSession, this._sourceSession);
        }
        return this._sourceTargetBarBuilder;
      }
    }
    var cd = i(65458);
    var hd = i(28120);
    var dd = i(37626);
    class ud extends dd.PriceLineAxisView {
      constructor(e, t) {
        super();
        this._model = e;
        this._source = t;
      }
      _value() {
        const e = this._model.mainSeries();
        const t = e.priceScale();
        const i = e.firstValue();
        if (i === null) {
          return {
            noData: true
          };
        }
        const s = this._source.price();
        const o = this._source.currentSession();
        if (s === null || o !== "pre_market" && o !== "post_market") {
          return {
            noData: true
          };
        }
        const n = t.priceToCoordinate(s, i);
        return {
          noData: false,
          floatCoordinate: n,
          coordinate: n,
          color: "",
          formattedPricePercentage: "",
          formattedPriceAbsolute: "",
          formattedPriceIndexedTo100: "",
          text: "",
          index: 0
        };
      }
      _priceLineColor(e) {
        const t = this._source.properties().childs();
        if (this._source.currentSession() === "pre_market") {
          return t.preMarketColor.value();
        } else {
          return t.postMarketColor.value();
        }
      }
      _lineWidth() {
        return this._source.properties().childs().lineWidth.value();
      }
      _lineStyle() {
        return this._source.properties().childs().lineStyle.value();
      }
      _isVisible() {
        if (!this._source.canBeVisibleOnSymbolAndInterval() || !this._model.properties().childs().scalesProperties.childs().showPrePostMarketPriceLabel.value()) {
          return false;
        }
        const e = this._source.price();
        const t = this._source.currentSession();
        return e !== null && (t === "pre_market" || t === "post_market");
      }
    }
    var _d = i(98558);
    class pd extends _d.PriceAxisView {
      constructor(e, t) {
        super();
        this._model = e;
        this._source = t;
      }
      _updateRendererData(e, t, s) {
        e.visible = false;
        t.visible = false;
        if (!this._model.properties().childs().scalesProperties.childs().showPrePostMarketPriceLabel.value()) {
          return;
        }
        const o = this._model.mainSeries();
        const n = o.priceScale();
        const r = o.firstValue();
        if (r === null) {
          return;
        }
        if (!this._source.canBeVisibleOnSymbolAndInterval()) {
          return;
        }
        const l = this._source.price();
        const c = this._source.currentSession();
        if (l == null || c !== "pre_market" && c !== "post_market") {
          return;
        }
        const h = this._source.properties().childs();
        const d = c === "pre_market" ? (0, Is.resetTransparency)(h.preMarketColor.value()) : (0, Is.resetTransparency)(h.postMarketColor.value());
        e.visible = true;
        t.visible = true;
        e.text = n.formatPriceAbsolute(l);
        t.text = c === "pre_market" ? a.t(null, {
          context: "market_status"
        }, i(93866)) : a.t(null, {
          context: "market_status"
        }, i(35359));
        s.coordinate = n.priceToCoordinate(l, r);
        s.background = d;
        s.textColor = this.generateTextColor(d);
      }
    }
    var md = i(52397);
    class gd extends md.HorizontalLinePaneView {
      constructor(e, t, i) {
        super();
        this._model = e;
        this._source = t;
        const s = {
          doubleClickHandler: i,
          doubleTapHandler: i
        };
        this._lineRenderer.setHitTest(new Vt.HitTestResult(Vt.HitTarget.Regular, s));
      }
      _updateImpl() {
        const e = this._lineRendererData;
        e.visible = false;
        const t = this._model.mainSeries();
        const i = this._source.properties().childs();
        if (!i.visible.value() || !t.isVisible()) {
          return;
        }
        const s = t.priceScale();
        const o = t.firstValue();
        if (o === null) {
          return;
        }
        if (!this._source.canBeVisibleOnSymbolAndInterval()) {
          return;
        }
        const n = this._source.price();
        const r = this._source.currentSession();
        if (n !== null && (r === "pre_market" || r === "post_market")) {
          e.visible = true;
          e.y = s.priceToCoordinate(n, o);
          e.linestyle = i.lineStyle.value();
          e.linewidth = i.lineWidth.value();
          e.color = r === "pre_market" ? i.preMarketColor.value() : i.postMarketColor.value();
        }
      }
    }
    Ot.LINESTYLE_DOTTED;
    Lt.colorsPalette["color-tv-blue-500"];
    class fd extends hd.CustomSourceBase {
      constructor(e, t, i) {
        super(e, t);
        this._extraHoursPrice = null;
        this._currentSession = "holiday";
        this._quotesProvider = t.mainSeries().quotesProvider();
        this._prePostMarketLinePaneView = new gd(t, this, i);
        this._prePostPriceAxisView = new pd(t, this);
        this._prePostLabelPaneView = new cd.PanePriceAxisView(this._prePostPriceAxisView, t.mainSeries(), t);
        this._prePostPriceLineAxisView = new ud(t, this);
        this._quotesProvider.quotesUpdate().subscribe(this, this._updateQuotes);
        this._updateQuotes();
      }
      destroy() {
        this._quotesProvider.quotesUpdate().unsubscribeAll(this);
      }
      paneViews(e) {
        if (this._areViewsAvailableForPane(e)) {
          return [this._prePostMarketLinePaneView];
        } else {
          return [];
        }
      }
      labelPaneViews(e) {
        if (this._areViewsAvailableForPane(e)) {
          return [this._prePostLabelPaneView];
        } else {
          return [];
        }
      }
      priceAxisViews(e, t) {
        if (this._areViewsAvailableForPane(e)) {
          return e.findTargetPriceAxisViews(this, t, [this._prePostPriceAxisView], [this._prePostPriceLineAxisView]);
        } else {
          return [];
        }
      }
      priceScale() {
        return this._model.mainSeries().priceScale();
      }
      updateAllViews(e) {
        this._prePostMarketLinePaneView.update(e);
        this._prePostPriceAxisView.update(e);
        this._prePostPriceLineAxisView.update(e);
        this._prePostLabelPaneView.update(e);
      }
      price() {
        return this._extraHoursPrice;
      }
      currentSession() {
        return this._currentSession;
      }
      canBeVisibleOnSymbolAndInterval() {
        return this._model.mainSeries().isPrePostMarketPricesAvailableProperty().value();
      }
      properties() {
        return this._model.mainSeries().properties().childs().prePostMarket;
      }
      _updateQuotes() {
        const e = this._quotesProvider.quotes();
        if (e === null) {
          this._extraHoursPrice = null;
        } else {
          this._extraHoursPrice = e.rtc;
          if (e.current_session !== undefined) {
            this._currentSession = e.current_session;
          }
        }
        const t = this._model.mainSeries().properties().childs().prePostMarket.childs().visible.value();
        const i = this._model.properties().childs().scalesProperties.childs().showPrePostMarketPriceLabel.value();
        if (this.canBeVisibleOnSymbolAndInterval() && (t || i)) {
          this.updateAllViews((0, Bt.sourceChangeEvent)(this.id()));
          this._model.updateSource(this);
        }
      }
      _areViewsAvailableForPane(e) {
        return !this._model.isInReplay().value() && !this._model.isSnapshot() && this._model.paneForSource(this._model.mainSeries()) === e;
      }
    }
    var yd = i(39772);
    function vd(e, t) {
      if (e.code < t.code) {
        return -1;
      } else if (e.code > t.code) {
        return 1;
      } else {
        return 0;
      }
    }
    class Sd {
      constructor(e) {
        this._convertibleItems = e;
        this._idsToItems = new Map();
        for (const t of e) {
          this._idsToItems.set(t.id, t);
        }
      }
      convertible(e) {
        return this._idsToItems.get(e) !== undefined;
      }
      item(e) {
        return this._idsToItems.get(e) ?? null;
      }
      size() {
        return this._convertibleItems.length;
      }
      filterConvertible(e, t) {
        const i = this._convertibleItems.filter(function (e, t) {
          return i => !e.has(i.id) && t(i.id);
        }(e, t));
        i.sort(vd);
        return i;
      }
      getItems() {
        return this._convertibleItems.map(e => e.id);
      }
    }
    class bd {
      constructor(e) {
        this._allGroups = new Set();
        this._idToName = new Map();
        this._idToDescription = new Map();
        this._groupedUnitIds = new Map();
        this._groupedUnits = new Map();
        this._groupById = new Map();
        this._size = 0;
        this._units = e;
        for (const t in e) {
          if (e.hasOwnProperty(t)) {
            this._allGroups.add(t);
            this._groupedUnitIds.set(t, new Set(e[t].map(e => e.id)));
            this._groupedUnits.set(t, e[t]);
            for (const i of e[t]) {
              this._size++;
              this._idToName.set(i.id, i.name);
              this._idToDescription.set(i.id, i.description);
              this._groupById.set(i.id, t);
            }
          }
        }
      }
      unitsChanged(e) {
        return this._units !== e;
      }
      size() {
        return this._size;
      }
      name(e) {
        return this._idToName.get(e) || e;
      }
      description(e) {
        return this._idToDescription.get(e) || e;
      }
      unitGroupById(e) {
        return this._groupById.get(e) || null;
      }
      allGroups() {
        return new Set(this._allGroups);
      }
      unitsByGroups(e) {
        const t = [];
        e.forEach(e => {
          const i = this._groupedUnits.get(e);
          if (i !== undefined) {
            t.push({
              name: e,
              units: i
            });
          }
        });
        return t;
      }
      convertible(e, t) {
        for (const i of t) {
          const t = this._groupedUnitIds.get(i);
          if (t !== undefined && t.has(e)) {
            return true;
          }
        }
        return false;
      }
    }
    var wd = i(50335);
    class Cd {
      constructor(e) {
        this._source = null;
        this._sourcePane = null;
        this._currentToolSupportsPhantomMode = false;
        this._model = e;
      }
      destroy() {
        this._source = null;
        this._sourcePane = null;
      }
      source() {
        return this._source;
      }
      onToolChanged() {
        this._removeSource();
        this._currentToolSupportsPhantomMode = (0, wt.isLineToolName)(lt.tool.value()) && (0, eo.supportsPhantomMode)(lt.tool.value());
      }
      onCursorPositionUpdated() {
        if (!this._currentToolSupportsPhantomMode) {
          return;
        }
        const e = this._model.crosshairSource();
        if (this._sourcePane !== e.pane) {
          this._removeSource();
        }
        if (e.pane === null || !(0, wd.isNumber)(e.index) || !(0, wd.isNumber)(e.price)) {
          this._removeSource();
          return;
        }
        const t = {
          index: e.index,
          price: e.price
        };
        if (this._source !== null) {
          this._source.setPoint(0, t);
        } else {
          this._source = this._model.createLineTool({
            pane: e.pane,
            point: t,
            linetool: lt.tool.value()
          });
          this._sourcePane = e.pane;
        }
      }
      _removeSource() {
        if (this._source !== null) {
          this._model.removeSource(this._source);
          this._source = null;
          this._sourcePane = null;
        }
      }
    }
    var Pd;
    var Td = i(92693);
    (function (e) {
      e[e.MagnetTolerance = 50] = "MagnetTolerance";
    })(Pd ||= {});
    class xd {
      constructor() {
        this._lastValue = null;
      }
      align(e, t, i) {
        this._lastValue = null;
        let s = e;
        if (!(0, Un.magnetEnabled)().value()) {
          return s;
        }
        const o = i.mainDataSource();
        if (o === null) {
          return s;
        }
        const r = o.model().mainSeries();
        if (o !== r) {
          return s;
        }
        const a = r.priceScale();
        if (a.isEmpty()) {
          return s;
        }
        const l = function (e, t) {
          const i = e.bars().valueAt(t);
          if (i === null) {
            return;
          }
          let s;
          if (e.priceSource() !== null) {
            s = [e.barFunction()(i)];
          } else {
            switch (e.style()) {
              case 12:
                s = [i[2], i[3]];
                break;
              case 16:
              case 21:
                s = [(0, n.ensure)(i[2]), (0, n.ensure)(i[4]), (0, n.ensure)(i[3])];
                break;
              default:
                s = [i[1], i[2], i[3], i[4]];
            }
          }
          return s;
        }(r, t);
        if (!l) {
          return s;
        }
        const c = (0, n.ensure)(r.firstValue());
        const h = l.map(e => ({
          y: a.priceToCoordinate(e, c),
          price: e
        }));
        const d = a.priceToCoordinate(e, c);
        h.sort((e, t) => Math.abs(e.y - d) - Math.abs(t.y - d));
        const u = h[0];
        if ((0, Un.magnetMode)().value() === Td.MagnetMode.StrongMagnet || Math.abs(u.y - d) < 50) {
          s = u.price;
          this._lastValue = s;
        }
        return s;
      }
      lastValue() {
        return this._lastValue;
      }
      resetLastValue() {
        this._lastValue = null;
      }
    }
    class Id {
      constructor(e) {
        this._appliedTimeFrame = new ht.WatchedObject(null);
        this._appliedTimeFrameInfo = null;
        this._appliedTimeFrameChangedBound = this._appliedTimeFrameChanged.bind(this);
        this._model = e;
        e.mainSeries().dataEvents().seriesTimeFrame().subscribe(this, this._onSeriesTimeFrame);
        this._appliedTimeFrame.subscribe(this._appliedTimeFrameChangedBound);
      }
      destroy() {
        this._appliedTimeFrame.unsubscribe(this._appliedTimeFrameChangedBound);
        this._model.timeScale().logicalRangeChanged().unsubscribeAll(this);
        this._model.mainSeries().dataEvents().seriesTimeFrame().unsubscribeAll(this);
      }
      appliedTimeFrame() {
        return this._appliedTimeFrame;
      }
      _appliedTimeFrameChanged() {
        this._model.timeScale().logicalRangeChanged().unsubscribe(this, this._invalidateAppliedTimeFrame);
      }
      _onSeriesTimeFrame(e, t, i, s) {
        if (s) {
          const e = this._model.timeScale();
          this._appliedTimeFrameInfo = {
            logicalRange: e.logicalRange(),
            baseIndex: e.baseIndex()
          };
          e.logicalRangeChanged().subscribe(this, this._invalidateAppliedTimeFrame);
        }
      }
      _invalidateAppliedTimeFrame() {
        if (this._appliedTimeFrameInfo === null) {
          return;
        }
        const e = this._model.timeScale();
        const t = e.logicalRange();
        const i = e.baseIndex();
        const s = this._appliedTimeFrameInfo.logicalRange;
        const o = this._appliedTimeFrameInfo.baseIndex;
        if (t === null || s === null || Math.abs(i - t.left() - (o - s.left())) >= 0.01 || Math.abs(i - t.right() - (o - s.right())) >= 0.01) {
          this._appliedTimeFrame.setValue(null);
        }
      }
    }
    var Md = i(53388);
    var Ad = i(30125);
    class Ld extends Ad.BitmapCoordinatesPaneRenderer {
      constructor() {
        super(...arguments);
        this._data = null;
      }
      setData(e) {
        this._data = e;
      }
      hitTest(e) {
        return null;
      }
      _drawImpl(e) {
        if (this._data === null) {
          return;
        }
        const {
          context: t,
          verticalPixelRatio: i,
          horizontalPixelRatio: s,
          bitmapSize: o
        } = e;
        const n = Math.max(1, Math.floor(s));
        t.lineWidth = n;
        const r = Math.ceil(o.height * i);
        const a = Math.ceil(o.width * s);
        t.lineCap = "butt";
        if (this._data.vertLinesVisible) {
          t.strokeStyle = this._data.vertLinesColor;
          (0, Ft.setLineStyle)(t, this._data.vertLineStyle);
          for (const e of this._data.timeMarks) {
            const i = Math.round(e.coord * s);
            (0, Ft.drawVerticalLine)(t, i, 0, r);
          }
        }
        if (this._data.horzLinesVisible) {
          t.strokeStyle = this._data.horzLinesColor;
          (0, Ft.setLineStyle)(t, this._data.horzLineStyle);
          for (const e of this._data.priceMarks) {
            const s = Math.round(e.coord * i);
            (0, Ft.drawHorizontalLine)(t, s, 0, a);
          }
        }
      }
    }
    class kd {
      constructor(e) {
        this._renderer = new Ld();
        this._pane = e;
      }
      update() { }
      renderer() {
        const e = this._pane.defaultPriceScale();
        const t = this._pane.model().timeScale();
        if (e.isEmpty() || t.isEmpty()) {
          return null;
        }
        const i = this._pane.model().properties().childs().paneProperties.childs();
        const s = t.marks();
        const o = i.gridLinesMode.value();
        const n = {
          horzLinesVisible: o === "both" || o === "horz",
          vertLinesVisible: o === "both" || o === "vert",
          horzLinesColor: i.horzGridProperties.childs().color.value(),
          vertLinesColor: i.vertGridProperties.childs().color.value(),
          horzLineStyle: i.horzGridProperties.childs().style.value(),
          vertLineStyle: i.vertGridProperties.childs().style.value(),
          priceMarks: e.marks(),
          timeMarks: s !== null ? s : []
        };
        this._renderer.setData(n);
        return this._renderer;
      }
    }
    class Dd extends di.DataSource {
      constructor(e) {
        super();
        this._model = e;
      }
      id() {
        return "grid";
      }
      paneViews(e) {
        if (e.mode() === Bi.PaneMode.Regular) {
          return [new kd(e)];
        } else {
          return null;
        }
      }
      name() {
        return "Grid";
      }
      model() {
        return this._model;
      }
    }
    class Ed extends _d.PriceAxisView {
      constructor(e, t, i, s) {
        super();
        this._source = e;
        this._pane = t;
        this._priceScale = i;
        this._priceProvider = s;
        this._properties = e.model().properties().childs().scalesProperties;
      }
      setHitTestData(e) {
        this._hitTestData = e;
      }
      setXCoord(e) {
        this._xCoord = e;
      }
      additionalPadding(e) {
        return 0;
      }
      _updateRendererData(e, t, i) {
        e.visible = false;
        t.visible = false;
        const s = this._priceScale;
        const o = s.mainSource();
        const n = o !== null ? o.firstValue() : null;
        if (!this._isVisible() || s.isEmpty() || n === null) {
          return;
        }
        const r = this._currentPrice(s);
        if (r === null) {
          return;
        }
        i.background = (0, Is.resetTransparency)(this._bgColor());
        i.textColor = this.generateTextColor(i.background);
        const a = this.additionalPadding(s.fontSize());
        i.additionalPaddingTop = a;
        i.additionalPaddingBottom = a;
        i.coordinate = s.priceToCoordinate(r, n);
        e.text = s.formatPrice(r, n);
        e.visible = true;
        t.visible = true;
        t.hitTestData = this._hitTestData;
        t.xCoord = this._xCoord;
      }
      _currentPrice(e) {
        return this._priceProvider(e);
      }
    }
    class Bd extends Ed {
      additionalPadding(e) {
        return 2 / 12 * e;
      }
      _isVisible() {
        const e = this._source.lockedPane();
        return this._properties.childs().showPriceScaleCrosshairLabel.value() && (this._source.visible || e !== null) && (e ?? this._source.pane) === this._pane;
      }
      _currentPrice(e) {
        const t = lt.crosshairLock.value();
        if (t !== null && t.type === 1) {
          if (this._pane === this._source.lockedPane()) {
            return t.price;
          } else {
            return null;
          }
        } else {
          return super._currentPrice(e);
        }
      }
      _bgColor() {
        const e = this._properties.childs();
        if (this._source.model().dark().value()) {
          return e.crosshairLabelBgColorDark.value();
        } else {
          return e.crosshairLabelBgColorLight.value();
        }
      }
      _updateRendererData(e, t, i) {
        const s = t.visible;
        super._updateRendererData(e, t, i);
        if (this._source.isHovered()) {
          t.backgroung = this._source.model().dark().value() ? Lt.colorsPalette["color-cold-gray-600"] : Lt.colorsPalette["color-cold-gray-650"];
        } else {
          t.backgroung = undefined;
        }
        if (!s) {
          t.visible = s;
        }
      }
    }
    class Vd extends Ed {
      _isVisible() {
        return this._source.measurePane().value() !== null;
      }
      _bgColor() {
        return this._properties.childs().axisLineToolLabelBackgroundColorCommon.value();
      }
    }
    var Rd;
    var Nd;
    var Od = i(19475);
    function Fd(e) {
      const t = e.priceScale();
      if (t === null) {
        return 0;
      } else if (t.isPercentage() || t.isIndexedTo100()) {
        return 2;
      } else {
        return 1;
      }
    }
    (function (e) {
      e[e.NotDefined = 0] = "NotDefined";
      e[e.Regular = 1] = "Regular";
      e[e.Unregular = 2] = "Unregular";
    })(Rd ||= {});
    class Wd extends cd.PanePriceAxisView {
      constructor(e, t, i, s, o) {
        super(e, t, s);
        this._crossHairMenuCachedState = null;
        this._hasActions = false;
        this._gaOrigin = "CH menu";
        this._crosshairPriceAxisView = e;
        e.setPaneRendererLabelIcon(0);
        this._crosshair = t;
        this._scale = i;
        this._options = o;
        this._updateGaOrigin();
      }
      _updateImpl(e) {
        const t = this._crosshair.y;
        const i = this._chartModel.properties().childs().scalesProperties.childs().fontSize.value();
        const s = this._chartModel.timeScale().width();
        const o = this._crosshair.model().priceAxisRendererOptions();
        const n = i + this._crosshairPriceAxisView.additionalPadding(i) * 2 + o.paddingTop + o.paddingBottom;
        const r = n;
        const a = t - n / 2;
        const c = this._crosshair.pane;
        const h = this._mainDataSourceOnPane();
        const d = h && h.symbolSource();
        const u = !!d && (d.isConvertedToOtherCurrency() || d.isConvertedToOtherUnit());
        this._updateGaOrigin();
        if (h !== null) {
          const e = Fd(h);
          const t = h.idForAlert();
          const i = this._chartModel.isInReplay().value();
          const s = this._crossHairMenuCachedState;
          const o = l.enabled("chart_crosshair_menu");
          if (s === null || s.id !== t || s.priceScale !== e || s.isCurrencyOrUnitConverted !== u || s.isInReplay !== i || s.isMenuEnabled !== o) {
            this._updateTooltipAndActionsAvailability(h, e, u);
            this._crossHairMenuCachedState = {
              id: t,
              priceScale: e,
              isCurrencyOrUnitConverted: u,
              isInReplay: i,
              isMenuEnabled: o
            };
          }
        }
        const _ = h !== null && (0, Nr.isActingAsSymbolSource)(h) ? h.symbol() : null;
        const p = c !== null && (c.maximized().value() || !c.collapsed().value()) && (Boolean(_) || false);
        this._crosshairPriceAxisView.setPaneLabelVisible(p);
        const m = this._position();
        if (m !== null) {
          const e = 0;
          const t = s - r;
          const i = Boolean(Od.showPlusButtonOnCursor.value());
          const o = i ? this._crosshair.x : undefined;
          const l = o !== undefined ? o - r / 2 : m === "left" ? e : t;
          const c = o !== undefined ? o + r / 2 : m === "left" ? e + r : t + r;
          const h = (0, At.box)(new At.Point(l, a), new At.Point(c, a + n));
          this._data = {
            itemBox: h,
            clickHandler: this._handleClick.bind(this, m, i, h)
          };
          this._crosshairPriceAxisView.setHitTestData(this._data);
          this._crosshairPriceAxisView.setXCoord(o);
        }
        super._updateImpl(e);
      }
      _priceScale() {
        return this._scale;
      }
      _updateGaOrigin() {
        this._gaOrigin = Boolean(Od.showPlusButtonOnCursor.value()) ? "CH menu cursor" : "CH menu";
      }
      _updateTooltipAndActionsAvailability(e, t, i) {
        this._hasActions = false;
        if (t !== 1) {
          return;
        }
        this._chartModel.isInReplay().value();
        this._hasActions = false;
      }
      _handleClick(e, t, i, s, o) {
        (0, ne.trackEvent)(this._gaOrigin, "click");
        const n = this._mainDataSourceOnPane();
        const r = n !== null && (0, Nr.isActingAsSymbolSource)(n) ? n.symbol() : null;
        const a = {
          pageX: o.pageX,
          pageY: o.pageY,
          clientX: o.clientX,
          clientY: o.clientY,
          screenX: o.screenX,
          screenY: o.screenY,
          price: this._crosshair.price,
          symbol: r
        };
        W.emit("onPlusClick", a);
      }
      _getMenuItems(e) {
        return Promise.resolve([]);
      }
      _createAlertMenuItems(e) {
        return Promise.resolve([]);
      }
      _getAddAlertActionOptions(e, t, i) {
        return {
          dataSource: e,
          y: t,
          disabled: i,
          analyticsOpt: {
            method: "crosshair_menu",
            source: "chart",
            actionSource: "crosshair_menu",
            gaOrigin: this._gaOrigin
          }
        };
      }
      _createTradingMenuItems() {
        return Promise.resolve([]);
      }
      _createAddHorizontalLineMenuItem() {
        return [];
      }
      _getActionAddHorizontalLine(e) {
        return null;
      }
      _getValue(e, t) {
        const i = e.priceScale();
        const s = e.firstValue();
        if (i === null || s === null) {
          return null;
        }
        if (i.isPercentage() || i.isIndexedTo100()) {
          return null;
        } else {
          return i.coordinateToPrice(t, s);
        }
      }
      _showContextMenu(e, t, i, s, o) {
        const r = o === "left";
        setTimeout(() => {
          const o = s.clientX - s.localX;
          const a = s.clientY - s.localY;
          const l = i.min.x + o;
          const c = i.max.x + o;
          const h = i.min.y + a;
          const d = c - l;
          const u = i.max.y + a - h;
          const _ = t ? lt.crosshairLock.value() : undefined;
          if (_ !== undefined) {
            const e = (0, n.ensureNotNull)(this._chartModel.timeScale().points().roughTime(this._crosshair.index));
            lt.crosshairLock.setValue({
              type: 1,
              price: this._crosshair.price,
              time: e,
              modelId: this._chartModel.id(),
              paneId: (0, n.ensureNotNull)(this._crosshair.pane).id()
            });
          }
          Oo.ContextMenuManager.showMenu(e, {
            clientX: s.clientX,
            clientY: s.clientY,
            box: {
              x: l,
              w: d,
              y: h,
              h: u
            },
            attachToXBy: t ? "auto" : r ? "left" : "right",
            attachToYBy: "auto-strict",
            marginX: t ? 0 : -d
          }, undefined, {
            menuName: "CrosshairMenuView"
          }, () => {
            if (_ !== undefined) {
              lt.crosshairLock.setValue(_);
            }
          });
        });
      }
      _mainDataSourceOnPane() {
        const e = this._crosshair.pane;
        if (e !== null) {
          return e.mainDataSource();
        } else {
          return null;
        }
      }
    }
    class Hd extends Ad.BitmapCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._data = e;
      }
      hitTest(e) {
        if (this._data.clickHandler === undefined) {
          return null;
        } else {
          return new Vt.HitTestResult(Vt.HitTarget.Custom, {
            clickHandler: this._data.clickHandler,
            tapHandler: this._data.clickHandler
          });
        }
      }
      _drawImpl(e) {
        const t = this._data.vertLinesVisible;
        const i = this._data.horzLinesVisible;
        if (!t && !i) {
          return;
        }
        const {
          context: s,
          horizontalPixelRatio: o,
          verticalPixelRatio: n,
          bitmapSize: r
        } = e;
        s.lineWidth = Math.max(1, Math.floor(this._data.lineWidth * o));
        s.strokeStyle = this._data.color;
        s.fillStyle = this._data.color;
        s.lineCap = "butt";
        (0, Ft.setLineStyle)(s, this._data.lineStyle);
        const a = Math.round(this._data.x * o);
        const l = Math.round(this._data.y * n);
        const c = Math.ceil(r.width * o);
        const h = Math.ceil(r.height * n);
        if (t && a >= 0) {
          (0, Ft.drawVerticalLine)(s, a, 0, h);
        }
        if (i && l >= 0) {
          (0, Ft.drawHorizontalLine)(s, l, 0, c);
        }
        if (this._data.drawCenter) {
          s.beginPath();
          s.arc(a, l, Math.round(o * 3), 0, Math.PI * 2, true);
          s.fillStyle = this._data.color;
          s.fill();
        }
        if (this._data.scissors) {
          (function (e, t, i) {
            const {
              context: s,
              bitmapSize: o,
              horizontalPixelRatio: n,
              verticalPixelRatio: r
            } = e;
            const a = n * 24;
            const l = Math.round(t - a / 2);
            let c = Math.round(i - a / 2);
            if (c < 0) {
              c = 0;
            } else {
              const e = o.height - a;
              if (c > e) {
                c = e;
              }
            }
            s.translate(l, c);
            s.scale(n, r);
            s.fillStyle = "#1A1A1A";
            s.fill(zd);
            s.strokeStyle = "#fff";
            s.lineWidth = 1;
            s.stroke(zd);
          })(e, a, l);
        }
      }
    }
    (function (e) {
      e.Path = "m15.68 3.72-3.82 5.52-3.83-5.52-.28-.42-.42.3a2.84 2.84 0 0 0-.68 3.92l3.27 4.73-1.16 1.68a3.34 3.34 0 0 0-4.26 3.22 3.34 3.34 0 0 0 3.32 3.35 3.34 3.34 0 0 0 3.08-4.6l1-1.44 1.13 1.62a3.34 3.34 0 0 0 3.15 4.42c1.84 0 3.32-1.5 3.32-3.35a3.34 3.34 0 0 0-4.42-3.17l-1.23-1.78 3.22-4.65a2.86 2.86 0 0 0-.69-3.96l-.41-.29-.29.42ZM7.82 16.27c.47 0 .86.39.86.88 0 .48-.39.87-.86.87a.87.87 0 0 1-.86-.87c0-.5.4-.88.86-.88Zm8.36 0c.47 0 .86.39.86.88 0 .48-.4.87-.86.87a.87.87 0 0 1-.86-.87c0-.5.39-.88.86-.88Z";
      e[e.Size = 24] = "Size";
      e.FillColor = "#1A1A1A";
      e.StrokeColor = "#fff";
      e[e.StrokeWidth = 1] = "StrokeWidth";
    })(Nd ||= {});
    const zd = new Path2D("m15.68 3.72-3.82 5.52-3.83-5.52-.28-.42-.42.3a2.84 2.84 0 0 0-.68 3.92l3.27 4.73-1.16 1.68a3.34 3.34 0 0 0-4.26 3.22 3.34 3.34 0 0 0 3.32 3.35 3.34 3.34 0 0 0 3.08-4.6l1-1.44 1.13 1.62a3.34 3.34 0 0 0 3.15 4.42c1.84 0 3.32-1.5 3.32-3.35a3.34 3.34 0 0 0-4.42-3.17l-1.23-1.78 3.22-4.65a2.86 2.86 0 0 0-.69-3.96l-.41-.29-.29.42ZM7.82 16.27c.47 0 .86.39.86.88 0 .48-.39.87-.86.87a.87.87 0 0 1-.86-.87c0-.5.4-.88.86-.88Zm8.36 0c.47 0 .86.39.86.88 0 .48-.4.87-.86.87a.87.87 0 0 1-.86-.87c0-.5.39-.88.86-.88Z");
    const Ud = Lt.colorsPalette["color-tv-blue-500"];
    class jd {
      constructor(e, t) {
        this._rendererData = {};
        this._renderer = new Hd(this._rendererData);
        this._source = e;
        this._pane = t;
      }
      update() { }
      renderer() {
        const e = this._source.selectPointMode().value() !== lt.SelectPointMode.None;
        const t = this._source.lockedPane();
        const i = (this._source.visible || t !== null) && (this._source.areLinesVisible || e) && !this._source.linesShouldBeHidden();
        const s = this._rendererData;
        if (!i || this._pane === null) {
          return null;
        }
        const o = this._source.paneForPointSelect();
        const r = this._source.isReplaySelection();
        const a = t ?? this._source.pane;
        const l = this._pane === a;
        const c = r || (o !== null ? a === o && this._pane === o : l);
        s.scissors = false;
        if (e && (r || this._source.isOnHoveredChartWidget()) && c) {
          const e = (0, n.ensureNotNull)(this._source.pointToSelect());
          s.color = this._source.lineColor() || Ud;
          if (r) {
            s.lineWidth = 2;
            s.scissors = l;
          } else {
            s.lineWidth = 1;
          }
          s.lineStyle = Ot.LINESTYLE_SOLID;
          s.horzLinesVisible = true;
          s.vertLinesVisible = true;
          s.drawCenter = false;
          if (e === "time") {
            s.horzLinesVisible = false;
          } else if (e === "price") {
            s.vertLinesVisible = false;
          }
        } else {
          const e = this._source.properties();
          const t = lt.tool.value();
          const i = (0, vo.lastMouseOrTouchEventInfo)();
          const o = i.isTouch && !i.stylus && ((0, wt.isLineToolName)(t) || (0, lt.toolIsMeasure)(t));
          let n;
          n = o ? Ud : e.childs().color.value();
          const r = e.childs().transparency.value();
          if (!o && r > 0) {
            n = (0, Is.generateColor)(n, r);
          }
          s.color = n;
          s.horzLinesVisible = this._pane === a && (this._pane.maximized().value() || !this._pane.collapsed().value());
          s.vertLinesVisible = true;
          s.lineWidth = e.childs().width.value();
          s.lineStyle = e.childs().style.value();
          s.drawCenter = o && this._pane === a;
        }
        s.x = this._source.lockedX() ?? this._source.x;
        s.y = this._source.lockedY() ?? this._source.y;
        return this._renderer;
      }
    }
    var Gd = i(62189);
    const qd = {
      backgroundColor: (0, Is.generateColor)(Lt.colorsPalette["color-tv-blue-500"], 70),
      borderColor: (0, Is.generateColor)(Lt.colorsPalette["color-tv-blue-500"], 20)
    };
    class $d {
      constructor(e) {
        this._renderer = new Gd.RectangleRenderer();
        this._rectangle = null;
        this._crosshair = e;
      }
      update() {
        const e = this._crosshair.selection();
        if (e !== null && this._crosshair.pane !== null) {
          this._rectangle = this._crosshair.pane.logicalRectToPixels(e);
        } else {
          this._rectangle = null;
        }
      }
      renderer() {
        if (!this._rectangle) {
          return null;
        }
        const e = {
          backcolor: qd.backgroundColor,
          color: qd.borderColor,
          fillBackground: true,
          linewidth: 1,
          points: [this._rectangle.min, this._rectangle.max],
          extendLeft: false,
          extendRight: false
        };
        this._renderer.setData(e);
        return this._renderer;
      }
    }
    var Kd = i(63273);
    var Yd = i(30699);
    var Zd = i(92953);
    var Xd = i(91046);
    var Jd = i(17330);
    var Qd = i(49857);
    const eu = a.t(null, undefined, i(41643));
    const tu = a.t(null, {
      context: "study"
    }, i(24261));
    const iu = (0, uh.getPercentageFormatter)();
    const su = new Zd.TimeSpanFormatter();
    const ou = (0, uh.getVolumeFormatter)();
    const nu = (0, Lt.getHexColorByName)("color-tv-blue-500");
    const ru = (0, Lt.getHexColorByName)("color-ripe-red-400");
    const au = {
      bgColorPositive: (0, Is.generateColor)(nu, 80),
      bgColorNegative: (0, Is.generateColor)(ru, 80),
      colorPositive: (0, Lt.getHexColorByName)("color-tv-blue-600"),
      colorNegative: (0, Lt.getHexColorByName)("color-ripe-red-400"),
      labelBgColorPositive: nu,
      labelBgColorNegative: ru
    };
    var lu;
    (function (e) {
      e[e.MinArrowDistance = 50] = "MinArrowDistance";
    })(lu ||= {});
    class cu {
      constructor(e, t) {
        this._horzTrenRenderer = new Xd.TrendLineRenderer();
        this._vertTrenRenderer = new Xd.TrendLineRenderer();
        this._bgRenderer = new Gd.RectangleRenderer();
        this._labelRenderer = new Jd.TextRenderer();
        this._p1 = null;
        this._p2 = null;
        this._source = e;
        this._pane = t;
      }
      update(e) {
        const [t, i] = this._source.measurePoints();
        if (i === undefined) {
          this._p1 = null;
          this._p2 = null;
          return;
        }
        const s = (0, n.ensureNotNull)(this._source.measurePane().value());
        const o = t.price;
        const r = i.price;
        const a = i.index - t.index;
        const l = (0, Kd.forceLTRStr)("" + a);
        const c = (0, n.ensureNotNull)(s.mainDataSource());
        const h = (0, n.ensureNotNull)(c.firstValue());
        const d = this._source.model().timeScale().indexToCoordinate(t.index);
        const u = this._source.model().timeScale().indexToCoordinate(i.index);
        const _ = s.defaultPriceScale().priceToCoordinate(o, h);
        const p = s.defaultPriceScale().priceToCoordinate(r, h);
        this._p1 = new At.Point(d, _);
        this._p2 = new At.Point(u, p);
        const m = this._source.model().timeScale().indexToUserTime(t.index);
        const f = this._source.model().timeScale().indexToUserTime(i.index);
        let y = null;
        if (m !== null && f !== null) {
          y = (f.valueOf() - m.valueOf()) / 1000;
        }
        const v = r - o;
        const S = v * 100 / Math.abs(o);
        const b = this._pane.model().mainSeries().symbolInfo();
        const w = b && (0, uh.getPipFormatter)(b);
        const C = (0, n.ensureNotNull)(c.formatter());
        const P = (C.formatChange?.(r, o) ?? C.format(v)) + " (" + iu.format(Math.round(S * 100) / 100) + ") " + (w ? w.format(v) : "");
        const T = y !== null ? su.format(y) : null;
        const x = T !== null ? ", " + (0, Kd.startWithLTR)(T) : "";
        let I = (0, Kd.forceLTRStr)(P) + "\n" + eu.format({
          count: l
        }) + x;
        const M = this._source.measureVolume();
        if (!Number.isNaN(M)) {
          I += `\n${tu} ${ou.format(M)}`;
        }
        const A = r < o ? au.bgColorNegative : au.bgColorPositive;
        const L = r < o ? au.colorNegative : au.colorPositive;
        const k = r < o ? au.labelBgColorNegative : au.labelBgColorPositive;
        const D = {
          points: [this._p1, this._p2],
          linewidth: 0,
          fillBackground: true,
          color: A,
          backcolor: A,
          extendLeft: false,
          extendRight: false
        };
        this._bgRenderer.setData(D);
        const E = this._p1.add(this._p2).scaled(0.5);
        {
          const e = Math.round(E.y);
          const t = new At.Point(this._p1.x, e);
          const i = new At.Point(this._p2.x, e);
          const s = {
            points: [t, i],
            color: L,
            linewidth: 1,
            linestyle: Ot.LINESTYLE_SOLID,
            extendleft: false,
            extendright: false,
            leftend: Qd.LineEnd.Normal,
            rightend: Math.abs(t.x - i.x) >= 50 ? Qd.LineEnd.Arrow : Qd.LineEnd.Normal
          };
          this._horzTrenRenderer.setData(s);
        }
        {
          const e = Math.round(E.x);
          const t = new At.Point(e, this._p1.y);
          const i = new At.Point(e, this._p2.y);
          const s = {
            points: [t, i],
            color: L,
            linewidth: 1,
            linestyle: Ot.LINESTYLE_SOLID,
            extendleft: false,
            extendright: false,
            leftend: Qd.LineEnd.Normal,
            rightend: Math.abs(t.y - i.y) >= 50 ? Qd.LineEnd.Arrow : Qd.LineEnd.Normal
          };
          this._vertTrenRenderer.setData(s);
        }
        const B = {
          x: 0,
          y: 10
        };
        const V = (this._p1.x + this._p2.x) * 0.5;
        const R = this._p2.y;
        const N = new At.Point(V, R);
        const O = {
          points: [N],
          text: I,
          color: "#FFFFFF",
          horzAlign: Yd.HorizontalAlign.Center,
          vertAlign: Yd.VerticalAlign.Middle,
          font: g.CHART_FONT_FAMILY,
          offsetX: B.x,
          offsetY: B.y,
          bold: false,
          italic: false,
          fontsize: 12,
          lineSpacing: 8,
          highlightBorder: false,
          backgroundColor: k,
          backgroundTransparency: 10,
          boxPaddingVert: 9,
          boxPaddingHorz: 9,
          backgroundRoundRect: 4
        };
        this._labelRenderer.setData(O);
        const F = this._labelRenderer.measure();
        const W = (0, Jd.calculateLabelPosition)(F, this._p1, this._p2, B, this._pane.height());
        this._labelRenderer.setPoints([W]);
      }
      renderer() {
        if (this._p1 === null || this._p2 === null) {
          return null;
        }
        const e = new Rt.CompositeRenderer();
        e.append(this._bgRenderer);
        e.append(this._horzTrenRenderer);
        e.append(this._vertTrenRenderer);
        e.append(this._labelRenderer);
        return e;
      }
    }
    var hu;
    var du = i(99875);
    (function (e) {
      e[e.Light = 0] = "Light";
      e[e.Dark = 1] = "Dark";
    })(hu ||= {});
    class uu extends Rc.MediaCoordinatesPaneRenderer {
      constructor(e) {
        super();
        this._svgMap = new Map();
        this._data = e;
        this._svgMap.set(e.theme, this._createSvgRenderer(e.theme));
      }
      hitTest() {
        return null;
      }
      setData(e) {
        if (!this._svgMap.has(e.theme)) {
          this._svgMap.set(e.theme, this._createSvgRenderer(e.theme));
        }
        this._data = e;
      }
      _drawImpl(e) {
        const {
          context: t,
          mediaSize: i
        } = e;
        const {
          theme: s,
          x: o
        } = this._data;
        const n = this._svgMap.get(s);
        if (!n) {
          return;
        }
        const r = n.viewBox();
        const {
          width: a,
          height: l
        } = r;
        const c = a / 2;
        if (!(o + c < 0) && !(o - c > i.width)) {
          t.translate(o - c, i.height - l);
          n.render(t, {
            targetViewBox: r
          });
        }
      }
      _createSvgRenderer(e) {
        const t = e === 1 ? du.replace("backgroundColor", (0, Lt.getHexColorByName)("color-cold-gray-900")).replace("lineColor", (0, Lt.getHexColorByName)("color-cold-gray-450")) : du.replace("backgroundColor", (0, Lt.getHexColorByName)("color-white")).replace("lineColor", (0, Lt.getHexColorByName)("color-cold-gray-550"));
        return (0, No.svgRenderer)(t);
      }
    }
    class _u {
      constructor(e) {
        this._source = e;
        this._renderer = new uu(this._getRenderData(0));
      }
      update() { }
      renderer() {
        const e = this._source.visible && this._source.areLinesVisible;
        const t = this._source.lockedX();
        const i = lt.crosshairLock.value()?.type === 0;
        if (e && i && t !== null) {
          this._renderer.setData(this._getRenderData(t + 1));
          return this._renderer;
        } else {
          return null;
        }
      }
      _getRenderData(e) {
        return {
          x: e,
          theme: this._source.model().dark().value() ? 1 : 0
        };
      }
    }
    var pu = i(7576);
    var mu = i(82587);
    class gu extends pu.DataWindowView {
      constructor(e) {
        super();
        this._invalidated = true;
        this._dateItem = new pu.DataWindowItem("", a.t(null, undefined, i(22677)), "");
        this._timeItem = new pu.DataWindowItem("", a.t(null, undefined, i(12806)), "");
        this._model = e;
        this._items.push(this._dateItem);
        this._items.push(this._timeItem);
      }
      update() {
        this._invalidated = true;
      }
      items() {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        return this._items;
      }
      _updateImpl() {
        const e = this._model.mainSeries().isDWM();
        this._timeItem.setVisible(!e);
        this._timeItem.setValue(mu.notAvailable);
        this._dateItem.setValue(mu.notAvailable);
        if (this._model.timeScale().isEmpty()) {
          return;
        }
        let t = this._model.crosshairSource().appliedIndex();
        if (!(0, wd.isNumber)(t)) {
          const e = this._model.mainSeries().data().last();
          if (e === null) {
            return;
          }
          t = e.index;
        }
        const i = this._model.timeScale().indexToUserTime(t);
        if (i !== null) {
          this._dateItem.setValue(this._model.dateFormatter().format(i));
          if (!e) {
            this._timeItem.setValue(this._model.timeFormatter().format(i));
          }
        }
      }
    }
    var fu = i(66156);
    const yu = Lt.colorsPalette["color-tv-blue-500"];
    const vu = a.t(null, {
      context: "Replay"
    }, i(53310));
    class Su extends fu.TimeAxisView {
      constructor(e, t, i, s = false) {
        super(e);
        this._indexProvider = i;
        this._highlighted = s;
        this._source = t;
        this._properties = e.properties().childs().scalesProperties;
      }
      _getText(e) {
        if (this._source.isReplaySelection()) {
          const t = this._model.timeScale().indexToUserTime(e);
          if (t !== null) {
            return `${vu}: ${this._model.dateTimeFormatter().format(t)}`;
          } else {
            return "";
          }
        }
        return super._getText(e);
      }
      _getBgColor() {
        if (this._source.isReplaySelection()) {
          return yu;
        }
        const e = this._properties.childs();
        if (this._highlighted) {
          return e.axisLineToolLabelBackgroundColorCommon.value();
        } else if (this._model.dark().value()) {
          return e.crosshairLabelBgColorDark.value();
        } else {
          return e.crosshairLabelBgColorLight.value();
        }
      }
      _getIndex() {
        if (this._model.crosshairSource().visible || this._source.lockedPane() !== null) {
          return this._indexProvider();
        } else {
          return null;
        }
      }
      _isVisible() {
        return this._properties.childs().showTimeScaleCrosshairLabel.value();
      }
    }
    var bu;
    var wu = i(61105);
    var Cu = i(97435);
    var Pu = i(49156);
    (function (e) {
      e[e.LineWidth = 36] = "LineWidth";
      e[e.CircleBorderWidth = 1] = "CircleBorderWidth";
      e[e.AnimationDuration = 4000] = "AnimationDuration";
    })(bu ||= {});
    const Tu = (0, Is.applyAlpha)(Pu.colors.colorRipeRed500, 0.25);
    const xu = (0, Is.applyAlpha)(Pu.colors.colorRipeRed500, 0.03);
    class Iu {
      constructor(e) {
        this._invalidated = true;
        this._circleRenderer = new Cu.CircleRenderer();
        this._source = e;
      }
      update(e) {
        this._invalidated = true;
      }
      renderer(e) {
        if (this._invalidated) {
          this._updateImpl();
          this._invalidated = false;
        }
        return this._circleRenderer;
      }
      _updateImpl() {
        const e = this._source.originX();
        const t = this._source.originY();
        if (Number.isFinite(e) && Number.isFinite(t)) {
          this._circleRenderer.setData({
            center: (0, At.point)(e, t),
            radius: 18,
            lineWidth: 1,
            color: xu,
            backColor: Tu,
            disableInteractions: true
          });
        } else {
          this._circleRenderer.setData(null);
        }
      }
    }
    class Mu {
      constructor(e) {
        this._activeHighlighter = null;
        this._highlighters = new Map();
        this._toolsFactory = null;
        this._throttleUpdateHighlighters = (0, o.default)(() => {
          const e = (0, Bt.sourceChangeEvent)(this._crosshair.id());
          let t = false;
          const i = Array.from(this._highlighters.keys());
          for (const s of i) {
            const i = [];
            for (const t of (0, n.ensureDefined)(this._highlighters.get(s))) {
              if (t.animationProgress() < 1) {
                t.updateAllViews(e);
                i.push(t);
              } else {
                t.destroy?.();
              }
            }
            if (i.length > 0) {
              this._highlighters.set(s, i);
              t = true;
            } else {
              this._highlighters.delete(s);
            }
          }
          if (t) {
            this._crosshair.model().updateSource(this._crosshair);
          }
        }, 20, {
          leading: true
        });
        this._crosshair = e;
        this._view = new Iu(e);
        this._currentTool = lt.tool.spawn();
        this._currentTool.subscribe(e => {
          if ((0, lt.toolIsDemonstration)(e) && this._toolsFactory === null) {
            this._toolsFactory = new Tc((async () => {
              const e = await i.e(360).then(i.bind(i, 13506));
              return (t, i, s, o) => new e.LineToolDemonstrationHighlighter(t, i, s, o);
            })());
          }
        }, {
          callWithLast: true
        });
      }
      destroy() {
        for (const [, e] of this._highlighters) {
          for (const t of e) {
            t.destroy?.();
          }
        }
        this._currentTool.destroy();
      }
      update(e) {
        this._view.update(e);
        for (const [, t] of this._highlighters) {
          for (const i of t) {
            i.updateAllViews(e);
          }
        }
      }
      paneViews(e) {
        const t = [];
        if (e === this._crosshair.pane && (0, lt.toolIsDemonstration)(lt.cursorTool.value())) {
          t.push(this._view);
        }
        for (const i of this._highlighters.get(e) ?? []) {
          const s = i.paneViews(e);
          if (s) {
            t.push(...s);
          }
        }
        if (this._highlighters.size > 0) {
          this._throttleUpdateHighlighters();
        }
        return t;
      }
      createHighlighter() {
        const e = this._toolsFactory?.get();
        if (!e) {
          return;
        }
        this._activeHighlighter = e(this._crosshair.model(), Tu, 36, 4000);
        const t = (0, n.ensureNotNull)(this._crosshair.pane);
        const i = (0, n.ensureNotNull)(t.mainDataSource());
        (0, eo.prepareLineToolPropertiesByOwnerSource)(this._activeHighlighter.properties(), i);
        this._activeHighlighter.setOwnerSource(i);
        const s = this._highlighters.get(t) ?? [];
        s.push(this._activeHighlighter);
        this._highlighters.set(t, s);
      }
      addHighlighterPosition(e) {
        this._activeHighlighter?.addPoint(e);
        this.update((0, Bt.sourceChangeEvent)(this._crosshair.id()));
      }
      isThereUnfinishedHighlighter() {
        return this._activeHighlighter !== null;
      }
      finishHighlighter() {
        this._activeHighlighter?.finish();
        this._activeHighlighter = null;
        this._throttleUpdateHighlighters();
      }
    }
    const Au = {
      menuEnabled: false,
      menuForMainSourceOnly: false,
      disableTradingMenuActions: false,
      disableDrawHorizLineMenuAction: false
    };
    let Lu = 0;
    const ku = (0, ae.getLogger)("Chart.Crosshair");
    class Du extends di.DataSource {
      constructor(e, t, i) {
        super();
        this.pane = null;
        this.price = NaN;
        this.index = NaN;
        this.visible = true;
        this.areLinesVisible = true;
        this.x = NaN;
        this.y = NaN;
        this._lockData = null;
        this._crosshairDemonstration = new Mu(this);
        this._measurePane = new F.WatchedValue(null);
        this._measurePaneViewCache = new WeakMap();
        this._startMeasurePoint = null;
        this._endMeasurePoint = null;
        this._lastValidMeasurePoint = null;
        this._linesShouldBeHidden = false;
        this._isOnHoveredChartWidget = false;
        this._crossHairSelectPointMode = new F.WatchedValue(lt.SelectPointMode.None);
        this._selectionPane = null;
        this._selectionView = new $d(this);
        this._selectionStartPoint = null;
        this._timeLockPaneView = null;
        this._crosshairPaneViewCache = new WeakMap();
        this._pointSelectionPaneViewCache = new WeakMap();
        this._priceAxisViews = new Map();
        this._panePriceAxisViews = new Map();
        this._startMeasurePriceAxisViews = new Map();
        this._endMeasurePriceAxisViews = new Map();
        this._originX = NaN;
        this._originY = NaN;
        this._subscribed = false;
        this._movedDelegate = new re.Delegate();
        this._pointSelectedDelegate = new re.Delegate();
        this._requestedPoint = null;
        this._paneForRequestedPoint = null;
        this._selectLineColor = null;
        this._volumeCalculator = null;
        this._selectFromAllChartsIfOutOfData = null;
        this._currentMeasurePointsetAndSymbolId = null;
        this._model = e;
        this._options = Object.assign({}, Au, i || {});
        this._dataWindowView = new gu(e);
        this.setSelectionEnabled(false);
        const s = e => t => t === (0, n.ensureNotNull)(this._measurePane.value()).defaultPriceScale() ? e() : null;
        this._currentPosPriceProvider = e => {
          const t = (0, n.ensureNotNull)(this.pane);
          if (e === t.defaultPriceScale()) {
            return this.price;
          }
          const i = (0, n.ensureNotNull)(t.defaultPriceScale().mainSource()).firstValue();
          if (i === null) {
            return null;
          }
          const s = t.defaultPriceScale().priceToCoordinate(this.price, i);
          const o = (0, n.ensureNotNull)(e.mainSource()).firstValue();
          if (o === null) {
            return null;
          } else {
            return e.coordinateToPrice(s, o);
          }
        };
        this._startMeasurePriceProvider = s(() => (0, n.ensureNotNull)(this._startMeasurePoint).price);
        this._endMeasurePriceProvider = s(() => (0, n.ensureNotNull)(this._lastMeasurePoint()).price);
        this._properties = t;
        this._timeAxisView = new Su(e, this, () => this.appliedIndex(), false);
        this._startMeasureTimeAxisView = new Su(e, this, () => (0, n.ensureNotNull)(this._startMeasurePoint).index, true);
        this._endMeasureTimeAxisView = new Su(e, this, () => (0, n.ensureNotNull)(this._lastMeasurePoint()).index, true);
        this._cursorTool = lt.cursorTool.spawn();
        if (!e.readOnly()) {
          this._cursorTool.subscribe(e => this.areLinesVisible = e !== "arrow", {
            callWithLast: true
          });
        }
        this._crosshairLock = lt.crosshairLock.spawn();
        this._showPlusButtonOnCursor = Od.showPlusButtonOnCursor.spawn();
        const o = () => {
          this.updateAllViews((0, Bt.sourceChangeEvent)(this.id()));
          this._model.lightUpdate();
        };
        this._crosshairLock.subscribe(o);
        this._showPlusButtonOnCursor.subscribe(o);
      }
      destroy() {
        if (this._volumeCalculator !== null) {
          this._volumeCalculator.destroy();
        }
        this._measurePane.setValue(null);
        this._crosshairLock.destroy();
        this._showPlusButtonOnCursor.destroy();
        this._cursorTool.destroy();
        this._removeMeasurePointset();
        this._crosshairDemonstration.destroy();
        super.destroy();
      }
      name() {
        return "Crosshair";
      }
      moved() {
        return this._movedDelegate;
      }
      originX() {
        return this._originX;
      }
      originY() {
        return this._originY;
      }
      saveOriginCoords(e, t) {
        this._originX = e;
        this._originY = t;
      }
      clearOriginCoords() {
        this._originX = NaN;
        this._originY = NaN;
      }
      currentPoint() {
        return new At.Point(this.x, this.y);
      }
      model() {
        return this._model;
      }
      appliedIndex() {
        return this._getLockData().index ?? this.index;
      }
      lockedX() {
        return this._getLockData().xCoord ?? null;
      }
      lockedY() {
        return this._getLockData().yCoord ?? null;
      }
      lockedPane() {
        const e = lt.crosshairLock.value();
        if (e === null || e.type !== 1) {
          return null;
        } else if (this._model.id() === e.modelId) {
          return this._model.paneForId(e.paneId);
        } else {
          return this._model.mainPane();
        }
      }
      invalidateLockPosition() {
        this._lockData = null;
      }
      startMeasurePoint() {
        return this._startMeasurePoint || null;
      }
      endMeasurePoint() {
        return this._endMeasurePoint || null;
      }
      measureVolume() {
        if (this._volumeCalculator === null) {
          return NaN;
        }
        const [e, t] = this.measurePoints();
        if (t === undefined) {
          return NaN;
        } else {
          return this._volumeCalculator.volume(e.index, t.index);
        }
      }
      measurePane() {
        return this._measurePane.readonly();
      }
      crosshairDemonstration() {
        return this._crosshairDemonstration;
      }
      startMeasuring(e, t) {
        this._startMeasurePoint = e;
        this._measurePane.setValue(t);
        if (t.containsMainSeries()) {
          (0, n.assert)(this._volumeCalculator === null);
          this._volumeCalculator = new wu.SeriesTimeRangeVolumeCalculator(this.model().mainSeries());
        }
        this._model.updatePane(t);
      }
      finishMeasure(e) {
        this._endMeasurePoint = e;
        this._createMeasurePointset((0, n.ensureNotNull)(this._startMeasurePoint), this._endMeasurePoint);
      }
      clearMeasure() {
        this._removeMeasurePointset();
        this._measurePane.setValue(null);
        delete this._startMeasurePoint;
        delete this._endMeasurePoint;
        delete this._lastValidMeasurePoint;
        this._model.lightUpdate();
        if (this._volumeCalculator !== null) {
          this._volumeCalculator.destroy();
          this._volumeCalculator = null;
        }
      }
      measurePoints() {
        const e = [(0, n.ensureNotNull)(this._startMeasurePoint)];
        const t = this._lastMeasurePoint();
        if (t !== null) {
          e.push(t);
        }
        return e;
      }
      startSelection(e) {
        this._selectionStartPoint = this.currentLogicalPoint();
        this._selectionPane = e;
      }
      clearSelection() {
        this._selectionStartPoint = null;
        this._selectionPane = null;
      }
      selection() {
        if (this._selectionStartPoint) {
          return {
            p1: this._selectionStartPoint,
            p2: this.currentLogicalPoint()
          };
        } else {
          return null;
        }
      }
      currentLogicalPoint() {
        return {
          index: this.appliedIndex(),
          price: this.price
        };
      }
      selectPointMode() {
        return this._crossHairSelectPointMode;
      }
      lineColor() {
        return this._selectLineColor;
      }
      cancelRequestSelectPoint() {
        if (this._crossHairSelectPointMode.value() !== lt.SelectPointMode.None) {
          this._setSelectPointModeState(lt.SelectPointMode.None);
        }
        this._selectFromAllChartsIfOutOfData = null;
      }
      requestSelectPoint(e) {
        (0, n.assert)(this._crossHairSelectPointMode.value() === lt.SelectPointMode.None, "Point already requested");
        const {
          pointType: t,
          pane: i,
          lineColor: s = null,
          selectFromAllChartsIfOutOfData: o,
          selectPointMode: r = lt.SelectPointMode.Study
        } = e;
        if (i) {
          (0, n.assert)(this._model.panes().indexOf(i) !== -1, "Chartmodel doesn't contains specified pane");
          this._paneForRequestedPoint = i;
          this._model.panesCollectionChanged().subscribe(this, this._paneCollectionChanged);
        }
        this._selectLineColor = s;
        this._requestedPoint = t;
        this._selectFromAllChartsIfOutOfData = o ?? null;
        this._setSelectPointModeState(r);
      }
      onPointSelected() {
        return this._pointSelectedDelegate;
      }
      trySelectCurrentPoint() {
        const e = this.pane;
        if (!e) {
          return;
        }
        const t = (0, n.ensureNotNull)(this._requestedPoint);
        let i = null;
        if (!this._model.mainSeries().bars().search(this.index, Yh.PlotRowSearchMode.Exact) && t !== "price" && (this._selectFromAllChartsIfOutOfData && (i = Math.min(...Array.from(lt.barTimesUnderCursor.values())) ?? null), i === null)) {
          return;
        }
        if (this._paneForRequestedPoint && this._paneForRequestedPoint !== e) {
          return;
        }
        let s;
        let o = i;
        if (t === "price" || i !== null || (o = this._model.timeScale().indexToTimePoint(this.index), o !== null)) {
          if (t !== "time") {
            const t = e.mainDataSource();
            if (t === null) {
              return;
            }
            const i = t.firstValue();
            const o = t.priceScale();
            if (i === null || o === null) {
              return;
            }
            s = o.coordinateToPrice(this.y, i);
          }
          this._setSelectPointModeState(lt.SelectPointMode.None);
          this._pointSelectedDelegate.fire({
            time: o ?? undefined,
            price: s
          }, e);
        }
      }
      isOnHoveredChartWidget() {
        return this._isOnHoveredChartWidget;
      }
      setOnHoveredChartWidget(e) {
        this._isOnHoveredChartWidget = e;
      }
      isReplaySelection() {
        return false;
      }
      clearPosition() {
        this.visible = false;
        this.index = NaN;
        this.price = NaN;
        this.x = NaN;
        this.y = NaN;
        this.pane = null;
        this.clearOriginCoords();
        this._updateVisibilityDependentPaneViews();
      }
      setPosition(e, t, i) {
        if (!this._subscribed) {
          this._model.mainSeries().onRestarted().subscribe(this, this.clearMeasure);
          this._subscribed = true;
        }
        this.visible = true;
        const s = this._model.id();
        const o = this._model.mainSeries().bars().search(this.index, Yh.PlotRowSearchMode.NearestRight);
        if (o) {
          lt.barTimesUnderCursor.set(s, o.value[0]);
        }
        return this._tryToUpdateViews(e, t, i);
      }
      setLinesShouldBeHidden(e) {
        this._linesShouldBeHidden = e;
      }
      linesShouldBeHidden() {
        return this._linesShouldBeHidden;
      }
      handleContextMenuEvent(e) {
        if (this._crossHairSelectPointMode.value() !== lt.SelectPointMode.None) {
          this._setSelectPointModeState(lt.SelectPointMode.None);
        }
      }
      properties() {
        return this._properties;
      }
      priceAxisViews(e, t) {
        const i = this._requestedPoint === null || this._requestedPoint !== "time" || !this._isOnHoveredChartWidget;
        const s = [];
        if ((this.lockedPane() ?? this.pane) === e && i) {
          s.push(this._createPriceAxisViewOnDemand(this._priceAxisViews, this._panePriceAxisViews, e, t, this._currentPosPriceProvider, Bd, true)[0]);
        }
        if (this._startMeasurePoint) {
          s.push(this._createPriceAxisViewOnDemand(this._startMeasurePriceAxisViews, null, e, t, this._startMeasurePriceProvider, Vd)[0]);
        }
        if (this._lastMeasurePoint()) {
          s.push(this._createPriceAxisViewOnDemand(this._endMeasurePriceAxisViews, null, e, t, this._endMeasurePriceProvider, Vd)[0]);
        }
        return s;
      }
      timeAxisViews() {
        const e = [];
        const t = this._requestedPoint === null || this._requestedPoint !== "price" || !this._isOnHoveredChartWidget;
        if (!this._linesShouldBeHidden && (!!this.visible || lt.crosshairLock.value() !== null) && !!t) {
          e.push(this._timeAxisView);
        }
        if (this._startMeasurePoint) {
          e.push(this._startMeasureTimeAxisView);
        }
        if (this._lastMeasurePoint()) {
          e.push(this._endMeasureTimeAxisView);
        }
        return e;
      }
      paneViews(e) {
        if (e === undefined || e.mode() !== Bi.PaneMode.Regular) {
          return null;
        }
        const t = [];
        if (this.isReplaySelection()) {
          let i = this._pointSelectionPaneViewCache.get(e);
          if (!i) {
            i = new CrosshairPointSelectionPaneView(this, e, this._model);
            this._pointSelectionPaneViewCache.set(e, i);
          }
          t.push(i);
        }
        let i = this._crosshairPaneViewCache.get(e);
        if (!i) {
          i = new jd(this, e);
          this._crosshairPaneViewCache.set(e, i);
        }
        t.push(i);
        if (e === this._selectionPane) {
          t.push(this._selectionView);
        }
        if (e === this._measurePane.value()) {
          let i = this._measurePaneViewCache.get(e);
          if (!i) {
            i = new cu(this, e);
            this._measurePaneViewCache.set(e, i);
          }
          i.update((0, Bt.sourceChangeEvent)(this.id()));
          t.push(i);
        }
        if ((Od.addPlusButtonProperty.value() || this._showPlusButtonOnCursor.value()) && lt.crosshairLock.value()?.type !== 1) {
          const i = e === this.pane;
          const s = !ze.CheckMobile.any() || window.screen.width >= 320;
          const o = lt.tool.value();
          const n = (0, wt.isLineToolName)(o);
          const r = this._model.lineBeingEdited() !== null || this._model.lineBeingCreated() !== null || this._model.sourcesBeingMoved().length > 0 || this._model.customSourceBeingMoved() !== null || (0, lt.toolIsMeasure)(o);
          if (i && this._isOnHoveredChartWidget && this._crossHairSelectPointMode.value() === lt.SelectPointMode.None && s && !n && !r) {
            const i = e.mainDataSource();
            if (i !== null) {
              const s = i.priceScale();
              if (s !== null) {
                const i = this._createPriceAxisViewOnDemand(this._priceAxisViews, this._panePriceAxisViews, e, s, this._currentPosPriceProvider, Bd, true)[1];
                if (i !== null) {
                  t.push(i);
                }
              }
            }
          }
        }
        if (lt.crosshairLock.value()?.type === 0) {
          if (this._timeLockPaneView === null) {
            this._timeLockPaneView = new _u(this);
          }
          t.push(this._timeLockPaneView);
        }
        t.push(...this._crosshairDemonstration.paneViews(e));
        return t;
      }
      dataWindowView() {
        return this._dataWindowView;
      }
      updateAllViews(e) {
        this._priceAxisViews.forEach(t => {
          t.forEach(t => t.update(e));
        });
        this._panePriceAxisViews.forEach(t => {
          t.forEach(t => t.update(e));
        });
        if (this._startMeasurePoint) {
          this._startMeasurePriceAxisViews.forEach(t => {
            t.forEach(t => t.update(e));
          });
          this._startMeasureTimeAxisView.update(e);
        }
        if (this._lastMeasurePoint()) {
          this._endMeasurePriceAxisViews.forEach(t => {
            t.forEach(t => t.update(e));
          });
          this._endMeasureTimeAxisView.update(e);
        }
        this._timeAxisView.update(e);
        this._selectionView.update();
        this._dataWindowView.update();
        this._crosshairDemonstration.update(e);
        this._updateVisibilityDependentPaneViews();
      }
      isMenuEnabled() {
        return true;
      }
      isHoveredEnabled() {
        return Od.addPlusButtonProperty.value() || this._showPlusButtonOnCursor.value();
      }
      isHovered() {
        return this._model.hoveredSource() === this;
      }
      pointToSelect() {
        return this._requestedPoint;
      }
      paneForPointSelect() {
        return this._paneForRequestedPoint;
      }
      _lastMeasurePoint() {
        if (this._endMeasurePoint) {
          return this._endMeasurePoint;
        } else {
          if (this.pane !== null && this._measurePane.value() === this.pane) {
            this._lastValidMeasurePoint = {
              price: this._model.magnet().align(this.price, this.index, this.pane),
              index: this.index
            };
          }
          return this._lastValidMeasurePoint || null;
        }
      }
      _createPriceAxisViewOnDemand(e, t, i, s, o, r, a = false) {
        let l = e.get(i);
        let c = t !== null ? t.get(i) : undefined;
        if (l === undefined) {
          l = new Map();
          e.set(i, l);
          if (this.isMenuEnabled() && t !== null) {
            c = new Map();
            t.set(i, c);
          }
          if (a) {
            i.onDestroyed().subscribe(this, () => this._onPaneDestroyed(i));
          }
        }
        let h = l.get(s);
        if (h === undefined) {
          h = new r(this, i, s, o);
          l.set(s, h);
          if (c !== undefined) {
            const e = new Wd(h, this, s, this._model, this._options);
            c.set(s, e);
          }
          if (a) {
            s.lastSourceRemoved().subscribe(this, () => this._onPriceScaleCleared(s));
          }
        }
        let d = null;
        if (c !== undefined) {
          d = (0, n.ensureDefined)(c.get(s));
        }
        return [h, d];
      }
      _onPaneDestroyed(e) {
        e.onDestroyed().unsubscribeAll(this);
        this._priceAxisViews.delete(e);
        this._panePriceAxisViews.delete(e);
        this._startMeasurePriceAxisViews.delete(e);
        this._endMeasurePriceAxisViews.delete(e);
      }
      _onPriceScaleCleared(e) {
        e.lastSourceRemoved().unsubscribeAll(this);
        this._priceAxisViews.forEach(t => t.delete(e));
        this._panePriceAxisViews.forEach(t => t.delete(e));
        this._startMeasurePriceAxisViews.forEach(t => t.delete(e));
        this._endMeasurePriceAxisViews.forEach(t => t.delete(e));
      }
      _tryToUpdateViews(e, t, i) {
        return !!this._tryToUpdateData(e, t, i) && (this.updateAllViews((0, Bt.sourceChangeEvent)(this.id())), this._movedDelegate.fire({
          index: this.index,
          price: this.price
        }), true);
      }
      _tryToUpdateData(e, t, i) {
        const s = this.x;
        const o = this.y;
        const r = this.price;
        const a = this.index;
        const l = this.pane;
        const c = this._priceScaleByPane(i);
        this.index = e;
        this.x = isNaN(e) ? NaN : this._model.timeScale().indexToCoordinate(e);
        if (c !== null && i !== null) {
          this.pane = i;
          this.price = t;
          const e = (0, n.ensureNotNull)(i.mainDataSource()).firstValue();
          this.y = e === null ? NaN : c.priceToCoordinate(t, e);
        } else {
          this.pane = null;
          this.price = NaN;
          this.y = NaN;
        }
        return s !== this.x || o !== this.y || a !== this.index || r !== this.price || l !== this.pane;
      }
      _priceScaleByPane(e) {
        if (e && !e.defaultPriceScale().isEmpty()) {
          return e.defaultPriceScale();
        } else {
          return null;
        }
      }
      _setSelectPointModeState(e) {
        if (e === lt.SelectPointMode.None) {
          this._requestedPoint = null;
          this._selectLineColor = null;
          if (this._paneForRequestedPoint) {
            this._paneForRequestedPoint = null;
            this._model.panesCollectionChanged().unsubscribe(this, this._paneCollectionChanged);
          }
        }
        lt.activePointSelectionMode.setValue(e);
        this._crossHairSelectPointMode.setValue(e);
        this._model.lightUpdate();
      }
      _paneCollectionChanged(e) {
        const t = this._paneForRequestedPoint;
        if (t !== null && e.indexOf(t) === -1) {
          this.cancelRequestSelectPoint();
        }
      }
      _updateVisibilityDependentPaneViews() {
        for (const e of this.model().panes()) {
          this._pointSelectionPaneViewCache.get(e)?.update();
        }
      }
      _getLockData() {
        if (this._lockData === null) {
          const e = lt.crosshairLock.value();
          if (e === null) {
            this._lockData = {};
          } else {
            const t = this._model.timeScale();
            const i = t.points().roughIndex(e.time) ?? undefined;
            const s = i === undefined ? undefined : t.indexToCoordinate(i);
            switch (e.type) {
              case 0:
                this._lockData = {
                  index: i,
                  xCoord: s
                };
                break;
              case 1:
                {
                  let t;
                  const o = this.lockedPane();
                  if (o !== null) {
                    const i = o.mainDataSource();
                    if (i !== null) {
                      const s = i.firstValue();
                      const o = i.priceScale();
                      if (o !== null && s !== null) {
                        t = o.priceToCoordinate(e.price, s);
                      }
                    }
                  }
                  this._lockData = {
                    index: i,
                    xCoord: s,
                    yCoord: t
                  };
                }
            }
          }
        }
        return this._lockData;
      }
      _createMeasurePointset(e, t) {
        const i = this._normalizePoint(e);
        const s = this._normalizePoint(t);
        const o = [[i.time_t, i.offset], [s.time_t, s.offset]];
        this._removeMeasurePointset();
        ++Lu;
        this._currentMeasurePointsetAndSymbolId = {
          measurePointsetId: Lu,
          symbolId: (0, n.ensureNotNull)(this._model.mainSeries().seriesSource().symbolInstanceId())
        };
        const r = (0, yi.getServerInterval)(this._model.mainSeries().interval());
        this._model.chartApi().createPointset(this._currentMeasurePointsetIdWithPrefix(), "turnaround", this._currentMeasurePointsetAndSymbolId.symbolId, r, o, this._onPointsetResponse.bind(this));
      }
      _removeMeasurePointset() {
        if (this._currentMeasurePointsetAndSymbolId !== null && this._model.chartApi().isConnected().value()) {
          this._model.chartApi().removePointset(this._currentMeasurePointsetIdWithPrefix());
        }
        this._currentMeasurePointsetAndSymbolId = null;
      }
      _currentMeasurePointsetIdWithPrefix() {
        return "pointsetMeasure_" + (0, n.ensureNotNull)(this._currentMeasurePointsetAndSymbolId).measurePointsetId;
      }
      _normalizePoint(e) {
        return {
          ...this._model.timeScale().normalizeBarIndex(e.index),
          price: e.price
        };
      }
      _onPointsetResponse(e) {
        if (e.method === "pointset_error") {
          ku.logError(`Error getting pointset: ${e.params[0]} ${e.params[1]}`);
          return;
        }
        if (e.params.customId !== this._currentMeasurePointsetIdWithPrefix()) {
          return;
        }
        if (this._startMeasurePoint === null || this._endMeasurePoint === null) {
          return;
        }
        const t = e.params.plots;
        if (t.length !== 2) {
          return;
        }
        const i = t[0].value[0];
        const s = t[1].value[0];
        this._startMeasurePoint.index = i;
        this._endMeasurePoint.index = s;
        this.updateAllViews((0, Bt.sourceChangeEvent)(this.id()));
        this._model.updateSource(this);
      }
    }
    var Eu = i(63812);
    var Bu = i(20596);
    var Vu = i(94164);
    const Ru = (0, ae.getLogger)("Chart.ApplyPreferencesToAllCharts");
    const Nu = {
      color: "",
      style: 0
    };
    const Ou = {
      autoScale: false,
      autoScaleDisabled: false,
      lockScale: false,
      percentage: false,
      percentageDisabled: false,
      log: false,
      logDisabled: false,
      alignLabels: false,
      isInverted: false,
      indexedTo100: false
    };
    const Fu = {
      backgroundType: So.ColorType.Solid,
      background: "",
      backgroundGradientStartColor: "",
      backgroundGradientEndColor: "",
      topMargin: 0,
      bottomMargin: 0,
      gridLinesMode: "both",
      horzGridProperties: (0, ge.deepExtend)({}, Nu),
      vertGridProperties: (0, ge.deepExtend)({}, Nu),
      crossHairProperties: (0, ge.deepExtend)({}, {
        color: "",
        style: 0,
        transparency: 0,
        width: 0
      }),
      legendProperties: (0, ge.deepExtend)({}, {
        showStudyArguments: false,
        showStudyTitles: false,
        showStudyValues: false,
        showSeriesTitle: false,
        showSeriesOHLC: false,
        showLegend: false,
        showLastDayChange: false,
        showBarChange: true,
        showVolume: false,
        showPriceSource: false,
        showBackground: true,
        backgroundTransparency: 0,
        showLogo: true,
        showTradingButtons: true,
        showTradingButtonsMobile: true
      }),
      axisProperties: (0, ge.deepExtend)({}, Ou),
      separatorColor: ""
    };
    const Wu = {
      lineColor: "",
      textColor: "",
      fontSize: 0,
      scaleSeriesOnly: false,
      showSeriesLastValue: false,
      seriesLastValueMode: Vu.PriceAxisLastValueMode.LastValueAccordingToScale,
      showSeriesPrevCloseValue: false,
      showStudyLastValue: false,
      showSymbolLabels: false,
      showStudyPlotLabels: false,
      showBidAskLabels: false,
      showPrePostMarketPriceLabel: true,
      showFundamentalLastValue: false,
      showFundamentalNameLabel: false,
      showPriceScaleCrosshairLabel: true,
      showTimeScaleCrosshairLabel: true
    };
    const Hu = {
      ...Wu
    };
    const zu = {
      visible: false,
      futureOnly: false,
      breaks: (0, ge.deepExtend)({}, {
        color: "",
        visible: false,
        style: 0,
        width: 0
      })
    };
    const Uu = {
      style: 0,
      minTick: "",
      showPriceLine: false,
      priceLineWidth: 0,
      priceLineColor: "",
      baseLineColor: "",
      showPrevClosePriceLine: false,
      showCountdown: true,
      prevClosePriceLineWidth: 0,
      sessionId: "regular",
      prevClosePriceLineColor: "",
      esdShowDividends: false,
      esdShowSplits: false,
      esdShowEarnings: false,
      esdShowBreaks: false,
      showContinuousContractSwitches: false,
      showContinuousContractSwitchesBreaks: false,
      showFuturesContractExpiration: false,
      showLastNews: false,
      dividendsAdjustment: false,
      backAdjustment: false,
      settlementAsClose: true,
      statusViewStyle: (0, ge.deepExtend)({}, {
        fontSize: 16,
        showExchange: true,
        showInterval: true,
        symbolTextSource: "description"
      }),
      priceAxisProperties: (0, ge.deepExtend)({}, Ou),
      highLowAvgPrice: (0, ge.deepExtend)({}, {
        highLowPriceLinesVisible: false,
        highLowPriceLabelsVisible: false,
        averageClosePriceLabelVisible: false,
        averageClosePriceLineVisible: false,
        highLowPriceLinesColor: "",
        highLowPriceLinesWidth: 0,
        averagePriceLineColor: "",
        averagePriceLineWidth: 0
      }),
      candleStyle: (0, ge.deepExtend)({}, Bu.candleStylePreferencesDefault),
      hollowCandleStyle: (0, ge.deepExtend)({}, Bu.hollowCandlePreferencesStyleDefault),
      barStyle: (0, ge.deepExtend)({}, Bu.barStylePreferencesDefault),
      lineStyle: (0, ge.deepExtend)({}, Bu.lineStyleDefault),
      lineWithMarkersStyle: (0, ge.deepExtend)({}, Bu.lineStyleDefault),
      steplineStyle: (0, ge.deepExtend)({}, Bu.lineStyleDefault),
      areaStyle: (0, ge.deepExtend)({}, Bu.areaStylePreferencesDefault),
      hlcAreaStyle: (0, ge.deepExtend)({}, Bu.hlcAreaStylePreferencesDefault),
      baselineStyle: (0, ge.deepExtend)({}, Bu.baselineStylePreferencesDefault),
      hiloStyle: (0, ge.deepExtend)({}, Bu.hiloStylePreferencesDefault),
      haStyle: (0, ge.deepExtend)({}, Bu.haStylePreferencesDefault),
      renkoStyle: (0, ge.deepExtend)({}, Bu.renkoStylePreferencesDefault),
      pbStyle: (0, ge.deepExtend)({}, Bu.pbStylePreferencesDefault),
      kagiStyle: (0, ge.deepExtend)({}, Bu.kagiStylePreferencesDefault),
      pnfStyle: (0, ge.deepExtend)({}, Bu.pnfStylePreferencesDefault),
      rangeStyle: (0, ge.deepExtend)({}, Bu.rangeStylePreferencesDefault),
      columnStyle: (0, ge.deepExtend)({}, Bu.columnStylePreferencesDefault),
      hlcBarsStyle: (0, ge.deepExtend)({}, Bu.hlcBarsStylePreferencesDefault)
    };
    const ju = {
      priceScaleSelectionStrategyName: "auto",
      timeScale: (0, ge.deepExtend)({}, {
        defaultRightOffset: 0,
        defaultRightOffsetPercentage: 5,
        usePercentageRightOffset: false
      }),
      mainSeries: (0, ge.deepExtend)({}, Uu),
      sessions: (0, ge.deepExtend)({}, xc.sessionsPreferencesDefault),
      paneProperties: (0, ge.deepExtend)({}, Fu),
      chartEventsSourceProperties: (0, ge.deepExtend)({}, zu),
      tradingProperties: (0, ge.deepExtend)({}, Eo.tradingPreferencesDefault)
    };
    const Gu = {
      timezone: "",
      scalesProperties: (0, ge.deepExtend)({}, Hu),
      ...ju
    };
    const qu = {
      scalesProperties: (0, ge.deepExtend)({}, Wu),
      ...ju
    };
    function $u(e, t, i, s, o = true) {
      if (t[e] === undefined) {
        Ru.logDebug(`We haven't had this property ${s}.${e} yet, please, remove it from whiteList`);
        return null;
      }
      if ((0, dt.isObject)(i[e])) {
        const n = Object.keys(i[e]);
        let r = "";
        return n.map(n => ({
          [n]: $u(n, t[e], i[e], `${s}.${e}`, o)
        })).reduce((e, t) => {
          r = Object.keys(t)[0];
          e[r] = t[r];
          return e;
        }, {});
      }
      if (o) {
        return t[e].value();
      } else {
        return t[e];
      }
    }
    var Ku;
    var Yu = i(31229);
    var Zu = i(25149);
    (function (e) {
      e.StudyCannotBeChild = "cannot_be_child";
      e.StubWasRemoved = "stub_was_removed";
      e.CannotGetMetainfo = "cannot_get_metainfo";
      e.CannotCompilePub = "cannot_compile_pub";
      e.Cancelled = "cancelled";
      e.Unknown = "unknown";
    })(Ku ||= {});
    const Xu = (0, ae.getLogger)("Chart.Studies.StudyInserter");
    const Ju = /^PUB;.*/;
    class Qu {
      constructor(e, t) {
        this._parentSources = [];
        this._propsState = undefined;
        this._preferredPriceScale = undefined;
        this._allowChangeCurrency = false;
        this._allowChangeUnit = false;
        this._paneSize = undefined;
        this._forceOverlay = false;
        this._inserterImpl = t;
        this._studyDescriptor = e;
      }
      setParentSources(e) {
        this._parentSources = e;
      }
      setPaneSize(e) {
        this._paneSize = e;
      }
      setPreferredPriceScale(e) {
        this._preferredPriceScale = e;
      }
      setAllowChangeCurrency(e) {
        this._allowChangeCurrency = e;
      }
      setAllowChangeUnit(e) {
        this._allowChangeUnit = e;
      }
      setForceOverlay(e) {
        this._forceOverlay = e;
      }
      setPropertiesState(e) {
        this._propsState = e;
      }
      setTargetPriceScaleMode(e) {
        this._targetPriceScaleMode = e;
      }
      async insert(e, t, i) {
        let s = null;
        var o;
        if (!i) {
          s = (o = this._inserterImpl).createStub !== undefined && o.removeStub !== undefined ? this._inserterImpl.createStub() : null;
        }
        const n = (e, t) => {
          if (i) {
            const s = (0, et.default)(e) ? {
              error: e
            } : {
              error: e.message,
              editorError: e
            };
            i.setStatus({
              type: yh.StudyStatusType.Error,
              errorDescription: s
            });
            if (t) {
              i.setMetaInfo(t);
            }
            this._inserterImpl.storeFailedStub(i);
          }
        };
        let r;
        let a;
        let l = true;
        try {
          r = await (0, ts.studyMetaInfoRepository)().findById(this._studyDescriptor);
        } catch (e) {
          Xu.logWarn(`Cannot get study ${JSON.stringify(this._studyDescriptor)}`);
          const t = this._studyDescriptor.pineId;
          Ju.test(t);
          n("Error: cannot compile script");
          return Promise.reject(Ku.CannotGetMetainfo);
        } finally {
          if (s !== null) {
            l = this._inserterImpl.removeStub(s);
          }
        }
        if (!l) {
          return Promise.reject(Ku.StubWasRemoved);
        }
        if (t !== undefined && t.cancelled) {
          return Promise.reject(Ku.Cancelled);
        }
        if (!this._canApplyStudyToParent(r)) {
          n("Error: cannot be child");
          return Promise.reject(Ku.StudyCannotBeChild);
        }
        const c = {
          ...r.defaults.inputs
        };
        let d = {};
        if (e !== undefined) {
          const t = is.StudyMetaInfo.getStudyPropertyRootName(r);
          const i = (0, dt.clone)((0, h.defaults)(t));
          (0, dt.merge)(c, i.inputs);
          const s = await e(c, r.inputs, r);
          d = s.inputs;
          this._parentSources = s.parentSources ?? [];
        }
        if (t !== undefined && t.cancelled) {
          return Promise.reject(Ku.Cancelled);
        }
        const u = this._insertStudy(r, d, i);
        if (u === null) {
          n("Error: unknown error");
          return Promise.reject(Ku.Unknown);
        }
        await u.startPromise;
        const _ = await u.study;
        if (a) {
          return Promise.reject(a);
        } else {
          return _;
        }
      }
      _insertStudy(e, t, i) {
        return this._inserterImpl.createStudy(e, t, null, i, this._propsState, this._forceOverlay, this._parentSources, this._preferredPriceScale, this._allowChangeCurrency, this._allowChangeUnit, this._paneSize, this._targetPriceScaleMode);
      }
      _canApplyStudyToParent(e) {
        return this._parentSources.length === 0 || is.StudyMetaInfo.canBeChild(e);
      }
    }
    class e_ {
      constructor(e) {
        this._priceSourceNamesById = new Map();
        e.forEach(e => this._priceSourceNamesById.set(e.id, e.name));
      }
      name(e) {
        return this._priceSourceNamesById.get(e) ?? null;
      }
      priceSourcesChanged(e) {
        return e.length !== this._priceSourceNamesById.size;
      }
    }
    var t_ = i(84425);
    class i_ {
      constructor() {
        this._widgets = null;
        this._provider = null;
        this._watermarkProperties = Ec();
        const e = (0, n.ensureDefined)(this._watermarkProperties.child("color"));
        const t = (0, n.ensureDefined)(this._watermarkProperties.child("visibility"));
        this._colorWatchedValue = (0, ye.convertPropertyToWatchedValue)(e);
        this._visibilityWatchedValue = (0, ye.convertPropertyToWatchedValue)(t);
      }
      setWidgetCollection(e) {
        this._widgets = e;
      }
      setContentProvider(e) {
        this._provider = e;
        if (this._widgets) {
          this._widgets.getAll().forEach(e => {
            e.model().model().lightUpdate();
          });
        }
      }
      provider() {
        return this._provider;
      }
      ready() {
        return this._widgets !== null;
      }
      destroy() {
        this._colorWatchedValue.destroy();
        this._visibilityWatchedValue.destroy();
      }
      visibility() {
        return this._visibilityWatchedValue;
      }
      color() {
        return this._colorWatchedValue;
      }
      static getInstance() {
        if (this._instance === null) {
          this._instance = new i_();
        }
        return this._instance;
      }
    }
    i_._instance = null;
    const s_ = new Di.TranslatedString("remove deselected empty line tools", a.t(null, undefined, i(27171)));
    const o_ = l.enabled("auto_enable_symbol_labels");
    const n_ = l.enabled("saveload_separate_drawings_storage");
    const r_ = (0, ae.getLogger)("Chart.ChartModel");
    function a_(e, t) {
      const i = e.indexOf(t);
      return i !== -1 && (e.splice(i, 1), true);
    }
    function l_(e) {
      for (let t = e.length; t--;) {
        const i = e[t].dataSources();
        for (let e = i.length; e--;) {
          i[e].dataWindowView()?.update((0, Bt.sourceChangeEvent)(i[e].id()));
        }
        const s = e[t].priceDataSources();
        for (let e = s.length; e--;) {
          s[e].legendView()?.update((0, Bt.sourceChangeEvent)(i[e].id()));
        }
      }
    }
    const c_ = {
      isSnapshot: false,
      readOnly: false,
      watermarkEnabled: true,
      shiftVisibleRangeOnNewBar: true,
      currencyConversionEnabled: false,
      unitConversionEnabled: false,
      countdownEnabled: true,
      lastPriceAnimationEnabled: true,
      onWidget: false,
      hideIdeas: false
    };
    var h_;
    (function (e) {
      e[e.MnPaneHeight = 30] = "MnPaneHeight";
      e[e.RecalcVisibleRangeStudiesTimeout = 2000] = "RecalcVisibleRangeStudiesTimeout";
      e[e.RecalcVisibleRangeStudiesLargeTimeout = 5000] = "RecalcVisibleRangeStudiesLargeTimeout";
      e[e.RecalcVisibleRangeStudiesTimeoutLibrary = 500] = "RecalcVisibleRangeStudiesTimeoutLibrary";
      e[e.RecalcColorStudiesTimeout = 250] = "RecalcColorStudiesTimeout";
    })(h_ ||= {});
    const d_ = {
      throttle: o.default,
      debounce: cc.default
    };
    const u_ = new Map([[Eo.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction, {
      timeout: 500,
      adapter: "debounce"
    }], [Eo.RecalcVisibleRangeStudiesReason.DataUpdate, {
      timeout: 500,
      adapter: "throttle"
    }], [Eo.RecalcVisibleRangeStudiesReason.SeriesRestart, {
      timeout: 500,
      adapter: "debounce"
    }], [Eo.RecalcVisibleRangeStudiesReason.SeriesCompleted, {
      timeout: 500,
      adapter: "debounce"
    }], [Eo.RecalcVisibleRangeStudiesReason.StudyCreation, {
      timeout: 500,
      adapter: "debounce"
    }]]);
    const __ = Array.from(u_.values());
    class p_ {
      constructor(e, t, i, s, o, n, r, a, c, d, u) {
        this._onRearrangePanes = new re.Delegate();
        this._lineToolsGroupModel = new nd();
        this._sourcesBeingMoved = [];
        this._activeItemBeingMoved = null;
        this._lineBeingEdited = null;
        this._linePointBeingEdited = null;
        this._linePointBeingChanged = null;
        this._customSourceBeingMovedHitTestData = null;
        this._customSourceBeingMoved = null;
        this._dataSourceCollectionChanged = new re.Delegate();
        this._sourceProperitesChanged = new re.Delegate();
        this._sourceZOrderChanged = new re.Delegate();
        this._symbolSourceResolved = new re.Delegate();
        this._symbolSourceResolvingActive = new F.WatchedValue(false);
        this._adjustForDividendsAvailability = new F.WatchedValue(0);
        this._adjustForDividendsEnabled = new F.WatchedValue(false);
        this._currentTool = lt.tool.spawn();
        this._lineBeingCreated = null;
        this._paneBeingCreatedLineOn = null;
        this._lineCancelled = new re.Delegate();
        this._phantomSourceContainer = new Cd(this);
        this._destroyed = false;
        this._restoringState = false;
        this._isSettingsExternalPosition = false;
        this._isTimeScrolling = false;
        this._magnet = new xd();
        this._scrollingState = null;
        this._modelIntervals = [];
        this._rendererOptionsProvider = new Pc(this);
        this._studyInserted = new re.Delegate();
        this._cachedStudiesMaxOffset = 0;
        this._replayStatus = new F.WatchedValue(0);
        this._panes = [];
        this._maximizedPane = new F.WatchedValue(null);
        this._tagsChanged = new re.Delegate();
        this._strategySources = [];
        this._strategySourcesChange = new re.Delegate();
        this._activeStrategySource = new F.WatchedValue(null);
        this._symbolIntervalChanged = new re.Delegate();
        this._paneCollapsingAvailable = new F.WatchedValue(false);
        this._panesCollectionChanged = new re.Delegate();
        this._scrollEnabled = l.enabled("chart_scroll");
        this._zoomEnabled = l.enabled("chart_zoom");
        this._lollipopSourcesWatcher = null;
        this._alertsWatcher = null;
        this._hoveredSource = null;
        this._hoveredSourceChanged = new re.Delegate();
        this._lastHoveredHittestData = null;
        this._hoveredSourceOrigin = null;
        this._lastSelectedHittestData = null;
        this._topmostCustomSources = [];
        this._fgCustomSources = [];
        this._bgCustomSources = [];
        this._allCustomSources = [];
        this._customSourcesMap = new Map();
        this._dragExportEnabled = new F.WatchedValue(false);
        this._multiPaneSources = [];
        this._showLegendProperty = new Rs.Property();
        this._id = (0, fe.guid)();
        this._chartSaveTime = null;
        this._availableCurrenciesList = null;
        this._availableCurrencies = new Sd([]);
        this._availablePriceSources = new e_([]);
        this._availableUnitsObject = null;
        this._availableUnits = new bd({});
        this._availablePriceSourcesBySymbol = new Map();
        this._shouldBeSavedEvenIfHidden = false;
        this._watchedThemeSpawn = D.watchedTheme.spawn();
        this._backgroundColorAtYPercentFromTop = new yd.GradientColorCache();
        this._studiesWV = new ht.WatchedObject([], ft.compareTwoCollectionsByIds);
        this._studiesExcludeInternalWV = new ht.WatchedObject([], ft.compareTwoCollectionsByIds);
        this._resetScalesAvailable = new F.WatchedValue(false);
        this._recalcVRStudiesParams = {
          reasons: new Set()
        };
        this._recalcColorStudiesParams = {};
        this._replayStudyStrategy = new F.WatchedValue(null);
        this._studyColorRotatorFactory = new fc(this);
        this._mainSeriesScaleRatioProperty = new jc(this);
        this._recalcVisibleRangeStudiesImplDebouncedByAdapter = new Map(Object.keys(d_).map(e => [e, new Map(__.filter(t => t.adapter === e).map(e => [e.timeout, d_[e.adapter](this._recalcVisibleRangeStudiesImpl.bind(this, this._recalcVRStudiesParams), e.timeout)]))]));
        this._recalcColorStudiesImplDebounced = (0, cc.default)(this._recalcColorStudiesImpl.bind(this, this._recalcColorStudiesParams), 250);
        this._width = 0;
        this._resetScales = new re.Delegate();
        this._chartThemeLoaded = new re.Delegate();
        this._selection = new vc();
        this._selectedSourceChanged = new re.Delegate();
        this._symbolSourceCollectionChanged = new re.Delegate();
        this._gridSource = new Dd(this);
        this._visibleRangeStudiesInputs = new ht.WatchedObject(null);
        this._syncPointCache = new Map();
        this._lastAppliedGotoTimeRange = null;
        this._lastGotoTimeRange = null;
        this._lollipopSourcesWatcherLoader = null;
        this._sessions = null;
        this._onMultipaneSourcesCollectionChanged = new re.Delegate();
        this._replayStudyStrategyInputs = null;
        this._studyShiftColorStartOffset = undefined;
        this._clearSelection = () => {
          this._lastSelectedHittestData = null;
          this._selection.clear();
        };
        this._removeSourceFromSelection = e => {
          this._selection.remove(e);
        };
        this._addSourceToSelection = (e, t) => {
          const i = this._selection.isSelected(e);
          if ((!i || this._lastSelectedHittestData !== t) && (!e || !!e.isSelectionEnabled())) {
            this._lastSelectedHittestData = t || null;
            if (!i) {
              this._selection.add(e);
            }
          }
        };
        this._recalcSymbolResolvingActive = () => {
          for (const e of this._panes) {
            if (e.symbolSourceResolvingActive().value()) {
              this._symbolSourceResolvingActive.setValue(true);
              return;
            }
          }
          this._symbolSourceResolvingActive.setValue(false);
        };
        this._recalcAdjustForDividendsAvailability = () => {
          if (this._symbolSourceResolvingActive.value()) {
            return;
          }
          const e = this.mainSeries();
          switch (e.symbolInfo()?.allowed_adjustment ?? "none") {
            case "dividends":
              this._adjustForDividendsAvailability.setValue(2);
              return;
            case "splits":
              this._adjustForDividendsAvailability.setValue(1);
              return;
            case "any":
              this._adjustForDividendsAvailability.setValue(3);
              return;
          }
          for (const t of this.symbolSources().filter(Nr.isActingAsSymbolSource)) {
            if (t.symbolHibernated().value() || t === e) {
              continue;
            }
            if ((t.symbolInfo()?.allowed_adjustment ?? "none") === "any") {
              this._adjustForDividendsAvailability.setValue(3);
              return;
            }
          }
          this._adjustForDividendsAvailability.setValue(0);
        };
        this._recalcAdjustForDividendsEnabled = () => {
          switch (this._adjustForDividendsAvailability.value()) {
            case 2:
              this._adjustForDividendsEnabled.setValue(true);
              return;
            case 0:
            case 1:
              this._adjustForDividendsEnabled.setValue(false);
              return;
          }
          this._adjustForDividendsEnabled.setValue(this.mainSeries().properties().childs().dividendsAdjustment.value());
        };
        this._recalcPaneCollapsingAvailable = e => {
          let t = this._panes.filter(e => !e.collapsed().value()).length;
          if (t === 0 && e && this._panes.length > 0) {
            this._panes[0].collapsed().setValue(false);
            t = 1;
          }
          this._paneCollapsingAvailable.setValue(t > 1);
        };
        this._updateResetScalesAvailableValue = () => {
          const e = this._timeScale.resetAvailable().value() || this._panes.some(e => e.resetPriceScalesAvailable().value());
          this._resetScalesAvailable.setValue(e);
        };
        this._onDrawingsVisibilityChanged = e => {
          const t = !e.value();
          for (const e of this.dataSources()) {
            const i = (0, eo.isLineTool)(e) && e.properties().visible.value();
            if (t && i) {
              (0, W.emit)("drawing_event", e.id(), "show");
            } else if (!t && i) {
              (0, W.emit)("drawing_event", e.id(), "hide");
            }
          }
          this.selectionMacro(e => e.clearSelection());
        };
        this._onIndicatorsVisibilityChanged = () => {
          if (this.allStudies().some(e => e.canBeHiddenByGlobalFlag() && e.properties().childs().visible.value() && this.selection().isSelected(e))) {
            this.selectionMacro(e => e.clearSelection());
          } else {
            this.lightUpdate();
          }
        };
        this._chartSession = e;
        this._invalidateHandler = t;
        this._undoModel = n;
        this._properties = i;
        this._options = (0, dt.merge)((0, dt.clone)(c_), a);
        this._hibernateWV = c;
        this._linkingGroupIndex = d;
        this._isAutoSaveEnabled = u;
        this._readOnly = this._options.readOnly;
        this._isSnapshot = this._options.isSnapshot;
        this._chartSaveTime = new Date().valueOf();
        this._backgroundColor = new F.WatchedValue(this._getBackgroundColor());
        this._backgroundTopColor = new F.WatchedValue(this._getBackgroundColor(true));
        this._properties.childs().paneProperties.childs().background.subscribe(this, this._updateBackgroundColor);
        this._properties.childs().paneProperties.childs().backgroundType.subscribe(this, this._updateBackgroundColor);
        this._properties.childs().paneProperties.childs().backgroundGradientStartColor.subscribe(this, this._updateBackgroundColor);
        this._properties.childs().paneProperties.childs().backgroundGradientEndColor.subscribe(this, this._updateBackgroundColor);
        this._properties.childs().paneProperties.childs().legendProperties.childs().showLegend.subscribe(this, this._updateShowLegendProperty);
        this._properties.childs().scalesProperties.subscribe(this, this.fullUpdate);
        this._backgroundColor.subscribe(this.recalcColorStudies.bind(this, false));
        this._backgroundTopColor.subscribe(this.recalcColorStudies.bind(this, false));
        this._backgroundCounterColor = new F.WatchedValue(this._getBackgroundCounterColor());
        this._backgroundColor.subscribe(() => this._backgroundCounterColor.setValue(this._getBackgroundCounterColor()));
        this._backgroundTheme = (0, Ji.combine)(e => e === "white" ? oo.StdTheme.Dark : oo.StdTheme.Light, this._backgroundCounterColor.weakReference());
        this._isDark = (0, Ji.combine)(e => e === oo.StdTheme.Dark, this._backgroundTheme.weakReference());
        this._watchedThemeSpawn.subscribe(this._updateBackgroundColor.bind(this));
        this._symbolSourceResolvingActive.subscribe(this._recalcAdjustForDividendsAvailability);
        (0, lt.init)();
        const _ = this._readOnly ? new Rs.Property((0, dt.merge)((0, dt.clone)(xs.lightTheme.content.chartProperties.paneProperties.crossHairProperties), (0, h.defaults)("chartproperties.paneProperties.crossHairProperties"))) : this._properties.childs().paneProperties.childs().crossHairProperties;
        this._crossHairSource = new Du(this, _, this._options.crossHair);
        this._crossHairSelectPointMode = this._crossHairSource.selectPointMode().spawn();
        this._crossHairSelectPointMode.subscribe(e => {
          if (e !== lt.SelectPointMode.None && this.lineBeingCreated()) {
            const e = lt.tool.value();
            this.cancelCreatingLine();
            lt.tool.setValue(e);
          }
        });
        this._tagsChanged = new re.Delegate();
        this._timeScale = new id(this, this._options.timeScale);
        this._timeScale.resetAvailable().subscribe(this._updateResetScalesAvailableValue);
        const p = {
          countdownEnabled: this._options.countdownEnabled,
          lastPriceAnimationEnabled: this._options.lastPriceAnimationEnabled
        };
        this._mainSeries = new Gn.Series(this, s, p, o);
        this._appliedTimeFrame = new Id(this);
        this._mainSeries.onStyleChanged().subscribe(this._timeScale, this._timeScale.invalidateVisibleBars);
        const m = () => this.fullUpdate();
        this._mainSeries.properties().childs().showCountdown.subscribe(this, () => {
          this._mainSeries.updateAllViews((0, Bt.sourceChangeEvent)(this._mainSeries.id()));
          m();
        });
        (0, Be.currencyUnitVisibilityProperty)().subscribe(this, m);
        (0, on.autoLogButtonsVisibilityProperty)().subscribe(this, m);
        this._timeScale.visibleBarsStrictRangeChanged().subscribe(this._mainSeries, this._mainSeries.clearHighLowPriceCache);
        this._timeScale.visibleBarsStrictRangeChanged().subscribe(this._mainSeries, this._mainSeries.clearAveragePriceCache);
        this.createPane(undefined, {
          axisProperties: s.childs().priceAxisProperties.state(["autoScale"])
        });
        this._adjustForDividendsAvailability.subscribe(this._recalcAdjustForDividendsEnabled);
        this.mainSeries().properties().childs().dividendsAdjustment.subscribe(this, this._recalcAdjustForDividendsEnabled);
        this._recalcAdjustForDividendsEnabled();
        this._boundUpdateStudiesMaxOffset = this._updateStudiesMaxOffset.bind(this);
        this.mainSeries().dataEvents().seriesTimeFrame().subscribe(this, (e, t, i, s) => {
          if (this._lastAppliedGotoTimeRange !== null && i !== null && s && (0, kr.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, i)) {
            const e = this.appliedTimeFrame().value();
            if (e !== null && !this._lastAppliedGotoTimeRange.actual && (0, kr.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, e.val)) {
              this.appliedTimeFrame().setValue(null);
            }
            this._lastAppliedGotoTimeRange = null;
          }
        });
        this.mainSeries().dataEvents().completed().subscribe(this, e => {
          if (this._lastAppliedGotoTimeRange === null && this._lastGotoTimeRange !== null) {
            this.gotoTimeRange(this._lastGotoTimeRange.from, this._lastGotoTimeRange.to);
            this._lastGotoTimeRange = null;
          }
        });
        const g = this._panes[0];
        g.setStretchFactor(g.stretchFactor() * 2);
        this._properties.subscribe(this, this.lightUpdate);
        this._properties.childs().timezone.subscribe(null, () => {
          if (this._chartSession && this._chartSession.isConnected().value()) {
            this._chartSession.switchTimezone(this.timezone());
          }
        });
        g.addDataSource(this._mainSeries, g.findSuitableScale(this._mainSeries), false);
        this._barsMarksSources = r(this);
        for (const e of this._barsMarksSources) {
          e.setOwnerSource(this._mainSeries);
          g.addDataSource(e, this._mainSeries.priceScale(), true);
        }
        this._mainSeries.symbolResolved().subscribe(this, this._clearAvailablePriceSources);
        this._mainSeries.onSymbolIntervalChanged().subscribe(this, this._onSymbolIntervalChanged);
        this._createLollipopSourcesWatcher();
        this._watermarkSource = this._options.watermarkEnabled ? new Wc(this) : null;
        this._timezoneExceptExchange = (0, Ji.combine)((e, t) => e !== "exchange" ? e : t, (0, t_.createWVFromProperty)(this._properties.childs().timezone).ownership(), (0, t_.createWVFromGetterAndSubscription)(() => this.mainSeries().symbolInfo()?.timezone ?? null, this.mainSeries().symbolResolved()).ownership());
        this._updateDateTimeFormatter();
        this._mainSeries.dataEvents().completed().subscribe(this, () => {
          if (this._scrollingState) {
            this.gotoTime(undefined, {
              targetPointAlignment: this._scrollingState.targetPointAlignment,
              autoscaleAfterScroll: this._scrollingState.autoscaleAfterScroll
            });
          }
        });
        this._mainSeries.onIntervalChanged().subscribe(this, () => {
          this._recalcVRStudiesParams.oldStartVisibleIndex = NaN;
          this._recalcVRStudiesParams.oldEndVisibleIndex = NaN;
        });
        if (!this._readOnly) {
          this._mainSeries.properties().addChild("priceAxisProperties", this._mainSeries.priceScale().properties());
          const e = this._properties.childs().paneProperties.childs().legendProperties.childs();
          e.showStudyTitles.subscribe(this, t => {
            if (!t.value()) {
              e.showStudyArguments.setValue(false);
            }
          });
        }
        this._mainSeries.properties().childs().interval.subscribe(this, this._updateDateTimeFormatter);
        this._mainSeries.onTimeFrameApplied().subscribe(this, e => {
          const t = e ? {
            res: this._mainSeries.interval(),
            val: e
          } : null;
          this.appliedTimeFrame().setValue(t);
        });
        this._maximizedPane.subscribe(() => n.model().fullUpdate());
        this._dataSourceCollectionChanged.subscribe(this, this._updateShowLegendProperty);
        (0, lt.hideAllDrawings)().subscribe(this, this._onDrawingsVisibilityChanged);
        (0, lt.hideAllIndicators)().subscribe(this, this._onIndicatorsVisibilityChanged);
        be.dateFormatProperty.subscribe(this, this._updateDateTimeFormatter);
        we.timeHoursFormatProperty.subscribe(this, this._updateDateTimeFormatter);
        this._currentTool.subscribe(e => {
          if ((0, wt.isLineToolName)(e)) {
            this.selectionMacro(e => {
              e.clearSelection();
            });
          }
          if (!(0, Ro.isLineToolLoaded)(e) && (0, Ro.isAsyncGenericLineToolName)(e)) {
            (0, Ro.loadLineTool)(e).then(() => this._phantomSourceContainer.onToolChanged());
          } else {
            this._phantomSourceContainer.onToolChanged();
          }
        });
      }
      destroy() {
        this.clearIntervals();
        this.resetDeferredStudies();
        this.allStudies().forEach(e => this.removeSource(e));
        be.dateFormatProperty.unsubscribe(this, this._updateDateTimeFormatter);
        we.timeHoursFormatProperty.unsubscribe(this, this._updateDateTimeFormatter);
        (0, lt.hideAllIndicators)().unsubscribe(this, this._onIndicatorsVisibilityChanged);
        (0, lt.hideAllDrawings)().unsubscribe(this, this._onDrawingsVisibilityChanged);
        this._dataSourceCollectionChanged.unsubscribeAll(this);
        this._phantomSourceContainer.destroy();
        this._hoveredSourceChanged.destroy();
        if (this._watermarkSource !== null) {
          this._watermarkSource.destroy();
          this._watermarkSource = null;
        }
        Array.from(this._customSourcesMap.keys()).forEach(this._removeCustomSource, this);
        (0, n.assert)(this._topmostCustomSources.length === 0);
        (0, n.assert)(this._fgCustomSources.length === 0);
        (0, n.assert)(this._bgCustomSources.length === 0);
        (0, n.assert)(this._allCustomSources.length === 0);
        (0, n.assert)(this._customSourcesMap.size === 0);
        this._panes.forEach(e => e.destroy());
        this._panes.length = 0;
        this._sessions = null;
        if (this._lollipopSourcesWatcher !== null) {
          this._lollipopSourcesWatcher.destroy();
          this._lollipopSourcesWatcher = null;
        }
        if (this._alertsWatcher !== null) {
          this._alertsWatcher.destroy();
        }
        this._properties.childs().paneProperties.childs().legendProperties.childs().showLegend.unsubscribeAll(this);
        this._properties.childs().paneProperties.childs().background.unsubscribeAll(this);
        this._properties.childs().paneProperties.childs().backgroundType.unsubscribeAll(this);
        this._properties.childs().paneProperties.childs().backgroundGradientEndColor.unsubscribeAll(this);
        this._properties.childs().paneProperties.childs().backgroundGradientStartColor.unsubscribeAll(this);
        this._watchedThemeSpawn.destroy();
        this._lastHoveredHittestData = null;
        this._lastSelectedHittestData = null;
        (0, Be.currencyUnitVisibilityProperty)().unsubscribeAll(this);
        (0, on.autoLogButtonsVisibilityProperty)().unsubscribeAll(this);
        this._mainSeries.properties().childs().interval.unsubscribe(this, this._updateDateTimeFormatter);
        this._mainSeries.properties().childs().showCountdown.unsubscribeAll(this);
        this._crossHairSelectPointMode.destroy();
        this._mainSeries.onIntervalChanged().unsubscribeAll(this);
        this._mainSeries.onTimeFrameApplied().unsubscribeAll(this);
        this._mainSeries.symbolResolved().unsubscribe(this, this._clearAvailablePriceSources);
        this._mainSeries.onSymbolIntervalChanged().unsubscribe(this, this._onSymbolIntervalChanged);
        this._mainSeries.onStyleChanged().unsubscribe(this._timeScale, this._timeScale.invalidateVisibleBars);
        this._timeScale.visibleBarsStrictRangeChanged().unsubscribe(this._mainSeries, this._mainSeries.clearHighLowPriceCache);
        this._timeScale.visibleBarsStrictRangeChanged().unsubscribe(this._mainSeries, this._mainSeries.clearAveragePriceCache);
        this._timeScale.barSpacingChanged().unsubscribeAll(this);
        this._timeScale.onScroll().unsubscribeAll(this);
        this._timeScale.destroy();
        this._timezoneExceptExchange.destroy();
        this._lollipopSourcesWatcherLoader?.destroy();
        this._appliedTimeFrame.destroy();
        this._crossHairSource.destroy();
        this._currentTool.destroy();
        this._destroyed = true;
      }
      restart() {
        this._chartSession.switchTimezone(this.timezone());
        this._timeScale.reset();
        this._mainSeries.restart();
        for (const e of this.dataSources()) {
          if (e.restart && e !== this._mainSeries) {
            e.restart();
          }
        }
        this._sessions?.get()?.restart();
      }
      version() {
        return 3;
      }
      collapsed() {
        return this._hibernateWV;
      }
      visibleRangeStudiesInputs() {
        return this._visibleRangeStudiesInputs.readonly();
      }
      chartSaveTime() {
        return this._chartSaveTime;
      }
      setChartSaveTime(e) {
        this._chartSaveTime = e;
      }
      startNotStartedStudies() {
        if (!this._mainSeries.isStarted()) {
          throw new Error("Cannot start studies: main series is not started");
        }
        for (const e of this.dataSources()) {
          if ((0, Js.isStudy)(e) && !e.isStarted()) {
            e.restart?.();
          }
        }
      }
      undoModel() {
        return this._undoModel;
      }
      onData(e) {
        switch (e.method) {
          case "timescale_update":
            {
              const t = e.params;
              this._updateTimeScale({
                index: t.index,
                zoffset: t.zoffset,
                values: t.changes,
                indexDiffs: t.index_diff,
                baseIndex: t.baseIndex,
                marks: t.marks,
                clearFlag: t.clear
              });
              break;
            }
          case "timescale_completed":
            {
              const t = Boolean(e.params[0]);
              this._timeScale.onTimeScaleCompleted(t);
              break;
            }
        }
      }
      addStrategySource(e, t) {
        if (t !== 1 && this._strategySources.indexOf(e) === -1) {
          this._strategySources.push(e);
          this._strategySourcesChange.fire(t);
          this.setActiveStrategySource(e);
        }
      }
      removeStrategySource(e, t) {
        if (t === 1) {
          return;
        }
        const i = this._strategySources.indexOf(e);
        if (i !== -1) {
          if (this._strategySources.splice(i, 1)[0] === this._activeStrategySource.value()) {
            this.unsetActiveStrategySource();
          }
          if (this._strategySources.length > 0) {
            const e = this._strategySources[this._strategySources.length - 1];
            this.setActiveStrategySource(e);
          }
          this._strategySourcesChange.fire(t);
        }
      }
      setActiveStrategySource(e) {
        if (this._strategySources.indexOf(e) !== -1) {
          this._activeStrategySource.setValue(e);
        }
      }
      unsetActiveStrategySource() {
        this._activeStrategySource.setValue(null);
      }
      activeStrategySource() {
        return this._activeStrategySource;
      }
      strategySources() {
        return this._strategySources;
      }
      strategySourcesChange() {
        return this._strategySourcesChange;
      }
      replayStudyStrategy() {
        return this._replayStudyStrategy;
      }
      setReplayStudyStrategy(e) {
        this._replayStudyStrategy.setValue(e);
      }
      async replayStudyStrategyProperties() {
        if (this._replayStudyStrategyInputs === null) {
          const e = await getReplayStrategyMetaInfo();
          if (this._replayStudyStrategyInputs !== null) {
            return this._replayStudyStrategyInputs;
          }
          this._replayStudyStrategyInputs = new li.DefaultProperty({
            defaultName: "replayStudyStrategyInputs",
            factoryDefaultsSupplier: () => (0, dt.clone)(e.defaults.inputs)
          });
        }
        return this._replayStudyStrategyInputs;
      }
      clearReplayStudyStrategyProperties() {
        this._replayStudyStrategyInputs = null;
      }
      setScrollEnabled(e) {
        this._scrollEnabled = e;
      }
      scrollEnabled() {
        return this._scrollEnabled;
      }
      setZoomEnabled(e) {
        this._zoomEnabled = e;
      }
      zoomEnabled() {
        return this._zoomEnabled;
      }
      dragExportEnabled() {
        return this._dragExportEnabled;
      }
      async setDragExportEnabled(e) {
        if (l.enabled("charting_library_export_chart_data")) {
          await async function () {
            if (qn === null) {
              const e = await i.e(9498).then(i.bind(i, 99992));
              qn = e;
            }
          }();
          this._dragExportEnabled.setValue(e);
        } else {
          console.error("feature is not enabled");
        }
      }
      zoomToViewport(e, t, i, s, o) {
        this.setTimeViewport(e, t);
        let n = Math.min(i, s);
        let r = Math.max(i, s);
        const a = o.defaultPriceScale();
        if (!a.isPercentage()) {
          a.setMode({
            autoScale: false
          });
        }
        if (a.isLog()) {
          n = a.priceToLogical(n);
          r = a.priceToLogical(r);
        }
        a.setPriceRange(new th.PriceRange(n, r));
        this.recalculateAllPanes((0, Bt.viewportChangeEvent)());
        this.invalidate(this._paneInvalidationMask(o, yo.InvalidationLevel.Light));
      }
      setTimeViewport(e, t) {
        const i = this.appliedTimeFrame().value();
        if (this._lastAppliedGotoTimeRange === null || i === null || !(0, kr.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, i.val) || !!this._lastAppliedGotoTimeRange.actual) {
          this.timeScale().zoomToBarsRange(e, t);
          this.recalculateAllPanes((0, Bt.viewportChangeEvent)());
          this.recalcVisibleRangeStudies(Eo.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction);
          this.lightUpdate();
        }
      }
      onTagsChanged() {
        return this._tagsChanged;
      }
      canZoomIn() {
        return this._timeScale.canZoomIn() && this._zoomEnabled;
      }
      canZoomOut() {
        return this._timeScale.canZoomOut() && this._zoomEnabled;
      }
      onPaneTagsChanged() {
        this._tagsChanged.fire();
      }
      panesCollectionChanged() {
        return this._panesCollectionChanged;
      }
      dataSourceCollectionChanged() {
        return this._dataSourceCollectionChanged;
      }
      symbolSourceCollectionChanged() {
        return this._symbolSourceCollectionChanged;
      }
      symbolSourceResolved() {
        return this._symbolSourceResolved;
      }
      symbolSourceResolvingActive() {
        return this._symbolSourceResolvingActive;
      }
      adjustForDividendsAvailability() {
        return this._adjustForDividendsAvailability;
      }
      adjustForDividendsEnabled() {
        return this._adjustForDividendsEnabled;
      }
      paneCollapsingAvailable() {
        return this._paneCollapsingAvailable;
      }
      sourcePropertiesChanged() {
        return this._sourceProperitesChanged;
      }
      sourceZOrderChanged() {
        return this._sourceZOrderChanged;
      }
      zoomTime(e, t, i) {
        if (!this._zoomEnabled) {
          return;
        }
        const s = this.timeScale();
        if (s.isEmpty() || t === 0) {
          return;
        }
        const o = s.width();
        e = Math.max(1, Math.min(e, o - 2));
        s.zoom(e, t, i);
        this.recalculateAllPanes((0, Bt.viewportChangeEvent)());
        this.lightUpdate();
        this.recalcVisibleRangeStudies(Eo.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction);
      }
      lineBeingEdited() {
        return this._lineBeingEdited;
      }
      linePointBeingEdited() {
        return this._linePointBeingEdited;
      }
      activeItemBeingMoved() {
        return this._activeItemBeingMoved;
      }
      linePointBeingChanged() {
        return this._linePointBeingChanged;
      }
      mainSeries() {
        return this._mainSeries;
      }
      updateAllPaneViews(e) {
        for (const t of this._panes) {
          t.updateAllViews(e);
        }
        this._watermarkSource?.updateAllViews(e);
      }
      dataSources() {
        const e = [this.crosshairSource()];
        for (const t of this._panes) {
          for (const i of t.dataSources()) {
            e.push(i);
          }
        }
        return e;
      }
      priceDataSources() {
        const e = [];
        for (const t of this._panes) {
          for (const i of t.priceDataSources()) {
            e.push(i);
          }
        }
        return e;
      }
      symbolSources() {
        const e = [];
        for (const t of this._panes) {
          for (const i of t.symbolSources()) {
            e.push(i);
          }
        }
        return e;
      }
      orderedDataSources(e) {
        let t = [this._crossHairSource];
        for (let i = 0; i < this._panes.length; i++) {
          let s = this._panes[i].sourcesByGroup().all();
          if (e) {
            s = s.slice().reverse();
          }
          t = t.concat(s);
        }
        return t;
      }
      lineToolByLinkKey(e) {
        for (const t of this._panes) {
          const i = t.lineToolByLinkKey(e);
          if (i) {
            return i;
          }
        }
        return null;
      }
      timeScale() {
        return this._timeScale;
      }
      selection() {
        return this._selection;
      }
      selectionMacro(e, t = false) {
        const i = this.selection().allSources();
        e({
          removeSourceFromSelection: this._removeSourceFromSelection,
          addSourceToSelection: this._addSourceToSelection,
          clearSelection: this._clearSelection,
          selection: this.selection.bind(this)
        });
        const s = (0, ft.subtract)(i, this.selection().allSources());
        const o = (0, ft.subtract)(this.selection().allSources(), i);
        o.concat(i).forEach(e => e.updateAllViews((0, Bt.selectionChangeEvent)()));
        let n = [];
        s.forEach(e => {
          if ((0, eo.isLineTool)(e)) {
            const i = e.hasAlert().value() && e.getAlertSync();
            if (i && !i.isPrice()) {
              i.setSelected(false);
            }
            if (!t && e.shouldBeRemovedOnDeselect()) {
              n.push(e);
            }
          }
        });
        o.forEach(e => {
          const t = (0, eo.isLineTool)(e) && e.hasAlert && e.hasAlert().value() && e.getAlertSync();
          if (t) {
            t.setSelected(true);
          }
        });
        if (o.length === 1) {
          const [e] = o;
          if ((0, eo.isLineTool)(e) && e.hasAlert().value() && e.alertStatus().value() === 0) {
            e.synchronizeAlert().catch(() => { });
          }
        }
        n = n.filter(e => this.dataSourceForId(e.id()) !== null);
        if (n.length > 0) {
          this._undoModel.removeSources(n, false, s_);
        }
        this.lightUpdate();
        if (s.length > 0 || o.length > 0) {
          this._selectedSourceChanged.fire();
        }
      }
      onSelectedSourceChanged() {
        return this._selectedSourceChanged;
      }
      checkLineToolSelection() {
        const e = this.selection().allSources();
        this._selection.checkLineToolSelection();
        if (e.length !== this.selection().allSources().length) {
          this._selectedSourceChanged.fire();
        }
      }
      lineToolsGroupModel() {
        return this._lineToolsGroupModel;
      }
      restoreLineToolsGroups(e) {
        this._lineToolsGroupModel = nd.fromState(this, e);
      }
      realignLineTools(e) {
        for (const t of this._panes) {
          if ((e === undefined || t.hasDataSource(e)) && t.realignLineTools(e)) {
            this._dataSourceCollectionChanged.fire(t);
          }
        }
      }
      copyToOtherCharts(e, t) {
        const i = this.mainSeries();
        const s = i.syncModel();
        const o = this.timeScale();
        if (s) {
          for (const r of e) {
            if (!r.isSynchronizable()) {
              continue;
            }
            const e = r.linkKey().value() || (0, fe.randomHash)();
            r.linkKey().setValue(e);
            const a = r.state(false);
            const l = r.normalizedPoints();
            const c = r.normalizedPointsForCreating();
            const h = r.properties().interval.value();
            const d = i.interval();
            const u = e => {
              if (Re.Interval.isEqual(h, d)) {
                return e.map(e => {
                  const t = (0, n.ensureNotNull)(o.timePointToIndex(e.time_t)) + e.offset;
                  return {
                    price: e.price,
                    timeStamp: (0, n.ensureNotNull)(this.externalTimeStamp(t))
                  };
                });
              }
              {
                const t = s.createNewModelWithResolution(h);
                return e.map(e => ({
                  price: e.price,
                  timeStamp: e.offset === 0 ? e.time_t : t.projectTime(e.time_t, e.offset)
                }));
              }
            };
            const _ = u(l);
            const p = u(c);
            const m = {
              ...a,
              id: r.id(),
              linkKey: e,
              points: _,
              pointsForCreating: p,
              linetool: r.toolname,
              model: this,
              symbol: i.symbol(),
              withUndo: t,
              zOrder: r.zorder(),
              finalState: {
                points: l,
                interval: h
              },
              pointPositionPercents: r.isFixed() ? r.calcPositionPercents() : undefined,
              sharingMode: r.sharingMode().value()
            };
            (0, lt.copyLineTool)(m);
          }
        }
      }
      isSnapshot() {
        return this._isSnapshot;
      }
      onWidget() {
        return this._options.onWidget;
      }
      hideIdeas() {
        return this._options.hideIdeas;
      }
      updateSource(e) {
        const t = this._invalidationMaskForSource(e);
        if (t !== null) {
          this.invalidate(t);
        }
      }
      updateSourcePriceScale(e) {
        const t = this._invalidationMaskForSourcePriceScale(e);
        if (t !== null) {
          this.invalidate(t);
        }
      }
      updatePane(e) {
        this.invalidate(this._paneInvalidationMask(e));
      }
      updateTimeScaleBaseIndex(e) {
        const t = this.mainSeries().bars();
        if (!t.isEmpty()) {
          this._updateBaseIndex((0, n.ensureNotNull)(t.lastIndex()), !!e && !!(e.index > 0));
        }
      }
      setInterval(e, t) {
        const i = setInterval(e, t);
        this._modelIntervals.push(i);
        return i;
      }
      clearInterval(e) {
        clearInterval(e);
        const t = this._modelIntervals.indexOf(e);
        if (t > -1) {
          this._modelIntervals.splice(t, 1);
        }
      }
      clearIntervals() {
        for (let e = 0; e < this._modelIntervals.length; e++) {
          clearInterval(this._modelIntervals[e]);
        }
        this._modelIntervals = [];
      }
      createStudyInserter(e) {
        return new Qu(e, {
          createStudy: (e, t, i, s, o, n, r, a, l, c, h, d, u) => this.insertStudyWithParams(e, t, i, o, n, r, a, l, c, h, d, u),
          storeFailedStub: e => { }
        });
      }
      insertStudyWithParams(e, t, i, s, o, r, a, l, c, h, u, _) {
        let p = null;
        if (!o && e.groupingKey !== undefined) {
          const t = this.findNonOverlayStudyWithGroupingKey(e.groupingKey);
          if (t !== null) {
            p = t.pane;
          }
        }
        if (p === null) {
          if (o || e.is_price_study) {
            p = (0, n.ensureNotNull)(this.paneForSource(r?.[0] ?? this._mainSeries));
          } else {
            p = this.createPane();
            if (h !== undefined) {
              p.setPaneSize(h);
            }
          }
        }
        if (e.id === "Compare@tv-basicstudies") {
          this._mainSeries.priceScale().setMode({
            log: false,
            percentage: true
          });
        }
        const m = (0, dt.merge)((0, hc.default)(s ?? {}), {
          inputs: t,
          parentSources: []
        });
        let g = false;
        let f = null;
        let y = null;
        const v = r ?? [];
        const S = (0, Cc.prepareStudyProperties)(e, m, p, (0, ts.studyMetaInfoRepository)().studyVersioning(), v);
        const b = (0, Js.createStudy)(this, S, v, e, _);
        const w = (0, me.createDeferredPromise)();
        b.then(e => {
          if (g) {
            e.stop();
            e.destroy?.();
            return;
          }
          f = e.id();
          const t = p.findSuitableScale(e, r?.[0] ?? this.mainSeries(), a);
          y = t.mode();
          if (t === this.mainSeries().priceScale() && (0, Nr.isSymbolSource)(e)) {
            const i = l ? Or(e, t, this, true) : null;
            const s = c ? oh(e, t, this, true) : null;
            if (i !== null || s !== null) {
              e.setSymbolParams({
                currency: i || undefined,
                unit: s || undefined
              });
            }
          }
          if ((0, Nr.isSymbolSource)(e) && (0, n.ensureNotNull)(p).hasDataSource(this.mainSeries()) && o_ && !d.getBool("enable_symbol_labels_on_inserting_compare_once", false)) {
            (0, li.allowSavingDefaults)(true);
            this.properties().childs().scalesProperties.childs().showSymbolLabels.setValue(true);
            (0, li.allowSavingDefaults)(false);
            d.setValue("enable_symbol_labels_on_inserting_compare_once", true);
          }
          w.resolve(e.start());
          if (i && p.id() === i.paneId) {
            p.insertDataSource(e, t, i.zorder);
          } else {
            p.addDataSource(e, t, false);
            if (e.preferredZOrder() !== null) {
              p.insertAfter([e], this.mainSeries());
            }
          }
          if (u !== undefined) {
            t.setMode(u);
          }
          if (e.isLinkedToSeries()) {
            e.setOwnerSource(this.mainSeries());
          }
          this.recalculatePane(p, (0, Bt.sourceChangeEvent)(e.id()));
          this.fullUpdate();
          this._invalidateBarColorerCaches();
          this._recalcVisibleRangeStudiesImpl({
            studies: [e],
            reasons: new Set([Eo.RecalcVisibleRangeStudiesReason.StudyCreation])
          });
          this._recalcColorStudiesImpl({
            studies: [e],
            force: true
          });
          this._studyInserted.fire(e);
          e.maxOffset().subscribe(this._boundUpdateStudiesMaxOffset, {
            callWithLast: true
          });
        });
        return {
          study: b,
          startPromise: w.promise,
          cancel: () => g = true,
          entityId: () => f,
          originalScaleMode: () => y
        };
      }
      replaceStudyStub(e, t) {
        const i = this.paneForSource(e);
        if (i === null) {
          return false;
        }
        const s = e.priceScale();
        const o = e.zorder();
        const n = e.ownerSource();
        if (this.paneForSource(e) === i) {
          i.replaceSource(e, t, s);
        } else {
          i.insertDataSource(t, s, o);
          this.removeSource(e);
        }
        t.setOwnerSource(n);
        this.dataSources().forEach(i => {
          if (i.ownerSource() === e) {
            i.setOwnerSource(t);
          }
        });
        this._invalidateBarColorerCaches();
        t.start();
        this.recalculatePane(i, (0, Bt.sourceChangeEvent)(t.id()));
        this.fullUpdate();
        return true;
      }
      insertStudyStub(e, t, i, s) {
        const o = t !== undefined;
        const r = new wc.StudyStub(this, i ?? null, e, t, s ?? null);
        let a;
        if (t || !o) {
          a = (0, n.ensureNotNull)(this.mainPane());
          const e = t === true ? this.mainSeries().priceScale() : a.createPriceScaleAtPosition("overlay");
          a.addDataSource(r, e, false);
        } else {
          a = this.createPane();
          a.addDataSource(r, null, false);
        }
        r.setZorder(a.newStudyZOrder());
        this.recalculatePane(a, (0, Bt.sourceChangeEvent)(r.id()));
        this.fullUpdate();
        return r;
      }
      removeStudyStub(e) {
        const t = this.dataSourceForId(e);
        if (t === null) {
          r_.logNormal("StudyStub id=" + e + " is not found in chart model");
          return false;
        } else {
          this.removeSource(t);
          return true;
        }
      }
      restoreStudyStub(e) {
        const t = this.insertStudyStub(e.title, e.isOverlay, e.descriptor);
        this.paneForSource(t)?.changeSourceId(t, e.id);
        t.setStatus(e.status);
        return t;
      }
      bulkActionMacro(e) {
        const t = this._panes;
        t.forEach(e => e.beginBulkAction());
        e();
        t.forEach(e => e.endBulkAction());
      }
      allLineTools() {
        return this._getAllSources(eo.isLineTool);
      }
      setHoveredSource(e, t = null, i) {
        const s = this._hoveredSource !== e;
        this._hoveredSourceOrigin = i ?? null;
        if (!!s || !(0, Vt.hitTestResultDataAreEqual)(this._lastHoveredHittestData, t)) {
          this._lastHoveredHittestData = t;
          if (this._hoveredSource) {
            this._hoveredSource.updateAllViews((0, Bt.hoverChangeEvent)());
            this.updateSource(this._hoveredSource);
          }
          this._hoveredSource = e;
          if (this._hoveredSource) {
            this._hoveredSource.updateAllViews((0, Bt.hoverChangeEvent)());
            this.updateSource(this._hoveredSource);
          }
          if (s) {
            this._hoveredSourceChanged.fire(e);
          }
        }
      }
      properties() {
        return this._properties;
      }
      chartApi() {
        return this._chartSession;
      }
      disconnect() {
        this._sessions?.get()?.stop();
        for (const e of this.dataSources()) {
          if (e.disconnect) {
            e.disconnect();
          }
        }
        this._timeScale.disconnect();
      }
      crosshairSource() {
        return this._crossHairSource;
      }
      gridSource() {
        return this._gridSource;
      }
      publishedChartsTimelineSource() {
        return null;
      }
      hoveredSource() {
        return this._hoveredSource;
      }
      hoveredSourceOrigin() {
        return this._hoveredSourceOrigin;
      }
      hoveredSourceChanged() {
        return this._hoveredSourceChanged;
      }
      lastHittestData() {
        return this._lastHoveredHittestData;
      }
      lastSelectedHittestData() {
        return this._lastSelectedHittestData;
      }
      lightUpdate() {
        this.invalidate(yo.InvalidationMask.light());
      }
      fullUpdate() {
        this.invalidate(yo.InvalidationMask.full());
      }
      async syncTimeWithModel(e, t, i) {
        const s = this.mainSeries().syncModel();
        if (s === null) {
          return;
        }
        const o = this.createSyncPoint(e, s.syncSourceTarget()).sourceTimeToTargetTime(t / 1000) * 1000;
        const r = (0, Ce.get_timezone)((0, n.ensureNotNull)(this.timezoneExceptExchange().value()));
        let a = (0, Ce.utc_to_cal)(r, o);
        if (this.mainSeries().isDWM()) {
          a = s.getSession().spec.correctTradingDay(a);
          (0, Ce.set_hms)(a, 0, 0, 0, 0, (0, Ce.get_timezone)("Etc/UTC"));
        }
        return this._gotoTimeImpl(a.getTime(), {
          targetPointAlignment: "center",
          alignIfTargetPointIsVisible: false,
          autoscaleAfterScroll: false,
          ...i
        }).catch(() => { });
      }
      gotoTime(e, t) {
        return this._gotoTimeImpl(e, {
          targetPointAlignment: "center",
          alignIfTargetPointIsVisible: true,
          autoscaleAfterScroll: true,
          ...t
        }).catch(() => { });
      }
      recalculatePane(e, t) {
        e?.recalculate(t);
      }
      recalculateAllPanes(e) {
        this._panes.forEach(t => t.recalculate(e));
        this.updateAllPaneViews(e);
        this.crosshairSource().updateAllViews(e);
      }
      gotoTimeRange(e, t) {
        const i = this.timeScale();
        const s = i.tickMarks();
        const o = this.mainSeries();
        if (s.minIndex === undefined) {
          this._lastGotoTimeRange = {
            from: e,
            to: t
          };
          return;
        }
        let r = e;
        let a = t;
        if (o.symbolInfo() !== null) {
          const i = (0, n.ensureNotNull)(this.timezoneExceptExchange().value());
          const s = (0, Ce.get_timezone)(i);
          const l = (0, Ce.utc_to_cal)(s, e);
          const c = (0, Ce.utc_to_cal)(s, t);
          if (o.isDWM()) {
            const e = (0, Ce.get_timezone)("Etc/UTC");
            (0, Ce.set_hms)(l, 0, 0, 0, 0, e);
            (0, Ce.set_hms)(c, 0, 0, 0, 0, e);
          }
          r = l.getTime();
          a = c.getTime();
        }
        const l = (0, n.ensureDefined)(s.maxIndex);
        const c = (0, n.ensureDefined)(s.minIndex);
        if (r >= (0, n.ensureNotNull)(s.indexToTime(c)).valueOf() || o.endOfData()) {
          const e = (e, t) => e < t;
          const t = e => (0, n.ensureNotNull)(s.indexToTime(e)).valueOf();
          const h = (0, ft.lowerboundExt)(t, r, e, s.nearestIndex(r), l);
          let d = r === a ? h : (0, ft.lowerboundExt)(t, a, e, s.nearestIndex(a), l);
          this._lastGotoTimeRange = null;
          if (this._lastAppliedGotoTimeRange !== null) {
            this._lastAppliedGotoTimeRange.actual = false;
          }
          const u = i.baseIndex();
          if (h + Math.max(d - h + 1, i.minVisibleBarCount()) > u) {
            const e = i.targetDefaultRightOffset();
            if (d - u < e) {
              d = u + e;
            }
          }
          const _ = h === d && h === c && o.endOfData() ? h - 1 : h;
          i.zoomToBarsRange(_, d);
          this.updateAllPaneViews((0, Bt.viewportChangeEvent)());
          this.lightUpdate();
        } else {
          const i = {
            type: "time-range",
            from: e / 1000,
            to: t / 1000
          };
          if (this._lastAppliedGotoTimeRange === null) {
            this._lastAppliedGotoTimeRange = {
              range: i,
              actual: true
            };
            o.loadDataTo(i);
          } else if (!(0, kr.areEqualTimeFrames)(this._lastAppliedGotoTimeRange.range, i)) {
            this._lastGotoTimeRange = {
              from: e,
              to: t
            };
          }
        }
      }
      paneForSource(e) {
        if (!(0, Vo.isDataSource)(e)) {
          if (Array.from(this._customSourcesMap.values()).includes(e)) {
            return this.paneForSource(this.mainSeries());
          } else {
            return null;
          }
        }
        for (let t = this._panes.length - 1; t >= 0; t--) {
          if (this._panes[t].hasDataSource(e)) {
            return this._panes[t];
          }
        }
        if (e instanceof mi) {
          return this.paneForSource(this.mainSeries());
        } else {
          return null;
        }
      }
      mainPane() {
        return this._panes.find(e => e.isMainPane().value()) ?? null;
      }
      lastPane() {
        return this._panes[this._panes.length - 1];
      }
      removeSource(e, t) {
        this.selectionMacro(t => t.removeSourceFromSelection(e), true);
        if (this._hoveredSource === e) {
          this._hoveredSource = null;
          this._lastHoveredHittestData = null;
        }
        if (this._sourcesBeingMoved.includes(e)) {
          this._sourcesBeingMoved = this._sourcesBeingMoved.filter(t => t !== e);
          if (!this._sourcesBeingMoved.length) {
            this._activeItemBeingMoved = null;
          }
        }
        if (e === this._lineBeingEdited) {
          this._lineBeingEdited = null;
          lt.isToolEditingNow.setValue(false);
        }
        if (e === this.lineBeingCreated()) {
          this._lineBeingCreated = null;
          lt.isToolCreatingNow.setValue(false);
        }
        if (!t && e.stop) {
          e.stop();
        }
        const i = this.detachSource(e);
        const s = this.mainSeries().priceScale();
        if ((0, Js.isStudy)(e) && (0, Nr.isActingAsSymbolSource)(e) && e.priceScale() === s && s.isPercentage() && s.seriesLikeSources().filter(Nr.isActingAsSymbolSource).length === 1) {
          s.setMode({
            percentage: false
          });
        }
        this.fullUpdate();
        this._invalidateBarColorerCaches();
        if ((0, Js.isStudy)(e)) {
          (0, W.emit)("study_event", e.id(), "remove");
          if (e.isChildStudy()) {
            e.parentSources().forEach(t => t.unsetChild(e));
          }
          e.maxOffset().unsubscribe(this._boundUpdateStudiesMaxOffset);
        }
        if (!t && e.destroy) {
          e.destroy();
        }
        if ((0, eo.isLineTool)(e)) {
          e.removeAlert();
          (0, W.emit)("drawing_event", e.id(), "remove");
        }
        return i;
      }
      mainSeriesScaleRatio() {
        return (0, uc.scaleRatio)(this._timeScale, this.mainSeries().priceScale());
      }
      setMainSeriesScaleRatio(e) {
        (0, n.ensureNotNull)(this.paneForSource(this._mainSeries)).applyPriceScaleRatio(this._mainSeries.priceScale(), e);
      }
      timezone() {
        return this._properties.childs().timezone.value();
      }
      timezoneExceptExchange() {
        return this._timezoneExceptExchange;
      }
      allStudies(e) {
        const t = e ? e => (0, Js.isStudy)(e) && true : Js.isStudy;
        return this._getAllSources(t);
      }
      studiesWV(e) {
        if (e) {
          return this._studiesExcludeInternalWV.readonly();
        } else {
          return this._studiesWV.readonly();
        }
      }
      listUserStudies(e) {
        const t = [];
        for (const i of this._panes) {
          for (const s of i.priceDataSources()) {
            if (!(0, Js.isFundamentalStudy)(s) && (0, Js.isStudy)(s) && s.showInObjectTree()) {
              const {
                id: i,
                shortDescription: o
              } = s.metaInfo();
              if (e.dontCountVolume && i === "Volume@tv-basicstudies" || e.dontCountCompare && i === "Compare@tv-basicstudies" || e.dontCountOverlay && i === "Overlay@tv-basicstudies") {
                continue;
              }
              t.push(o);
            }
          }
        }
        return t;
      }
      findNonOverlayStudyWithGroupingKey(e, t) {
        const i = t !== undefined ? [t] : this._panes;
        for (const t of i) {
          const i = t.dataSources().find(i => (0, Js.isStudy)(i) && i.metaInfo().groupingKey === e && !t.isOverlay(i));
          if (i !== undefined) {
            return {
              pane: t,
              study: i
            };
          }
        }
        return null;
      }
      movePaneUp(e) {
        this.movePane(e, e - 1);
      }
      movePaneDown(e) {
        this.movePane(e, e + 1);
      }
      movePane(e, t) {
        const i = this._panes[e];
        this._panes.splice(e, 1);
        this._panes.splice(t, 0, i);
        this._panesCollectionChanged.fire(this._panes);
        this._onRearrangePanes.fire();
        this.invalidate(yo.InvalidationMask.panesOrder());
      }
      toggleCollapsedPane(e) {
        const t = this._panes[e];
        t.collapsed().setValue(!t.collapsed().value());
        this.fullUpdate();
      }
      sendToBack(e) {
        this._sendTo(e, (e, t) => e.sendToBack(t));
      }
      bringToFront(e) {
        this._sendTo(e, (e, t) => e.bringToFront(t));
      }
      backgroundColor() {
        return this._backgroundColor;
      }
      backgroundTopColor() {
        return this._backgroundTopColor;
      }
      backgroundColorAtYPercentFromTop(e) {
        const t = this.backgroundColor().value();
        const i = this.backgroundTopColor().value();
        return this._backgroundColorAtYPercentFromTop.gradientColor(i, t, e);
      }
      backgroundCounterColor() {
        return this._backgroundCounterColor.readonly();
      }
      dark() {
        return this._isDark;
      }
      backgroundTheme() {
        return this._backgroundTheme;
      }
      readOnly() {
        return this._readOnly;
      }
      defaultResolutions() {
        return this.chartApi().defaultResolutions();
      }
      availableCurrencies() {
        const e = this._getAvailableCurrencies();
        if (e.length !== this._availableCurrencies.size()) {
          this._availableCurrencies = new Sd(e);
        }
        return this._availableCurrencies;
      }
      currencyConversionEnabled() {
        return this._options.currencyConversionEnabled;
      }
      availableUnits() {
        const e = this._getAvailableUnits();
        if (this._availableUnits.unitsChanged(e)) {
          this._availableUnits = new bd(e);
        }
        return this._availableUnits;
      }
      unitConversionEnabled() {
        return this._options.unitConversionEnabled;
      }
      availablePriceSources(e) {
        const t = this._getAvailablePriceSources(e);
        if (t !== null && this._availablePriceSources.priceSourcesChanged(t)) {
          this._availablePriceSources = new e_(t);
        }
        return this._availablePriceSources;
      }
      resetDeferredStudies() {
        bh.instance(this).reset();
      }
      waitForStudy(e) {
        const t = this.dataSourceForId(e);
        if (t && (0, Js.isStudy)(t)) {
          return Promise.resolve(t);
        } else {
          return bh.instance(this).get(e);
        }
      }
      resetWaitForStudy(e) {
        bh.instance(this).delete(e);
      }
      isJustClonedChart() {
        return this._undoModel.isJustClonedChart();
      }
      studyTemplate(e, t, i) {
        const s = {
          panes: [],
          version: this.version()
        };
        for (const e of this.panes()) {
          s.panes.push(e.state(true, false, true));
        }
        const o = this.mainSeries();
        if (e) {
          s.symbol = o.symbol();
          if (this.currencyConversionEnabled() && i) {
            s.currency = o.currency();
          }
          if (this.unitConversionEnabled() && i) {
            s.unit = o.unit();
          }
        }
        if (t) {
          s.interval = o.interval();
        }
        return s;
      }
      dataSourceForId(e) {
        for (const t of this._panes) {
          const i = t.dataSourceForId(e);
          if (i) {
            return i;
          }
        }
        return null;
      }
      getStudyById(e) {
        const t = this.dataSourceForId(e);
        if (t !== null && (0, Js.isStudy)(t)) {
          return t;
        } else {
          return null;
        }
      }
      getLineToolById(e) {
        const t = this.dataSourceForId(e);
        if (t !== null && (0, eo.isLineTool)(t)) {
          return t;
        } else {
          return null;
        }
      }
      restoreLineToolState(e, t, i) {
        if (t.positionPercents) {
          e.restorePositionPercents(t.positionPercents);
        } else {
          e.clearFixedPoint();
          e.restorePoints(t.points, t.indexes || []);
        }
        t.state.intervalsVisibilities = (0, Ch.mergeIntervalVisibilitiesDefaults)(t.state.intervalsVisibilities);
        e.properties().merge(t.state);
        if (e.restoreData) {
          e.restoreData(t);
        }
        e.linkKey().setValue(t.linkKey || null);
        e.createServerPoints();
        e.setZorder(t.zorder ?? e.zorder());
        this.fullUpdate();
        const s = e.linkKey().value();
        if (s !== null && i) {
          (0, lt.restoreLineToolState)({
            model: this,
            linkKey: s,
            state: t
          });
        }
      }
      restoreFactoryDefaults(e) {
        e.restoreFactoryDefaults();
        this.recalcVisibleRangeStudies(Eo.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction);
      }
      preferences() {
        return function (e, t, i = Gu) {
          const s = {
            timezone: "",
            priceScaleSelectionStrategyName: "auto",
            timeScale: {
              defaultRightOffset: e.timeScale().defaultRightOffset().value(),
              defaultRightOffsetPercentage: e.timeScale().defaultRightOffsetPercentage().value(),
              usePercentageRightOffset: e.timeScale().usePercentageRightOffset().value()
            },
            mainSeries: {},
            sessions: {},
            paneProperties: {},
            scalesProperties: {},
            chartEventsSourceProperties: {},
            tradingProperties: {}
          };
          const o = ["timeScale", "mainSeries", "sessions"];
          const n = i.mainSeries;
          const r = Object.keys(i);
          const a = Object.keys(n);
          const l = t.properties();
          const c = e.sessions().properties();
          const h = e.properties();
          const d = i.sessions;
          const u = Object.keys(d);
          a.forEach(e => {
            s.mainSeries[e] = $u(e, l, n, "mainSeries");
          });
          u.forEach(e => {
            s.sessions[e] = $u(e, c, d, "sessions");
          });
          r.forEach(e => {
            if (!o.includes(e)) {
              s[e] = $u(e, h, i, "preferences");
            }
          });
          return s;
        }(this, this.mainSeries());
      }
      applyPreferences(e) {
        for (const [t, i] of Object.entries(e)) {
          const e = this._properties.child(t);
          if (i !== undefined && e !== undefined) {
            e.mergeAndFire(i);
          }
        }
        if (e.timeScale !== undefined) {
          const t = e.timeScale;
          this._timeScale.defaultRightOffset().setValue(t.defaultRightOffset);
          this._timeScale.defaultRightOffsetPercentage().setValue(t.defaultRightOffsetPercentage);
          this._timeScale.usePercentageRightOffset().setValue(t.usePercentageRightOffset);
        }
        this._properties.saveDefaults();
        this._mainSeries.applyPreferences(e.mainSeries);
        this.sessions().restoreState({
          properties: e.sessions
        }, false);
        this.recalculateAllPanes((0, Bt.globalChangeEvent)());
        this.fullUpdate();
      }
      restoreTheme(e, t, i) {
        e.mainSourceProperties.hollowCandleStyle ||= e.mainSourceProperties.candleStyle;
        this._undoModel.chartLoadTheme(e, t, i);
      }
      updateScales() {
        this.mainSeries().properties().childs().priceAxisProperties.fireChanged();
      }
      onResetScales() {
        return this._resetScales;
      }
      startMovingSources(e, t, i, s, o, r) {
        this._sourcesBeingMoved = e;
        this._activeItemBeingMoved = i;
        let a = false;
        this._sourcesBeingMoved.forEach(e => {
          if (!a && (0, Js.isStudy)(e)) {
            a = true;
          }
          const l = (0, n.ensureNotNull)(this.paneForSource(e));
          const c = (0, eo.isLineTool)(e);
          const h = c && e.linkKey().value();
          if (h !== false && h !== null && s.has(h) && c && e.isFixed()) {
            const t = (0, n.ensureDefined)(s.get(h));
            const a = {
              screen: this._percentPositionToPoint(t, l)
            };
            e.startMoving(a, i, o, r);
          } else {
            e.startMoving(t, i, o, r);
          }
          const d = this._paneInvalidationMask(l, yo.InvalidationLevel.Light);
          this.invalidate(d);
        });
        if (!r) {
          const s = e.filter(eo.isLineTool).filter(e => e.linkKey().value() && e.isSynchronizable()).map(e => e.linkKey().value());
          if (s.length && t.logical) {
            const r = this.externalTimeStamp(t.logical.index);
            const a = {
              linkKeys: s,
              model: this,
              symbol: this.mainSeries().symbol(),
              point: {
                price: t.logical.price,
                timeStamp: r
              },
              activeItem: i !== null ? i : undefined,
              envState: o,
              pointPositionPercents: new Map()
            };
            e.forEach(e => {
              if ((0, eo.isLineTool)(e)) {
                const i = e.linkKey().value();
                if (i && e.isSynchronizable() && e.isFixed()) {
                  const s = (0, n.ensureNotNull)(this.paneForSource(e));
                  a.pointPositionPercents.set(i, this._pointToPercentPosition((0, n.ensureDefined)(t.screen), s));
                }
              }
            });
            (0, lt.startMovingLineTool)(a);
          }
        }
        lt.isToolMovingNow.setValue(true);
        if (a) {
          lt.isStudyEditingNow.setValue(true);
        }
      }
      moveSources(e, t, i, s) {
        this._sourcesBeingMoved.filter(e => !e.isLocked || !e.isLocked()).forEach(o => {
          const r = (0, eo.isLineTool)(o) ? o.linkKey().value() : null;
          if (r !== null && t.has(r)) {
            const e = (0, n.ensureNotNull)(this.paneForSource(o));
            const a = (0, n.ensureDefined)(t.get(r));
            const l = {
              screen: this._percentPositionToPoint(a, e)
            };
            o.move(l, this._activeItemBeingMoved, i, s);
          } else {
            o.move(e, this._activeItemBeingMoved, i, s);
          }
        });
        this.lightUpdate();
        if (!s && e.logical) {
          const t = this._sourcesBeingMoved.filter(eo.isLineTool).filter(e => e.isSynchronizable() && !!e.linkKey().value()).map(e => e.linkKey().value());
          const s = this.externalTimeStamp(e.logical.index);
          const o = {
            linkKeys: t,
            model: this,
            point: {
              price: e.logical.price,
              timeStamp: s
            },
            envState: i,
            pointPositionPercents: new Map()
          };
          this._sourcesBeingMoved.filter(eo.isLineTool).forEach(t => {
            if (t.linkKey().value() && t.isSynchronizable() && t.isFixed()) {
              const i = (0, n.ensureNotNull)(this.paneForSource(t));
              o.pointPositionPercents.set(t.linkKey().value(), this._pointToPercentPosition((0, n.ensureDefined)(e.screen), i));
            }
          });
          (0, lt.moveLineTool)(o);
        }
      }
      endMovingSources(e, t, i) {
        const s = this._sourcesBeingMoved.map(s => {
          const o = (0, n.ensureNotNull)(this.paneForSource(s));
          const r = s.endMoving(e, t, i);
          const a = this._paneInvalidationMask(o, yo.InvalidationLevel.Light);
          a.invalidateAll(yo.InvalidationLevel.Light);
          this.invalidate(a);
          return r;
        });
        const o = this._sourcesBeingMoved.filter(eo.isLineTool).filter(e => e.isSynchronizable() && !!e.linkKey().value()).map(e => e.linkKey().value());
        const r = this._sourcesBeingMoved.filter(eo.isLineTool).filter(e => e.isSynchronizable() && !!e.linkKey).map(e => {
          const t = {
            points: e.normalizedPoints(),
            interval: this.mainSeries().interval()
          };
          if (e.isFixed()) {
            t.pointPositionPercents = e.calcPositionPercents();
          }
          return t;
        });
        if (o.length) {
          (0, lt.finishMovingLineTool)({
            linkKeys: o,
            model: this,
            finalStates: r,
            changes: s
          });
        }
        this._sourcesBeingMoved = [];
        this._activeItemBeingMoved = null;
        lt.isToolMovingNow.setValue(false);
        lt.isStudyEditingNow.setValue(false);
      }
      sourcesBeingMoved() {
        return this._sourcesBeingMoved;
      }
      setMovingCustomSource(e, t) {
        this._customSourceBeingMoved = e;
        this._customSourceBeingMovedHitTestData = t !== null ? {
          beingMoved: false,
          cancelled: false,
          ...t
        } : null;
      }
      processingCustomSourceMove() {
        if (this._customSourceBeingMovedHitTestData !== null) {
          this._customSourceBeingMovedHitTestData.beingMoved = true;
        }
      }
      customSourceMovingHitTestData() {
        return this._customSourceBeingMovedHitTestData;
      }
      customSourceBeingMoved() {
        if (this._customSourceBeingMovedHitTestData !== null && this._customSourceBeingMovedHitTestData.beingMoved) {
          return this._customSourceBeingMoved;
        } else {
          return null;
        }
      }
      lineToolsSynchronizer() {
        return this._lineToolsSynchronizer;
      }
      setLineToolsSynchronizer(e) {
        this._lineToolsSynchronizer = e;
      }
      width() {
        return this._width;
      }
      setWidth(e, t) {
        if (this._panes.reduce((t, i) => i.setWidth(e) || t, false) || this._width !== e) {
          this._width = e;
          this._timeScale.setWidth(e, t);
          this.recalculateAllPanes((0, Bt.viewportChangeEvent)());
          this.recalcVisibleRangeStudies(Eo.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction);
        }
      }
      setPaneHeight(e, t) {
        e.setHeight(t);
        this.recalculateAllPanes((0, Bt.viewportChangeEvent)());
        this.lightUpdate();
      }
      resetScalesAvailable() {
        return this._resetScalesAvailable.readonly();
      }
      maximizedPane() {
        return this._maximizedPane.readonly();
      }
      setMaximizedPane(e) {
        (0, n.assert)(e === null || this._panes.includes(e), "The pane is not part of this chart");
        this._maximizedPane.setValue(e);
      }
      panes() {
        return this._panes;
      }
      paneForId(e) {
        return this._panes.find(t => t.id() === e) || null;
      }
      createPane(e, t, i, s) {
        if (!this._restoringState) {
          this._maximizedPane.setValue(null);
        }
        const o = this._properties.childs().paneProperties;
        if (t) {
          o.merge(t);
        }
        const n = new Eh(this._timeScale, o, this, i, s ?? Bi.PaneMode.Regular);
        if (e !== undefined) {
          this._panes.splice(e, 0, n);
        } else {
          this._panes.push(n);
        }
        n.onTagsChanged().subscribe(this, () => this.onPaneTagsChanged());
        n.dataSourcesCollectionChanged().subscribe(this, () => this._dataSourceCollectionChanged.fire(n));
        n.symbolSourceCollectionChanged().subscribe(this, () => this._onSymbolSourceCollectionChanged(n));
        n.priceSourcesCollectionChanged().subscribe(this, () => this._onPriceSourcesCollectionChanged(n));
        n.sourcePropertiesChanged().subscribe(this, e => this._sourceProperitesChanged.fire(n, e));
        n.sourceZOrderChanged().subscribe(this, e => this._sourceZOrderChanged.fire(n, e));
        n.symbolSourceResolved().subscribe(this, e => this._symbolSourceResolved.fire(n, e));
        n.symbolSourceResolvingActive().subscribe(this._recalcSymbolResolvingActive);
        n.collapsed().subscribe(this._recalcPaneCollapsingAvailable);
        n.resetPriceScalesAvailable().subscribe(this._updateResetScalesAvailableValue, {
          callWithLast: true
        });
        this._recalcPaneCollapsingAvailable();
        this._panesCollectionChanged.fire(this._panes);
        this.invalidate(yo.InvalidationMask.panesOrder());
        return n;
      }
      removePane(e) {
        if (e === this._maximizedPane.value()) {
          this._maximizedPane.setValue(null);
        }
        const t = e;
        t.destroy();
        const i = this._panes.indexOf(t);
        if (i !== -1) {
          this._panes.splice(i, 1);
          e.dataSourcesCollectionChanged().unsubscribeAll(this);
          e.symbolSourceCollectionChanged().unsubscribeAll(this);
          e.priceSourcesCollectionChanged().unsubscribeAll(this);
          e.sourcePropertiesChanged().unsubscribeAll(this);
          e.onTagsChanged().unsubscribeAll(this);
          e.symbolSourceResolved().unsubscribeAll(this);
          t.symbolSourceResolvingActive().unsubscribe(this._recalcSymbolResolvingActive);
          e.collapsed().unsubscribe(this._recalcPaneCollapsingAvailable);
          e.resetPriceScalesAvailable().unsubscribe(this._updateResetScalesAvailableValue);
          this._recalcPaneCollapsingAvailable(true);
        }
        this._updateResetScalesAvailableValue();
        if (this.crosshairSource().pane === e) {
          this.clearCurrentPosition();
        }
        this._panesCollectionChanged.fire(this._panes);
        this.invalidate(yo.InvalidationMask.panesOrder());
      }
      changePanesHeight(e, t) {
        if (this._panes.length < 2) {
          return;
        }
        (0, n.assert)(e >= 0 && e < this._panes.length, "Invalid pane index");
        const i = this._panes[e];
        const s = this._panes.reduce((e, t) => e + t.stretchFactor(), 0);
        const o = this._panes.reduce((e, t) => e + t.height(), 0);
        const r = o - (this._panes.length - 1) * 30;
        t = Math.min(r, Math.max(30, t));
        const a = s / o;
        const l = i.height();
        i.setStretchFactor(t * a);
        let c = t - l;
        let h = this._panes.length - 1;
        for (const e of this._panes) {
          if (e !== i) {
            const t = Math.min(r, Math.max(30, e.height() - c / h));
            c -= e.height() - t;
            h -= 1;
            const i = t * a;
            e.setStretchFactor(i);
          }
        }
        this.fullUpdate();
      }
      clearCurrentPosition() {
        const e = this.crosshairSource();
        e.clearPosition();
        (0, n.ensureNotNull)(e.dataWindowView()).update((0, Bt.sourceChangeEvent)(e.id()));
        l_(this._panes);
        this.invalidate(yo.InvalidationMask.cursor());
        this._undoModel.syncCrosshair(null);
        this._phantomSourceContainer.onCursorPositionUpdated();
      }
      setAndSaveCurrentPosition(e, t, i, s) {
        this.crosshairSource().saveOriginCoords(e, t);
        this.setCurrentPosition(e, t, i, s);
      }
      setCurrentPosition(e, t, i, s) {
        let o = NaN;
        const r = this._timeScale.coordinateToVisibleIndex(e);
        const a = (this._lineBeingEdited ?? this.lineBeingCreated())?.priceScale() ?? i.defaultPriceScale();
        let l = null;
        if (!a.isEmpty() && Number.isFinite(t)) {
          l = (0, n.ensureNotNull)(i.mainDataSource()).firstValue();
          if (l !== null) {
            o = a.coordinateToPrice(t, l);
          }
        }
        const c = this._crossHairSelectPointMode.value() !== lt.SelectPointMode.None;
        const h = lt.tool.value();
        const d = this.mainSeries();
        const u = this.crosshairSource();
        const _ = u.index;
        const p = u.price;
        const m = c || lt.isStudyEditingNow.value();
        let g = false;
        if (a === this._mainSeries.priceScale()) {
          if ((0, wt.isLineDrawnWithPressedButton)(h)) {
            g = this._lineBeingCreated === null || (0, eo.isBrushBasedLineTool)(this._lineBeingCreated.lineDataSource) && this._lineBeingCreated.lineDataSource.hasOnlyOnePoint();
          } else {
            g = Boolean(this._lineBeingCreated || this._lineBeingEdited || (0, wt.isLineToolName)(h) || (0, lt.toolIsMeasure)(h)) || m;
          }
        }
        if (!this._isSettingsExternalPosition && g) {
          o = this._magnet.align(o, r, i);
          if (l !== null) {
            this._setCorrectedPositionToCrosshair(r, o, i);
          }
        } else {
          this._magnet.resetLastValue();
        }
        let f = null;
        if (!isNaN(o)) {
          f = i;
        }
        if (this._isTimeScrolling) {
          if (!this._isSettingsExternalPosition && c) {
            const e = d.bars().firstIndex();
            const t = d.bars().lastIndex();
            if (e !== null && t !== null) {
              const s = Math.min(Math.max(r, e), t);
              if (s !== r) {
                this._setCorrectedPositionToCrosshair(s, o, i);
              }
            }
          } else {
            u.setPosition(u.index, o, f);
          }
          return;
        }
        u.setOnHoveredChartWidget(true);
        u.setPosition(r, o, f);
        (0, n.ensureNotNull)(u.dataWindowView()).update((0, Bt.sourceChangeEvent)(u.id()));
        l_(this._panes);
        const y = d.syncModel();
        if (this.crosshairSource().startMeasurePoint() || this._lineBeingCreated) {
          this.lightUpdate();
        } else {
          this.invalidate(yo.InvalidationMask.cursor());
        }
        const v = this.lineBeingCreated();
        if (v) {
          const e = v.linkKey().value();
          if (!this._isSettingsExternalPosition) {
            const t = v.setLastPoint({
              index: r,
              price: o
            }, s);
            v.updateAllViews((0, Bt.sourceChangeEvent)(v.id()));
            if (t.price !== o || t.index !== r) {
              this._setCorrectedPositionToCrosshair(t.index, t.price, i);
            }
            if (y && e) {
              const i = this._timeScale.points().roughTime(t.index, y.projectTime.bind(y));
              (0, lt.setLineToolLastPoint)({
                model: this,
                linkKey: e,
                point: {
                  timeStamp: (0, n.ensureNotNull)(i),
                  price: t.price
                }
              });
            }
          }
        }
        if (!this._isSettingsExternalPosition && this._lineBeingEdited !== null && this._linePointBeingEdited !== null) {
          const e = {
            index: r,
            price: o
          };
          if (this._linePointBeingChanged?.nonDiscreteIndex) {
            const t = this.crosshairSource().originX();
            if (Number.isFinite(t)) {
              e.index = this._timeScale.coordinateToFloatIndex(t);
            }
          }
          this.changeLinePoint(e, s);
          const t = this._lineBeingEdited.alignCrossHairToAnchor(this._linePointBeingEdited) ? this._lineBeingEdited.getPoint(this._linePointBeingEdited) : e;
          if (t !== null) {
            this._setCorrectedPositionToCrosshair(t.index, t.price, i);
          }
        }
        if (!this._isSettingsExternalPosition && this._sourcesBeingMoved.length === 1) {
          const e = this._sourcesBeingMoved[0];
          if (e.alignCrossHairToMovePoint?.()) {
            const t = e.currentMovingPoint?.();
            if (t && t.logical) {
              this._setCorrectedPositionToCrosshair(t.logical.index, t.logical.price, i);
            }
          }
        }
        if (!this._isSettingsExternalPosition && m) {
          const e = d.bars().firstIndex();
          const t = d.bars().lastIndex();
          if (e !== null && t !== null) {
            const s = Math.min(Math.max(r, e), t);
            if (s !== r) {
              this._setCorrectedPositionToCrosshair(s, o, i);
            }
          }
        }
        if (_ !== r || p !== o) {
          this._syncCrosshair(s);
        }
      }
      setExternalPosition(e, t) {
        let i;
        const s = this.crosshairSource();
        s.setOnHoveredChartWidget(false);
        if (e !== null && (0, dt.isNumber)(e.timeStamp)) {
          const t = this.mainSeries().syncModel();
          if (t) {
            const s = this.createSyncPoint(e.syncSourceTarget, t.syncSourceTarget()).sourceTimeToTargetTime(e.timeStamp);
            i = this._timeScale.points().roughIndex(s, t.distance.bind(t), 1);
          }
        }
        if (e !== null && i != null && Number.isFinite(i)) {
          this._isSettingsExternalPosition = true;
          const o = (0, n.ensureNotNull)(this.paneForSource(this.mainSeries()));
          const r = this._timeScale.indexToCoordinate(i);
          const a = (0, n.ensureNotNull)(o.mainDataSource()).firstValue();
          if (a !== null) {
            let i = NaN;
            if (e.price !== undefined && Number.isFinite(e.price)) {
              i = this.mainSeries().priceScale().priceToCoordinate(e.price, a);
            }
            s.clearOriginCoords();
            this.setCurrentPosition(r, i, o, t);
          }
          s.setOnHoveredChartWidget(false);
          this._isSettingsExternalPosition = false;
          return;
        }
        s.clearPosition();
        (0, n.ensureNotNull)(s.dataWindowView()).update((0, Bt.sourceChangeEvent)(s.id()));
        l_(this._panes);
        this.invalidate(yo.InvalidationMask.cursor());
      }
      startScaleTime(e) {
        this._timeScale.startScale(e);
      }
      scaleTimeTo(e) {
        this._timeScale.scaleTo(e);
        this.recalculateAllPanes((0, Bt.viewportChangeEvent)());
        this.lightUpdate();
      }
      endScaleTime() {
        this._timeScale.endScale();
        this.lightUpdate();
        this.recalcVisibleRangeStudies(Eo.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction);
      }
      resetTimeScale() {
        this._timeScale.restoreDefault();
        this.recalculateAllPanes((0, Bt.viewportChangeEvent)());
        this.recalcVisibleRangeStudies(Eo.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction);
        this.lightUpdate();
        this._resetScales.fire();
      }
      startScalePrice(e, t, i) {
        e.startScalePrice(t, i);
      }
      scalePriceTo(e, t, i) {
        e.scalePriceTo(t, i);
        if (this.mainSeries().priceScale().isLockScale()) {
          this.lightUpdate();
        } else {
          this.invalidate(this._paneInvalidationMask(e, yo.InvalidationLevel.Light));
        }
      }
      endScalePrice(e, t) {
        e.endScalePrice(t);
        this.invalidate(this._paneInvalidationMask(e, yo.InvalidationLevel.Light));
      }
      startTwoPointsScalePrice(e, t, i, s) {
        t.startTwoPointsScale(i, s);
      }
      twoPointsScalePriceTo(e, t, i, s) {
        t.twoPointsScale(i, s);
        t.updateAllViews((0, Bt.viewportChangeEvent)());
        this.invalidate(this._paneInvalidationMask(e));
      }
      endTwoPointsScalePrice(e, t) {
        t.endTwoPointsScale();
        this.invalidate(this._paneInvalidationMask(e));
      }
      resetPriceScale(e, t) {
        e.resetPriceScale(t);
        this.invalidate(this._paneInvalidationMask(e, yo.InvalidationLevel.Light));
      }
      restorePriceScaleState(e, t, i) {
        e.restorePriceScaleState(t, i);
        this.invalidate(this._paneInvalidationMask(e, yo.InvalidationLevel.Light));
      }
      detachSource(e) {
        const t = this.paneForSource(e);
        return !!t && (t.removeDataSource(e), t.isEmpty() ? (this._lineBeingCreated && t === this._paneBeingCreatedLineOn && this.cancelCreatingLine(), this.removePane(t), true) : (this.fullUpdate(), false));
      }
      restoreSource(e, t, i, s, o) {
        const n = e ? this.createPane(t) : this.panes()[t];
        const r = (0, pt.isStudyState)(s);
        const a = r ? n.restoreStudy(s) : (0, pt.isLineToolState)(s) ? n.restoreLineTool(s) : s.id === tpoSummaryDataSourceId && this.mainSeries().style() === 18 ? n.restoreTpoSummaryDataSource(s) : null;
        if (!a) {
          return null;
        }
        let l = null;
        if (o) {
          l = n.getPriceScaleById(o.id);
          if (!l) {
            l = n.createPriceScaleAtPosition(o.position, o.priceScaleIndex);
            l.setId(o.id);
          }
        } else {
          l = a.ownerSource()?.priceScale() ?? l;
        }
        if (l) {
          a.setPriceScale(l);
          l.addDataSource(a);
        }
        if (!e && i && i.overlayPriceScales) {
          const e = this.dataSources().filter(e => i.overlayPriceScales[e.id()] !== undefined);
          e.forEach(e => n.removeSourceFromPriceScale(e));
          const t = new Map();
          e.forEach(e => {
            const s = i.overlayPriceScales[e.id()];
            if (!s) {
              return;
            }
            let o;
            if (t.has(s.id)) {
              o = t.get(s.id);
            } else {
              o = n.createPriceScaleAtPosition("overlay");
              o.restoreState(s);
              t.set(s.id, o);
            }
            e.setPriceScale(o);
            o.addDataSource(e);
          });
        }
        if (e && i) {
          n.restoreState({
            state: i,
            withData: false,
            version: this.version()
          });
        }
        if (r) {
          this.recalculateAllPanes((0, Bt.sourceChangeEvent)(a.id()));
          this.mainSeries().invalidateBarColorerCache();
          this.fullUpdate();
        }
        return a;
      }
      children(e, t) {
        return this.dataSources().filter(i => (0, Js.isStudy)(i) ? !t && i.parentSources().includes(e) : i.ownerSource() === e);
      }
      onRearrangePanes() {
        return this._onRearrangePanes;
      }
      studyInserted() {
        return this._studyInserted;
      }
      finishLineTool(e) {
        const t = e.linkKey().value();
        if ((0, lt.drawOnAllCharts)().value() && t !== null && e.isSynchronizable()) {
          (0, lt.finishLineTool)({
            linkKey: t,
            model: this
          });
        }
      }
      startChangingLinetool(e, t, i, s, o) {
        this._lineBeingEdited = e;
        this._linePointBeingChanged = t || null;
        this._linePointBeingEdited = i === undefined ? null : i;
        this._lineBeingEdited.startChanging(i, t, o);
        lt.isToolEditingNow.setValue(true);
        const r = (0, n.ensureNotNull)(this.paneForSource(e));
        if (this._lineBeingEdited.startDragPoint && i !== undefined && t !== undefined) {
          this._lineBeingEdited.startDragPoint(i, t);
        }
        if (!o && i !== undefined && t !== undefined) {
          this._lineBeingEdited.setPoint(i, t, s, o);
        }
        this._lineBeingEdited.updateAllViews((0, Bt.sourceChangeEvent)(this._lineBeingEdited.id()));
        const a = this._paneInvalidationMask(r, yo.InvalidationLevel.Light);
        this.invalidate(a);
        const l = e.linkKey().value();
        if (l && e.isSynchronizable() && i !== undefined && t !== undefined) {
          const o = (0, n.ensureNotNull)(this.externalTimeStamp(t.index));
          (0, lt.startChangingLineTool)({
            linkKey: l,
            model: this,
            symbol: this.mainSeries().symbol(),
            point: {
              price: t.price,
              timeStamp: o
            },
            positionPercents: e.positionPercents(),
            pointIndex: i,
            envState: s || null
          });
        }
      }
      createLineTool(e) {
        const {
          pane: t,
          point: i,
          linetool: s,
          linkKey: o = null,
          sharingMode: r = 0,
          id: a,
          fromExternalModel: l
        } = e;
        let {
          properties: c,
          ownerSource: h
        } = e;
        (0, n.assert)((0, wt.isLineToolName)(s), `Cannot create unknown line tool: ${s}`);
        if (c) {
          const e = {
            ...Yu.intervalsVisibilitiesDefaults
          };
          const t = c.childs().intervalsVisibilities.state();
          (0, dt.merge)(e, t ?? {});
          const i = c.state();
          i.intervalsVisibilities = e;
          c = (0, eo.createLineToolProperties)(this.backgroundTheme().spawnOwnership(), s, !this.readOnly(), i);
        }
        const d = (0, eo.createLineTool)(s, this, c, null, undefined, a);
        if (s !== "LineToolExecution") {
          let e;
          switch (s) {
            case "LineToolIcon":
              e = d.properties().childs().icon.value().toString(16).toUpperCase();
              break;
            case "LineToolEmoji":
              e = d.properties().childs().emoji.value();
              break;
            case "LineToolSticker":
              e = d.properties().childs().sticker.value();
          }
          (0, ne.trackEvent)("drawings", "Study_Drawing_" + s, e);
        }
        if ((0, eo.isStudyLineTool)(d)) {
          (0, ne.trackEvent)("studies", `Study_${d.metaInfo().id}`);
        }
        const u = !d.linkKey().value() && !o;
        h = (0, n.ensureDefined)(h || (0, n.ensureNotNull)(t.mainDataSource()));
        if (!c) {
          (0, eo.prepareLineToolPropertiesByOwnerSource)(d.properties(), h);
        }
        d.setOwnerSource(h);
        const _ = h.priceScale();
        d.setPriceScale(_);
        if (n_ && h === this.mainSeries()) {
          d.share(r);
        }
        t.addDataSource(d, _, false);
        if (d.preferredZOrder() !== null) {
          t.insertAfter([d], this.mainSeries());
        }
        if ((0, lt.drawOnAllCharts)().value()) {
          const e = d.isSynchronizable() ? o || (0, fe.randomHash)() : null;
          d.linkKey().setValue(e);
        } else {
          d.linkKey().setValue(o);
        }
        let p;
        if (u) {
          d.enableCurrentIntervalVisibility();
        }
        if (d.isFixed()) {
          const e = (0, n.ensureNotNull)((0, n.ensureNotNull)(t.mainDataSource()).firstValue());
          const s = this._timeScale.indexToCoordinate(i.index);
          const o = (0, n.ensureNotNull)(_).priceToCoordinate(i.price, e);
          p = d.addFixedPoint(new At.Point(s, o));
        } else {
          p = d.addPoint(i);
        }
        if (!p) {
          this._lineBeingCreated = {
            lineDataSource: d,
            fromExternal: !!l
          };
          this._paneBeingCreatedLineOn = t;
          lt.isToolCreatingNow.setValue(true);
        }
        this.fullUpdate();
        return d;
      }
      endChangingLinetool(e, t) {
        const i = (0, n.ensureNotNull)(this._lineBeingEdited);
        const s = i.endChanging(false, e, t);
        this._lineBeingEdited = null;
        lt.isToolEditingNow.setValue(false);
        this._linePointBeingEdited = null;
        this._linePointBeingChanged = null;
        this.lightUpdate();
        const o = {
          points: i.normalizedPoints(),
          interval: this.mainSeries().interval()
        };
        const r = i.linkKey().value();
        if (r !== null && i.isSynchronizable() && !t) {
          (0, lt.finishChangingLineTool)({
            model: this,
            linkKey: r,
            symbol: this.mainSeries().symbol(),
            finalState: o,
            changes: s
          });
        }
      }
      continueCreatingLine(e, t, i, s, o) {
        const r = (0, n.ensureNotNull)(this.lineBeingCreated());
        const a = r.addPoint(e, t, i, o);
        r.updateAllViews((0, Bt.sourceChangeEvent)(r.id()));
        const l = new yo.InvalidationMask(yo.InvalidationLevel.Light);
        if (a) {
          this._paneBeingCreatedLineOn = null;
          this._lineBeingCreated = null;
          lt.isToolCreatingNow.setValue(false);
        }
        this.invalidate(l);
        return a;
      }
      cancelCreatingLine() {
        const e = this.lineBeingCreated();
        if (e) {
          this.removeSource(e);
          this._lineBeingCreated = null;
          this._lineCancelled.fire();
          lt.isToolCreatingNow.setValue(false);
          if ((0, lt.drawOnAllCharts)().value() && e.isSynchronizable()) {
            (0, lt.cancelLineTool)({
              model: this
            });
          }
        }
      }
      lineBeingCreated() {
        return this._lineBeingCreated?.lineDataSource || null;
      }
      lineBeingCreateFromExternal() {
        return this._lineBeingCreated?.fromExternal || false;
      }
      paneBeingCreatedLineOn() {
        return this._paneBeingCreatedLineOn;
      }
      lineCancelled() {
        return this._lineCancelled;
      }
      isPhantomLine(e) {
        return this._phantomSourceContainer.source() === e;
      }
      alignTo45Degrees(e, t) {
        const [i, s] = t;
        const o = {
          ...s
        };
        e.snapPoint45Degree(i, o);
        this.startChangingLinetool(e, s, s.pointIndex);
        this.changeLinePoint(o, Bo.EnvironmentState.create(true));
        this.endChangingLinetool(false);
      }
      changeLinePoint(e, t, i) {
        const s = (0, n.ensureNotNull)(this._lineBeingEdited);
        const o = (0, n.ensureNotNull)(this._linePointBeingEdited);
        let r = e.price;
        let a = e.index;
        s.setPoint(o, e, t, i);
        if (!i) {
          const t = s.alignCrossHairToAnchor(o) ? s.getPoint(o) : e;
          if (t !== null) {
            a = t.index;
            r = t.price;
          }
        }
        s.updateAllViews((0, Bt.sourceChangeEvent)(s.id()));
        this.lightUpdate();
        const l = s.linkKey().value();
        if (!i && l !== null && s.isSynchronizable()) {
          const e = (0, n.ensureNotNull)(this._linePointBeingChanged);
          const i = {
            indexesChanged: a !== e.index,
            pricesChanged: r !== e.price
          };
          const c = s.getChangePointForSync(o);
          if (c !== null) {
            const e = this.externalTimeStamp(a);
            if (e !== null) {
              r = c.price;
              (0, lt.changeLineTool)({
                linkKey: l,
                model: this,
                symbol: this.mainSeries().symbol(),
                point: {
                  price: r,
                  timeStamp: e
                },
                positionPercents: s.positionPercents(),
                envState: t,
                changes: i
              });
            }
          }
        }
      }
      changeLinePoints(e, t, i) {
        const s = e.points();
        const o = e.linkKey().value();
        if (!i && o && e.isSynchronizable()) {
          t.forEach((t, i) => {
            const r = s[i];
            const a = r.price !== t.price;
            const l = r.index !== t.index;
            if (e.getChangePointForSync(i)) {
              const i = (0, n.ensureNotNull)(this.externalTimeStamp(t.index));
              (0, lt.changeLineTool)({
                linkKey: o,
                model: this,
                symbol: this.mainSeries().symbol(),
                point: {
                  price: t.price,
                  timeStamp: i
                },
                positionPercents: e.positionPercents(),
                changes: {
                  pricesChanged: a,
                  indexesChanged: l
                }
              });
            }
          });
        }
        e.setPoints(t);
        e.updateAllViews((0, Bt.sourceChangeEvent)(e.id()));
        this.lightUpdate();
      }
      startScrollTime(e) {
        this._timeScale.startScroll(e);
        this._isTimeScrolling = true;
        this.mainSeries().clearGotoDateResult();
      }
      scrollTimeTo(e) {
        this._timeScale.scrollTo(e);
        this.recalculateAllPanes((0, Bt.viewportChangeEvent)());
        this.lightUpdate();
      }
      endScrollTime() {
        this._timeScale.endScroll();
        this.lightUpdate();
        this.recalcVisibleRangeStudies(Eo.RecalcVisibleRangeStudiesReason.ViewportChangeUserAction);
        this._isTimeScrolling = false;
      }
      startScrollPrice(e, t, i) {
        e.startScrollPrice(t, i);
      }
      scrollPriceTo(e, t, i) {
        e.scrollPriceTo(t, i);
        this.invalidate(this._paneInvalidationMask(e, yo.InvalidationLevel.Light));
      }
      endScrollPrice(e, t) {
        e.endScrollPrice(t);
        this.invalidate(this._paneInvalidationMask(e, yo.InvalidationLevel.Light));
      }
      addCustomSource(e, t, i = Eo.CustomSourceLayer.Foreground) {
        if (this._customSourcesMap.has(e)) {
          r_.logWarn(`Attempt to add the same custom source multiple time "${e}"`);
        }
        r_.logNormal(`Adding custom source "${e}"`);
        const s = t(e, this);
        switch (i) {
          case Eo.CustomSourceLayer.Background:
            this._bgCustomSources.push(s);
            break;
          case Eo.CustomSourceLayer.Foreground:
            this._fgCustomSources.push(s);
            break;
          case Eo.CustomSourceLayer.Topmost:
            this._topmostCustomSources.push(s);
            break;
          default:
            throw new Error(`Unknown custom sources layer ${i}`);
        }
        this._allCustomSources.push(s);
        this._customSourcesMap.set(e, s);
        this.lightUpdate();
      }
      removeCustomSource(e) {
        this._removeCustomSource(e);
        this.lightUpdate();
      }
      hasCustomSource(e) {
        return this._customSourcesMap.has(e);
      }
      customSourceForName(e) {
        return this._customSourcesMap.get(e) || null;
      }
      customSourceName(e) {
        let t = null;
        this._customSourcesMap.forEach((i, s) => {
          if (i === e) {
            t = s;
          }
        });
        return t;
      }
      customSources(e) {
        switch (e) {
          case Eo.CustomSourceLayer.Background:
            return this._bgCustomSources;
          case Eo.CustomSourceLayer.Foreground:
            return this._fgCustomSources;
          case Eo.CustomSourceLayer.Topmost:
            return this._topmostCustomSources;
          default:
            return this._allCustomSources;
        }
      }
      addMultiPaneSource(e) {
        this._multiPaneSources.push(e);
        this._onMultipaneSourcesCollectionChanged.fire();
        this.lightUpdate();
      }
      removeMultiPaneSource(e) {
        const t = this._multiPaneSources.indexOf(e);
        if (t === -1) {
          r_.logWarn("Attempt to remove multi-pane source which does not exist in the model");
        } else {
          this._onMultipaneSourcesCollectionChanged.fire();
          this._multiPaneSources.splice(t, 1);
        }
        this.lightUpdate();
      }
      multiPaneSources(e) {
        return this._multiPaneSources.filter(t => !e.hasDataSource(t));
      }
      onMultipaneSourcesCollectionChanged() {
        return this._onMultipaneSourcesCollectionChanged;
      }
      rendererOptionsProvider() {
        return this._rendererOptionsProvider;
      }
      magnet() {
        return this._magnet;
      }
      priceAxisRendererOptions() {
        return this._rendererOptionsProvider.options();
      }
      priceScaleSlotsCount() {
        let e = 0;
        let t = 0;
        this._panes.forEach(i => {
          e = Math.max(i.leftPriceScales().length, e);
          t = Math.max(i.rightPriceScales().length, t);
        });
        const i = e + t;
        if (ze.CheckMobile.any()) {
          const e = (0, n.ensureNotNull)(this.paneForSource(this.mainSeries()));
          const t = e.priceScalePosition(this.mainSeries().priceScale());
          if (t === "overlay" ? e.rightPriceScales().length > 0 : t === "right") {
            return {
              left: 0,
              right: 1,
              totallySlots: i
            };
          } else {
            return {
              left: 1,
              right: 0,
              totallySlots: i
            };
          }
        }
        return {
          left: e,
          right: t,
          totallySlots: i
        };
      }
      dateTimeFormatter() {
        return this._dateTimeFormatter;
      }
      dateFormatter() {
        return this._dateFormatter;
      }
      timeFormatter() {
        return this._timeFormatter;
      }
      isUnmergeAvailableForSource(e) {
        if (!this._unmergeAvailable(e)) {
          return false;
        }
        return (0, n.ensureNotNull)(this.paneForSource(e)).dataSources().filter(this._unmergeAvailable, this).length > 1;
      }
      isMergeDownAvailableForSource(e) {
        if (!this._unmergeAvailable(e)) {
          return false;
        }
        const t = this.paneForSource(e);
        const i = this.panes().filter(e => e.mode() === Bi.PaneMode.Regular);
        return t !== i[i.length - 1];
      }
      isMergeUpAvailableForSource(e) {
        if (!this._unmergeAvailable(e)) {
          return false;
        }
        return this.paneForSource(e) !== this.panes().filter(e => e.mode() === Bi.PaneMode.Regular)[0];
      }
      isPriceScaleVisible(e) {
        const t = e.mainSource();
        if (!t) {
          return false;
        }
        const i = (0, n.ensureNotNull)(this.paneForSource(t));
        const s = i.priceScalePosition(e);
        if (s === "overlay") {
          return true;
        }
        const o = i.priceScaleIndex(e, s);
        const r = this.priceScaleSlotsCount()[s];
        return o !== undefined && o < r;
      }
      getStudyShiftColorStartOffset() {
        return this._studyShiftColorStartOffset;
      }
      setStudyShiftColorStartOffset(e) {
        this._studyShiftColorStartOffset = e;
      }
      sessions() {
        return (0, n.ensureNotNull)(this._sessions);
      }
      createSessions(e) {
        if (this._sessions === null) {
          const t = function (e) {
            const t = new Mc(e);
            (0, h.applyDefaultsOverrides)(t.childs().sessionHighlight, undefined, false, "sessions");
            t.removeDuplicateProperties();
            return t;
          }((0, t_.createWVFromGetterAndSubscription)(() => this.mainSeries().symbolInfo(), this.mainSeries().dataEvents().symbolResolved()).ownership());
          this._sessions = new Ac((async () => {
            const s = await Promise.all([i.e(4821), i.e(7539)]).then(i.bind(i, 83943));
            this.addCustomSource("sessions", (i, o) => {
              const n = new s.Sessions(i, o, t, e);
              n.start();
              return n;
            }, Eo.CustomSourceLayer.Background);
            return this.customSourceForName("sessions");
          })(), this, t);
        }
      }
      createPrePostMarket(e) {
        this.addCustomSource("prePostMarket", (t, i) => new fd(t, i, e));
      }
      watermarkSource() {
        return this._watermarkSource;
      }
      watermarkContentProvider() {
        return i_.getInstance().provider();
      }
      studiesColorRotatorFactory() {
        return this._studyColorRotatorFactory;
      }
      replayStatus() {
        return this._replayStatus;
      }
      setReplayStatus(e) {
        this._replayStatus.setValue(e);
      }
      isInReplay() {
        return this._mainSeries.isInReplay();
      }
      getSymbolString() {
        return this._mainSeries.getSymbolString();
      }
      interval() {
        return this._mainSeries.interval();
      }
      onInReplayStateChanged() {
        return new re.Delegate();
      }
      switchToReplay(e, t) {
        0;
      }
      switchToRealtime() {
        0;
      }
      canChangeResolution(e) {
        return this._mainSeries.canChangeResolution(e);
      }
      canChangeSymbol(e) {
        return this._mainSeries.canChangeSymbol(e);
      }
      onReplayModified() {
        (0, n.assert)(false, "Replay not implemented");
        return this._mainSeries.onReplayModified();
      }
      mainSeriesScaleRatioProperty() {
        return this._mainSeriesScaleRatioProperty;
      }
      mainSeriesScaleRatioPropertyOnChanged() {
        this._mainSeriesScaleRatioProperty.fireChanged();
      }
      getThemeNameIfStdTheme() {
        const e = this.sessions().properties();
        const t = this.properties();
        const i = this.mainSeries().properties();
        if (e.allThemePropertiesAreDefault(oo.StdTheme.Light) && t.allThemePropertiesAreDefault(oo.StdTheme.Light) && i.allThemePropertiesAreDefault(oo.StdTheme.Light)) {
          return oo.StdTheme.Light;
        } else if (e.allThemePropertiesAreDefault(oo.StdTheme.Dark) && t.allThemePropertiesAreDefault(oo.StdTheme.Dark) && i.allThemePropertiesAreDefault(oo.StdTheme.Dark)) {
          return oo.StdTheme.Dark;
        } else {
          return null;
        }
      }
      theme() {
        return {
          chartProperties: this.properties().themeState(),
          sessions: this.sessions().properties().themeState(),
          mainSourceProperties: this.mainSeries().properties().themeState(),
          version: this.version()
        };
      }
      template() {
        return {
          chartProperties: this.properties().template(),
          sessions: this.sessions().properties().template(),
          mainSourceProperties: this.mainSeries().properties().template(),
          version: this.version()
        };
      }
      onChartThemeLoaded() {
        return this._chartThemeLoaded;
      }
      chartThemeLoaded() {
        this._chartThemeLoaded.fire();
      }
      async colorStudiesPropertiesReady() {
        this._recalcColorStudiesImpl(this._recalcVRStudiesParams);
        const e = this.allStudies(true).filter(e => e.metaInfo().inputs.filter(Vs.isStudyInputDependsOnChartColors).length > 0);
        await Promise.all(e.map(e => e.propertiesPatched()));
      }
      state(e, t, i, s) {
        const o = this.publishedChartsTimelineSource();
        const n = this.properties().childs();
        const r = n.tradingProperties.state();
        const a = {
          panes: this._panes.map(o => o.state(true, e, false, t, i, s)),
          timeScale: this._timeScale.state(e),
          chartProperties: {
            paneProperties: n.paneProperties.state(["horzGridProperties.style", "vertGridProperties.style"]),
            scalesProperties: n.scalesProperties.state(),
            publishedChartsTimelineProperties: o ? o.state(e) : undefined,
            chartEventsSourceProperties: n.chartEventsSourceProperties?.state(),
            tradingProperties: r,
            priceScaleSelectionStrategyName: n.priceScaleSelectionStrategyName.value()
          },
          sessions: this.sessions().state(e),
          version: this.version(),
          timezone: this.timezone(),
          shouldBeSavedEvenIfHidden: this._shouldBeSavedEvenIfHidden,
          linkingGroup: this._linkingGroupIndex.value()
        };
        if (!s) {
          a.lineToolsGroups = this.lineToolsGroupModel().state(t);
        }
        return a;
      }
      isInRestoreState() {
        return this._restoringState;
      }
      restoreState(e, t, i) {
        bh.instance(this).reset();
        const s = {};
        if (!e.panes) {
          r_.logDebug("ChartModel.restoreState: invalid state");
          return;
        }
        if (!Array.isArray(e.panes)) {
          r_.logDebug("ChartModel.restoreState: invalid state");
          return;
        }
        if (e.panes.length < 1) {
          r_.logDebug("ChartModel.restoreState: invalid state");
          return;
        }
        this._restoringState = true;
        for (const e of this._barsMarksSources) {
          this.detachSource(e);
        }
        this._shouldBeSavedEvenIfHidden = e.shouldBeSavedEvenIfHidden ?? true;
        if (e.chartProperties && !e.chartProperties.timezone) {
          e.chartProperties.timezone = e.timezone;
        }
        if (e.chartProperties) {
          const i = (0, h.factoryDefaults)("chartproperties").scalesProperties;
          (0, dt.merge)(i, e.chartProperties.scalesProperties);
          if (!!("showLastValue" in i) && !("showSeriesLastValue" in i) && !("showStudyLastValue" in i)) {
            i.showSeriesLastValueProperty = i.showLastValue;
            i.showStudyLastValueProperty = i.showLastValue;
          }
          if ("showSeriesLastValue" in i) {
            s.showSeriesLastValueProperty = true;
          }
          if ("showStudyLastValue" in i) {
            s.showStudyLastValueProperty = true;
          }
          if (!this.isSnapshot() && !this.readOnly() && "showCurrency" in i || "showUnit" in i) {
            (0, Be.migrateShowCurrencyAndShowUnitProperties)(i.showCurrency, i.showUnit);
            delete i.showCurrency;
            delete i.showUnit;
          }
          {
            const {
              paneProperties: t
            } = e.chartProperties;
            t.vertGridProperties = t.vertGridProperties || (0, dt.clone)(t.gridProperties);
            t.horzGridProperties = t.horzGridProperties || (0, dt.clone)(t.gridProperties);
            if (!("backgroundType" in t)) {
              t.backgroundType = So.ColorType.Solid;
            }
            if (!("separatorColor" in t)) {
              t.separatorColor = (0, k.getThemedColor)("color-chart-page-bg");
            }
            this._properties.childs().paneProperties.mergeAndFire(t);
          }
          this._properties.childs().scalesProperties.mergeAndFire(i);
          if (e.chartProperties.timezone) {
            this._properties.childs().timezone.setValue(e.chartProperties.timezone);
          }
          if (e.chartProperties.chartEventsSourceProperties && this._properties.hasChild("chartEventsSourceProperties")) {
            this._properties.childs().chartEventsSourceProperties.mergeAndFire(e.chartProperties.chartEventsSourceProperties);
          }
          if (e.chartProperties.tradingProperties && this._properties.hasChild("tradingProperties")) {
            if (e.chartProperties.tradingProperties.horizontalAlignment === undefined) {
              e.chartProperties.tradingProperties.horizontalAlignment = (o = e.chartProperties.tradingProperties.lineLength) <= 40 ? Eo.TradedGroupHorizontalAlignment.Right : o >= 60 ? Eo.TradedGroupHorizontalAlignment.Left : Eo.TradedGroupHorizontalAlignment.Center;
            }
            this._properties.childs().tradingProperties.mergeAndFire(e.chartProperties.tradingProperties);
          }
          this._timeScale.restoreState(e.timeScale, t);
          this._updateDateTimeFormatter();
        }
        var o;
        if (e.timeScale) {
          this._timeScale.restoreState(e.timeScale, t);
        }
        if (!this.readOnly()) {
          const t = this._getExceedingChildStudies(e.panes);
          if (t.length) {
            for (let i = e.panes.length - 1; i >= 0; --i) {
              const s = e.panes[i];
              for (let e = s.sources.length - 1; e >= 0; --e) {
                const i = s.sources[e];
                if (~t.indexOf(i)) {
                  s.sources.splice(e, 1);
                }
              }
              if (!s.sources.length) {
                e.panes.splice(i, 1);
              }
            }
            0;
          }
        }
        const r = e.version || 0;
        const a = e.panes;
        let l = "_seriesId";
        let c = 1;
        for (const e of a) {
          const t = e.sources.find(e => e.type === "MainSeries");
          if (t) {
            l = t.id;
            if (t.state) {
              c = t.state.style;
            }
            break;
          }
        }
        const d = true;
        const u = a[0];
        this.panes()[0].restoreState({
          state: u,
          withData: t,
          version: r,
          seriesId: l,
          settingsMigration: s,
          contentOverrides: i,
          restoreSilently: d,
          reason: 2,
          targetSeriesStyle: c
        });
        if (!this.panes()[0].mainDataSource()) {
          this.removePane(this.panes()[0]);
        }
        let _ = 1;
        for (let o = 1; o < e.panes.length; o++) {
          const n = e.panes[o];
          if (n.sources.length === 0 && (n.mode ?? Bi.PaneMode.Regular) === Bi.PaneMode.Regular) {
            r_.logWarn("Empty pane detected - restoring is skipped. idx=" + o + ", state=" + JSON.stringify(n));
            continue;
          }
          const a = this.panes()[_] || this.createPane();
          a.restoreState({
            state: n,
            withData: t,
            version: r,
            seriesId: l,
            settingsMigration: s,
            contentOverrides: i,
            restoreSilently: d,
            reason: 2,
            targetSeriesStyle: c
          });
          if (a.mainDataSource()) {
            _ += 1;
          } else {
            this.removePane(a);
          }
        }
        if (u.isCollapsed) {
          this._panes[0].collapsed().setValue(true);
        }
        this._invalidateBarColorerCaches();
        const p = this.dataSources();
        let m = 0;
        for (let e = 0; e < p.length; e++) {
          const t = p[e];
          if ((0, eo.isLineTool)(t)) {
            m++;
            t.calcIsActualSymbol();
          }
        }
        this.updateTimeScaleBaseIndex();
        this.recalculateAllPanes((0, Bt.globalChangeEvent)());
        this.fullUpdate();
        this.syncLollipopSources();
        const g = (0, n.ensureNotNull)(this.mainPane());
        for (const e of this._barsMarksSources) {
          this.detachSource(e);
          g.addDataSource(e, this._mainSeries.priceScale(), true);
        }
        let f = dc.TVLocalStorage.getItem("linetools_limit") || 1000;
        if (window.is_authenticated && window.user && window.user.settings) {
          f = window.user.settings.linetools_limit || f;
        }
        if (e.sessions) {
          this.sessions().restoreState(e.sessions, t);
        }
        if (e.lineToolsGroups) {
          this._lineToolsGroupModel = nd.fromState(this, e.lineToolsGroups);
        }
        if (m > f && m % 100 == 0) {
          return {
            lines_limit_exceeded: true,
            line_tools_count: m
          };
        } else {
          this.panes().forEach(e => this._dataSourceCollectionChanged.fire(e));
          this._lineToolsGroupModel.fireChangedAll();
          this._linkingGroupIndex.setValue(e.linkingGroup ?? null);
          this._restoringState = false;
          return {};
        }
      }
      shouldBeSavedEvenIfHidden() {
        return this._shouldBeSavedEvenIfHidden;
      }
      setShouldBeSavedEvenIfHidden(e) {
        this._shouldBeSavedEvenIfHidden = e;
      }
      externalTimeStamp(e) {
        const t = this.mainSeries().syncModel();
        return this.timeScale().points().roughTime(e, t && t.projectTime.bind(t));
      }
      syncLollipopSources() {
        this._lollipopSourcesWatcherLoader?.callFunction(() => {
          if (this._lollipopSourcesWatcher !== null) {
            this._lollipopSourcesWatcher.syncSources();
          }
        });
      }
      restoreChartEvents(e) {
        this._lollipopSourcesWatcherLoader?.callFunction(() => {
          if (this._lollipopSourcesWatcher !== null && this._options.chartEventsEnabled) {
            this._lollipopSourcesWatcher.restoreChartEvents(e);
          }
        });
      }
      recalcVisibleRangeStudies(e) {
        this._recalcVRStudiesParams.reasons.add(e);
        if (this._mainSeries.isStarted() && this._mainSeries.isCompleted()) {
          const t = (0, n.ensureDefined)(u_.get(e)).adapter;
          const i = Math.min(...Array.from(this._recalcVRStudiesParams.reasons).map(e => (0, n.ensureDefined)(u_.get(e))).filter(e => e.adapter === t).map(e => e.timeout));
          (0, n.ensureDefined)(this._recalcVisibleRangeStudiesImplDebouncedByAdapter.get(t)?.get(i))();
        } else {
          this._recalcVisibleRangeStudiesImpl(this._recalcVRStudiesParams);
        }
      }
      recalcColorStudies(e) {
        this._recalcColorStudiesParams.force = this._recalcColorStudiesParams.force || Boolean(e);
        this._recalcColorStudiesImplDebounced();
      }
      recalcStudyBasedLineTools() {
        this.dataSources().forEach(e => {
          if ((0, eo.isStudyLineTool)(e)) {
            e.recalcStudyIfNeeded();
          }
        });
      }
      alertsWatcher() {
        return this._alertsWatcher;
      }
      showLegend() {
        return this._showLegendProperty;
      }
      id() {
        return this._id;
      }
      selectPointMode() {
        return this._crossHairSelectPointMode;
      }
      cancelRequestSelectPoint() {
        this._crossHairSource.cancelRequestSelectPoint();
      }
      requestSelectPoint(e) {
        return this._crossHairSource.requestSelectPoint(e);
      }
      onPointSelected() {
        return this._crossHairSource.onPointSelected();
      }
      recalculatePriceRangeOnce() {
        const e = this.mainSeries();
        for (const t of this._panes) {
          for (const i of t.priceDataSources()) {
            if (i.symbolSource() === e) {
              i.disablePriceRangeReady();
            }
          }
        }
      }
      invalidate(e) {
        this._invalidateHandler?.(e);
      }
      appliedTimeFrame() {
        return this._appliedTimeFrame.appliedTimeFrame();
      }
      barsMarksSources() {
        return this._barsMarksSources;
      }
      createSyncPoint(e, t) {
        return (0, Eu.getDefault2Lazy)(this._syncPointCache, e.uniqueId, t.uniqueId, () => new ld(e, t));
      }
      isAutoSaveEnabled() {
        return this._isAutoSaveEnabled;
      }
      linkingGroupIndex() {
        return this._linkingGroupIndex;
      }
      studyAwareDefaultRightOffset() {
        if (this._timeScale.usePercentageRightOffset().value()) {
          return this._timeScale.percentsToBarIndexLength(this.studyAwareDefaultRightOffsetPercentage());
        } else {
          return Math.max(this._timeScale.defaultRightOffset().value(), this._cachedStudiesMaxOffset);
        }
      }
      studyAwareDefaultRightOffsetPercentage() {
        if (this._timeScale.usePercentageRightOffset().value()) {
          return Math.max(this._timeScale.defaultRightOffsetPercentage().value(), this._timeScale.barIndexLengthToPercents(this._cachedStudiesMaxOffset));
        } else {
          return this._timeScale.barIndexLengthToPercents(this.studyAwareDefaultRightOffset());
        }
      }
      clearAllStudies() {
        this.dataSources().forEach(e => e.clearData?.());
      }
      setTimeScaleAnimation(e, t) {
        const i = yo.InvalidationMask.light();
        const s = this._timeScale;
        i.setTimeScaleAnimation(e, t ?? s.width() - s.indexToCoordinate(s.baseIndex()));
        this.invalidate(i);
      }
      stopTimeScaleAnimation() {
        this._timeScale.endScroll();
        const e = yo.InvalidationMask.light();
        e.stopTimeScaleAnimation();
        this.invalidate(e);
      }
      lollipopSourcesOptions() {
        const e = this._options;
        return {
          chartEventsEnabled: !this._options.isSnapshot && this._options.chartEventsEnabled,
          esdEnabled: e.esdEnabled,
          newsNotificationsEnabled: e.newsNotificationsEnabled,
          continuousContractSwitchesEnabled: e.continuousContractSwitchesEnabled,
          futuresContractExpirationEnabled: e.futuresContractExpirationEnabled,
          latestUpdatesEnabled: e.latestUpdatesEnabled
        };
      }
      onSymbolIntervalChanged() {
        return this._symbolIntervalChanged;
      }
      setPriceAutoScale(e, t, i) {
        e.setPriceAutoScale(t, i);
        this.invalidate(this._paneInvalidationMask(e, yo.InvalidationLevel.Light));
      }
      calculateDefaultTags() {
        return this.dataSources().reduce((e, t) => {
          if (t.tags) {
            e.push(...t.tags());
          }
          return e;
        }, []);
      }
      _initAlertsList() {
        throw new Error("Not implemented");
      }
      _updateStudiesMaxOffset() {
        const e = Math.max(...this.allStudies().map(e => e.maxOffset().value()));
        this._cachedStudiesMaxOffset = e;
        const t = this._timeScale.rightOffset();
        if (t < 0) {
          return;
        }
        if (e <= t) {
          return;
        }
        const i = this._timeScale.logicalRange();
        if (i) {
          this._timeScale.zoomToBarsRange(i.left(), this._timeScale.baseIndex() + Math.max(this._timeScale.rightOffset(), e));
        } else {
          this._timeScale.setRightOffset(Math.max(t, e));
        }
      }
      _updateBaseIndex(e, t) {
        const i = this._timeScale;
        const s = i.baseIndex();
        const o = i.logicalRange();
        if (o !== null && t) {
          const t = o.contains(s);
          const n = e - s;
          const r = t ? null : i.rightOffset() - n;
          if (!this._options.shiftVisibleRangeOnNewBar && t) {
            const e = i.width() / i.barSpacing();
            const t = e / (e + n);
            const s = Math.max(i.minBarSpacing(), i.barSpacing() * t);
            i.setBarSpacing(s);
          }
          if (r !== null) {
            i.setRightOffset(r);
          }
        }
        i.setBaseIndex(e);
      }
      async _createLollipopSourcesWatcher() { }
      _updateDateTimeFormatter() {
        const e = be.dateFormatProperty.value();
        const t = undefined;
        this._dateFormatter = new od.DateFormatter(e, t);
        if (this.mainSeries().isDWM()) {
          this._dateTimeFormatter = new od.DateFormatter(e, t);
          this._timeFormatter = new $h.TimeFormatter((0, Kh.getHourMinuteFormat)(we.timeHoursFormatProperty.value()));
        } else {
          const i = Re.Interval.parse(this.mainSeries().interval());
          const s = (0, Kh.getTimeFormatForInterval)(i, we.timeHoursFormatProperty.value());
          this._dateTimeFormatter = new sd.DateTimeFormatter({
            dateFormat: e,
            withWeekday: t,
            timeFormat: s,
            dateTimeSeparator: "   "
          });
          this._timeFormatter = new $h.TimeFormatter(s);
        }
      }
      _invalidationMaskForSource(e, t = yo.InvalidationLevel.Light) {
        if (e === this.crosshairSource()) {
          return yo.InvalidationMask.cursor();
        }
        if (this._watermarkSource === e) {
          return this._paneInvalidationMask((0, n.ensureNotNull)(this.paneForSource(this.mainSeries())), t);
        }
        if (this._allCustomSources.indexOf(e) !== -1) {
          const e = new yo.InvalidationMask();
          e.invalidateAll(t);
          return e;
        }
        if (!(0, Vo.isDataSource)(e)) {
          return null;
        }
        if (e.isMultiPaneEnabled()) {
          return new yo.InvalidationMask(t);
        }
        const i = this.paneForSource(e);
        if (i !== null) {
          return this._paneInvalidationMask(i, t);
        } else {
          return null;
        }
      }
      _paneInvalidationMask(e, t = yo.InvalidationLevel.Light) {
        const i = new yo.InvalidationMask();
        const s = this._panes.indexOf(e);
        i.invalidateAllPane(s, t);
        return i;
      }
      _invalidationMaskForSourcePriceScale(e, t = yo.InvalidationLevel.Light) {
        if (!(0, Vo.isDataSource)(e)) {
          return new yo.InvalidationMask(t);
        }
        const i = this.paneForSource(e);
        if (i === null) {
          return null;
        }
        let s = e.priceScale();
        if (s === null) {
          return null;
        }
        const o = this._panes.indexOf(i);
        let n = i.priceScalePosition(s);
        if (n === "overlay") {
          const e = this._panes[o].defaultPriceScale();
          s = e;
          n = i.priceScalePosition(e);
        }
        const r = i.priceScaleIndex(s, n);
        if (r === undefined) {
          return null;
        }
        const a = new yo.InvalidationMask();
        a.invalidatePriceScale(o, n, r, t);
        return a;
      }
      _removeCustomSource(e) {
        const t = this._customSourcesMap.get(e);
        if (t === undefined) {
          r_.logWarn(`Attempt to remove custom source which does not exist in the model - "${e}"`);
          return;
        }
        r_.logNormal(`Removing custom source "${e}"`);
        this.selectionMacro(e => {
          e.removeSourceFromSelection(t);
        });
        if (this._hoveredSource === t) {
          this.setHoveredSource(null);
        }
        if (this._customSourceBeingMoved === t) {
          this.setMovingCustomSource(null, null);
        }
        const i = a_(this._bgCustomSources, t);
        const s = a_(this._fgCustomSources, t);
        const o = a_(this._topmostCustomSources, t);
        const r = a_(this._allCustomSources, t);
        (0, n.assert)(i || s || o, "Source should be presented in one of the layers");
        (0, n.assert)(r, "Source should be presented in the array");
        this._customSourcesMap.delete(e);
        t.destroy();
      }
      _updateShowLegendProperty() {
        const e = this._properties.childs().paneProperties.childs().legendProperties.childs().showLegend;
        const t = this._showLegendProperty;
        if (e.value()) {
          t.setValue(true);
        } else {
          for (const e of this._panes) {
            let i = 0;
            for (const s of e.priceDataSources()) {
              if (s.statusView() !== null && (i++, i >= 2)) {
                t.setValue(false);
                return;
              }
            }
          }
          t.setValue(true);
        }
      }
      _pointToPercentPosition(e, t) {
        return {
          x: e.x / this._timeScale.width(),
          y: e.y / (0, n.ensureNotNull)((0, n.ensureNotNull)(t.mainDataSource()).priceScale()).height()
        };
      }
      _percentPositionToPoint(e, t) {
        const i = e.x * this._timeScale.width();
        const s = e.y * (0, n.ensureNotNull)((0, n.ensureNotNull)(t.mainDataSource()).priceScale()).height();
        return new At.Point(i, s);
      }
      _recalcVisibleRangeStudiesImpl(e) {
        if (!this._mainSeries.isStarted() || !this._mainSeries.isCompleted()) {
          this._visibleRangeStudiesInputs.setValue(null);
          return;
        }
        if (this.timeScale().isEmpty()) {
          return;
        }
        const t = this.timeScale().visibleBarsStrictRange();
        if (t === null) {
          return;
        }
        const i = this._mainSeries.bars();
        const s = i.search(t.firstBar(), Yh.PlotRowSearchMode.NearestRight);
        const o = i.search(t.lastBar(), Yh.PlotRowSearchMode.NearestLeft);
        const n = i.lastIndex();
        const r = s ? s.index : undefined;
        const a = o ? o.index : undefined;
        const l = r === e.oldStartVisibleIndex;
        const c = a === e.oldEndVisibleIndex;
        const h = [Eo.RecalcVisibleRangeStudiesReason.SeriesRestart, Eo.RecalcVisibleRangeStudiesReason.SeriesCompleted, Eo.RecalcVisibleRangeStudiesReason.StudyCreation].some(t => e.reasons.has(t));
        if (!l || !c || !!h) {
          e.reasons.clear();
          e.oldStartVisibleIndex = r !== undefined ? r : NaN;
          e.oldEndVisibleIndex = a !== undefined ? a : NaN;
          this._visibleRangeStudiesInputs.setValue({
            firstVisibleBarTime: (s?.value[0] ?? 0) * 1000,
            lastVisibleBarTime: (o?.value[0] ?? 0) * 1000,
            subscribeRealtime: o?.index === n
          });
        }
      }
      _recalcColorStudiesImpl(e) {
        const t = this.backgroundColorAtYPercentFromTop(0.5);
        const i = this.dark().value() ? Lt.colorsPalette["color-cold-gray-200"] : Lt.colorsPalette["color-cold-gray-900"];
        const s = t === e.oldBgColor;
        const o = i === e.oldFgColor;
        if (s && o && !e.force) {
          return;
        }
        e.force = false;
        e.oldBgColor = t;
        e.oldFgColor = i;
        const n = e.studies ?? this.priceDataSources();
        e.studies = undefined;
        for (const e of n) {
          if ((0, Js.isStudy)(e)) {
            const s = e.metaInfo().inputs.filter(Vs.isStudyInputDependsOnChartColors);
            const o = e.properties().childs().inputs;
            s.forEach(e => {
              const s = e.id === Vs.ChartColorDependentStudyInputNames.FgColor ? i : t;
              o.childs()[e.id].setValueSilently(s);
            });
            if (s.length > 0) {
              o.fireChanged();
            }
          }
        }
      }
      _getAllSources(e) {
        const t = [];
        for (const i of this._panes) {
          const s = i.sourcesByGroup().allWithoutMultipane();
          for (const i of s) {
            if (e(i)) {
              t.push(i);
            }
          }
        }
        return t;
      }
      _invalidateBarColorerCaches() {
        this.mainSeries().invalidateBarColorerCache();
      }
      _addAlertLabelToChart(e) {
        throw new Error("Not implemented");
      }
      _removeAlertLabelFromChart(e) {
        throw new Error("Not implemented");
      }
      _removeAllAlertLabelsFromChart() {
        throw new Error("Not implemented");
      }
      _updateTimeScale(e) {
        const {
          index: t,
          zoffset: i,
          values: s,
          indexDiffs: o,
          baseIndex: n,
          marks: r,
          clearFlag: a
        } = e;
        if (a) {
          this._timeScale.reset();
          for (const e of this.dataSources()) {
            e.clearData?.();
          }
        }
        if (o.length > 0) {
          for (const e of this.dataSources()) {
            e.moveData?.(o);
          }
        }
        const l = this._timeScale.indexToTimePoint(this._timeScale.baseIndex());
        const c = this._timeScale.canNormalize();
        this._timeScale.update(t, i, s, r);
        const h = this._timeScale.points().range().value();
        let d = "ChartModel.prototype._updateTimeScale(" + t + "," + i + "," + s.length + "," + o.length + "," + r.length + "," + a + ")";
        d += "TimeScale: {first:" + (h?.firstIndex ?? null) + ",last:" + (h?.lastIndex ?? null) + "}";
        if (n === null) {
          this._timeScale.resetBaseIndex();
          const e = this._timeScale.rightOffset();
          if (e < 0) {
            this._timeScale.setRightOffset(this.studyAwareDefaultRightOffset());
          } else {
            this._timeScale.setRightOffset(Math.max(e, this._cachedStudiesMaxOffset));
          }
        } else if (n !== undefined) {
          const e = this._timeScale.indexToTimePoint(n);
          const t = l !== null && e !== null && e > l;
          this._updateBaseIndex(n, t);
        }
        r_.logDebug(d);
        if (!c && c !== this._timeScale.canNormalize()) {
          for (const e of this.dataSources()) {
            if (!!(0, eo.isLineTool)(e) && !e.isFixed() && !e.isSourceHidden()) {
              e.processHibernate();
            }
          }
        }
        for (const e of this.dataSources()) {
          e.updateAllViews({
            type: "data-source-change",
            sourceId: e.id(),
            clearData: true
          });
        }
        this.recalculateAllPanes((0, Bt.globalChangeEvent)());
        this.lightUpdate();
      }
      _getAvailableCurrencies() {
        if (!this.currencyConversionEnabled() || this.isSnapshot()) {
          return [];
        } else if ((0, dt.isArray)(this._availableCurrenciesList)) {
          return this._availableCurrenciesList;
        } else {
          if (this._availableCurrenciesList === null) {
            this._availableCurrenciesList = this.chartApi().availableCurrencies();
            this._availableCurrenciesList.then(e => {
              if (!this._destroyed) {
                this._availableCurrenciesList = e;
                this.fullUpdate();
              }
            }).catch(e => {
              r_.logWarn(`An error occurred while getting currencies config: ${e}`);
            });
          }
          return [];
        }
      }
      _getAvailableUnits() {
        if (!this.unitConversionEnabled() || this.isSnapshot()) {
          return {};
        } else if (this._availableUnitsObject instanceof Promise || this._availableUnitsObject === null) {
          if (this._availableUnitsObject === null) {
            this._availableUnitsObject = this.chartApi().availableUnits();
            this._availableUnitsObject.then(e => {
              if (!this._destroyed) {
                this._availableUnitsObject = e;
                this.fullUpdate();
              }
            }).catch(e => {
              r_.logWarn(`An error occurred while getting units config: ${e}`);
            });
          }
          return {};
        } else {
          return this._availableUnitsObject;
        }
      }
      _getAvailablePriceSources(e) {
        const t = this._availablePriceSourcesBySymbol.get(e);
        if (Array.isArray(t)) {
          return t;
        }
        if ((0, dt.isPromise)(t)) {
          return [];
        }
        const i = this.chartApi().availablePriceSources(e);
        this._availablePriceSourcesBySymbol.set(e, i);
        i.then(t => {
          if (!this._destroyed) {
            this._availablePriceSourcesBySymbol.set(e, t);
            this.fullUpdate();
          }
        }).catch(e => {
          r_.logWarn(`An error occurred while getting price sources config: ${e}`);
        });
        return [];
      }
      _clearAvailablePriceSources() {
        this._availablePriceSourcesBySymbol.clear();
      }
      _onSymbolIntervalChanged() {
        this._symbolIntervalChanged.fire();
      }
      _getBackgroundColor(e) {
        const t = this._properties.childs().paneProperties.childs();
        if (t.backgroundType.value() === So.ColorType.Gradient) {
          const i = t.backgroundGradientStartColor.value();
          const s = t.backgroundGradientEndColor.value();
          if (e) {
            return i;
          } else {
            return s;
          }
        }
        return t.background.value();
      }
      _getBackgroundCounterColor() {
        const e = this.backgroundColor().value();
        if ((0, kt.rgbToBlackWhiteString)((0, kt.parseRgb)(e), 150) === "black") {
          return "white";
        } else {
          return "black";
        }
      }
      _updateBackgroundColor() {
        this._backgroundColor.setValue(this._getBackgroundColor());
        this._backgroundTopColor.setValue(this._getBackgroundColor(true));
      }
      _syncCrosshair(e) {
        if (!this._isSettingsExternalPosition) {
          const t = this._undoModel.mainSeries();
          const i = t.syncModel();
          const s = this._undoModel.crosshairSource();
          const o = s.pane;
          if (i !== null && o !== null) {
            const n = {
              timeStamp: this._timeScale.points().roughTime(s.index, i.projectTime.bind(i)),
              syncSourceTarget: i.syncSourceTarget()
            };
            if (o.mainDataSource() === t) {
              n.price = s.price;
              n.symbol = t.symbol();
            }
            this._undoModel.syncCrosshair(n, e);
          }
          this._phantomSourceContainer.onCursorPositionUpdated();
        }
      }
      _gotoTimeImpl(e, t) {
        const i = this.timeScale();
        const s = this.mainSeries();
        let o;
        if (e !== undefined) {
          if (this._scrollingState) {
            this._scrollingState.deferred.reject();
          }
          o = (0, me.createDeferredPromise)();
          if (!s.isDWM()) {
            const t = s.symbolInfo();
            if (t !== null) {
              const i = (0, n.ensureNotNull)(this.timezoneExceptExchange().value());
              const o = (0, Ce.cal_to_utc)((0, Ce.get_timezone)(i), new Date(e));
              const r = (0, Md.createTimeToBarTimeAligner)(s.interval(), t)(o);
              e = (0, Ce.utc_to_cal)((0, Ce.get_timezone)(i), r).getTime();
            }
          }
          this._scrollingState = {
            targetDate: e,
            deferred: o,
            targetPointAlignment: t.targetPointAlignment,
            autoscaleAfterScroll: t.autoscaleAfterScroll
          };
        } else {
          if (!this._scrollingState) {
            r_.logError("scrollTo called without an argument");
            return Promise.reject();
          }
          e = this._scrollingState.targetDate;
          o = this._scrollingState.deferred;
        }
        if (i.tickMarks().minIndex === undefined) {
          o.resolve(undefined);
          return o.promise;
        }
        this.stopTimeScaleAnimation();
        let r = ((e, o) => {
          if ((e => (0, n.ensureNotNull)(i.tickMarks().indexToTime((0, n.ensureDefined)(i.tickMarks().minIndex))).valueOf() - e)(o) < 0) {
            let r = i.tickMarks().nearestIndex(o);
            const a = s.bars().lastIndex();
            if (a === null) {
              return "no_data";
            }
            r = Math.min(r, a);
            let l = (0, n.ensureNotNull)(i.tickMarks().indexToTime(r)).valueOf();
            while (l < o && r < a) {
              r++;
              l = (0, n.ensureNotNull)(i.tickMarks().indexToTime(r)).valueOf();
            }
            if ((0, n.ensureNotNull)(i.visibleBarsStrictRange()).contains(r) && !t.alignIfTargetPointIsVisible) {
              return "in_visible_range";
            }
            if (e !== "none") {
              const t = i.width();
              if (e === "left") {
                i.scrollToBar(r);
              } else {
                const e = i.indexToCoordinate(r);
                const s = i.coordinateToFloatIndex(e - t / 2);
                i.scrollToBar(s);
              }
            }
            return {
              timestamp: (0, n.ensureNotNull)(i.indexToTimePoint(r))
            };
          }
          return "no_data";
        })(this._scrollingState.targetPointAlignment, this._scrollingState.targetDate);
        if (r === "no_data") {
          const t = (0, n.ensureDefined)(i.tickMarks().minIndex);
          const o = (0, n.ensureNotNull)(i.visibleBarsStrictRange());
          const a = o.lastBar() - o.firstBar();
          if (s.requestMoreDataAvailable()) {
            const t = i.tickMarks().estimateLeft(e);
            i.requestMoreHistoryPoints(Math.ceil(t + a / 2));
          } else {
            i.zoomToBarsRange(t - a / 2, t + a / 2);
            r = {
              timestamp: (0, n.ensureNotNull)(i.indexToTimePoint(t)),
              eod: true
            };
          }
        }
        if (r !== "no_data" && r !== "in_visible_range") {
          if (this._scrollingState.autoscaleAfterScroll) {
            const e = (0, n.ensureNotNull)(i.visibleBarsStrictRange());
            for (const t of this.panes()) {
              for (const i of t.leftPriceScales()) {
                i.recalculatePriceRange(e);
              }
              for (const i of t.rightPriceScales()) {
                i.recalculatePriceRange(e);
              }
            }
          }
          this.fullUpdate();
          this._scrollingState = null;
          o.resolve(r);
        }
        if (r === "in_visible_range") {
          o.reject("already visible");
          this._scrollingState = null;
        }
        return o.promise;
      }
      _setCorrectedPositionToCrosshair(e, t, i) {
        this.crosshairSource().setPosition(e, t, i);
      }
      _onSymbolSourceCollectionChanged(e) {
        this._clearAvailablePriceSources();
        this._recalcAdjustForDividendsAvailability();
        this._symbolSourceCollectionChanged.fire(e);
      }
      _onPriceSourcesCollectionChanged(e) {
        if (this._panes.some(e => e.hasDataSource(this._mainSeries))) {
          this._studiesWV.setValue(this.allStudies());
          this._studiesExcludeInternalWV.setValue(this.allStudies(true));
        }
      }
      _unmergeAvailable(e) {
        return e === this._mainSeries || (0, Js.isStudy)(e) && !e.isLinkedToSeries() && !(0, Zu.isNonSeriesStudy)(e) && e.showInObjectTree();
      }
      _getExceedingChildStudies(e) {
        let t = [];
        for (let i = 0; i < e.length; ++i) {
          t = t.concat(e[i].sources || []);
        }
        let i = 0;
        const s = [];
        const o = {};
        let n = 0;
        let r = 1000000;
        while (t.length && --r) {
          const e = t[n];
          if (e.ownerSource && o[e.ownerSource] || !e.ownerSource) {
            o[e.id] = e;
            t.splice(t.indexOf(e), 1);
            if (e.ownerSource && (0, pt.isStudyState)(e) && e.state && e.state.isChildStudy && ++i > 1) {
              s.push(e);
            }
          }
          n = (n + 1) % t.length;
        }
        return s;
      }
      _sendTo(e, t) {
        const i = new Map();
        e.forEach(e => {
          const t = this.paneForSource(e);
          if (!t) {
            return;
          }
          const s = this._panes.indexOf(t);
          if (!i.has(s)) {
            i.set(s, []);
          }
          i.get(s)?.push(e);
        });
        for (const [e, s] of i.entries()) {
          t(this._panes[e], s);
        }
        this.fullUpdate();
      }
    }
    var m_ = i(3503);
    const g_ = new Di.TranslatedString("zoom", a.t(null, undefined, i(91084)));
    class f_ extends tt.UndoCommand {
      constructor(e, t, i, s, o, n) {
        super(g_);
        this._barSpacing = null;
        this._rightBarsOffset = null;
        this._leftBarsOffset = null;
        this._priceMode = null;
        this._model = e;
        this._startBar = t;
        this._endBar = i;
        this._startPrice = s;
        this._endPrice = o;
        this._pane = n;
      }
      redo() {
        const e = (0, n.ensureNotNull)(this._model.timeScale().visibleBarsStrictRange());
        this._leftBarsOffset = e.firstBar() - this._startBar;
        this._rightBarsOffset = e.lastBar() - this._endBar;
        this._barSpacing = this._model.timeScale().barSpacing();
        this._priceMode = this._pane.defaultPriceScale().mode();
        this._model.zoomToViewport(this._startBar, this._endBar, this._startPrice, this._endPrice, this._pane);
      }
      undo() {
        const e = this._model.timeScale();
        const t = this._pane.defaultPriceScale();
        const i = (0, n.ensureNotNull)(e.visibleBarsStrictRange());
        e.setBarSpacing((0, n.ensureNotNull)(this._barSpacing));
        e.zoomToBarsRange(i.firstBar() + (0, n.ensureNotNull)(this._leftBarsOffset), i.lastBar() + (0, n.ensureNotNull)(this._rightBarsOffset));
        t.setMode((0, n.ensureNotNull)(this._priceMode));
        t.recalculatePriceRange((0, n.ensureNotNull)(e.visibleBarsStrictRange()));
        this._model.recalculateAllPanes((0, Bt.viewportChangeEvent)());
        this._model.lightUpdate();
      }
    }
    const y_ = (0, ae.getLogger)("Chart.ChartUndoModel");
    const v_ = new Di.TranslatedString("zoom", a.t(null, undefined, i(91084)));
    class S_ extends tt.UndoCommand {
      constructor(e, t, i) {
        super(v_);
        this._baseCmd = e;
        this._zoomStack = t;
        this._inOut = i;
      }
      undo(e) {
        if (this._inOut) {
          if (this._baseCmd !== this._zoomStack.head()) {
            y_.logDebug("zoom stack inconsistency");
            return;
          }
          this._baseCmd.undo(e);
          this._zoomStack.pop();
        } else {
          this._baseCmd.redo(e);
          this._zoomStack.push(this._baseCmd);
        }
      }
      redo(e) {
        if (this._inOut) {
          this._baseCmd.redo(e);
          this._zoomStack.push(this._baseCmd);
        } else {
          if (this._baseCmd !== this._zoomStack.head()) {
            y_.logDebug("zoom stack inconsistency");
            return;
          }
          this._baseCmd.undo(e);
          this._zoomStack.pop();
        }
      }
    }
    const b_ = new Di.TranslatedString("stop syncing drawing", a.t(null, undefined, i(3350)));
    class w_ extends tt.UndoCommand {
      constructor(e, t) {
        super(b_, undefined, !$r.lineToolsDoNotAffectChartInvalidation);
        this._model = e;
        this._sourceId = t.id();
        this._linkKey = t.linkKey().value();
      }
      redo() {
        (0, n.ensureNotNull)(this._model.dataSourceForId(this._sourceId)).linkKey().setValue(null);
      }
      undo() {
        (0, n.ensureNotNull)(this._model.dataSourceForId(this._sourceId)).linkKey().setValue(this._linkKey);
      }
    }
    const C_ = new Di.TranslatedString("restore defaults", a.t(null, undefined, i(85815)));
    class P_ extends tt.UndoCommand {
      constructor(e, t, i = C_, s = true) {
        super(i, undefined, s);
        this._chartModel = e;
        this._defaultProperty = t;
        this._state = t.state();
      }
      redo() {
        this._chartModel.restoreFactoryDefaults(this._defaultProperty);
      }
      undo() {
        this._defaultProperty.mergeAndFire(this._state);
        this._chartModel.mainSeries().onChartStyleChanged();
      }
    }
    class T_ extends P_ {
      constructor(e, t, i, s) {
        super(e, t, i, s ?? !$r.lineToolsDoNotAffectChartInvalidation);
      }
      redo() {
        this._defaultProperty.child("intervalsVisibilities")?.mergeAndFire(Yu.intervalsVisibilitiesDefaults);
        super.redo();
      }
    }
    const x_ = new Di.TranslatedString("restore study defaults", a.t(null, undefined, i(96881)));
    class I_ extends T_ {
      constructor(e, t, i = x_) {
        super(e, t.properties(), i, true);
        this._study = t;
      }
      redo() {
        super.redo();
        this._chartModel.recalcColorStudies(true);
        this._patchProperties();
      }
      undo() {
        super.undo();
        this._chartModel.recalcColorStudies(true);
        this._patchProperties();
      }
      _patchProperties() {
        0;
      }
    }
    function M_(e, t) {
      return (0, li.extractState)(e, t.map(e => e.path));
    }
    const A_ = new Di.TranslatedString("apply chart theme", a.t(null, undefined, i(68231)));
    class L_ extends tt.UndoCommand {
      constructor(e, t, i) {
        super(A_);
        this._model = e;
        if (t.sessions) {
          this._newSessionProps = i ? t.sessions : M_(t.sessions, (0, li.extractThemedColors)(xs.lightTheme.content.sessions, xs.darkTheme.content.sessions));
        }
        xh(t.mainSourceProperties.candleStyle);
        xh(t.mainSourceProperties.hollowCandleStyle);
        xh(t.mainSourceProperties.haStyle);
        const s = t;
        s.chartProperties = s.chartProperties ?? {
          paneProperties: {},
          scalesProperties: undefined
        };
        const o = s.chartProperties.paneProperties.gridProperties;
        s.chartProperties.paneProperties.vertGridProperties = s.chartProperties.paneProperties.vertGridProperties ?? o;
        s.chartProperties.paneProperties.horzGridProperties = s.chartProperties.paneProperties.horzGridProperties ?? o;
        const n = this._model.properties().state().paneProperties.legendProperties;
        delete n.backgroundTransparency;
        const r = s.chartProperties.paneProperties;
        if (i) {
          r.legendProperties = {
            ...r.legendProperties,
            ...n
          };
        }
        const a = (0, hc.default)((0, h.factoryDefaults)("chartproperties"));
        delete a.timezone;
        if (i) {
          const e = a.paneProperties;
          if (e) {
            delete e.topMargin;
            delete e.bottomMargin;
          }
        }
        const l = (0, ge.deepExtend)({}, a, t.chartProperties);
        this._newChartProps = i ? l : M_(l, (0, li.extractThemedColors)(xs.lightTheme.content.chartProperties, xs.darkTheme.content.chartProperties));
        if (e.timeScale().preserveBarSpacing() && "barSpacing" in this._newChartProps.scalesProperties) {
          delete this._newChartProps.scalesProperties.barSpacing;
        }
        Ih(t.mainSourceProperties.lineStyle);
        Ih(t.mainSourceProperties.lineWithMarkersStyle);
        Ih(t.mainSourceProperties.steplineStyle);
        const c = (0, h.factoryDefaults)("chartproperties.mainSeriesProperties");
        const d = (0, ge.deepExtend)({}, c, t.mainSourceProperties);
        this._newSeriesProps = i ? d : M_(d, (0, li.extractThemedColors)(xs.lightTheme.content.mainSourceProperties, xs.darkTheme.content.mainSourceProperties));
        this._oldChartProps = i ? e.properties().state() : e.properties().themeState();
        this._oldSeriesProps = i ? e.mainSeries().properties().state() : e.mainSeries().properties().themeState();
        this._oldSessionProps = i ? this._model.sessions().properties().state() : this._model.sessions().properties().themeState();
      }
      undo() {
        this._merge(this._oldChartProps, this._oldSeriesProps, this._oldSessionProps);
        this._model.mainSeries().onChartStyleChanged();
        this._model.updateScales();
        this._model.chartThemeLoaded();
      }
      redo() {
        this._merge(this._newChartProps, this._newSeriesProps, this._newSessionProps);
        this._model.mainSeries().onChartStyleChanged();
        this._model.updateScales();
        this._model.chartThemeLoaded();
      }
      _merge(e, t, i) {
        const s = this._model;
        (0, li.allowSavingDefaults)(true);
        const o = s.properties();
        const n = s.mainSeries().properties();
        const r = s.sessions().properties();
        o.applyDefaultThemedProperties(D.watchedTheme.value());
        o.mergeAndFire(e);
        o.saveDefaults();
        if ("priceAxisProperties" in t) {
          s.mainSeries().priceScale().setMode({
            autoScale: t.priceAxisProperties?.autoScale,
            percentage: t.priceAxisProperties?.percentage,
            log: t.priceAxisProperties?.log,
            lockScale: t.priceAxisProperties?.lockScale
          });
        }
        n.applyDefaultThemedProperties(D.watchedTheme.value());
        n.mergeAndFire(t);
        n.saveDefaults();
        s.mainSeries().createPaneView();
        s.mainSeries().invalidateBarStylesCache();
        s.recalculateAllPanes((0, Bt.globalChangeEvent)());
        if (i) {
          r.applyDefaultThemedProperties(D.watchedTheme.value());
          r.loadThemeState(i);
          r.saveDefaults();
        }
        s.fullUpdate();
        (0, li.allowSavingDefaults)(false);
      }
    }
    const k_ = new Di.TranslatedString("change resolution", a.t(null, undefined, i(32829)));
    class D_ extends Jl {
      constructor(e, t, i) {
        super(k_, e, function (e, t) {
          let i;
          const s = (0, yt.isRangeStyle)(e.style());
          const o = Re.Interval.isRange(t);
          if (!s && o) {
            i = 11;
          } else if (s && !o) {
            i = (0, yt.getLastUsedStyle)();
          }
          return {
            interval: t,
            style: i
          };
        }(e, t), i);
        this._resolution = t;
      }
      canMerge(e) {
        return e instanceof D_ && e._resolution === this._resolution && super.canMerge(e);
      }
      _showFade(e, t) {
        return true;
      }
    }
    class E_ extends rt {
      constructor() {
        super(...arguments);
        this._firstRedo = true;
      }
      redo() {
        if (!this._firstRedo) {
          (0, ki.muteLinkingGroup)(this._newValue, true);
        }
        (0, ki.muteLinkingGroup)(this._oldValue, true);
        super.redo();
        if (!this._firstRedo) {
          (0, ki.muteLinkingGroup)(this._newValue, false);
        }
        (0, ki.muteLinkingGroup)(this._oldValue, false);
        this._firstRedo = false;
      }
      undo() {
        (0, ki.muteLinkingGroup)(this._newValue, true);
        (0, ki.muteLinkingGroup)(this._oldValue, true);
        super.undo();
        (0, ki.muteLinkingGroup)(this._newValue, false);
        (0, ki.muteLinkingGroup)(this._oldValue, false);
      }
    }
    var B_ = i(15491);
    class V_ extends tt.UndoCommand {
      constructor(e, t, i) {
        super(i);
        this._chartModel = e;
        this._stubDescriptor = (0, n.ensureNotNull)(t.getDescriptor());
      }
      redo() {
        if (!this._chartModel.dataSourceForId(this._stubDescriptor.id)) {
          this._chartModel.restoreStudyStub(this._stubDescriptor);
        }
      }
      undo() {
        this._chartModel.removeStudyStub(this._stubDescriptor.id);
      }
    }
    class R_ extends tt.UndoCommand {
      constructor(e, t, i) {
        super(i, undefined, !$r.lineToolsDoNotAffectChartInvalidation);
        this._source = e;
        this._newState = t;
        this._oldState = e.properties().state();
      }
      redo() {
        this._source.applyTemplate(this._newState);
      }
      undo() {
        this._source.applyTemplate(this._oldState);
      }
    }
    var N_ = i(30141);
    var O_ = i(79320);
    const F_ = new Di.TranslatedString("apply all chart properties", a.t(null, undefined, i(99551)));
    class W_ extends tt.UndoCommand {
      constructor(e) {
        super(F_);
        this._trading = null;
        this._oldNoConfirmEnabled = null;
        this._oldShowOnlyRejectionNotifications = null;
        this._oldShowPricesWithZeroVolume = null;
        this._oldShowPricesWithSpread = null;
        this._oldOrderExecutedSoundEnabled = null;
        this._prevWatermarkPreferences = null;
        this._prevAlertLabelsPreferences = null;
        this._prevAlertNotificationsPreferences = null;
        this._model = e;
        this._trading = (0, O_.tradingService)();
        if (this._trading !== null) {
          this._oldNoConfirmEnabled = this._trading.noConfirmEnabled.value();
          this._oldShowOnlyRejectionNotifications = this._trading.showOnlyRejectionNotifications.value();
          this._oldShowPricesWithZeroVolume = this._trading.showPricesWith().zeroVolume.value();
          this._oldShowPricesWithSpread = this._trading.showPricesWith().spread.value();
          this._oldOrderExecutedSoundEnabled = this._trading.orderExecutedSoundParams.enabled.value();
        }
        this._defaultsPreferences = function (e, t, i = qu, s = true) {
          const o = {
            timeScale: {
              defaultRightOffset: e.timeScale().rightOffsetDefaultValue(),
              defaultRightOffsetPercentage: e.timeScale().defaultRightOffsetPercentage().value(),
              usePercentageRightOffset: e.timeScale().usePercentageRightOffset().value()
            },
            mainSeries: {},
            sessions: {},
            paneProperties: {},
            scalesProperties: {},
            chartEventsSourceProperties: {},
            tradingProperties: {},
            priceScaleSelectionStrategyName: "auto"
          };
          const n = ["timeScale", "mainSeries", "sessions"];
          const r = i.mainSeries;
          const a = Object.keys(i);
          const l = Object.keys(r);
          const c = i.sessions;
          const h = Object.keys(c);
          const d = e.mainSeries().properties().factoryDefaults();
          const u = e.properties().factoryDefaults();
          const _ = e.sessions().properties().factoryDefaults();
          l.forEach(e => {
            if (!s || e !== "style") {
              o.mainSeries[e] = $u(e, d, r, "mainSeries", false);
            }
          });
          a.forEach(e => {
            if (!n.includes(e)) {
              o[e] = $u(e, u, i, "preferences", false);
            }
          });
          h.forEach(e => {
            o.sessions[e] = $u(e, _, c, "sessions", false);
          });
          return o;
        }(this._model, this._model.mainSeries());
        this._oldPreferences = e.preferences();
        this._prevDateFormat = be.dateFormatProperty.value();
        this._prevTimeHoursFormat = we.timeHoursFormatProperty.value();
        this._prevAddPlusButton = Od.addPlusButtonProperty.value();
        this._prevShowOpenMarkerStatus = N_.showMarketOpenStatusProperty.value();
        this._prevCurrencyUnitVisibility = (0, Be.currencyUnitVisibilityProperty)().value();
        this._prevAutoLogButtonsVisibility = (0, on.autoLogButtonsVisibilityProperty)().value();
        this._prevNavigationButtonsVisibility = (0, ve.property)().value();
        this._prevPaneButtonsVisibility = (0, Se.property)().value();
        const t = this._model.watermarkSource();
        if (t !== null) {
          this._prevWatermarkPreferences = t.properties().state();
        }
      }
      redo() {
        if (this._trading !== null) {
          this._trading.noConfirmEnabled.setValue(false);
          this._trading.showOnlyRejectionNotifications.setValue(false);
          this._trading.showPricesWith().zeroVolume.setValue(true);
          this._trading.showPricesWith().spread.setValue(true);
          this._trading.orderExecutedSoundParams.enabled.setValue(false);
        }
        this._model.applyPreferences(this._defaultsPreferences);
        this._model.updateScales();
        (0, be.restoreDateFormatSettingsValue)();
        (0, we.restoreTimeHoursFormatSettingsValue)();
        (0, Od.restoreAddPlusButtonSettingsValue)();
        (0, N_.restoreShowMarketOpenStatusProperty)();
        (0, Be.restoreCurrencyUnitVisibilitySettingsValue)();
        (0, on.restoreAutoLogButtonsVisibilitySettingsValue)();
        (0, ve.restoreNavigationButtonsVisibilitySettingsValue)();
        (0, Se.restorePaneButtonsVisibilitySettingsValue)();
        const e = this._model.watermarkSource();
        if (e !== null) {
          e.restorePropertiesDefaults();
        }
      }
      undo() {
        if (this._trading !== null) {
          this._trading.noConfirmEnabled.setValue((0, n.ensureNotNull)(this._oldNoConfirmEnabled));
          this._trading.showOnlyRejectionNotifications.setValue((0, n.ensureNotNull)(this._oldShowOnlyRejectionNotifications));
          this._trading.showPricesWith().zeroVolume.setValue((0, n.ensureNotNull)(this._oldShowPricesWithZeroVolume));
          this._trading.showPricesWith().spread.setValue((0, n.ensureNotNull)(this._oldShowPricesWithSpread));
          this._trading.orderExecutedSoundParams.enabled.setValue((0, n.ensureNotNull)(this._oldOrderExecutedSoundEnabled));
        }
        this._model.applyPreferences(this._oldPreferences);
        this._model.updateScales();
        be.dateFormatProperty.setValue(this._prevDateFormat);
        we.timeHoursFormatProperty.setValue(this._prevTimeHoursFormat);
        N_.showMarketOpenStatusProperty.setValue(this._prevShowOpenMarkerStatus);
        Od.addPlusButtonProperty.setValue(this._prevAddPlusButton);
        (0, Be.currencyUnitVisibilityProperty)().setValue(this._prevCurrencyUnitVisibility);
        (0, on.autoLogButtonsVisibilityProperty)().setValue(this._prevAutoLogButtonsVisibility);
        (0, ve.property)().setValue(this._prevNavigationButtonsVisibility);
        (0, Se.property)().setValue(this._prevPaneButtonsVisibility);
        const e = this._model.watermarkSource();
        if (e !== null && this._prevWatermarkPreferences !== null) {
          e.properties().mergeAndFire(this._prevWatermarkPreferences);
        }
      }
    }
    class H_ extends tt.UndoCommand {
      constructor(e, t, i, s) {
        super(i);
        this._property = e;
        this._newValue = t;
        this._model = s;
        this._priceScale = this._model.mainSeries().priceScale();
        this._oldValue = this._property.value();
        this._oldMode = this._priceScale.mode();
      }
      redo() {
        this._oldValue = this._property.value();
        this._oldMode = this._priceScale.mode();
        (0, li.allowSavingDefaults)(true);
        this._priceScale.setMode({
          autoScale: false,
          percentage: false,
          log: false
        });
        this._property.setValue(this._newValue);
        (0, li.allowSavingDefaults)(false);
        this._model.recalculateAllPanes((0, Bt.viewportChangeEvent)());
        this._model.lightUpdate();
      }
      undo() {
        (0, li.allowSavingDefaults)(true);
        this._property.setValue(this._oldValue);
        this._priceScale.setMode(this._oldMode);
        (0, li.allowSavingDefaults)(false);
        this._model.recalculateAllPanes((0, Bt.viewportChangeEvent)());
        this._model.lightUpdate();
      }
    }
    class z_ {
      constructor(e) {
        this._leftScales = e.leftPriceScales().map(e => e.id());
        this._rightScales = e.rightPriceScales().map(e => e.id());
      }
      restorePane(e) {
        this._leftScales.reverse().map(t => (0, n.ensureNotNull)(e.getPriceScaleById(t))).forEach(t => e.movePriceScale(t, "left"));
        this._rightScales.reverse().map(t => (0, n.ensureNotNull)(e.getPriceScaleById(t))).forEach(t => e.movePriceScale(t, "right"));
      }
    }
    class U_ extends tt.UndoCommand {
      constructor(e, t, i) {
        super(i);
        this._chartModel = e;
        this._targetStrategy = (0, qc.createPriceScaleSelectionStrategy)(t);
        this._initialState = e.panes().map(e => new z_(e));
      }
      redo() {
        this._chartModel.panes().forEach(e => e.setPriceScaleSelectionStrategy(this._targetStrategy));
        this._chartModel.fullUpdate();
      }
      undo() {
        const e = this._chartModel.panes();
        for (let t = 0; t < e.length; t++) {
          this._initialState[t].restorePane(e[t]);
        }
        this._chartModel.fullUpdate();
      }
    }
    const j_ = new Di.TranslatedString("send {title} backward", a.t(null, undefined, i(40962)));
    const G_ = new Di.TranslatedString("bring {title} forward", a.t(null, undefined, i(41966)));
    const q_ = new Di.TranslatedString("insert {title} after {target}", a.t(null, undefined, i(32960)));
    const $_ = new Di.TranslatedString("insert {title} before {target}", a.t(null, undefined, i(57106)));
    const K_ = new Di.TranslatedString("cut {title}", a.t(null, undefined, i(11500)));
    const Y_ = new Di.TranslatedString("cut sources", a.t(null, undefined, i(94227)));
    const Z_ = new Di.TranslatedString("remove {title}", a.t(null, undefined, i(94543)));
    const X_ = new Di.TranslatedString("remove drawings group", a.t(null, undefined, i(1193)));
    const J_ = new Di.TranslatedString("move scale", a.t(null, undefined, i(44854)));
    const Q_ = new Di.TranslatedString("stop syncing line tool(s)", a.t(null, undefined, i(49183)));
    const ep = new Di.TranslatedString("zoom out", a.t(null, undefined, i(73638)));
    const tp = new Di.TranslatedString("zoom in", a.t(null, undefined, i(49856)));
    const ip = new Di.TranslatedString("move drawing(s)", a.t(null, undefined, i(52510)));
    const sp = new Di.TranslatedString("load default drawing template", a.t(null, undefined, i(43364)));
    const op = new Di.TranslatedString("apply factory defaults to selected sources", a.t(null, undefined, i(27851)));
    const np = new Di.TranslatedString("change currency", a.t(null, undefined, i(32302)));
    const rp = new Di.TranslatedString("change unit", a.t(null, undefined, i(85975)));
    const ap = new Di.TranslatedString("clone line tools", a.t(null, undefined, i(32943)));
    const lp = new Di.TranslatedString("merge up", a.t(null, undefined, i(52458)));
    const cp = new Di.TranslatedString("merge down", a.t(null, undefined, i(78055)));
    const hp = new Di.TranslatedString("merge to pane", a.t(null, undefined, i(41866)));
    const dp = new Di.TranslatedString("unmerge up", a.t(null, undefined, i(79443)));
    const up = new Di.TranslatedString("unmerge down", a.t(null, undefined, i(46453)));
    const _p = new Di.TranslatedString("unmerge to new bottom pane", a.t(null, undefined, i(81576)));
    const pp = new Di.TranslatedString("move {title} to new right scale", a.t(null, undefined, i(77482)));
    const mp = new Di.TranslatedString("move {title} to new left scale", a.t(null, undefined, i(58228)));
    const gp = new Di.TranslatedString("make {title} no scale (Full screen)", a.t(null, undefined, i(10625)));
    const fp = new Di.TranslatedString("scroll time", a.t(null, undefined, i(87840)));
    const yp = new Di.TranslatedString("scale time", a.t(null, undefined, i(70771)));
    const vp = new Di.TranslatedString("reset time scale", a.t(null, undefined, i(17336)));
    const Sp = new Di.TranslatedString("reset scales", a.t(null, undefined, i(3323)));
    const bp = new Di.TranslatedString("create {tool}", a.t(null, undefined, i(12898)));
    const wp = new Di.TranslatedString("paste {title}", a.t(null, undefined, i(57010)));
    const Cp = new Di.TranslatedString("insert {title}", a.t(null, undefined, i(48818)));
    const Pp = new Di.TranslatedString("remove pane", a.t(null, undefined, i(93333)));
    const Tp = new Di.TranslatedString("invert scale", a.t(null, undefined, i(6830)));
    const xp = new Di.TranslatedString("toggle auto scale", a.t(null, undefined, i(42240)));
    const Ip = new Di.TranslatedString("toggle lock scale", a.t(null, undefined, i(49695)));
    const Mp = new Di.TranslatedString("toggle regular scale", a.t(null, undefined, i(80688)));
    const Ap = new Di.TranslatedString("toggle indexed to 100 scale", a.t(null, undefined, i(24736)));
    const Lp = new Di.TranslatedString("toggle percentage scale", a.t(null, undefined, i(98994)));
    const kp = new Di.TranslatedString("toggle log scale", a.t(null, undefined, i(49403)));
    const Dp = new Di.TranslatedString("move left", a.t(null, undefined, i(79209)));
    const Ep = new Di.TranslatedString("move right", a.t(null, undefined, i(60114)));
    const Bp = new Di.TranslatedString("align to 45 degrees", a.t(null, undefined, i(4128)));
    const Vp = new Di.TranslatedString("set price scale selection strategy to {title}", a.t(null, undefined, i(82241)));
    const Rp = new Di.TranslatedString("remove all indicators", a.t(null, undefined, i(60806)));
    const Np = new Di.TranslatedString("remove drawings", a.t(null, undefined, i(30538)));
    const Op = new Di.TranslatedString("remove all indicators and drawing tools", a.t(null, undefined, i(29096)));
    new Di.TranslatedString("turn line tools sharing off", a.t(null, undefined, i(8040)));
    new Di.TranslatedString("share line tools in layout", a.t(null, undefined, i(90221)));
    new Di.TranslatedString("share line tools globally", a.t(null, undefined, i(63934)));
    const Fp = new Di.TranslatedString("change linking group", a.t(null, undefined, i(88849)));
    new Di.TranslatedString("apply drawing template", a.t(null, undefined, i(89720)));
    const Wp = (0, ae.getLogger)("Chart.ChartUndoModel");
    var Hp;
    function zp(e, t) {
      return {
        bringForwardEnabled: e.bringForwardEnabled || t.bringForwardEnabled,
        bringToFrontEnabled: e.bringToFrontEnabled || t.bringToFrontEnabled,
        sendBackwardEnabled: e.sendBackwardEnabled || t.sendBackwardEnabled,
        sendToBackEnabled: e.sendToBackEnabled || t.sendToBackEnabled
      };
    }
    (function (e) {
      e[e.Up = 0] = "Up";
      e[e.Down = 1] = "Down";
      e[e.Left = 2] = "Left";
      e[e.Right = 3] = "Right";
    })(Hp ||= {});
    const Up = (0, l.enabled)("saveload_separate_drawings_storage");
    function jp() {
      if (Up) {
        if ((0, lt.drawOnAllCharts)().value()) {
          if ((0, lt.drawOnAllChartsMode)().value() === 1) {
            return 1;
          } else {
            return 2;
          }
        } else {
          return 0;
        }
      } else if ((0, lt.drawOnAllCharts)().value()) {
        return 1;
      } else {
        return 0;
      }
    }
    function Gp(e, t) {
      (0, Ar.showTooManyStudiesNotice)(t.limitValue);
    }
    class qp extends Ir() {
      constructor(e, t, i, s, o, n, r, a, l, c, h, d) {
        super();
        this._createLineCommand = null;
        this._initialTimeScrollState = null;
        this._initialTimeScrollPos = null;
        this._initialTimeScaleState = null;
        this._scalePriceInfo = null;
        this._currentSourceMoveCommand = null;
        this._currentLineChangeCommand = null;
        this._currentCustomMoveCommand = null;
        this._zoomStack = new st();
        this._initialPriceScrollState = null;
        this._initialPriceScrollPos = null;
        this._chartWidget = n;
        this.m_model = new p_(e, t, i, s, o, this, a, l, c, h, d);
        this._undoHistory = r;
        this._lineToolsGroupController = new hl({
          model: this._model.bind(this),
          pushUndoCommand: this._pushUndoCommand.bind(this),
          beginUndoMacro: e => {
            this._undoHistory.beginUndoMacro(e);
          },
          endUndoMacro: this._undoHistory.endUndoMacro.bind(this._undoHistory),
          emitEvent: this.emitEvent.bind(this)
        });
      }
      id() {
        return this._model().id();
      }
      undoHistory() {
        return this._undoHistory;
      }
      setWatchedValue(e, t, i) {
        this._undoHistory.setWatchedValue(e, t, i);
      }
      lineToolsGroupController() {
        return this._lineToolsGroupController;
      }
      mergeAllScales(e) {
        (function (e, t) {
          e.beginUndoMacro(t === "left" ? Ur : jr);
          e.model().panes().forEach(i => {
            const s = t === "left" ? i.rightPriceScales() : i.leftPriceScales();
            const o = (t === "left" ? i.leftPriceScales() : i.rightPriceScales()).concat(s);
            const n = i.priceScalePosition(i.defaultPriceScale()) === "overlay" ? o[0] : i.defaultPriceScale();
            e.movePriceScale(i, n, t, 0);
            o.forEach(t => {
              if (t === n) {
                return;
              }
              let s = t.mainSource();
              while (s !== null) {
                e.moveToScale(s, i, n, null, true);
                const o = t.mainSource();
                if (o === s) {
                  Gr.logError("Loop detected while trying to merge scales");
                  break;
                }
                s = o;
              }
            });
          });
          e.endUndoMacro();
          e.model().fullUpdate();
        })(this, e);
      }
      movePriceScale(e, t, i, s) {
        const o = new qr(this._model(), e, t, i, s, J_);
        this._pushUndoCommand(o);
      }
      createLineTool({
        pane: e,
        point: t,
        linetool: i,
        properties: s,
        linkKey: o,
        ownerSource: r,
        synchronizationMode: a = Lr.CreateLineToolSyncMode.Default,
        sharingMode: l = jp(),
        id: c
      }) {
        const h = B_.lineToolsStudyIds[i];
        (0, n.assert)(!(0, wt.isStudyLineToolName)(h) || !!h);
        if (h) {
          const e = this.canCreateStudy({
            id: h
          });
          if (!e.success) {
            Gp(this.model(), e);
            if ((0, wt.isStudyLineToolName)(lt.tool.value())) {
              (0, lt.resetToCursor)();
            }
            return null;
          }
        }
        const d = bp.format({
          tool: new Di.TranslatedString(i, ca.lineToolsLocalizedNames[i])
        });
        this.beginUndoMacro(d);
        const u = a !== Lr.CreateLineToolSyncMode.ForceOff;
        this._createLineCommand = new da({
          model: this._model(),
          pane: e,
          lineTool: i,
          ownerSource: r || (0, n.ensureNotNull)(e.mainDataSource()),
          drawOnAllChartsMode: l,
          id: c
        });
        const _ = this._createLineCommand.startCreatingLine(t, s, o || null, l, a === Lr.CreateLineToolSyncMode.ForceOff);
        const p = (0, n.ensureNotNull)(this._createLineCommand.line());
        let m = null;
        if (_) {
          if (u) {
            this.finishLineTool(p);
          }
          this._pushUndoCommand(this._createLineCommand);
          this._createLineCommand = null;
          m = {
            points: p.normalizedPoints(),
            interval: this.mainSeries().interval()
          };
        }
        if ((o === undefined && a === Lr.CreateLineToolSyncMode.Default && (0, lt.drawOnAllCharts)().value() || a === Lr.CreateLineToolSyncMode.ForceOn) && p.isSynchronizable()) {
          const e = (0, n.ensureNotNull)(this.model().externalTimeStamp(t.index));
          const s = {
            point: {
              price: t.price,
              timeStamp: e
            },
            linetool: i,
            properties: p.properties(),
            symbol: this.mainSeries().symbol(),
            model: this.model(),
            linkKey: (0, n.ensureNotNull)(p.linkKey().value()),
            finalState: m,
            id: p.id(),
            sharingMode: p.sharingMode().value()
          };
          if (p.isFixed()) {
            s.pointPositionPercents = p.calcPositionPercents();
          }
          (0, lt.createLineTool)(s);
        }
        this.endUndoMacro();
        return p;
      }
      continueCreatingLine(e, t, i, s) {
        const o = (0, n.ensureNotNull)(this._createLineCommand);
        this.beginUndoMacro(o.text());
        const r = (0, n.ensureNotNull)(this._model().lineBeingCreated());
        const a = o.continueCreatingLine(e, t, i, s);
        let l = null;
        if (a) {
          this.finishLineTool(r);
          this._pushUndoCommand(o);
          this._createLineCommand = null;
          l = {
            points: r.normalizedPoints(),
            interval: this.mainSeries().interval()
          };
        }
        if (o.drawOnAllCharts() && r.isSynchronizable()) {
          const i = (0, n.ensureNotNull)(this._model().externalTimeStamp(e.index));
          (0, lt.continueLineTool)({
            point: {
              price: e.price,
              timeStamp: i
            },
            envState: t,
            finalState: l,
            model: this._model()
          });
        }
        this.endUndoMacro();
        return a;
      }
      continueExternalLine(e, t, i) {
        const s = (0, n.ensureNotNull)(this._createLineCommand);
        const o = s.continueCreatingLine(e, t, i);
        if (o) {
          this._pushUndoCommand(s);
          this._createLineCommand = null;
        }
        return o;
      }
      finishLineTool(e) {
        this._model().finishLineTool(e);
      }
      cancelCreatingLine() {
        this.m_model.cancelCreatingLine();
      }
      lineBeingCreated() {
        return this.m_model.lineBeingCreated();
      }
      pasteImageAsLineTool(e, t, i, s) {
        const o = this._model().timeScale();
        const r = o.width();
        const a = i.height();
        const l = i.defaultPriceScale();
        const c = (0, n.ensureNotNull)((0, n.ensureNotNull)(l.mainSource()).firstValue());
        const h = {
          price: l.coordinateToPrice(a / 2, c),
          index: o.coordinateToIndex(r / 2)
        };
        const d = (0, eo.createLineToolProperties)(i.model().backgroundTheme().spawnOwnership(), "LineToolImage", !i.model().readOnly());
        if (s !== undefined) {
          d.childs().transparency.setValue(s);
        }
        const u = (0, n.ensureNotNull)(l.mainSource());
        (0, eo.prepareLineToolPropertiesByOwnerSource)(d, u);
        const _ = this.createLineTool({
          pane: i,
          point: h,
          linetool: "LineToolImage",
          properties: d
        });
        if (_) {
          _.setBlobImageUrl(t);
          this.selectionMacro(e => {
            e.clearSelection();
            e.addSourceToSelection(_, null);
          });
          e.then(e => {
            _.properties().childs().url.setValue(e);
          }).catch(e => {
            const t = _.linkKey().value();
            const i = this.model();
            if (t !== null) {
              (0, lt.removeLineTool)({
                withUndo: false,
                model: i,
                linkKey: t,
                symbol: _.symbol(),
                sourceTitle: new Di.TranslatedString(_.name(), _.translatedType()),
                lineToolState: _.state(false)
              });
            }
            i.removeSource(_);
          });
        }
        return _;
      }
      loadRange(e) {
        const t = this._model();
        const i = t.appliedTimeFrame().value();
        return (i === null || !Dr(i, e)) && (this._pushUndoCommand(new qa(t, e)), (0, W.emit)("timeframe_interval", e), true);
      }
      mainSeries() {
        return this.m_model.mainSeries();
      }
      model() {
        return this.m_model;
      }
      publishedChartsTimelineSource() {
        return this.m_model.publishedChartsTimelineSource();
      }
      unlinkLines(e) {
        const t = this.model();
        this.beginUndoMacro(Q_);
        for (const i of e) {
          if (i.linkKey().value() !== null) {
            (0, lt.removeLineTool)({
              withUndo: true,
              model: this.model(),
              symbol: i.symbol(),
              linkKey: (0, n.ensureNotNull)(i.linkKey().value()),
              sourceTitle: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, i),
              lineToolState: i.state(false),
              unlink: true
            });
          }
          this._pushUndoCommand(new w_(t, i));
        }
        this.endUndoMacro();
      }
      zoomFromViewport() {
        const e = new S_((0, n.ensureDefined)(this._zoomStack.head()), this._zoomStack, false);
        this._pushUndoCommand(e);
      }
      zoomToViewport(e, t, i, s, o) {
        const n = new f_(this.m_model, e, t, i, s, o);
        const r = new S_(n, this._zoomStack, true);
        this._pushUndoCommand(r);
      }
      zoomStack() {
        return this._zoomStack;
      }
      timeScale() {
        return this.m_model.timeScale();
      }
      selection() {
        return this.m_model.selection();
      }
      selectionMacro(e, t) {
        return this.m_model.selectionMacro(e, t);
      }
      onSelectedSourceChanged() {
        return this.m_model.onSelectedSourceChanged();
      }
      onTagsChanged() {
        return this.m_model.onTagsChanged();
      }
      lineCancelled() {
        return this.m_model.lineCancelled();
      }
      hoveredSource() {
        return this.m_model.hoveredSource();
      }
      crosshairSource() {
        return this.m_model.crosshairSource();
      }
      activeStrategySource() {
        return this.m_model.activeStrategySource();
      }
      setProperty(e, t, i, s) {
        if (e && e.value() !== t) {
          this.beginUndoMacro(i);
          const o = new Ua(e, t, i, this.m_model, !s);
          this._pushUndoCommand(o);
          this.endUndoMacro();
          this.emitEvent("setProperty");
        }
      }
      setProperties(e, t, i, s = true) {
        this.beginUndoMacro(i);
        this.m_model.selectionMacro(() => {
          for (let o = 0; o < e.length; o++) {
            this.setProperty(e[o], t[o], i, !s);
          }
        });
        this.endUndoMacro();
      }
      beginUndoMacro(e) {
        return this._undoHistory.beginUndoMacro(e);
      }
      endUndoMacro() {
        this._undoHistory.endUndoMacro();
      }
      invertPriceScale(e) {
        const t = e.properties().childs().isInverted;
        this.setProperty(t, !t.value(), Tp);
      }
      togglePriceScaleAutoScaleMode(e) {
        const t = {
          autoScale: !e.isAutoScale()
        };
        this.setPriceScaleMode(t, e, xp);
      }
      togglePriceScaleLockScaleMode(e) {
        const t = {
          lockScale: !e.isLockScale()
        };
        this.setPriceScaleMode(t, e, Ip);
      }
      togglePriceScalePercentageScaleMode(e) {
        const t = {
          percentage: !e.isPercentage()
        };
        this.setPriceScaleMode(t, e, Lp);
      }
      togglePriceScaleIndexedTo100ScaleMode(e) {
        const t = {
          indexedTo100: !e.isIndexedTo100()
        };
        this.setPriceScaleMode(t, e, Ap);
      }
      togglePriceScaleLogScaleMode(e) {
        const t = {
          log: !e.isLog()
        };
        this.setPriceScaleMode(t, e, kp);
      }
      setPriceScaleRegularScaleMode(e) {
        this.setPriceScaleMode({
          log: false,
          percentage: false,
          indexedTo100: false
        }, e, Mp);
      }
      withMacro(e, t) {
        const i = this.beginUndoMacro(e);
        try {
          t();
        } finally {
          this.endUndoMacro();
        }
        return i;
      }
      dataSources() {
        return this.m_model.dataSources();
      }
      orderedDataSources(e) {
        return this.m_model.orderedDataSources(e);
      }
      barsMarksSources() {
        return this.m_model.barsMarksSources();
      }
      removeAllDrawingTools(e) {
        this.beginUndoMacro(Np);
        this._removeAllDrawingToolsImpl(e);
        this.endUndoMacro();
      }
      removeAllStudiesAndDrawingTools(e) {
        this.beginUndoMacro(Op);
        this._removeAllDrawingToolsImpl(e);
        this._removeAllStudiesImpl();
        this.endUndoMacro();
      }
      removeAllStudies() {
        this.beginUndoMacro(Rp);
        this._removeAllStudiesImpl();
        this.endUndoMacro();
      }
      scrollChartByBar(e) {
        if (!this.m_model.scrollEnabled()) {
          return;
        }
        const t = e * this.m_model.timeScale().barSpacing();
        this.startScrollTime(0);
        this.scrollTimeTo(t);
        this.endScrollTime();
      }
      canZoomIn() {
        return this.model().canZoomIn();
      }
      canZoomOut() {
        return this.model().canZoomOut();
      }
      zoomOut() {
        const e = this.timeScale().width();
        if (this.canZoomOut()) {
          this.changeTimeScale(ep);
          (0, Er.doAnimate)({
            to: e / 5,
            onStep: e => {
              this.startScaleTime(0);
              this.scaleTimeTo(e);
              this.endScaleTime();
            }
          });
        }
      }
      zoomIn() {
        const e = this.timeScale().width();
        if (this.canZoomIn()) {
          this.changeTimeScale(tp);
          (0, Er.doAnimate)({
            to: e / 5,
            onStep: e => {
              this.startScaleTime(e);
              this.scaleTimeTo(0);
              this.endScaleTime();
            }
          });
        }
      }
      scrollChart(e) {
        if (this.m_model.scrollEnabled()) {
          this.startScrollTime(0);
          this.scrollTimeTo(e);
          this.endScrollTime();
        }
      }
      startMovingSources(e, t, i, s) {
        if (e.filter(e => e.doesMovingAffectsUndo()).length) {
          this._currentSourceMoveCommand = new Jr(this.model(), e, ip, false);
        }
        this.model().startMovingSources(e, t, i, new Map(), s);
      }
      moveSources(e, t) {
        this.model().moveSources(e, new Map(), t);
      }
      endMovingSource(e, t) {
        this.model().endMovingSources(e, undefined, t);
        if (this._currentSourceMoveCommand !== null) {
          this._currentSourceMoveCommand.saveNewState();
          this._pushUndoCommand(this._currentSourceMoveCommand);
        }
        this._currentSourceMoveCommand = null;
      }
      startChangingLinetool(e, t, i, s, o) {
        this._currentLineChangeCommand = new Jr(this.model(), [e], e.changePointUndoText(i), false);
        this.model().startChangingLinetool(e, t, i, s, o);
      }
      changeLinePoint(e, t) {
        this.model().changeLinePoint(e, t);
      }
      alignToolTo45Degrees(e) {
        const t = e.alignTo45DegreesPoints();
        if (t) {
          this._pushUndoCommand(new Jr(this.model(), [e], Bp, false));
          this.model().alignTo45Degrees(e, t);
        }
      }
      endChangingLinetool(e) {
        this.model().endChangingLinetool(e);
        if (this._currentLineChangeCommand !== null) {
          this._currentLineChangeCommand.saveNewState();
          this._pushUndoCommand(this._currentLineChangeCommand);
        }
        this._currentLineChangeCommand = null;
      }
      setChartStyleProperty(e, t, i) {
        if (e.value() !== t) {
          const s = undefined;
          const o = () => {
            this.beginUndoMacro(i);
            const s = new ja(e, t, this.mainSeries(), i, this.model(), this._chartWidget);
            this._pushUndoCommand(s);
            this.emitEvent("setChartStyleProperty");
            e.value();
            this.endUndoMacro();
          };
          if (s) {
            runOrGoPro(o, s.feature, {
              feature: s.featureName
            });
          } else {
            o();
          }
        }
      }
      setPriceAutoScale(e, t, i) {
        this._pushUndoCommand(new Nn(this.m_model, e, t, t.state()));
        this.m_model.setPriceAutoScale(e, t, i);
      }
      setPriceScaleMode(e, t, i) {
        if (!(0, Do.default)(t.mode(), e)) {
          const s = new lc(e, t, i, this.m_model);
          this._pushUndoCommand(s);
        }
      }
      setPriceScaleSelectionStrategy(e) {
        const t = this.m_model.properties().childs();
        if (t.priceScaleSelectionStrategyName.value() === e) {
          return;
        }
        (0, ne.trackEvent)("Chart", "Change PriceScale Selection Strategy");
        const i = Vp.format({
          title: e
        });
        this.beginUndoMacro(i);
        this.setProperty(t.priceScaleSelectionStrategyName, e, i);
        const s = new U_(this.m_model, e, i);
        this._pushUndoCommand(s);
        this.endUndoMacro();
      }
      setScaleRatioProperty(e, t, i) {
        if (e.value() !== t) {
          const s = new H_(e, t, i, this.m_model);
          this._pushUndoCommand(s);
        }
      }
      createUndoCheckpoint() {
        return this._undoHistory.createUndoCheckpoint();
      }
      undoToCheckpoint(e) {
        this._undoHistory.undoToCheckpoint(e);
      }
      restorePropertiesForSource(e) {
        if ((0, eo.isLineTool)(e)) {
          this._restoreLineToolFactoryDefaults(e);
        } else {
          this._restoreStudyFactoryDefaults(e);
        }
      }
      restoreLineToolsFactoryDefaults(e) {
        if (e.length === 1) {
          this._restoreLineToolFactoryDefaults(e[0]);
        } else {
          this.beginUndoMacro(op);
          e.forEach(e => this._restoreLineToolFactoryDefaults(e));
          this.endUndoMacro();
        }
      }
      restorePreferences() {
        const e = new W_(this.model());
        this._pushUndoCommand(e);
      }
      restoreState(e, t, i) {
        return this.m_model.restoreState(e, t, i);
      }
      async clipboardCopy(e, t = this.selection().dataSources()) {
        if (!(0, l.enabled)("datasource_copypaste")) {
          return;
        }
        const i = t.filter(e => e.copiable());
        if (i.length === 0) {
          return;
        }
        for (const e of i) {
          if ((0, Js.isStudy)(e) && e.isChildStudy()) {
            throw new Error("Can not copy child study");
          }
        }
        const s = (0, Rr.clipboardDataForSources)(this._model().id(), i);
        if (s !== null) {
          return e.write({
            app: JSON.stringify(s),
            text: s.title
          });
        } else {
          return undefined;
        }
      }
      async clipboardCut(e, t = this.selection().dataSources()) {
        if (!(0, l.enabled)("datasource_copypaste")) {
          return;
        }
        const i = t.filter(e => e.copiable());
        if (i.length === 0) {
          return;
        }
        await this.clipboardCopy(e, i);
        const s = i.filter(e => e.isUserDeletable());
        if (s.length === 0) {
          return;
        }
        const o = (s.length === 1 ? K_ : Y_).format({
          title: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, s[0])
        });
        this.beginUndoMacro(o);
        this.m_model.selectionMacro(() => this.removeSources(s, false, o), true);
        this.endUndoMacro();
      }
      async clipboardPaste(e, t) {
        let i = null;
        if ((0, l.enabled)("datasource_copypaste") && (i = i || (await e.read()), i.app)) {
          const e = JSON.parse(i.app);
          if ((await this.pasteSourceFromClip(t, e)) !== null) {
            return;
          }
        }
        await this._processSpecialLineToolsContents(e, i, t);
      }
      applyStudyTemplate(e, t) {
        const i = new zl(this._model(), e, t);
        this.beginUndoMacro(i.text());
        const s = this.m_model.panes().reduce((e, t) => e.concat(t.sourcesByGroup().allWithoutMultipaneWithHidden().filter(e => (0, eo.isLineTool)(e) && e.ownerSource() !== this.m_model.mainSeries())), []);
        this.removeSources(s, false, null);
        this._pushUndoCommand(i);
        this.endUndoMacro();
        (0, W.emit)("load_study_template");
      }
      createStudyInserter(e, t, i = {}) {
        const {
          stubTitle: s,
          isOverlay: o
        } = i;
        const n = {
          createStudy: (e, t, i, s, o, n, r, a, l, c, h, d) => {
            if (!this.checkIfFeatureAvailable(e, r)) {
              Wp.logNormal("Cannot insert study " + e.id);
              return null;
            }
            (0, ne.trackEvent)("studies", "Study_" + e.id);
            if (e.id === "Compare@tv-basicstudies") {
              (0, ne.trackEvent)("compare", "symbol:" + t.symbol);
            }
            if (s) {
              this.m_model.removeSource(s);
            }
            const u = this._insertStudy(e, t, o, n, r, a, l, c, h, null, d);
            u.study.then(e => (0, W.emit)("study_event", e.id(), "create"));
            return u;
          },
          storeFailedStub: e => {
            this._storeFailedStub(e);
          }
        };
        if (s !== undefined) {
          n.createStub = () => this.m_model.insertStudyStub(s, o).id();
          n.removeStub = e => this.m_model.removeStudyStub(e);
        }
        const r = new Qu(e, n);
        r.setParentSources(t);
        return r;
      }
      applyLineToolTemplate(e, t, i) {
        this.beginUndoMacro(i);
        this.saveLineToolState(e, i);
        const s = new R_(e, t, i);
        this._pushUndoCommand(s);
        this.saveLineToolState(e, i);
        this.endUndoMacro();
        this.model().updateSource(e);
      }
      applyLineToolsTemplate(e) {
        throw new Error("Not implemented");
      }
      replayStatus() {
        return this.m_model.replayStatus();
      }
      setReplayStatus(e) {
        return this.m_model.setReplayStatus(e);
      }
      isInReplay() {
        return this.m_model.isInReplay();
      }
      getSymbolString() {
        return this.m_model.getSymbolString();
      }
      interval() {
        return this.m_model.interval();
      }
      onInReplayStateChanged() {
        return this.m_model.onInReplayStateChanged();
      }
      switchToReplay(e, t) {
        0;
      }
      switchToRealtime() {
        0;
      }
      canChangeResolution(e) {
        return this.model().canChangeResolution(e);
      }
      canChangeSymbol(e) {
        return this.model().canChangeSymbol(e);
      }
      onReplayModified() {
        return this.model().onReplayModified();
      }
      startCustomMoving(e, t, i) {
        this._currentCustomMoveCommand = new rc(this.model(), e, t, i);
      }
      customMoveBeingProcessed() {
        return this._currentCustomMoveCommand !== null;
      }
      processCustomMove(e) {
        (0, n.ensureNotNull)(this._currentCustomMoveCommand).move(e);
      }
      endCustomMoving() {
        if (this._currentCustomMoveCommand !== null && this._currentCustomMoveCommand.hasChanges()) {
          this._pushUndoCommand(this._currentCustomMoveCommand);
          this._currentCustomMoveCommand = null;
        }
      }
      state(e, t, i, s) {
        return this.m_model.state(e, t, i, s);
      }
      panes() {
        return this.m_model.panes();
      }
      cloneLineTools(e, t) {
        for (let t = 0; t < Math.min(5, e.length); ++t) {
          e[t];
          Wn();
        }
        this.beginUndoMacro(ap);
        const i = new Kr(this._model(), e, t, ap);
        this._pushUndoCommand(i);
        const s = i.newIds().map(e => (0, n.ensureNotNull)(this.model().dataSourceForId(e))).filter(e => e.sharingMode().value() !== 0);
        if (s.length) {
          this._model().copyToOtherCharts(s, true);
        }
        this.endUndoMacro();
        this.emitEvent("cloneLineTools");
        return i.newIds();
      }
      removeSource(e, t, i) {
        if (this.lineBeingCreated() !== e) {
          this.removeSources([e], t, Z_.format({
            title: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, e)
          }), i);
        } else {
          this.cancelCreatingLine();
        }
      }
      removeSelectedSources() {
        const e = this._model().selection().dataSources();
        if (!e.length) {
          return;
        }
        const t = (e.length > 1 ? X_ : Z_).format({
          title: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, e[0])
        });
        this.removeSources(e, false, t);
      }
      removeSources(e, t, i, s) {
        if (!s) {
          e = e.filter(e => e.isUserDeletable());
        }
        const o = this._model();
        const r = o.lineToolsGroupModel();
        this.beginUndoMacro(i);
        o.selectionMacro(s => {
          const a = new Map();
          e.forEach(e => {
            if ((0, eo.isLineTool)(e)) {
              const t = r.groupForLineTool(e);
              if (t !== null) {
                const i = a.get(t) || [];
                i.push(e);
                a.set(t, i);
              }
              if (e.linkKey().value() !== null) {
                (0, lt.removeLineTool)({
                  withUndo: true,
                  model: this.model(),
                  linkKey: (0, n.ensureNotNull)(e.linkKey().value()),
                  symbol: this.model().mainSeries().symbol(),
                  lineToolState: e.state(false),
                  sourceTitle: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, e)
                });
              }
            }
          });
          const l = new Yr.RemoveSourcesUndoCommand(o, e, i);
          const c = l.removedIds();
          this._pushUndoCommand(l);
          if (!t && c.length > 0) {
            if (c.length === 1) {
              this.emitEvent("removeSource", [c[0]]);
            } else {
              this.emitEvent("removeSources", [c]);
            }
          }
        }, true);
        this.endUndoMacro();
      }
      async scrollToLineTool(e) {
        const t = this.timeScale().logicalRange();
        if (t === null) {
          return;
        }
        const i = e.points().map(e => e.index);
        const s = this.timeScale().points().range().value();
        if (s === null) {
          return;
        }
        let o = s.firstIndex;
        const r = s.lastIndex;
        const a = t.length() / 2;
        if (i.length === 0 || i.some(e => t.contains(e))) {
          return;
        }
        const l = () => {
          const t = e.points().map(e => e.index);
          const i = t.filter(e => e <= r).reduce((e, t) => e === null ? t : Math.max(e, t), null);
          if (i !== null) {
            return i;
          } else {
            return t.reduce((e, t) => Math.min(e, t));
          }
        };
        let c = l();
        if (o - a > c) {
          const t = e.points().map(e => e.time).filter(dt.notUndefined).map(e => e * 1000);
          if (t.length === 0) {
            return;
          }
          const i = t.reduce((e, t) => Math.min(e, t), t[0]);
          await this.model().gotoTime(i);
          c = l();
          if ((0, n.ensureNotNull)(this.timeScale().logicalRange()).contains(c)) {
            return;
          }
          o = (0, n.ensureNotNull)(this.timeScale().points().range().value()).firstIndex;
        }
        if (o - a > c) {
          this.mainSeries().setGotoDateResult({
            timestamp: (0, n.ensureNotNull)(this.timeScale().points().valueAt(o)),
            eod: true
          });
        }
        const h = this.timeScale().width() / 2;
        const d = this.timeScale().indexToCoordinate(c);
        this.model().stopTimeScaleAnimation();
        this.model().setTimeScaleAnimation(new Vr({
          from: 0,
          to: h - d,
          duration: Mr.dur,
          easing: Mr.easingFunc.easeInOutCubic
        }));
      }
      mergeSourceUp(e) {
        const t = new na(this._model(), e, lp);
        this._mergeUnmergeSource(e, t);
      }
      mergeSourceDown(e) {
        const t = new ra(this._model(), e, cp);
        this._mergeUnmergeSource(e, t);
      }
      mergeToPane(e, t, i) {
        const s = this._model().panes().indexOf(t);
        const o = new aa(this._model(), e, s, hp, i);
        this._mergeUnmergeSource(e, o);
      }
      unmergeSourceUp(e) {
        const t = new ia(this._model(), e, dp);
        this._mergeUnmergeSource(e, t);
      }
      unmergeSourceDown(e) {
        const t = new ta(this._model(), e, up);
        this._mergeUnmergeSource(e, t);
      }
      unmergeToNewBottomPane(e) {
        const t = new sa(this._model(), e, _p);
        this._mergeUnmergeSource(e, t);
      }
      moveLeft() {
        this.beginUndoMacro(Dp);
        (0, Er.doAnimate)({
          to: this.m_model.timeScale().width() / 5,
          onStep: e => {
            this.startScrollTime(e);
            this.scrollTimeTo(0);
            this.endScrollTime();
          },
          onComplete: () => {
            this.endUndoMacro();
          }
        });
      }
      moveRight() {
        this.beginUndoMacro(Ep);
        (0, Er.doAnimate)({
          to: this.m_model.timeScale().width() / 5,
          onStep: e => {
            this.startScrollTime(0);
            this.scrollTimeTo(e);
            this.endScrollTime();
          },
          onComplete: () => {
            this.endUndoMacro();
          }
        });
      }
      availableZOrderOperations(e) {
        const t = this._model().lineToolsGroupModel();
        const i = e.filter(eo.isLineTool);
        const s = i.map(e => t.groupForLineTool(e));
        (0, n.assert)(new Set(s).size <= 1, "Cannot move line tools from different group");
        const o = s.length === 0 ? null : s[0];
        let r = {
          bringForwardEnabled: false,
          bringToFrontEnabled: false,
          sendBackwardEnabled: false,
          sendToBackEnabled: false
        };
        const a = new Set(i);
        for (const t of (0, ci.sortSources)(e)) {
          if ((0, eo.isLineTool)(t) && o !== null) {
            const e = (0, ci.sortSources)(o.lineTools().filter(e => !a.has(e) || e === t));
            r = zp(r, {
              bringForwardEnabled: t !== e[e.length - 1],
              bringToFrontEnabled: t !== e[e.length - 1],
              sendBackwardEnabled: t !== e[0],
              sendToBackEnabled: t !== e[0]
            });
            continue;
          }
          const e = (0, n.ensureNotNull)(this._model().paneForSource(t)).sourcesByGroup().allExceptSpecialSources();
          if (e.length === 0) {
            continue;
          }
          const i = t.zorder();
          const s = e[0].zorder();
          const l = e[e.length - 1].zorder();
          r = zp(r, {
            bringForwardEnabled: i !== l,
            bringToFrontEnabled: i !== l,
            sendBackwardEnabled: i !== s,
            sendToBackEnabled: i !== s
          });
        }
        return r;
      }
      sendToBack(e) {
        if (!this.availableZOrderOperations(e).sendToBackEnabled) {
          throw new Error("Send to back operation is unavailable");
        }
        let t = null;
        const i = e[0];
        if ((0, eo.isLineTool)(i)) {
          const s = this._model().lineToolsGroupModel().groupForLineTool(i);
          if (s !== null) {
            const i = s.lineTools();
            t = new Ma(this.model(), (0, ci.sortSources)(e), i[0]);
          }
        }
        if (t === null) {
          t = new Pa(this.model(), (0, ci.sortSources)(e));
        }
        this._pushUndoCommand(t);
        this.emitEvent("changeZOrder", [e]);
      }
      bringToFront(e) {
        if (!this.availableZOrderOperations(e).bringToFrontEnabled) {
          throw new Error("Bring to front operation is unavailable");
        }
        let t = null;
        const i = e[0];
        if ((0, eo.isLineTool)(i)) {
          const s = this._model().lineToolsGroupModel().groupForLineTool(i);
          if (s !== null) {
            const i = s.lineTools();
            t = new xa(this.model(), (0, ci.sortSources)(e), i[i.length - 1]);
          }
        }
        if (t === null) {
          t = new Ca(this.model(), (0, ci.sortSources)(e));
        }
        this._pushUndoCommand(t);
        this.emitEvent("changeZOrder", [e]);
      }
      sendBackward(e) {
        if (!this.availableZOrderOperations(e).sendBackwardEnabled) {
          throw new Error("Send backward operation is unavailable");
        }
        const t = j_.format({
          title: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, e[0])
        });
        this._sendBackOrBringForward(t, (0, ci.sortSources)(e), (e, t) => new La(this.model(), e, t));
      }
      bringForward(e) {
        if (!this.availableZOrderOperations(e).bringForwardEnabled) {
          throw new Error("Bring forward operation is unavailable");
        }
        const t = G_.format({
          title: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, e[0])
        });
        this._sendBackOrBringForward(t, (0, ci.sortSources)(e), (e, t) => new Da(this.model(), e, t));
      }
      insertAfter(e, t) {
        e = (0, ci.sortSources)(e);
        const i = q_.format({
          title: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, e[0]),
          target: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, t)
        });
        this._insertAfterOrBefore(i, e, t, () => new xa(this.model(), e, t));
      }
      insertBefore(e, t) {
        e = (0, ci.sortSources)(e);
        const i = $_.format({
          title: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, e[0]),
          target: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, t)
        });
        this._insertAfterOrBefore(i, e, t, () => new Ma(this.model(), e, t));
      }
      detachToRight(e, t) {
        (0, ne.trackEvent)("Chart", "Move to new right scale");
        const i = pp.format({
          title: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, e)
        });
        const s = new Zl(this.model(), e, t, "right", i);
        this._pushUndoCommand(s);
        this.emitEvent("moveSource", [e]);
      }
      detachToLeft(e, t) {
        (0, ne.trackEvent)("Chart", "Move to new left scale");
        const i = mp.format({
          title: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, e)
        });
        const s = new Zl(this.model(), e, t, "left", i);
        this._pushUndoCommand(s);
        this.emitEvent("moveSource", [e]);
      }
      detachNoScale(e, t) {
        (0, ne.trackEvent)("Chart", "Make source no scale");
        const i = gp.format({
          title: (0, di.getTranslatedStringForSource)(ua.TitleDisplayTarget.StatusLine, e)
        });
        const s = new Zl(this.model(), e, t, "overlay", i);
        this._pushUndoCommand(s);
        this.emitEvent("moveSource", [e]);
      }
      moveToScale(e, t, i, s, o) {
        (0, ne.trackEvent)("Chart", "Move source to target scale");
        this.beginUndoMacro(s);
        const n = new Xl(this.model(), e, t, i, s);
        const r = o ? null : Or(e, i, this._model());
        const a = o ? null : oh(e, i, this._model());
        this._pushUndoCommand(n);
        if (r !== null) {
          this.setPriceScaleCurrency(i, r);
        }
        if (a !== null) {
          this.setPriceScaleUnit(i, a);
        }
        this.endUndoMacro();
        this.emitEvent("moveSource", [e]);
      }
      setLinkingGroupIndex(e) {
        const t = this.model().linkingGroupIndex();
        this._undoHistory.beginUndoMacro(Fp);
        this._pushUndoCommand(new E_(t, t.value(), e, Fp));
        this._model().setShouldBeSavedEvenIfHidden(true);
        this._undoHistory.endUndoMacro();
      }
      startScrollPrice(e, t, i) {
        if (!t.isAutoScale()) {
          this._initialPriceScrollState = t.state();
          this._initialPriceScrollPos = i;
          this._model().startScrollPrice(e, t, i);
        }
      }
      scrollPriceTo(e, t, i) {
        if (!t.isAutoScale()) {
          if (this._initialPriceScrollState && this._initialPriceScrollPos && Math.abs(this._initialPriceScrollPos - i) > 20) {
            this._pushUndoCommand(new Nn(this.m_model, e, t, this._initialPriceScrollState, undefined, false));
            this._initialPriceScrollState = null;
            this._initialPriceScrollPos = null;
          }
          this._model().scrollPriceTo(e, t, i);
        }
      }
      endScrollPrice(e, t) {
        if (!t.isAutoScale()) {
          this._initialPriceScrollState = null;
          this._initialPriceScrollPos = null;
          this._model().endScrollPrice(e, t);
        }
      }
      startScrollTime(e) {
        const t = this.timeScale();
        this._initialTimeScrollState = {
          rightOffset: t.rightOffset(),
          barSpacing: t.barSpacing()
        };
        this._initialTimeScrollPos = e;
        this.model().startScrollTime(e);
      }
      scrollTimeTo(e) {
        if (this._initialTimeScrollPos !== null && this._initialTimeScrollState !== null && Math.abs(e - this._initialTimeScrollPos) > 20) {
          this._pushUndoCommand(new En(this.model(), this._initialTimeScrollState, fp, false));
          this._initialTimeScrollPos = null;
          this._initialTimeScrollState = null;
        }
        this.model().scrollTimeTo(e);
      }
      endScrollTime() {
        this.model().endScrollTime();
        this._initialTimeScrollPos = null;
        this._initialTimeScrollState = null;
      }
      startScaleTime(e) {
        const t = this.timeScale();
        this._initialTimeScaleState = {
          rightOffset: t.rightOffset(),
          barSpacing: t.barSpacing()
        };
        this.model().startScaleTime(e);
      }
      scaleTimeTo(e) {
        if (this._initialTimeScaleState !== null && this._initialTimeScaleState.barSpacing !== this.timeScale().barSpacing()) {
          this._pushUndoCommand(new En(this.model(), this._initialTimeScaleState, yp, true));
          this._initialTimeScaleState = null;
        }
        this.model().scaleTimeTo(e);
      }
      endScaleTime() {
        this.model().endScaleTime();
      }
      resetTimeScale() {
        this.changeTimeScale(vp, this.timeScale().resetAvailable().value());
        this.model().resetTimeScale();
      }
      changeTimeScale(e, t = true) {
        const i = this.timeScale();
        const s = {
          rightOffset: i.rightOffset(),
          barSpacing: i.barSpacing()
        };
        this._pushUndoCommand(new En(this.model(), s, e, t));
      }
      startScalePrice(e, t, i, s) {
        this._scalePriceInfo = {
          priceScaleState: t.state(),
          tryMergeConsecutiveScales: s
        };
        this.model().startScalePrice(e, t, i);
      }
      scalePriceTo(e, t, i) {
        this.model().scalePriceTo(e, t, i);
      }
      endScalePrice(e, t) {
        this.model().endScalePrice(e, t);
        const i = (0, n.ensureNotNull)(this._scalePriceInfo);
        if (!(0, Do.default)(i.priceScaleState, t.state())) {
          this._pushUndoCommand(new Nn(this.model(), e, t, i.priceScaleState, i.tryMergeConsecutiveScales));
        }
        this._scalePriceInfo = null;
      }
      startTwoPointsScalePrice(e, t, i, s, o) {
        this._scalePriceInfo = {
          priceScaleState: t.state(),
          tryMergeConsecutiveScales: o
        };
        this.model().startTwoPointsScalePrice(e, t, i, s);
      }
      twoPointsScalePriceTo(e, t, i, s) {
        this.model().twoPointsScalePriceTo(e, t, i, s);
      }
      endTwoPointsScalePrice(e, t) {
        this.model().endTwoPointsScalePrice(e, t);
        const i = (0, n.ensureNotNull)(this._scalePriceInfo);
        if (!(0, Do.default)(i.priceScaleState, t.state())) {
          this._pushUndoCommand(new Nn(this.model(), e, t, i.priceScaleState, i.tryMergeConsecutiveScales));
        }
        this._scalePriceInfo = null;
      }
      resetPriceScale(e, t) {
        const i = t.state();
        this.model().resetPriceScale(e, t);
        if (!(0, Do.default)(i, t.state())) {
          this._pushUndoCommand(new Nn(this.m_model, e, t, i));
        }
      }
      rearrangePanes(e, t) {
        const i = new Na(this._model(), e, t);
        this._pushUndoCommand(i);
      }
      movePane(e, t) {
        const i = new Na(this._model(), e, t);
        this._pushUndoCommand(i);
      }
      toggleCollapsedPane(e) {
        const t = this.panes().findIndex(t => t === e);
        if (!(t < 0)) {
          this._pushUndoCommand(new Wr(this._model(), t));
        }
      }
      toggleMaximizedPane(e) {
        this._pushUndoCommand(new zr(this._model(), e));
      }
      readOnly() {
        return this.m_model.readOnly();
      }
      checkIfFeatureAvailable(e, t) {
        const i = t.length > 0;
        const s = this.canCreateStudy({
          id: e.id,
          child: i,
          fundamental: false
        });
        return !!s.success || (Gp(this.model(), s), false);
      }
      async pasteSourceFromClip(e, t, i) {
        const s = t;
        if (!s || s.sources.length === 0) {
          return null;
        }
        const o = e || (0, n.ensureNotNull)(this.model().paneForSource(this.mainSeries()));
        if (!s.sources.some(e => e.type !== "drawing" || o.clipboardLineToolOwnerSource(e.source.id) !== null)) {
          return null;
        }
        const r = Array.from(new Set(s.sources.filter(Rr.isLineToolClipboardData).map(e => e.source.type)));
        await Promise.all(r.map(e => (0, eo.initLineTool)(e)));
        this.beginUndoMacro(wp.format({
          title: s.title
        }));
        let a = 0;
        const l = [];
        const c = [];
        for (const t of s.sources) {
          if (t.type === "drawing" && o.clipboardLineToolOwnerSource(t.source.id) !== null) {
            const e = await this.pasteLineTool(o, t);
            if (a < 5) {
              Wn();
              a += 1;
            }
            c.push(e);
            l.push(e);
          } else if (t.type === "study" && t.source && t.source.metaInfo && this.checkIfFeatureAvailable(new is.StudyMetaInfo(t.source.metaInfo), [])) {
            l.push(this.pasteStudy(t, i ? e : undefined));
          }
        }
        if (c.length) {
          this.selectionMacro(e => {
            e.clearSelection();
            c.forEach(t => {
              e.addSourceToSelection(t, null);
            });
          });
        }
        this.endUndoMacro();
        return l;
      }
      async pasteLineTool(e, t, i, s) {
        await (0, Ro.ensureLineToolLoaded)(t.source.type);
        t.source.state.intervalsVisibilities = (0, Ch.mergeIntervalVisibilitiesDefaults)(t.source.state.intervalsVisibilities);
        (0, Ch.makeIntervalsVisibilitiesVisibleAtInterval)(t.source.state.intervalsVisibilities, this.model().mainSeries().intervalObj());
        const o = new ql(this.model(), t, e, i, s);
        this._pushUndoCommand(o);
        const n = o.source();
        if (o.needCopyToOtherCharts()) {
          this._model().copyToOtherCharts([n], true);
        }
        this.selectionMacro(e => {
          e.clearSelection();
          e.addSourceToSelection(n, null);
        });
        return n;
      }
      pasteStudy(e, t) {
        const i = new sc(this.model(), e, t?.id());
        this._pushUndoCommand(i);
        const s = (0, n.ensureNotNull)(i.state()).id;
        (0, W.emit)("study_event", s, "paste_study");
        return (0, n.ensureNotNull)(this._model().dataSourceForId(s));
      }
      removePane(e) {
        const t = this.m_model.panes()[e].dataSources().slice();
        this.removeSources(t, false, Pp);
      }
      createPane(e) {
        return this.m_model.createPane(e);
      }
      setPriceScaleCurrency(e, t) {
        const i = new $l(this.m_model, e, t, np);
        this._pushUndoCommand(i);
      }
      setPriceScaleUnit(e, t) {
        const i = new Kl(this.m_model, e, t, rp);
        this._pushUndoCommand(i);
      }
      setSymbol(e, t) {
        if (!e.symbolSameAsResolved(t)) {
          this._pushUndoCommand(new ec(e, t, this._chartWidget));
        }
      }
      setResolution(e, t) {
        if (!Re.Interval.isEqual(e.interval(), t)) {
          this._pushUndoCommand(new D_(e, t, this._chartWidget));
        }
      }
      syncCrosshair(e, t) {
        this._chartWidget.chartWidgetCollection().syncCrosshair(e, this._chartWidget.id(), t);
      }
      loadingScreen() {
        return this._chartWidget.screen;
      }
      chartLoadTheme(e, t, i) {
        const s = new L_(this.model(), e, t);
        if (i) {
          s.redo();
        } else {
          this._pushUndoCommand(s);
        }
      }
      isJustClonedChart() {
        return this._chartWidget.isJustClonedChart();
      }
      isMultipleLayout() {
        return this._chartWidget.isMultipleLayout();
      }
      addPaneStretchFactorUndoCommand(e, t, i, s) {
        const o = new oc(this.model(), e, t, i, s);
        this._pushUndoCommand(o);
      }
      applyPreferences(e) {
        throw new Error("Not implemented");
      }
      paneForSource(e) {
        return this.m_model.paneForSource(e);
      }
      destroy() {
        this.m_model.destroy();
      }
      moveSelectedToolsLeft() {
        return this._moveSelectedTools(2);
      }
      moveSelectedToolsUp() {
        return this._moveSelectedTools(0);
      }
      moveSelectedToolsRight() {
        return this._moveSelectedTools(3);
      }
      moveSelectedToolsDown() {
        return this._moveSelectedTools(1);
      }
      insertStudyWithoutCheck(e, t, i, s) {
        return this._insertStudy(e, t, {}, false, [], undefined, undefined, undefined, undefined, i ?? null, undefined, s);
      }
      saveLineToolState(e, t) {
        this._pushUndoCommand(new Jr(this.m_model, [e], t));
      }
      resetScales() {
        this._model().stopTimeScaleAnimation();
        this.beginUndoMacro(Sp);
        this.resetTimeScale();
        for (const e of this.m_model.panes()) {
          for (const t of e.leftPriceScales()) {
            this.resetPriceScale(e, t);
          }
          for (const t of e.rightPriceScales()) {
            this.resetPriceScale(e, t);
          }
        }
        this.endUndoMacro();
        this.m_model.recalculateAllPanes((0, Bt.viewportChangeEvent)());
      }
      shareLineTools(e, t) { }
      canCreateStudy(e, t) {
        return this.model().chartApi().canCreateStudy(e, t);
      }
      chartWidgetCollectionLock() {
        return this._chartWidget.chartWidgetCollection().lock;
      }
      onSymbolIntervalChanged() {
        return this.m_model.onSymbolIntervalChanged();
      }
      paneBeingCreatedLineOn() {
        return this.m_model.paneBeingCreatedLineOn();
      }
      invalidate(e) {
        this.m_model.invalidate(e);
      }
      setWidth(e) {
        this.m_model.setWidth(e);
      }
      setPaneHeight(e, t) {
        this.m_model.setPaneHeight(e, t);
      }
      dataSourceForId(e) {
        return this.m_model.dataSourceForId(e);
      }
      lineBeingEdited() {
        return this.m_model.lineBeingEdited();
      }
      sourcesBeingMoved() {
        return this.m_model.sourcesBeingMoved();
      }
      gridSource() {
        return this.m_model.gridSource();
      }
      watermarkSource() {
        return this.m_model.watermarkSource();
      }
      mainSeriesScaleRatioProperty() {
        return this.m_model.mainSeriesScaleRatioProperty();
      }
      setHoveredSource(e, t) {
        this.m_model.setHoveredSource(e, t);
      }
      setCurrentPosition(e, t, i, s) {
        this.m_model.setCurrentPosition(e, t, i, s);
      }
      setAndSaveCurrentPosition(e, t, i, s) {
        this.m_model.setAndSaveCurrentPosition(e, t, i, s);
      }
      version() {
        return this.m_model.version();
      }
      restart() {
        this.m_model.restart();
      }
      disconnect() {
        this.m_model.disconnect();
      }
      calculateDefaultTags() {
        return this.m_model.calculateDefaultTags();
      }
      drawRightThere(e, t, i) {
        if ((0, wt.isLineToolName)(e)) {
          if (i === undefined) {
            const e = this.crosshairSource();
            const s = this.model().magnet().align(e.price, e.index, t);
            i = {
              index: e.index,
              price: s
            };
          }
          const s = this.createLineTool({
            point: i,
            linetool: e,
            pane: t
          });
          if (s) {
            this.selectionMacro(e => {
              e.clearSelection();
              e.addSourceToSelection(s);
            });
          }
        }
      }
      _model() {
        return this.m_model;
      }
      _pushUndoCommand(e) {
        this._undoHistory.pushUndoCommand(e);
      }
      _mergeUnmergeSource(e, t) {
        this.beginUndoMacro(t.text());
        const i = (0, n.ensureNotNull)(this._model().paneForSource(e));
        const s = new Set(i.sourcesByGroup().lineSources().filter(t => t.ownerSource() === e));
        this._model().lineToolsGroupModel().groups().filter(e => {
          const t = e.lineTools().some(e => s.has(e));
          const i = e.lineTools().some(e => !s.has(e));
          return t && i;
        }).forEach(e => {
          this._pushUndoCommand(new Zr.ExcludeLineToolsFromGroupUndoCommand(this._model(), e, e.lineTools()));
        });
        this._pushUndoCommand(t);
        this.endUndoMacro();
      }
      _insertStudy(e, t, i, s, o, n, r, a, l, c, h, d) {
        const u = Cp.format({
          title: e.description
        });
        const _ = new ac({
          chartModel: this.model(),
          studyMetaInfo: e,
          inputs: t,
          props: i,
          addAsOverlay: s,
          parentSources: o,
          preferredPriceScale: n,
          allowChangeCurrency: r,
          allowChangeUnit: a,
          paneSize: l,
          targetZOrder: c ?? null,
          targetScaleMode: h,
          studyId: d,
          undoText: u
        });
        this._pushUndoCommand(_);
        return _.insertedStudy();
      }
      _storeFailedStub(e) {
        const t = Cp.format({
          title: e.title()
        });
        this.beginUndoMacro(t);
        const i = new V_(this.model(), e, t);
        this._pushUndoCommand(i);
        this.endUndoMacro();
      }
      async _processSpecialLineToolsContents(e, t, i) {
        t = t || (await e.read());
        if ((window.user.id || (0, l.enabled)("image_drawingtool")) && t.files) {
          const e = Array.from(t.files).find(m_.blobImageFilter);
          if (e) {
            const t = URL.createObjectURL(e);
            const s = (0, m_.uploadImage)(e);
            if (i === undefined) {
              i = (0, n.ensureNotNull)(this._model().paneForSource(this.mainSeries()));
            }
            await (0, Ro.ensureLineToolLoaded)("LineToolImage");
            this.pasteImageAsLineTool(s, t, i);
            await s;
            return;
          }
        }
      }
      _insertAfterOrBefore(e, t, i, s) {
        const o = (0, n.ensureNotNull)(this._model().paneForSource(i));
        if (t.some(e => (0, eo.isLineTool)(e) && this._model().paneForSource(e) !== o)) {
          throw new Error("Cannot insert line tool after target on another pane");
        }
        this.beginUndoMacro(e);
        t.forEach(e => {
          if ((0, n.ensureNotNull)(this.model().paneForSource(e)) !== o) {
            this.mergeToPane(e, o);
          }
        });
        const r = s();
        this._pushUndoCommand(r);
        this.emitEvent("changeZOrder", [t]);
        this.endUndoMacro();
      }
      _sendBackOrBringForward(e, t, i) {
        const s = new Map();
        t.forEach(e => {
          const t = (0, n.ensureNotNull)(this._model().paneForSource(e));
          const i = s.get(t) || [];
          i.push(e);
          s.set(t, i);
        });
        this.beginUndoMacro(e);
        s.forEach((e, t) => {
          this._pushUndoCommand(i(t, e));
        });
        this.endUndoMacro();
        this.emitEvent("changeZOrder", [t]);
      }
      _moveSelectedTools(e) {
        const t = this.model().selection().lineDataSources().filter(e => !e.isSourceHidden());
        if (t.length === 0) {
          return false;
        }
        if ((0, lt.lockDrawings)().value()) {
          return true;
        }
        const i = this.timeScale().visibleBarsStrictRange();
        if (i === null) {
          return false;
        }
        const s = function (e) {
          const t = new Map();
          for (const i of e) {
            const e = i.ownerSource();
            if (e === null) {
              continue;
            }
            let s = t.get(e);
            if (s === undefined) {
              const o = e.priceScale();
              const n = e.priceStep();
              const r = e.firstValue();
              if (o === null || n === null || r === null) {
                continue;
              }
              if (o.priceRange() === null) {
                continue;
              }
              s = {
                sources: [],
                priceScale: o,
                priceStep: n,
                startPrice: i.points()[0].price,
                firstValue: r
              };
              t.set(e, s);
            }
            s.sources.push(i);
          }
          return t;
        }(t);
        if (s.size === 0) {
          return false;
        }
        this.beginUndoMacro(ip);
        const o = i.firstBar();
        const n = this.timeScale().indexToCoordinate(o);
        const r = o + (e === 3 ? 1 : e === 2 ? -1 : 0);
        const a = this.timeScale().indexToCoordinate(r);
        lt.isDirectionalMovementActive.setValue(true);
        s.forEach(t => {
          const {
            startPrice: i,
            priceStep: s,
            priceScale: l,
            firstValue: c
          } = t;
          const h = i + (e === 0 ? s : e === 1 ? -s : 0);
          const d = l.priceToCoordinate(i, c);
          const u = l.priceToCoordinate(h, c);
          const _ = {
            logical: {
              index: o,
              price: i
            },
            screen: new At.Point(n, d)
          };
          const p = {
            logical: {
              index: r,
              price: h
            },
            screen: new At.Point(a, u)
          };
          this.startMovingSources(t.sources, _, null);
          this.moveSources(p);
          this.endMovingSource(false, true);
        });
        lt.isDirectionalMovementActive.setValue(false);
        this.endUndoMacro();
        return true;
      }
      _restoreStudyFactoryDefaults(e) {
        const t = new I_(this.m_model, e);
        this._pushUndoCommand(t);
      }
      _restoreLineToolFactoryDefaults(e) {
        this.beginUndoMacro(sp);
        this.saveLineToolState(e, sp);
        const t = new T_(this.m_model, e.properties(), sp);
        this._pushUndoCommand(t);
        this.saveLineToolState(e, sp);
        this.endUndoMacro();
        this.model().updateSource(e);
      }
      _removeAllDrawingToolsImpl(e, t) {
        this.selectionMacro(() => {
          if (this.lineBeingCreated()) {
            this.cancelCreatingLine();
          }
          this.dataSources().filter(eo.isLineTool).filter(e => e.isActualSymbol() && e.isUserDeletable()).filter(e => !t || t === e.toolname).filter(t => e || !t.isLocked?.()).forEach(e => this.removeSource(e, false));
        }, true);
      }
      _removeAllStudiesImpl() {
        const e = this.dataSources();
        const t = e.filter(Js.isStudy).filter(e => !e.isChildStudy() && e.removeByRemoveAllStudies());
        const i = e.filter(Js.isStudyStub);
        t.concat(i).forEach(e => this.removeSource(e, false));
      }
    }
    class $p {
      constructor() {
        this._ariaElement = null;
        this._nextAnnouncementTime = Date.now().valueOf();
        this._latestDescription = "";
        this._timeoutId = null;
        this._locale = "en";
      }
      createElement(e) {
        this._ariaElement = Pt(e);
      }
      setLocale(e) {
        this._locale = e;
      }
      async updateChartDescription(e, t, i, s) {
        if (this._locale !== "en") {
          return;
        }
        let o = `Price ${e.formatter().format(t)}`;
        if (i) {
          o += ` as of ${Tt(i / 1000, s)}`;
        }
        this._setChartDescription(o);
      }
      static getInstance() {
        if (this._instance === null) {
          this._instance = new $p();
        }
        return this._instance;
      }
      _setChartDescription(e) {
        this._latestDescription = e;
        if (this._timeoutId !== null) {
          return;
        }
        const t = Date.now().valueOf();
        if (t < this._nextAnnouncementTime) {
          this._timeoutId = setTimeout(() => {
            this._timeoutId = null;
            this._applyChartDescription();
          }, this._nextAnnouncementTime - t);
        } else {
          this._applyChartDescription();
        }
      }
      _applyChartDescription() {
        if (!this._ariaElement) {
          return;
        }
        this._ariaElement.textContent = this._latestDescription;
        const e = Date.now().valueOf();
        this._nextAnnouncementTime = e + 2000;
      }
    }
    $p._instance = null;
    var Kp = i(17402);
    const Yp = a.t(null, undefined, i(47773));
    class Zp {
      constructor(e) {
        this._lastResolvedSymbol = null;
        this._chart = e;
        this._chart.withModel(this, this._connectToModel);
      }
      _getPopupContent() {
        const e = this._getProSymbol();
        const t = new URL("https://www.tradingview.com/chart/");
        t.searchParams.append("symbol", e);
        t.searchParams.append("utm_source", "www.tradingview.com");
        t.searchParams.append("utm_medium", "widget");
        t.searchParams.append("utm_campaign", "chart");
        t.searchParams.append("utm_term", e);
        return Yp.format({
          linkStart: `<a target="_blank" href="${t.toString()}">`,
          linkEnd: "</a>"
        });
      }
      _onPopupClosed() {
        const e = this._chart.defaultSymbol();
        const t = this._getSymbol();
        let i;
        i = this._lastResolvedSymbol ? this._lastResolvedSymbol : e !== t ? e : "AAPL";
        this._chart.setSymbol(i);
      }
      _getProSymbol() {
        return this._chart.model().mainSeries().proSymbol();
      }
      _getSymbol() {
        return this._chart.model().mainSeries().actualSymbol();
      }
      _connectToModel() {
        const e = this._chart.model().mainSeries();
        e.dataEvents().symbolResolved().subscribe(this, this._onSymbolResolved);
        e.dataEvents().symbolGroupNotPermitted().subscribe(this, this._onSymbolGroupNotPermitted);
        e.dataEvents().symbolNotPermitted().subscribe(this, this.show);
      }
      _onSymbolResolved() {
        this._lastResolvedSymbol = this._getSymbol();
      }
      _onSymbolGroupNotPermitted() {
        this.show();
      }
    }
    class Xp extends Zp {
      show() {
        (0, q.showWarning)({
          title: "Unavailable",
          html: this._getPopupContent(),
          onClose: () => this._onPopupClosed()
        });
      }
    }
    const Jp = (0, ae.getLogger)("ChartApi.AbstractSession");
    var Qp;
    (function (e) {
      e[e.Disconnected = 0] = "Disconnected";
      e[e.Registered = 1] = "Registered";
      e[e.Connected = 2] = "Connected";
    })(Qp ||= {});
    class em {
      constructor(e, t, i) {
        this._isConnected = new F.WatchedValue(false);
        this._state = 0;
        this._isConnectForbidden = false;
        this._sessionId = "";
        this._sessionIdChanged = new re.Delegate();
        this._chartApi = e;
        this._sessionPrefix = t;
        this._shouldReconnectAfterCriticalError = i;
      }
      destroy() {
        this._logNormal("Destroying session");
        this._isConnected.unsubscribe();
        this.disconnect();
        this._sessionIdChanged.destroy();
        delete this._chartApi;
        this._logNormal("Session has been destroyed");
      }
      isConnected() {
        return this._isConnected;
      }
      sessionId() {
        return this._sessionId;
      }
      onSessionIdChanged() {
        return this._sessionIdChanged;
      }
      connect() {
        if (this._state === 0) {
          (0, n.assert)(!this._isConnectForbidden, "Cannot call connect because it is forbidden at this moment");
          this._setSessionId(`${this._sessionPrefix}_${(0, fe.randomHash)()}`);
          this._logNormal("Connecting session - wait until transport stay connected");
          this._state = 1;
          this._chartApi.createSession(this._sessionId, this);
        }
      }
      disconnect() {
        if (this._state !== 0) {
          (0, n.assert)(this._sessionId !== "", "sessionId must not be invalid");
          this._logNormal("Disconnecting session...");
          this._forbidConnectWhile(() => {
            if (this._chartApi.connected()) {
              this._sendRemoveSession();
            }
            this._processDestroyingOnServer();
          });
        }
      }
      onMessage(e) {
        switch (e.method) {
          case "connected":
            this._onChartApiConnected();
            return;
          case "disconnected":
            this._onChartApiDisconnected();
            return;
          case "critical_error":
            const t = String(e.params[0]);
            const i = String(e.params[1]);
            this._onCriticalError(t, i);
            return;
        }
        this._onMessage(e);
      }
      serverTime() {
        return this._chartApi.serverTime();
      }
      _getChartApi() {
        return this._chartApi;
      }
      _generateLogMessage(e) {
        return `[${this._sessionId}] ${e}`;
      }
      _onCriticalError(e, t) {
        this._logError(`Critical error. Reason=${e}, info=${t}.`);
        this._forbidConnectWhile(() => {
          this._processDestroyingOnServer();
        });
        if (this._shouldReconnectAfterCriticalError) {
          this._logNormal("Reconnecting after critical error...");
          this.connect();
        } else {
          this._logNormal("Reconnecting after critical error skipped");
        }
      }
      _onChartApiConnected() {
        (0, n.assert)(this._state === 1, "Session is not registered");
        this._logNormal("Transport is connected. Creating session on the server");
        this._sendCreateSession();
        this._state = 2;
        this._isConnected.setValue(true);
      }
      _onChartApiDisconnected() {
        this._logNormal("Transport is disconnected. Reconnecting...");
        this._forbidConnectWhile(() => {
          this._processDestroyingOnServer();
        });
        this.connect();
      }
      _setSessionId(e) {
        const t = this._sessionId;
        this._logNormal(`Changing sessionId: old=${t}, new=${e}`);
        this._sessionId = e;
        this._sessionIdChanged.fire(e, t);
      }
      _logNormal(e) {
        Jp.logNormal(this._generateLogMessage(e));
      }
      _logError(e) {
        Jp.logError(this._generateLogMessage(e));
      }
      _processDestroyingOnServer() {
        this._state = 0;
        this._isConnected.setValue(false);
        this._chartApi.removeSession(this._sessionId);
        this._setSessionId("");
      }
      _forbidConnectWhile(e) {
        this._isConnectForbidden = true;
        e();
        this._isConnectForbidden = false;
      }
    }
    class tm extends em {
      constructor(e, t = false) {
        super(e, "cs", false);
        this._sessionDisabled = false;
        this._handler = null;
        this._criticalError = new re.Delegate();
        this._symbolResolveMap = new Map();
        this._lastSymbolResolveInfoMap = new Map();
        this._disableStatistics = t;
      }
      destroy() {
        this._criticalError.destroy();
        this._handler = null;
        this._symbolResolveMap.clear();
        super.destroy();
      }
      switchTimezone(e) {
        return this._getChartApi().switchTimezone(this.sessionId(), e);
      }
      defaultResolutions() {
        return this._getChartApi().defaultResolutions();
      }
      availableCurrencies() {
        return this._getChartApi().availableCurrencies();
      }
      availableUnits() {
        return this._getChartApi().availableUnits();
      }
      availablePriceSources(e) {
        return this._getChartApi().availablePriceSources(e);
      }
      resolveSymbol(e, t, i) {
        if (this._symbolResolveMap.has(t)) {
          const [e, s] = this._symbolResolveMap.get(t);
          if (Array.isArray(s)) {
            s.push(i);
          } else {
            s.then(i);
          }
          return e;
        }
        {
          const s = [i];
          this._getChartApi().resolveSymbol(this.sessionId(), e, t, i => {
            if (i.method === "symbol_error") {
              this._symbolResolveMap.delete(t);
            } else {
              this._symbolResolveMap.set(t, [e, Promise.resolve(i)]);
              const [, s] = i.params;
              const o = {
                pro_name: s.pro_name,
                ticker: s.ticker
              };
              this._lastSymbolResolveInfoMap.set(t, o);
              if (o.pro_name) {
                this._lastSymbolResolveInfoMap.set(o.pro_name, o);
              }
              if (s.full_name) {
                this._lastSymbolResolveInfoMap.set(s.full_name, o);
              }
              if (o.ticker) {
                this._lastSymbolResolveInfoMap.set(o.ticker, o);
              }
            }
            s.forEach(e => e(i));
          });
          this._symbolResolveMap.set(t, [e, s]);
          return e;
        }
      }
      requestFirstBarTime(e, t, i) {
        return this._getChartApi().requestFirstBarTime(this.sessionId(), e, t, i);
      }
      lastSymbolResolveInfo(e) {
        return this._lastSymbolResolveInfoMap.get(e) ?? null;
      }
      createSeries(e, t, i, s, o, n, r) {
        return this._getChartApi().createSeries(this.sessionId(), e, t, i, s, o, n, r);
      }
      modifySeries(e, t, i, s, o, n, r) {
        return this._getChartApi().modifySeries(this.sessionId(), e, t, i, s, o, n, r);
      }
      removeSeries(e) {
        return !!this.isConnected().value() && this._getChartApi().removeSeries(this.sessionId(), e);
      }
      requestMoreData(e, t, i) {
        if (typeof e == "number") {
          return this._getChartApi().requestMoreData(this.sessionId(), e);
        } else {
          return this._getChartApi().requestMoreData(this.sessionId(), e, t, i);
        }
      }
      requestMoreTickmarks(e, t, i) {
        return this._getChartApi().requestMoreTickmarks(this.sessionId(), e, t, i);
      }
      setFutureTickmarksMode(e) {
        return this._getChartApi().setFutureTickmarksMode(this.sessionId(), e);
      }
      canCreateStudy(e, t) {
        return this._getChartApi().canCreateStudy(this.sessionId(), e, t);
      }
      getStudyCounter() {
        return this._getChartApi().getStudyCounter(this.sessionId());
      }
      getFundamentalCounter() {
        return this._getChartApi().getFundamentalCounter(this.sessionId());
      }
      createStudy(e, t, i, s, o, n, r) {
        return this._getChartApi().createStudy(this.sessionId(), e, t, i, s, o, n, r);
      }
      modifyStudy(e, t, i, s, o) {
        return this._getChartApi().modifyStudy(this.sessionId(), e, t, i, s, o);
      }
      notifyStudy(e, t, i) {
        return this._getChartApi().notifyStudy(this.sessionId(), e, t, i);
      }
      removeStudy(e) {
        return this._getChartApi().removeStudy(this.sessionId(), e);
      }
      createPointset(e, t, i, s, o, n) {
        return this._getChartApi().createPointset(this.sessionId(), e, t, i, s, o, n);
      }
      modifyPointset(e, t, i, s) {
        return this._getChartApi().modifyPointset(this.sessionId(), e, t, i, s);
      }
      removePointset(e) {
        return this._getChartApi().removePointset(this.sessionId(), e);
      }
      setVisibleTimeRange(e, t, i, s, o, n, r) {
        this._getChartApi().setVisibleTimeRange(this.sessionId(), e, t, i, s, true, o, n, undefined, r);
      }
      criticalError() {
        return this._criticalError;
      }
      connect(e = null) {
        if (e !== null) {
          this._handler = e;
        }
        this._symbolResolveMap.clear();
        super.connect();
      }
      setHandler(e) {
        this._handler = e;
      }
      connected() {
        return this.isConnected().value() && !this._sessionDisabled;
      }
      disable() {
        this._sessionDisabled = true;
      }
      chartApi() {
        return this._getChartApi();
      }
      _sendCreateSession() {
        Object.keys(this).forEach(e => {
          if (/^(s|st|symbol_)\d+$/.test(e)) {
            delete this[e];
          }
        });
        this._getChartApi().chartCreateSession(this.sessionId(), this._disableStatistics);
      }
      _sendRemoveSession() {
        this._getChartApi().chartDeleteSession(this.sessionId());
      }
      _onMessage(e) {
        if (this._handler) {
          this._handler(e);
        }
      }
      _onCriticalError(e, t) {
        this._criticalError.fire(e, t);
        super._onCriticalError(e, t);
      }
    }
    var im = i(2433);
    var sm = i(72595);
    const om = (0, li.extractThemedColors)(xs.lightTheme.content.mainSourceProperties, xs.darkTheme.content.mainSourceProperties);
    const nm = "chartproperties.mainSeriesProperties";
    const rm = (0, s.default)(() => {
      const e = (0, sm.createPropertySchema)((0, Qe.default)((0, h.factoryDefaults)(nm), im.light.content.mainSourceProperties), 7);
      (0, Qe.default)(e, {
        subschema: {
          priceAxisProperties: {
            lockScale: {
              saveFlags: 6
            },
            percentage: {
              saveFlags: 6
            },
            percentageDisabled: {
              saveFlags: 6
            },
            indexedTo100: {
              saveFlags: 6
            },
            log: {
              saveFlags: 6
            },
            logDisabled: {
              saveFlags: 6
            },
            isInverted: {
              saveFlags: 6
            },
            autoScaleDisabled: {
              saveFlags: 6
            }
          },
          visible: {
            type: sm.DataTypes.BOOLEAN,
            saveFlags: 2
          },
          symbol: {
            type: sm.DataTypes.STRING,
            saveFlags: 2
          },
          shortName: {
            type: sm.DataTypes.STRING,
            saveFlags: 2
          },
          timeframe: {
            type: sm.DataTypes.STRING,
            saveFlags: 2
          },
          interval: {
            type: sm.DataTypes.STRING,
            saveFlags: 2
          },
          currencyId: {
            type: sm.DataTypes.STRING,
            saveFlags: 2
          },
          unitId: {
            type: sm.DataTypes.STRING,
            saveFlags: 2
          },
          style: {
            type: sm.DataTypes.NUMBER,
            saveFlags: 2
          },
          sessionId: {
            type: sm.DataTypes.STRING,
            saveFlags: 2
          }
        }
      });
      return e;
    });
    class am extends li.DefaultProperty {
      constructor() {
        super({
          defaultName: nm,
          themedColors: om,
          schema: rm()
        });
      }
    }
    let lm = null;
    var cm = i(7029);
    var hm = i(34585);
    var dm = i(80387);
    var um = i(62400);
    var _m = i(78956);
    function pm(e) {
      const t = e.model().dataSources();
      const s = t.filter(_m.isLineTool).filter(e => e.isActualSymbol() && e.isUserDeletable()).length;
      const o = t.filter(Js.isStudy).filter(e => e.removeByRemoveAllStudies()).length;
      const n = a.t(null, {
        plural: "{amount} drawings",
        count: s,
        replace: {
          amount: s.toString()
        }
      }, i(22299));
      const r = a.t(null, {
        plural: "{amount} indicators",
        count: o,
        replace: {
          amount: o.toString()
        }
      }, i(68984));
      return {
        drawings: {
          label: a.t(null, {
            replace: {
              drawings: n
            }
          }, i(86285)),
          disabled: s === 0
        },
        studies: {
          label: a.t(null, {
            replace: {
              indicators: r
            }
          }, i(87797)),
          disabled: o === 0
        },
        all: {
          label: a.t(null, {
            replace: {
              drawings: n,
              indicators: r
            }
          }, i(87796)),
          disabled: s === 0 && o === 0
        }
      };
    }
    var mm = i(86235);
    function gm(e) {
      const t = e.options();
      const s = {
        label: (0, hm.appendEllipsis)(cm.t(null, undefined, i(2569))),
        statName: "ChangeInterval",
        onExecute: () => (0, mm.showChangeIntervalDialogAsync)({
          initVal: de.linking.interval.value(),
          selectOnInit: true
        })
      };
      if (!!(0, l.enabled)("show_interval_dialog_on_key_press") && !t.readOnly && !t.hideSymbolSearch) {
        s.shortcutHint = ",";
        s.hotkeyGroup = e.hotkeys();
        s.hotkeyHash = 188;
      }
      return new Jo.Action({
        actionId: "Chart.Dialogs.ShowChangeInterval",
        options: s
      });
    }
    class fm extends Jo.Action {
      constructor(e, t = new F.WatchedValue(false)) {
        super({
          ...e,
          options: {
            ...e.options,
            checkable: true,
            checked: t.value(),
            onExecute: () => {
              this._wv.setValue(!this._wv.value());
            }
          }
        });
        this._updateChecked = e => {
          this.update({
            checked: e
          });
        };
        t.subscribe(this._updateChecked);
        this._wv = t;
      }
      destroy() {
        this._wv.unsubscribe(this._updateChecked);
        super.destroy();
      }
    }
    const ym = (0, l.enabled)("show_average_close_price_line_and_label");
    const vm = new Di.TranslatedString("scale price chart only", cm.t(null, undefined, i(63796)));
    const Sm = new Di.TranslatedString("stay in drawing mode", cm.t(null, undefined, i(4114)));
    const bm = new Di.TranslatedString("hide marks on bars", cm.t(null, undefined, i(62249)));
    const wm = new Di.TranslatedString("change symbol last value visibility", cm.t(null, undefined, i(67453)));
    new Di.TranslatedString("change symbol previous close value visibility", cm.t(null, undefined, i(4729)));
    new Di.TranslatedString("change previous close price line visibility", cm.t(null, undefined, i(58419)));
    const Cm = new Di.TranslatedString("change symbol labels visibility", cm.t(null, undefined, i(73357)));
    const Pm = new Di.TranslatedString("change indicators value labels visibility", cm.t(null, undefined, i(64729)));
    const Tm = new Di.TranslatedString("change indicators name labels visibility", cm.t(null, undefined, i(24893)));
    new Di.TranslatedString("change bid and ask labels visibility", cm.t(null, undefined, i(69362)));
    new Di.TranslatedString("change bid and ask lines visibility", cm.t(null, undefined, i(52919)));
    new Di.TranslatedString("change pre/post market price label visibility", cm.t(null, undefined, i(30870)));
    new Di.TranslatedString("change pre/post market price line visibility", cm.t(null, undefined, i(11718)));
    const xm = new Di.TranslatedString("change high and low price labels visibility", cm.t(null, undefined, i(24226)));
    const Im = new Di.TranslatedString("change high and low price lines visibility", cm.t(null, undefined, i(80692)));
    const Mm = new Di.TranslatedString("change average close price label visibility", cm.t(null, undefined, i(76852)));
    const Am = new Di.TranslatedString("change average close price line visibility", cm.t(null, undefined, i(1022)));
    const Lm = new Di.TranslatedString("change countdown to bar close visibility", cm.t(null, undefined, i(39383)));
    const km = new Di.TranslatedString("change plus button visibility", cm.t(null, undefined, i(96379)));
    const Dm = new Di.TranslatedString("change session breaks visibility", cm.t(null, undefined, i(38413)));
    const Em = new Di.TranslatedString("change price line visibility", cm.t(null, undefined, i(8662)));
    const Bm = new Di.TranslatedString("change timezone", cm.t(null, undefined, i(20137)));
    function Vm(e) {
      const t = e.hotkeys();
      const s = e.model();
      const o = e.options();
      const n = e.properties();
      const r = new Jo.Action({
        actionId: "Chart.Series.PriceScale.ToggleInvertPriceScale",
        options: {
          label: cm.t(null, undefined, i(37189)),
          statName: "Invert Scale",
          checkable: true,
          onExecute: () => s.invertPriceScale(s.mainSeries().priceScale()),
          hotkeyGroup: t,
          hotkeyHash: V.Modifiers.Alt + 73
        }
      });
      const c = new Jo.Action({
        actionId: "Chart.Series.PriceScale.ToggleAutoScale",
        options: {
          label: cm.t(null, undefined, i(24157)),
          checkable: true,
          onExecute: e => {
            const t = s.mainSeries().priceScale();
            s.togglePriceScaleAutoScaleMode(t);
            e.update({
              checked: t.isAutoScale()
            });
          }
        }
      });
      const h = new Jo.Action({
        actionId: "Chart.Scales.ToggleLockPriceToBarRatio",
        options: {
          label: cm.t(null, undefined, i(14017)),
          checkable: true,
          statName: "ToggleLockScale",
          onExecute: () => s.togglePriceScaleLockScaleMode(s.mainSeries().priceScale())
        }
      });
      const d = new Jo.Action({
        actionId: "Chart.Series.PriceScale.ToggleRegular",
        options: {
          label: cm.t(null, {
            context: "scale_menu"
          }, i(55300)),
          checkable: true,
          statName: "ToggleRegularScale",
          onExecute: e => {
            const t = s.mainSeries().priceScale();
            s.setPriceScaleRegularScaleMode(t);
            e.update({
              checked: t.isRegular()
            });
          }
        }
      });
      const u = new Jo.Action({
        actionId: "Chart.Series.PriceScale.TogglePercentage",
        options: {
          label: cm.t(null, undefined, i(6919)),
          checkable: true,
          statName: "TogglePercantage",
          onExecute: () => s.togglePriceScalePercentageScaleMode(s.mainSeries().priceScale()),
          hotkeyGroup: t,
          hotkeyHash: V.Modifiers.Alt + 80
        }
      });
      const _ = new Jo.Action({
        actionId: "Chart.Series.PriceScale.ToggleIndexedTo100",
        options: {
          label: cm.t(null, undefined, i(89999)),
          checkable: true,
          statName: "ToggleIndexedTo100",
          onExecute: () => s.togglePriceScaleIndexedTo100ScaleMode(s.mainSeries().priceScale())
        }
      });
      const p = new Jo.Action({
        actionId: "Chart.Series.PriceScale.ToggleLogarithmic",
        options: {
          label: cm.t(null, undefined, i(16170)),
          statName: "ToggleLogScale",
          checkable: true,
          onExecute: () => s.togglePriceScaleLogScaleMode(s.mainSeries().priceScale()),
          hotkeyGroup: t,
          hotkeyHash: V.Modifiers.Alt + 76
        }
      });
      const m = new Jo.Action({
        actionId: "Chart.ChangeTimeZone",
        options: {
          label: cm.t(null, undefined, i(20909)),
          statName: "TimeZone",
          onDestroy: () => e.properties().childs().timezone.unsubscribeAll(m)
        }
      });
      const g = e.properties().childs().timezone;
      const f = () => {
        const t = [];
        const i = Pe.availableTimezones;
        const s = e => e.id === g.value();
        i.forEach(i => {
          const o = new Jo.Action({
            actionId: "Chart.ChangeTimeZone",
            options: {
              label: i.title,
              checkable: true,
              checked: s(i),
              statName: "SetTimeZone",
              onExecute: () => {
                e.model().setProperty(g, i.id, Bm);
              }
            }
          });
          t.push(o);
        });
        m.update({
          subItems: t
        });
      };
      f();
      g.subscribe(m, f);
      const y = new nn.ActionWithStandardIcon({
        actionId: "Chart.TimeScale.Reset",
        options: {
          label: cm.t(null, undefined, i(54170)),
          iconId: "Chart.Reset",
          statName: "ResetScale",
          onExecute: () => s.resetTimeScale(),
          hotkeyGroup: e.hotkeys(),
          hotkeyHash: V.Modifiers.Mod + V.Modifiers.Alt + 81
        }
      });
      const v = new Jo.Action({
        actionId: "Chart.Dialogs.ShowInsertIndicators",
        options: {
          label: (0, hm.appendEllipsis)(cm.t(null, undefined, i(87829))),
          statName: "InsertIndicator",
          onExecute: () => e.showIndicators(),
          ...(o.indicatorsDialogShortcutEnabled ? {
            hotkeyGroup: t,
            hotkeyHash: 191
          } : undefined)
        }
      });
      const S = new Jo.Action({
        actionId: "Chart.Dialogs.ShowCompareOrAddSymbol",
        options: {
          label: (0, hm.appendEllipsis)(cm.t(null, undefined, i(53942))),
          statName: "CompareOrAddSymbol",
          onExecute: () => e.toggleCompareOrAdd()
        }
      });
      const b = new nn.ActionWithStandardIcon({
        actionId: "Chart.Dialogs.ShowGeneralSettings",
        options: {
          label: (0, hm.appendEllipsis)(cm.t(null, undefined, i(32514))),
          iconId: "Settings",
          statName: "ChartProperties",
          onExecute: () => e.showGeneralChartProperties()
        }
      });
      const w = new nn.ActionWithStandardIcon({
        actionId: "Chart.Dialogs.ShowGeneralSettings.SymbolTab",
        options: {
          label: (0, hm.appendEllipsis)(cm.t(null, undefined, i(32514))),
          iconId: "Settings",
          statName: "MainSeriesProperties",
          onExecute: () => e.showGeneralChartProperties(Zs.TabNames.symbol)
        }
      });
      const C = new nn.ActionWithStandardIcon({
        actionId: "Chart.Dialogs.ShowGeneralSettings.ScalesTab",
        options: {
          label: (0, hm.appendEllipsis)(cm.t(null, undefined, i(93907))),
          iconId: "Settings",
          statName: "ScalesProperties",
          onExecute: () => e.showGeneralChartProperties(Zs.TabNames.scales)
        }
      });
      const P = new Jo.Action({
        actionId: "Chart.SelectedObject.ToggleLocked",
        options: {
          label: cm.t(null, undefined, i(79777)),
          statName: "ToggleLockSelectedObject",
          onExecute: () => e.toggleLockSelectedObject()
        }
      });
      const T = new nn.ActionWithStandardIcon({
        actionId: "Chart.SelectedObject.Hide",
        options: {
          label: cm.t(null, undefined, i(27298)),
          iconId: "Chart.Hide",
          statName: "HideSelectedObject",
          onExecute: () => e.hideSelectedObject()
        }
      });
      const x = new en({
        actionId: "Chart.PriceScale.ToggleAutoScaleSeriesOnly",
        options: {
          label: cm.t(null, undefined, i(43758)),
          checkable: true,
          statName: "ScalePriceChartOnly"
        }
      }, {
        property: n.childs().scalesProperties.childs().scaleSeriesOnly,
        undoModel: s,
        undoText: vm
      });
      const I = new fm({
        actionId: "Chart.DrawingToolbar.ToggleVisibility",
        options: {
          label: cm.t(null, undefined, i(93864)),
          statName: "ToggleDrawingToolbar"
        }
      }, o.isDrawingToolbarVisible);
      const M = new en({
        actionId: "",
        options: {
          label: cm.t(null, undefined, i(4035)),
          checkable: true,
          statName: "ToggleStayInDrawingMode"
        }
      }, {
        property: lt.properties().childs().stayInDrawingMode,
        undoModel: s,
        undoText: Sm
      });
      const A = new en({
        actionId: "Chart.Marks.ToggleVisibility",
        options: {
          label: cm.t(null, undefined, i(28345)),
          checkable: true,
          statName: "ToggleHideMarksOnBars"
        }
      }, {
        property: lt.hideMarksOnBars(),
        undoModel: s,
        undoText: bm,
        callback: e => lt.hideMarksOnBars().setValue(e.isChecked())
      });
      const L = new en({
        actionId: "Chart.PriceScale.Labels.ToggleSeriesLastValueVisibility",
        options: {
          label: cm.t(null, undefined, i(10127)),
          checkable: true,
          checked: false,
          statName: "ToggleSymbolLastValue"
        }
      }, {
        property: n.childs().scalesProperties.childs().showSeriesLastValue,
        undoModel: s,
        undoText: wm
      });
      const k = new en({
        actionId: "Chart.PriceScale.Labels.ToggleSymbolNameLabelsVisibility",
        options: {
          label: cm.t(null, undefined, i(32390)),
          checkable: true,
          checked: false,
          statName: "ToggleSymbolLabels"
        }
      }, {
        property: n.childs().scalesProperties.childs().showSymbolLabels,
        undoModel: s,
        undoText: Cm
      });
      const D = (0, t_.combineProperty)((e, t) => e || false, n.childs().scalesProperties.childs().showStudyLastValue.weakReference(), n.childs().scalesProperties.childs().showFundamentalLastValue.weakReference());
      const E = new en({
        actionId: "Chart.PriceScale.Labels.ToggleIndicatorsValueLabelsVisibility",
        options: {
          label: cm.t(null, undefined, i(46850)),
          checkable: true,
          checked: false,
          statName: "ToggleStudiesAndFundamentalsPriceLabels",
          onDestroy: () => {
            D.destroy();
          }
        }
      }, {
        property: D,
        undoModel: s,
        undoText: null,
        callback: () => {
          const e = !D.value();
          s.beginUndoMacro(Pm);
          s.setProperty(n.childs().scalesProperties.childs().showStudyLastValue, e, null);
          s.endUndoMacro();
        }
      });
      const B = (0, t_.combineProperty)((e, t) => e || false, n.childs().scalesProperties.childs().showStudyPlotLabels.weakReference(), n.childs().scalesProperties.childs().showFundamentalNameLabel.weakReference());
      const R = new en({
        actionId: "Chart.PriceScale.Labels.ToggleIndicatorsNameLabelsVisibility",
        options: {
          label: cm.t(null, undefined, i(54418)),
          checkable: true,
          checked: false,
          statName: "ToggleStudiesAndFundamentalsNameLabels",
          onDestroy: () => {
            B.destroy();
          }
        }
      }, {
        property: B,
        undoModel: s,
        undoText: null,
        callback: () => {
          const e = !B.value();
          s.beginUndoMacro(Tm);
          s.setProperty(n.childs().scalesProperties.childs().showStudyPlotLabels, e, null);
          s.endUndoMacro();
        }
      });
      const N = s.mainSeries().properties().childs().highLowAvgPrice.childs();
      const O = new en({
        actionId: "Chart.PriceScale.Labels.ToggleHighLowPriceLabelsVisibility",
        options: {
          label: cm.t(null, undefined, i(99479)),
          checkable: true,
          checked: false,
          statName: "ToggleHighLowPriceLabels"
        }
      }, {
        property: N.highLowPriceLabelsVisible,
        undoModel: s,
        undoText: xm
      });
      const F = new en({
        actionId: "Chart.Lines.ToggleHighLowLinesVisibility",
        options: {
          label: cm.t(null, undefined, i(33766)),
          checkable: true,
          checked: false,
          statName: "ToggleHighLowPriceLine"
        }
      }, {
        property: N.highLowPriceLinesVisible,
        undoModel: s,
        undoText: Im
      });
      const W = new en({
        actionId: "Chart.PriceScale.ToggleCountdownToBarCloseVisibility",
        options: {
          label: cm.t(null, undefined, i(83140)),
          checkable: true,
          checked: false,
          statName: "ToggleCountdown"
        }
      }, {
        property: s.mainSeries().properties().childs().showCountdown,
        undoModel: s,
        undoText: Lm
      });
      const H = new en({
        actionId: "Chart.PriceScale.ToggleAddOrderPlusButtonVisibility",
        options: {
          label: cm.t(null, undefined, i(71566)),
          checkable: true,
          checked: Od.addPlusButtonProperty.value(),
          statName: "ToggleAddOrderPlusButton"
        }
      }, {
        property: Od.addPlusButtonProperty,
        undoModel: s,
        undoText: km
      });
      const z = new nn.ActionWithStandardIcon({
        actionId: "Chart.Dialogs.ShowSymbolInfo",
        options: {
          label: (0, hm.appendEllipsis)(cm.t(null, undefined, i(75594))),
          iconId: "Chart.SymbolInfo",
          checkable: false,
          statName: "SymbolInfo",
          onExecute: () => {
            {
              const t = e.model().model();
              const i = t.mainSeries().symbolInfo();
              if (i) {
                const e = t.availableUnits();
                const s = t.unitConversionEnabled();
                (0, dm.showSymbolInfoDialog)({
                  symbolInfo: i,
                  showUnit: s,
                  unitDescription: t => t ? e.description(t) : "",
                  dateFormatter: t.dateFormatter()
                });
              }
            }
          }
        }
      });
      const U = new Jo.Action({
        actionId: "Chart.PriceScale.MergeAllScalesToLeft",
        options: {
          label: cm.t(null, undefined, i(62329)),
          statName: "MergeAllScalesToLeft",
          onExecute: () => s.mergeAllScales("left")
        }
      });
      const j = new Jo.Action({
        actionId: "Chart.PriceScale.MergeAllScalesToRight",
        options: {
          label: cm.t(null, undefined, i(55813)),
          statName: "MergeAllScalesToRight",
          onExecute: () => s.mergeAllScales("right")
        }
      });
      const G = new Jo.Action({
        actionId: "Chart.PriceScale.MoveToLeft",
        options: {
          label: cm.t(null, undefined, i(26493)),
          statName: "MoveScaleToLeft",
          onExecute: () => s.mergeAllScales("left")
        }
      });
      const q = new Jo.Action({
        actionId: "Chart.PriceScale.MoveToRight",
        options: {
          label: cm.t(null, undefined, i(40789)),
          statName: "MoveScaleToRight",
          onExecute: () => s.mergeAllScales("right")
        }
      });
      const $ = new nn.ActionWithStandardIcon({
        actionId: "Chart.Scales.Reset",
        options: {
          label: cm.t(null, undefined, i(75246)),
          iconId: "Chart.Reset",
          statName: "ResetChart",
          onExecute: () => e.GUIResetScales(),
          hotkeyGroup: t,
          hotkeyHash: V.Modifiers.Alt + 82
        }
      });
      const K = e.model().model().sessions().properties().childs().sessionHighlight.childs().vertlines.childs().sessBreaks.childs().visible;
      const Y = (0, t_.createWVFromProperty)(e.model().mainSeries().isDWMProperty());
      const Z = new Jo.Action({
        actionId: "Chart.SessionBreaks.ToggleVisibility",
        options: {
          label: cm.t(null, undefined, i(66707)),
          checkable: true,
          checked: K.value(),
          statName: "ToggleSessionBreaks",
          disabled: Y.value(),
          onExecute: () => {
            if (K) {
              s.setProperty(K, !K.value(), Dm);
            }
          },
          onDestroy: () => Y.destroy()
        }
      });
      Y.subscribe(() => Z.update({
        disabled: Y.value()
      }));
      const X = new en({
        actionId: "Chart.Lines.ToggleSeriesPriceLineVisibility",
        options: {
          label: cm.t(null, undefined, i(72926)),
          checkable: true,
          statName: "TogglePriceLine"
        }
      }, {
        property: s.mainSeries().properties().childs().showPriceLine,
        undoModel: s,
        undoText: Em
      });
      const J = new Jo.Action({
        actionId: "Chart.Undo",
        options: {
          label: cm.t(null, undefined, i(14804)),
          onExecute: () => {
            (0, ne.trackEvent)("GUI", "Undo");
            s.undoHistory().undo();
          },
          onDestroy: () => {
            e.model().undoHistory().undoStack().onChange().unsubscribeAll(J);
          },
          disabled: true,
          hotkeyGroup: t,
          hotkeyHash: V.Modifiers.Mod + 90,
          isRepeatAccepted: true
        }
      });
      e.model().undoHistory().undoStack().onChange().subscribe(J, () => J.update({
        disabled: e.model().undoHistory().undoStack().isEmpty()
      }));
      const Q = new Jo.Action({
        actionId: "Chart.Redo",
        options: {
          label: cm.t(null, undefined, i(48236)),
          onExecute: () => {
            (0, ne.trackEvent)("GUI", "Redo");
            e.model().undoHistory().redo();
          },
          onDestroy: () => {
            e.model().undoHistory().redoStack().onChange().unsubscribeAll(Q);
          },
          disabled: true,
          hotkeyGroup: t,
          hotkeyHash: V.Modifiers.Mod + 89,
          isRepeatAccepted: true
        }
      });
      e.model().undoHistory().redoStack().onChange().subscribe(Q, () => Q.update({
        disabled: e.model().undoHistory().redoStack().isEmpty()
      }));
      const ee = {
        invertSeriesScale: r,
        autoSeriesScale: c,
        lockSeriesScale: h,
        regularSeriesScale: d,
        percentSeriesScale: u,
        indexedTo100SeriesScale: _,
        logSeriesScale: p,
        applyTimeZone: m,
        symbolSearch: new Jo.Action({
          actionId: "Chart.Dialogs.ShowChangeSymbol",
          options: {
            label: (0, hm.appendEllipsis)(a.t(null, undefined, i(85124))),
            statName: "ChangeSymbol",
            onExecute: () => {
              (0, Ls.showDialog)({
                defaultValue: "",
                trackResultsOptions: {
                  trackResults: false,
                  emptySearchType: "empty_result__supercharts"
                },
                enableOptionsChain: l.enabled("symbol_search_option_chain_selector")
              });
            }
          }
        }),
        changeInterval: gm(e),
        timeScaleReset: y,
        insertIndicator: v,
        compareOrAdd: S,
        chartProperties: b,
        mainSeriesPropertiesAction: w,
        scalesProperties: C,
        lineToggleLock: P,
        seriesHide: T,
        studyHide: T,
        lineHide: T,
        scaleSeriesOnly: x,
        drawingToolbarAction: I,
        stayInDrawingModeAction: M,
        hideAllMarks: A,
        showSeriesLastValue: L,
        showSymbolLabelsAction: k,
        showStudyLastValue: E,
        showStudyPlotNamesAction: R,
        showHighLowPriceLabels: O,
        showHighLowPriceLines: F,
        showCountdown: W,
        addPlusButton: H,
        showSymbolInfoDialog: z,
        mergeLeftScalesAction: U,
        mergeRightScalesAction: j,
        moveScaleToLeft: G,
        moveScaleToRight: q,
        chartReset: $,
        sessionBreaks: Z,
        showPriceLine: X,
        undo: J,
        redo: Q
      };
      if (o.goToDateEnabled) {
        ee.gotoDate = new Jo.Action({
          actionId: "Chart.Dialogs.ShowGoToDate",
          options: {
            label: (0, hm.appendEllipsis)(cm.t(null, undefined, i(54280))),
            statName: "GoToDate",
            onExecute: () => (0, um.showGoToDateDialog)(e.chartWidgetCollection().activeChartWidget.value()),
            hotkeyGroup: t,
            hotkeyHash: V.Modifiers.Alt + 71
          }
        });
      }
      if ((0, l.enabled)("show_object_tree")) {
        ee.paneObjectTree = new Jo.Action({
          actionId: "Chart.ObjectTree.Show",
          options: {
            label: (0, hm.appendEllipsis)(cm.t(null, undefined, i(51221))),
            statName: "ObjectsTree",
            onExecute: () => e.showObjectsTreePanelOrDialog()
          }
        });
      }
      if ((0, l.enabled)("property_pages")) {
        ee.format = new nn.ActionWithStandardIcon({
          actionId: "Chart.SelectedObject.ShowSettingsDialog",
          options: {
            label: (0, hm.appendEllipsis)(cm.t(null, undefined, i(32514))),
            iconId: "Settings",
            statName: "EditSelectedObject",
            onExecute: () => e.showSelectedSourcesProperties()
          }
        });
      }
      if (ym) {
        ee.showAverageClosePriceLabel = new en({
          actionId: "Chart.PriceScale.Labels.ToggleAveragePriceLabelVisibility",
          options: {
            label: cm.t(null, undefined, i(21841)),
            checkable: true,
            checked: false,
            statName: "ToggleAverageClosePriceLabel"
          }
        }, {
          property: N.averageClosePriceLabelVisible,
          undoModel: s,
          undoText: Mm
        });
        ee.showAverageClosePriceLine = new en({
          actionId: "Chart.Lines.ToggleAverageLineVisibility",
          options: {
            label: cm.t(null, undefined, i(16138)),
            checkable: true,
            checked: false,
            statName: "ToggleAverageClosePriceLine"
          }
        }, {
          property: N.averageClosePriceLineVisible,
          undoModel: s,
          undoText: Am
        });
      }
      if (!e.readOnly()) {
        const s = function (e) {
          const t = pm(e);
          const i = new Jo.Action({
            actionId: "Chart.RemoveAllLineTools",
            options: {
              label: t.drawings.label,
              disabled: t.drawings.disabled,
              statName: "RemoveAllDrawingTools",
              onExecute: () => e.removeAllDrawingTools()
            }
          });
          const s = new Jo.Action({
            actionId: "Chart.RemoveAllIndicators",
            options: {
              label: t.studies.label,
              disabled: t.studies.disabled,
              statName: "RemoveAllIndicators",
              onExecute: () => e.removeAllStudies()
            }
          });
          const o = new Jo.Action({
            actionId: "Chart.RemoveAllIndicatorsAndLineTools",
            options: {
              label: t.all.label,
              disabled: t.all.disabled,
              statName: "RemoveAllIndicatorsAndDrawingTools",
              onExecute: () => e.removeAllStudiesDrawingTools()
            }
          });
          e.model().model().dataSourceCollectionChanged().subscribe(null, () => {
            const {
              studies: t,
              drawings: n,
              all: r
            } = pm(e);
            s.update({
              disabled: t.disabled,
              label: t.label
            });
            i.update({
              disabled: n.disabled,
              label: n.label
            });
            o.update({
              disabled: r.disabled,
              label: r.label
            });
          });
          return {
            drawings: i,
            studies: s,
            all: o
          };
        }(e);
        ee.paneRemoveAllStudies = s.studies;
        ee.paneRemoveAllDrawingTools = s.drawings;
        ee.paneRemoveAllStudiesDrawingTools = s.all;
        ee.applyStudiesToAllCharts = new Jo.Action({
          actionId: "Chart.ApplyIndicatorsToAllCharts",
          options: {
            label: cm.t(null, undefined, i(22437)),
            statName: "ApplyIndicatorsToAllCharts",
            onExecute: () => e.chartWidgetCollection().applyIndicatorsToAllCharts(e)
          }
        });
        ee.studyRemove = ee.lineRemove = new nn.ActionWithStandardIcon({
          actionId: "Chart.SelectedObject.Remove",
          options: {
            label: cm.t(null, undefined, i(67410)),
            iconId: "Chart.RemoveSelectedObject",
            statName: "RemoveSelectedObject",
            onExecute: () => {
              (e.chartWidgetCollection().activeChartWidget.value() ?? e).removeSelectedSources();
            },
            hotkeyGroup: t,
            hotkeyHash: V.isMacKeyboard ? 8 : 46
          }
        });
      }
      return ee;
    }
    var Rm = i(19334);
    var Nm = i(55744);
    i(43882);
    const Om = (0, ae.getLogger)("ChartWidget", {
      color: "#606"
    });
    const Fm = l.enabled("chart_content_overrides_by_defaults");
    const Wm = l.enabled("symphony_embed");
    const Hm = new Di.TranslatedString("hide {title}", a.t(null, undefined, i(13017)));
    const zm = new Di.TranslatedString("unlock {title}", a.t(null, undefined, i(12525)));
    const Um = new Di.TranslatedString("lock {title}", a.t(null, undefined, i(76104)));
    const jm = new Di.TranslatedString("change session", a.t(null, undefined, i(87041)));
    const Gm = {
      addToWatchlistEnabled: true,
      showFinancialsEnabled: false,
      sourceSelectionEnabled: true,
      propertyPagesEnabled: true,
      paneContextMenuEnabled: true,
      priceScaleContextMenuEnabled: true,
      currencyConversionEnabled: false,
      unitConversionEnabled: false,
      goToDateEnabled: false,
      marketStatusWidgetEnabled: true,
      chartWarningWidgetEnabled: true,
      dataProblemWidgetEnabled: true,
      paneControlsEnabled: true,
      isSymbolAvailable: e => Promise.resolve(true),
      legendWidgetEnabled: true,
      chartEventsEnabled: true,
      newsNotificationsEnabled: true,
      esdEnabled: false,
      latestUpdatesEnabled: false,
      continuousContractSwitchesEnabled: false,
      futuresContractExpirationEnabled: false,
      croppedTickMarks: true,
      countdownEnabled: true,
      lastPriceAnimationEnabled: true,
      useKineticScroll: ze.CheckMobile.any(),
      indicatorsDialogShortcutEnabled: true,
      handleScale: {
        mouseWheel: true,
        pinch: true,
        axisPressedMouseMove: {
          time: true,
          price: true
        }
      },
      handleScroll: {
        mouseWheel: true,
        pressedMouseMove: true,
        horzTouchDrag: true,
        vertTouchDrag: true
      }
    };
    const qm = (0, li.extractThemedColors)(xs.lightTheme.content.chartProperties, xs.darkTheme.content.chartProperties);
    var $m;
    function Km(e, t, i, s = 0) {
      const o = t.mainSeries().syncModel();
      const n = e.mainSeries().syncModel();
      let r = i;
      if (o !== null && n !== null) {
        const t = e.createSyncPoint(o.syncSourceTarget(), n.syncSourceTarget());
        if (s !== 0) {
          i = o.projectTime(i, s);
        }
        r = t.sourceTimeToTargetTime(i);
      }
      return e.timeScale().points().roughIndex(r, n && n.distance.bind(n));
    }
    (function (e) {
      e[e.ShowTimeAxisMinChartHeight = 61] = "ShowTimeAxisMinChartHeight";
      e[e.ShowPriceAxisMinChartWidth = 102] = "ShowPriceAxisMinChartWidth";
    })($m ||= {});
    const Ym = new Set(["Volume@tv-basicstudies", "Compare@tv-basicstudies", "Overlay@tv-basicstudies", "Dividends@tv-basicstudies", "Earnings@tv-basicstudies", "Splits@tv-basicstudies", "BarSetContinuousRollDates@tv-corestudies", "Sessions@tv-basicstudies", "VbPSessionsRough@tv-volumebyprice", "AnchoredVWAP@tv-basicstudies", "RegressionTrend@tv-basicstudies", "VbPAnchored@tv-basicstudies", "VbPFixed@tv-basicstudies", "VbPFixed@tv-volumebyprice", "LongShortPosition@tv-basicstudies"]);
    const Zm = (0, s.default)(() => {
      window.ChartApiInstance.setIsNonCountedStudyFn(e => Ym.has(e));
    });
    class Xm {
      constructor(e, t) {
        this.activePaneWidget = null;
        this._model = null;
        this._mainDiv = null;
        this._parent = null;
        this._elTooltipDiv = null;
        this._paneWidgets = new F.WatchedValue([]);
        this._timeAxisWidget = null;
        this._paneSeparators = [];
        this._controlBarNavigation = null;
        this._lineToolsSynchronizer = null;
        this._lineToolsSynchronizerHasChanges = null;
        this._modelCreated = new re.Delegate();
        this._isDestroyed = false;
        this._customLegendWidgetsFactoryMap = new Map();
        this._backgroundTopTheme = new F.WatchedValue("light");
        this._backgroundBasedTheme = new F.WatchedValue("light");
        this._backgroundBottomTheme = new F.WatchedValue("light");
        this._backgroundTopColorSpawn = null;
        this._backgroundBottomColorSpawn = null;
        this._lhsAxesWidth = 0;
        this._rhsAxesWidth = 0;
        this._lhsPriceAxisWidthChanged = new re.Delegate();
        this._rhsPriceAxisWidthChanged = new re.Delegate();
        this._hotkeysListener = null;
        this._mouseWheelHelper = null;
        this._onWheelBound = null;
        this._justActivated = false;
        this._inited = false;
        this._containsData = false;
        this._initialLoading = false;
        this._onWidget = false;
        this._widgetCustomer = undefined;
        this._defInterval = null;
        this._defStyle = null;
        this._defTimeframe = null;
        this._removeMaximizeHotkey = null;
        this._invalidationMask = null;
        this._drawPlanned = false;
        this._drawRafId = 0;
        this._inLoadingState = false;
        this._timingsMeter = null;
        this._tagsChanged = new re.Delegate();
        this._redraw = new re.Delegate();
        this._isVisible = new F.WatchedValue(true);
        this._collapsed = new F.WatchedValue(false);
        this._dataWindowWidget = null;
        this._resizeHandler = null;
        this._spinner = null;
        this._symbolWV = new F.WatchedValue();
        this._resolutionWV = new F.WatchedValue();
        this._actions = null;
        this._updateThemedColorBound = this._updateThemedColor.bind(this);
        this._disconnected = new re.Delegate();
        this._reconnectBailout = new re.Delegate();
        this._connected = new re.Delegate();
        this._chartWidgetInitialized = new re.Delegate();
        this._aboutToBeDestroyed = new re.Delegate();
        this._saveChartService = null;
        this._objectTreeDialogController = null;
        this._chartPaintedPromise = null;
        this._noExchangeSubscrptionWarning = null;
        this._paneWidgetsSharedState = new yr();
        this._onZoom = new re.Delegate();
        this._onScroll = new re.Delegate();
        this._availableScreen = null;
        this._hoveredPriceAxes = new Set();
        this._anyAxisHovered = new F.WatchedValue(false);
        this._linkingGroupIndex = new F.WatchedValue(null);
        this._isHovered = new F.WatchedValue(false);
        this._activeHint = null;
        this._eventHintDeferredPromise = null;
        this._warningHintDeferredPromise = null;
        this._setSymbolIntervalContentOverrides = {};
        this._ariaPriceDescription = null;
        this._definitionsViewModel = null;
        this._barsButton = null;
        this._updateScalesActions = () => {
          const e = this.actions();
          const t = this.model().mainSeries();
          const i = t.priceScale();
          const s = t.properties();
          const o = i.isLockScale();
          const n = s.childs().style.value() === 6;
          e.percentSeriesScale.update({
            disabled: o || n,
            checked: i.isPercentage()
          });
          e.logSeriesScale.update({
            disabled: o || n,
            checked: i.isLog()
          });
          e.regularSeriesScale.update({
            disabled: o || n,
            checked: i.isRegular()
          });
          e.indexedTo100SeriesScale.update({
            disabled: o || n,
            checked: i.isIndexedTo100()
          });
          e.invertSeriesScale.update({
            checked: i.isInverted()
          });
          e.lockSeriesScale.update({
            checked: i.isLockScale()
          });
          e.autoSeriesScale.update({
            checked: i.isAutoScale(),
            disabled: i.properties().childs().autoScaleDisabled.value()
          });
        };
        this._invalidationHandler = e => {
          if (!(e instanceof yo.InvalidationMask)) {
            throw new Error("Invalid mask");
          }
          if (this._invalidationMask !== null) {
            this._invalidationMask.merge(e);
          } else {
            this._invalidationMask = e;
          }
          if (!this._drawPlanned) {
            this._drawPlanned = true;
            this._options.visible.when(() => {
              const e = !document.hidden;
              const t = this.screen && this.screen.isShown();
              if (this._timingsMeter !== null && e && !t) {
                this._timingsMeter.startWaitingDraw();
              }
              const i = (0, n.ensureNotNull)((0, n.ensureNotNull)(this._parent).ownerDocument.defaultView);
              this._drawRafId = i.requestAnimationFrame(this._invalidationRAFCallback.bind(this));
            });
          }
        };
        this._onChartSessionIsConnectedChanged = e => {
          if (e) {
            this._onConnection();
          } else {
            this._onDisconnect();
          }
        };
        this._subscribeToBanInfo = e => {
          if (e) {
            this._spinner?.stop();
          } else {
            this._spinner?.spin();
          }
        };
        this._id = t;
        this._options = (0, dt.merge)((0, dt.clone)(Gm), e);
        this._chartWidgetCollection = this._options.chartWidgetCollection;
        this._isActive = new F.WatchedValue(!!this._options.isActive);
        if (this._options.customLegendWidgetFactories) {
          this._customLegendWidgetsFactoryMap = this._options.customLegendWidgetFactories;
        }
        this._subscribeToDrawingState();
        this.withModel(this, () => {
          const e = this.model().model();
          e.backgroundTopColor().subscribe(this._updateThemedColorBound);
          e.backgroundColor().subscribe(this._updateThemedColorBound);
        });
        this._errorRenderer = new mo(this);
        this._scrollHelper = new Ys(this);
        this._objectTreeDialogController = Es.getInstance();
        this._properties = new li.DefaultProperty({
          defaultName: "chartproperties",
          useUserPreferences: this._options.useUserChartPreferences,
          excludedDefaultsKeys: ["scalesProperties.axisHighlightColor", "scalesProperties.axisLineToolLabelBackgroundColorActive", "scalesProperties.axisLineToolLabelBackgroundColorCommon", "scalesProperties.showPriceScaleCrosshairLabel", "scalesProperties.showTimeScaleCrosshairLabel", "scalesProperties.crosshairLabelBgColorLight", "scalesProperties.crosshairLabelBgColorDark", "alertsProperties", "mainSeriesProperties"],
          excludedTemplateKeys: ["timezone", "tradingProperties", "mainSeriesProperties", "chartEventsSourceProperties", "priceScaleSelectionStrategyName", "paneProperties.horzGridProperties.style", "paneProperties.vertGridProperties.style", "paneProperties.topMargin", "paneProperties.bottomMargin", "volumePaneSize", "alertsProperties"],
          excludedStateKeys: ["alertsProperties", "mainSeriesProperties"],
          themedColors: qm
        });
        this._mainSeriesProperties = new am();
        this._startSpinner(this._options.container.value());
        this._chartSession = new tm(window.ChartApiInstance);
        Zm();
        this._isMultipleLayout = (0, Ji.combine)(e => (0, Ct.isMultipleLayout)(e), this._chartWidgetCollection.layout.weakReference());
        this._properties.childs().scalesProperties.childs().scaleSeriesOnly.subscribe(null, () => {
          const e = this.model().model();
          e.recalculateAllPanes((0, Bt.viewportChangeEvent)());
          e.invalidate(yo.InvalidationMask.full());
        });
        this._hotkeys = B.createGroup({
          desc: "Chart actions",
          isDisabled: () => !this.isActive().value()
        });
        this._ariaPriceDescription = $p.getInstance();
        this.withModel(this, () => {
          this.model().crosshairSource().moved().subscribe(this, this._updateAriaPriceDescription);
        });
        this._compareDialog = this._chartWidgetCollection.getCompareDialogRenderer();
        if (this._options.timeScaleWidget) {
          this._options.timeScaleWidget.pressedMouseMoveScale = this._options.handleScale.axisPressedMouseMove.time;
        }
        const i = this._options.onCmeWidget;
        if (i) {
          Om.logWarn("[ChartWidget] 'onCmeWidget' option is depricated");
        }
        const s = this._options.widgetCustomer;
        const o = this._options.timezone;
        let r = this._options.defSymbol ?? "";
        let a = Re.Interval.isValid(this._options.defInterval) ? this._options.defInterval : null;
        const l = this._options.defStyle;
        let c = (0, yt.isValidStyle)(l) ? l : null;
        const d = this._options.defSessionId;
        const u = this._options.defTimeframe !== undefined ? typeof this._options.defTimeframe == "string" ? {
          value: this._options.defTimeframe.toUpperCase(),
          type: "period-back"
        } : {
          ...this._options.defTimeframe,
          type: "time-range"
        } : null;
        this._content = this._options.content;
        this._initialLoading = this._options.initialLoading;
        this._containsData = !!this._options.containsData;
        this._onWidget = !!this._options.onWidget;
        this._compareSymbols = this._options.compareSymbols;
        this._defSymbol = r;
        this._defInterval = a;
        this._defTimeframe = u;
        this._defStyle = c;
        if (this._onWidget) {
          if (i) {
            this._widgetCustomer = "cme";
          } else if (s) {
            this._widgetCustomer = s;
          }
        }
        this._compareDialog = this._chartWidgetCollection.getCompareDialogRenderer();
        const _ = this._contentSeriesProperties();
        if (_) {
          r = _.symbol;
          a = _.interval;
        }
        if (this._options.useUserChartPreferences === undefined) {
          this._options.useUserChartPreferences = true;
        }
        const p = "chartproperties.mainSeriesProperties";
        const m = this._options.useUserChartPreferences ? (0, h.defaults)(p) : (0, h.factoryDefaults)(p);
        const g = this._mainSeriesProperties;
        g.merge(m);
        const f = a || m.interval || "D";
        if (c === null || !(0, yt.isValidStyle)(c)) {
          c = (0, yt.isValidStyle)(m.style) ? m.style : (0, yt.getDefaultStyle)(Re.Interval.isRange(f));
        }
        g.merge({
          visible: true,
          symbol: r || window.DEFAULT_SYMBOL,
          shortName: "",
          timeframe: "",
          interval: f,
          currencyId: null,
          unitId: null,
          style: c,
          sessionId: d
        });
        this._symbolWV.setValue(r);
        this._resolutionWV.setValue(f);
        if (this._containsData) {
          this._mainSeriesProperties.merge({
            showCountdown: false
          });
        }
        if (o && (0, Pe.timezoneIsAvailable)(o)) {
          this._properties.childs().timezone.setValue(o);
        }
        this._options.container.subscribe(e => {
          this._setElement(e);
        }, {
          callWithLast: true
        });
        const y = () => {
          this.resize();
        };
        this._options.width.subscribe(y);
        this._options.height.subscribe(y);
        this._options.visible.subscribe(this._updateTimingsMeterState.bind(this));
      }
      refreshMarks() {
        this.model().barsMarksSources().forEach(e => e.refreshData());
      }
      clearMarks(e) {
        this.model().barsMarksSources().forEach(t => t.clearMarks(e));
      }
      setTimezone(e) {
        const t = e;
        if (t && (0, Pe.timezoneIsAvailable)(t)) {
          this.properties().childs().timezone.setValue(t);
        } else {
          console.warn("Incorrect timezone: " + JSON.stringify(t));
        }
      }
      getTimezone() {
        return this.properties().childs().timezone.value();
      }
      destroy() {
        this._unsetActions();
        this._hotkeys?.destroy();
        this._lineToolsSynchronizer?.destroy();
        this._noExchangeSubscrptionWarning?.destroy();
        window.loginStateChange.unsubscribe(this, this._handleLoginStateChanged);
        if (this._model !== null) {
          this._model.model().backgroundTopColor().unsubscribe(this._updateThemedColorBound);
          this._model.model().backgroundColor().unsubscribe(this._updateThemedColorBound);
          this._model.model().crosshairSource().moved().unsubscribe(this, this._updateAriaPriceDescription);
          this._model.destroy();
        }
        this._ariaPriceDescription = null;
        this._customLegendWidgetsFactoryMap.clear();
        this._scrollHelper.destroy();
        this._errorRenderer.destroy();
        this._chartSession.criticalError().unsubscribe(this, this._onChartSessionCriticalError);
        this._chartSession.isConnected().unsubscribe(this._onChartSessionIsConnectedChanged);
        this._chartSession.destroy();
        this._persistentLogSwitcher?.destroy();
        this._isDestroyed = true;
        this._aboutToBeDestroyed.fire();
        this._removeMaximizeHotkey?.();
        this._removeMaximizeHotkey = null;
        if (this._drawRafId !== 0) {
          this._parent?.ownerDocument.defaultView?.cancelAnimationFrame(this._drawRafId);
        }
        this._backgroundTopColorSpawn?.destroy();
        this._backgroundBottomColorSpawn?.destroy();
        this._timingsMeter?.stopCollect();
        this._timingsMeter = null;
        const e = this._paneWidgets.value();
        for (let t = 0; t < e.length; t++) {
          e[t].destroy();
        }
        this._paneWidgets.setValue([]);
        for (let e = 0; e < this._paneSeparators.length; e++) {
          this._paneSeparators[e].destroy();
        }
        this._paneSeparators.length = 0;
        this._hotkeysListener?.destroy();
        this._barsButton?.destroy();
        this._controlBarNavigation?.destroy();
        this._controlBarNavigation = null;
        if (this._mainDiv) {
          if (this._onWheelBound) {
            this._mainDiv.removeEventListener("wheel", this._onWheelBound);
          }
          this._mainDiv.remove();
        }
        this._timeAxisWidget?.destroy();
        this._timeAxisWidget = null;
        this._definitionsViewModel?.destroy();
        this._isMultipleLayout.destroy();
        lt.createdLineTool.unsubscribeAll(this);
        lt.continuedLineTool.unsubscribeAll(this);
        lt.cancelledLineTool.unsubscribeAll(this);
        lt.beenSetLineToolLastPoint.unsubscribeAll(this);
        lt.startedMovingLineTool.unsubscribeAll(this);
        lt.movedLineTool.unsubscribeAll(this);
        lt.finishedMovingLineTool.unsubscribeAll(this);
        lt.startedChangingLineTool.unsubscribeAll(this);
        lt.changedLineTool.unsubscribeAll(this);
        lt.finishedChangingLineTool.unsubscribeAll(this);
        lt.removedLineTool.unsubscribeAll(this);
        lt.finishedLineTool.unsubscribeAll(this);
        lt.changedLineStyle.unsubscribeAll(this);
        lt.restoredLineToolState.unsubscribeAll(this);
        lt.restoredLineTool.unsubscribeAll(this);
        lt.copiedLineTool.unsubscribeAll(this);
      }
      title() {
        return a.t(null, undefined, i(39950));
      }
      emulateCriticalError() {
        this._chartSession.removeSeries("-1");
      }
      chartSession() {
        return this._chartSession;
      }
      onDisconnected() {
        return this._disconnected;
      }
      onReconnectBailout() {
        return this._reconnectBailout;
      }
      onConnected() {
        return this._connected;
      }
      chartWidgetInitialized() {
        return this._chartWidgetInitialized;
      }
      setBarsButton(e) {
        this._barsButton = e;
      }
      setVisibleTimeRange(e, t, i, s, o) {
        {
          const r = this.model().mainSeries().seriesSource();
          this._chartSession.setVisibleTimeRange((0, n.ensureNotNull)(r.instanceId()), r.turnaround(), e, t, i, s, o);
        }
      }
      chartWidgetCollection() {
        return this._chartWidgetCollection;
      }
      isInitialized() {
        return this._inited;
      }
      lineToolsSynchronizer() {
        return this._lineToolsSynchronizer;
      }
      actions() {
        if (this._actions === null) {
          return this._setActions();
        } else {
          return this._actions;
        }
      }
      defaultSymbol() {
        return this._defSymbol;
      }
      requestFullscreen() {
        this.getResizerDetacher().requestFullscreen();
      }
      exitFullscreen() {
        this.getResizerDetacher().exitFullscreen();
      }
      inFullscreen() {
        return this.getResizerDetacher().fullscreen.value();
      }
      modelCreated() {
        return this._modelCreated;
      }
      containsStudyByPredicate(e) {
        return !!this._model && this._model.dataSources().some(t => !!(0, Js.isStudy)(t) && e(t.metaInfo()));
      }
      model() {
        return (0, n.ensureNotNull)(this._model);
      }
      id() {
        return this._id;
      }
      layoutId() {
        return this._chartWidgetCollection.metaInfo.uid.value();
      }
      properties() {
        return this._properties;
      }
      mainSeriesProperties() {
        return this._mainSeriesProperties;
      }
      readOnly() {
        return Boolean(this._options.readOnly);
      }
      isActive() {
        return this._isActive.readonly();
      }
      isHovered() {
        return this._isHovered.readonly();
      }
      crossHairSyncEnabled() {
        return this._chartWidgetCollection.lock.crosshair.value();
      }
      isVisible() {
        return this._isVisible.value();
      }
      setVisible(e) {
        this._isVisible.setValue(e);
      }
      visible() {
        return this._isVisible.readonly();
      }
      isCollapsed() {
        return this._collapsed.value();
      }
      setCollapsed(e) {
        this._collapsed.setValue(e);
      }
      collapsed() {
        return this._collapsed.readonly();
      }
      isJustClonedChart() {
        return !!(this._options || {}).justCloned;
      }
      removeAllDrawingTools() {
        if (this.model().model().allLineTools().find(e => e.isLocked?.())) {
          (0, Nm.confirmRemovingLockedLineTools)(Nm.DeleteLockedLineToolReason.RemoveAll).then(e => {
            this.model().removeAllDrawingTools(e);
          });
        } else {
          this.model().removeAllDrawingTools(true);
        }
      }
      removeAllStudies() {
        this.model().removeAllStudies();
      }
      removeAllStudiesDrawingTools() {
        if (this.model().model().allLineTools().find(e => e.isLocked?.())) {
          (0, Nm.confirmRemovingLockedLineTools)(Nm.DeleteLockedLineToolReason.RemoveAll).then(e => {
            this.model().removeAllStudiesAndDrawingTools(e);
          });
        } else {
          this.model().removeAllStudiesAndDrawingTools(true);
        }
      }
      removeSelectedSources() {
        this.removeDataSources(this.model().selection().dataSources());
      }
      removeDataSources(e) {
        const t = this.model();
        const i = e.filter(e => e !== t.mainSeries() && e !== t.lineBeingCreated() && e.isUserDeletable());
        if (i.length === 0) {
          return;
        }
        let s = null;
        if ((0, Js.isStudy)(i[0])) {
          (0, n.assert)(i.length === 1, "Cannot remove several studies (no multi select for studies)");
          s = i[0];
        }
        i.find(e => e.hasAlert().value());
        const o = !!i.find(e => (0, eo.isLineTool)(e) && e.isLocked?.());
        if (s && s.hasChildren()) {
          (0, Ms.showDeleteStudyTreeConfirm)(() => {
            t.removeSelectedSources();
          });
        } else if (o) {
          (0, Nm.showDeleteLockedLineToolsConfirm)(Nm.DeleteLockedLineToolReason.RemoveSelected, e => {
            if (!e) {
              t.selectionMacro(e => {
                i.filter(e => (0, eo.isLineTool)(e) && e.isLocked?.()).forEach(t => {
                  e.removeSourceFromSelection(t);
                });
              });
            }
            t.removeSelectedSources();
          });
        } else {
          t.removeSelectedSources();
        }
      }
      getSymbol(e) {
        if (!this._model) {
          return this._setSymbolIntervalContentOverrides.symbol || window.DEFAULT_SYMBOL;
        }
        if (!e) {
          return this._symbolWV.value();
        }
        const t = this._model.mainSeries().properties().childs();
        if (t.shortName && t.shortName.value()) {
          return t.shortName?.value() ?? "";
        } else {
          return t.symbol?.value() ?? "";
        }
      }
      setSymbol(e) {
        if (this._model) {
          this._symbolWV.setValue(e);
          this._model.setSymbol(this._model.mainSeries(), e);
        } else {
          this._mainSeriesProperties.merge({
            symbol: e
          });
          this._symbolWV.setValue(e);
          this._setSymbolIntervalContentOverrides.symbol = e;
        }
      }
      setResolution(e) {
        if (this._model) {
          this._resolutionWV.setValue(e);
          this._model.setResolution(this._model.mainSeries(), e);
        } else {
          this._mainSeriesProperties.merge({
            interval: e
          });
          this._resolutionWV.setValue(e);
          this._setSymbolIntervalContentOverrides.interval = e;
        }
      }
      getResolution() {
        return this._resolutionWV.value();
      }
      symbolWV() {
        return this._symbolWV.readonly();
      }
      resolutionWV() {
        return this._resolutionWV.readonly();
      }
      loadRange(e) {
        if (this._model) {
          this.screen.show();
          if (!this._model.loadRange(e)) {
            this.screen.hide();
          }
        }
      }
      async showGeneralChartProperties(e, t) {
        if (!l.enabled("show_chart_property_page")) {
          return Promise.resolve(null);
        }
        const s = await this._showChartProperties(this.model().mainSeries(), e, {
          doNotCloseOnBgClick: true,
          onResetToDefault: async () => {
            this.model().restorePreferences();
            const [e, t] = await Promise.all([Promise.resolve().then(i.bind(i, 85662)), Promise.resolve().then(i.bind(i, 58519))]);
            const s = e.getCurrentTheme().name;
            t.loadTheme(this.chartWidgetCollection(), {
              themeName: s,
              standardTheme: true
            });
          },
          shouldReturnFocus: t?.shouldReturnFocus
        });
        if (s === null) {
          return null;
        }
        const o = () => {
          s.hide();
          this._chartWidgetCollection.activeChartWidget.unsubscribe(o);
        };
        this._chartWidgetCollection.activeChartWidget.subscribe(o);
        return s;
      }
      showChartPropertiesForSource(e, t, i, s) {
        if (l.enabled("property_pages") && e.userEditEnabled()) {
          if (e === this.model().model().mainSeries()) {
            return this.showGeneralChartProperties(t);
          } else {
            (i = i || {}).onResetToDefault = () => {
              if ((0, eo.isLineTool)(e) || (0, Js.isStudy)(e)) {
                this.model().restorePropertiesForSource.bind(this._model, e);
              }
            };
            return this._showChartProperties(e, t, i, s);
          }
        } else {
          return Promise.resolve(null);
        }
      }
      toggleCompareOrAdd() {
        if (this._compareDialog.visible().value()) {
          this._compareDialog.hide();
        } else {
          this._compareDialog.show();
        }
      }
      tags() {
        if (this._model) {
          return this._model.calculateDefaultTags();
        } else {
          return [];
        }
      }
      options() {
        return this._options;
      }
      ownerDocument() {
        return (0, n.ensureNotNull)(this._parent).ownerDocument;
      }
      async showChartPropertiesForSources(e) {
        if (!l.enabled("property_pages")) {
          return Promise.resolve(null);
        }
        const {
          sources: t,
          title: s,
          tabName: o,
          renamable: r
        } = e;
        const c = (0, n.ensureNotNull)(this._model);
        const h = js(t.map(e => e.properties().childs()));
        const d = js(t.map(e => e.properties().childs().intervalsVisibilities));
        const [{
          createPropertyPage: u
        }, {
          getSelectionStylePropertiesDefinitions: _
        }, {
          getSelectionIntervalsVisibilitiesPropertiesDefinition: p
        }, {
          getSelectionCoordinatesPropertyDefinition: m
        }] = await Promise.all([Promise.all([i.e(6406), i.e(3889), i.e(8009), i.e(8056), i.e(8537)]).then(i.bind(i, 57717)), Promise.all([i.e(6406), i.e(3889), i.e(8009), i.e(8056), i.e(8537)]).then(i.bind(i, 72707)), Promise.all([i.e(6406), i.e(3889), i.e(8009), i.e(8056), i.e(8537)]).then(i.bind(i, 26434)), Promise.all([i.e(6406), i.e(3889), i.e(8009), i.e(8056), i.e(8537)]).then(i.bind(i, 73174))]);
        return async function (e) {
          const {
            SourcesPropertiesEditorRenderer: t
          } = await Promise.all([i.e(6655), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(2564), i.e(6445), i.e(7384), i.e(3799), i.e(2197), i.e(5480), i.e(5323), i.e(1072), i.e(9325), i.e(4066), i.e(116), i.e(8985), i.e(9766), i.e(8222), i.e(4106), i.e(7444), i.e(5375), i.e(2440), i.e(9296), i.e(625), i.e(5083), i.e(9255), i.e(7935), i.e(601), i.e(422), i.e(1531), i.e(8544), i.e(3828), i.e(7519), i.e(6847), i.e(1833), i.e(2227), i.e(4931), i.e(9418), i.e(3202), i.e(2751), i.e(769), i.e(9928), i.e(7223), i.e(9443), i.e(3489), i.e(6780)]).then(i.bind(i, 66512));
          const s = new t(e);
          if (Os !== null) {
            Os.hide();
            Os = s;
          }
          s.show();
          return s;
        }({
          sources: t,
          propertyPages: [u(_(h, c), "style", a.t(null, undefined, i(92516))), u({
            definitions: [m(t, c)]
          }, "displacement", a.t(null, undefined, i(70132))), u(p(d, c), "visibility", a.t(null, undefined, i(40091)))],
          undoModel: c,
          title: s,
          activeTabId: o,
          renamable: r
        });
      }
      getPriceAxisWidthChangedByName(e) {
        if (e === "left") {
          return this._lhsPriceAxisWidthChanged;
        } else {
          return this._rhsPriceAxisWidthChanged;
        }
      }
      getPriceAxisMaxWidthByName(e) {
        if (e === "left") {
          return this._lhsAxesWidth;
        } else {
          return this._rhsAxesWidth;
        }
      }
      timeAxisHeight() {
        if (this._timeAxisWidget !== null) {
          return this._timeAxisWidget.size.height;
        } else {
          return 0;
        }
      }
      withModel(e, t) {
        if (this._model !== null) {
          t.call(e);
        } else {
          this.modelCreated().subscribe(e, t, true);
        }
      }
      hasModel() {
        return this._model !== null;
      }
      onRedraw() {
        return this._redraw;
      }
      copyLineToOtherCharts() {
        const e = (0, n.ensureNotNull)(this._model);
        const t = e.selection().lineDataSources().filter(e => e.isSynchronizable());
        e.model().copyToOtherCharts(t, true);
      }
      toggleLockSelectedObject() {
        const e = this.model();
        e.selection().lineDataSources().forEach(t => {
          const i = t.properties().frozen.value();
          e.setProperty(t.properties().frozen, !i, (i ? zm : Um).format({
            title: new Di.TranslatedString(t.name(), t.title(ua.TitleDisplayTarget.StatusLine))
          }), $r.lineToolsDoNotAffectChartInvalidation);
        });
      }
      hideDataSources(e) {
        if (e.length) {
          const t = e.map(e => e.properties().visible);
          const i = e.map(() => false);
          this.model().setProperties(t, i, Hm.format({
            title: new Di.TranslatedString(e[0].name(), e[0].title(ua.TitleDisplayTarget.StatusLine))
          }));
        }
      }
      hideSelectedObject() {
        this.hideDataSources(this.model().selection().dataSources().filter(e => true));
      }
      unlinkSelectedLine() {
        const e = (0, n.ensureNotNull)(this._model);
        const t = e.selection().lineDataSources();
        e.unlinkLines(t);
      }
      paneWidgetsWV() {
        return this._paneWidgets;
      }
      paneWidgets() {
        return this._paneWidgets.value();
      }
      paneWidgetSeparators(e) {
        const t = this.paneWidgets().indexOf(e);
        const i = {};
        this._paneSeparators.forEach(e => {
          if (e.topPaneIndex() === t) {
            i.separatorBelow = e;
          }
          if (e.bottomPaneIndex() === t) {
            i.separatorAbove = e;
          }
        });
        return i;
      }
      paneByState(e) {
        return this._paneWidgets.value().find(t => t.state() === e) ?? null;
      }
      paneByCanvas(e) {
        return this._paneWidgets.value().find(t => t.hasCanvas(e)) ?? null;
      }
      timeAxisByCanvas(e) {
        if (this._timeAxisWidget?.hasCanvas(e)) {
          return this._timeAxisWidget;
        } else {
          return null;
        }
      }
      selectPointMode() {
        return (0, n.ensureNotNull)(this._model).model().selectPointMode();
      }
      cancelRequestSelectPoint() {
        const e = (0, n.ensureNotNull)(this._model).model();
        e.cancelRequestSelectPoint();
        e.setReplayStatus(e.isInReplay().value() ? 3 : 0);
        e.clearCurrentPosition();
      }
      requestSelectPoint(e, t) {
        const i = (0, n.ensureNotNull)(this._model);
        if (e.selectPointMode === lt.SelectPointMode.Replay) {
          i.model().setReplayStatus(1);
        }
        return new Promise((s, o) => {
          const n = () => !!this.isVisible() || (o("Chartwidget must be visible"), this.cancelRequestSelectPoint(), false);
          if (!n()) {
            return;
          }
          (0, lt.resetToCursor)(true);
          if (i.lineBeingCreated()) {
            i.cancelCreatingLine();
          }
          let r = false;
          const a = {};
          i.model().onPointSelected().subscribe(a, (e, t) => {
            r = true;
            this._isVisible.unsubscribe(n);
            this._hideHint();
            s({
              point: e,
              pane: t
            });
          }, true);
          i.model().requestSelectPoint(e);
          this.startTrackingMode();
          if (t !== undefined) {
            this._showEventHint(t);
          }
          this._isVisible.subscribe(n);
          this.selectPointMode().subscribe(() => {
            setTimeout(() => {
              if (!r) {
                if (this.selectPointMode().value() === lt.SelectPointMode.None) {
                  this._hideHint();
                }
                i.model().onPointSelected().unsubscribeAll(a);
                this._isVisible.unsubscribe(n);
                o("cancelled");
              }
            });
          }, {
            once: true
          });
        });
      }
      showReplayOrderConfirmationDialog() {
        this.model().isInReplay().value();
        return Promise.resolve();
      }
      showSourceProperties(e, t) {
        if (e === this.model().mainSeries()) {
          t = Zs.TabNames.symbol;
        }
        this.showChartPropertiesForSource(e, t);
      }
      onScroll() {
        return this._onScroll;
      }
      onZoom() {
        return this._onZoom;
      }
      onTagsChanged() {
        return this._tagsChanged;
      }
      onWidget() {
        return this._onWidget;
      }
      containsVolume() {
        return this.model().dataSources().some(e => (0, Js.isStudy)(e) && e.metaInfo().shortId === "Volume");
      }
      containsStudy(e) {
        return this.containsStudyByPredicate(t => t.id === e || t.fullId === e);
      }
      isSmall() {
        return this._width() < 550 || this._height() < 300;
      }
      onCmeWidget() {
        return this._widgetCustomer === "cme";
      }
      widgetCustomer() {
        return this._widgetCustomer;
      }
      compareSymbols() {
        return this._compareSymbols;
      }
      images(e) {
        window.TradingView.printing = true;
        const t = this.model().selection().allSources();
        this.model().selectionMacro(e => e.clearSelection());
        this.model().model().recalculateAllPanes((0, Bt.globalChangeEvent)());
        const i = (t, i) => {
          t.paint(i);
          const s = {
            showCollapsedStudies: Boolean(e?.showCollapsedStudies),
            status: e?.status
          };
          return t.getScreenshotData(s);
        };
        const s = [];
        const o = this.maximizedPaneWidget();
        if (o !== null) {
          const e = this._paneWidgets.value().indexOf(o);
          s.push(i(o, yo.InvalidationMask.light().invalidateForPane(e)));
        } else {
          const e = this._paneWidgets.value();
          e.forEach((t, o) => {
            s.push(i(t, yo.InvalidationMask.light().invalidateForPane(o)));
            if (o < e.length - 1) {
              s.push(this._paneSeparators[o].image());
            }
          });
        }
        let n;
        if (this._timeAxisWidget) {
          this._timeAxisWidget.paint(yo.InvalidationLevel.Light);
          n = this._timeAxisWidget.getScreenshotData();
        }
        window.TradingView.printing = false;
        this.model().selectionMacro(e => {
          t.forEach(t => {
            e.addSourceToSelection(t);
          });
        });
        this.model().model().recalculateAllPanes((0, Bt.globalChangeEvent)());
        this.model().model().lightUpdate();
        const r = this.mainSeriesQuotesAndMetainfo();
        return {
          panes: s,
          timeAxis: n,
          colors: {
            text: this.properties().childs().scalesProperties.childs().textColor.value(),
            bg: this.properties().childs().paneProperties.childs().background.value(),
            scales: this.properties().childs().scalesProperties.childs().lineColor.value()
          },
          meta: r.meta,
          ohlc: r.ohlc,
          quotes: r.quotes
        };
      }
      insertStudy(e, t, i, s, o) {
        return this._insertStudyOrReplaceStub(e, t, undefined, i, s, o);
      }
      replaceStubByStudy(e, t, i, s, o, n) {
        e.updateDescriptor(t);
        return this._insertStudyOrReplaceStub(t, i, e, s, o, n);
      }
      addOverlayStudy(e, t, i) {
        const s = this.model();
        if (this._options && this._options.isSymbolAvailable) {
          return this._options.isSymbolAvailable(e).then(async o => {
            if (!o) {
              return null;
            }
            await (0, ts.studyMetaInfoRepository)().requestMetaInfo();
            const n = s.createStudyInserter({
              type: "java",
              studyId: "Overlay@tv-basicstudies"
            }, []);
            const r = {
              allowExtendTimeScale: i
            };
            if (l.enabled("use_overrides_for_overlay")) {
              const e = (0, h.factoryDefaults)("study_Overlay@tv-basicstudies.style");
              r.style = e;
            }
            n.setPropertiesState(r);
            n.setForceOverlay(t);
            return n.insert(() => Promise.resolve({
              inputs: {
                symbol: e
              },
              parentSources: []
            }));
          });
        } else {
          return Promise.resolve(null);
        }
      }
      addCompareStudy(e) {
        const t = this.model();
        if (this._options && this._options.isSymbolAvailable) {
          return this._options.isSymbolAvailable(e).then(async i => i ? (await (0, ts.studyMetaInfoRepository)().requestMetaInfo(), t.createStudyInserter({
            type: "java",
            studyId: "Compare@tv-basicstudies"
          }, []).insert(() => Promise.resolve({
            inputs: {
              symbol: e
            },
            parentSources: []
          }))) : null);
        } else {
          return Promise.resolve(null);
        }
      }
      showIndicators(e, t) {
        if (window.studyMarket) {
          if (window.studyMarket.visible().value()) {
            window.studyMarket.hide();
            return;
          } else {
            window.studyMarket.show(e, t);
            return window.studyMarket;
          }
        }
      }
      setSaveChartService(e) {
        this._saveChartService = e;
        if (this._lineToolsSynchronizer !== null) {
          this._lineToolsSynchronizer.setSaveChartService(e);
        }
      }
      getSaveChartService() {
        return this._saveChartService;
      }
      mainSeriesQuotesAndMetainfo() {
        let e;
        let t;
        let i;
        const s = this._model && this._model.mainSeries();
        if (s) {
          const o = e => e == null ? "" : s.formatter().format(e, {
            signNegative: true,
            useRtlFormat: false
          });
          const n = e => e == null ? "" : e + "";
          e = {
            resolution: s.interval(),
            symbol: s.symbol(),
            values: s.legendValuesProvider().getValues(null)
          };
          const r = s.symbolInfo();
          if (r) {
            e.symbol = r.full_name;
            e.description = r.description;
            e.exchange = r.exchange;
          }
          const a = s.bars().last();
          if (a !== null) {
            t = a.value.slice(1, 5).map(o);
          }
          const l = s.quotes();
          if (l) {
            i = {
              change: o(l.change),
              changePercent: n(l.change_percent),
              last: o(l.last_price)
            };
          }
        }
        return {
          meta: e,
          ohlc: t,
          quotes: i
        };
      }
      isMultipleLayout() {
        return this._isMultipleLayout;
      }
      updateCrossHairPositionIfNeeded() {
        if (this._model) {
          const e = (0, vo.lastMouseOrTouchEventInfo)();
          if (e.isTouch) {
            const t = this.maximizedPaneWidget() || this._paneWidgets.value()[0];
            if (t.hasState() && (!e.stylus && (this._isLineToolModeExceptBrush() || (0, lt.toolIsMeasure)(lt.tool.value())) || this.selectPointMode().value() !== lt.SelectPointMode.None)) {
              const e = this._model.model().timeScale().width() * 0.5;
              const i = t.state().defaultPriceScale().height() * 0.5;
              t.setCursorPosition(e, i);
            }
            const i = this._model.model().crosshairSource();
            i.updateAllViews((0, Bt.sourceChangeEvent)(i.id()));
          }
        }
      }
      trackingModePaneWidget() {
        if (!(0, vo.lastMouseOrTouchEventInfo)().isTouch) {
          return null;
        }
        for (const e of this.paneWidgets()) {
          if (e.trackingModeEnabled()) {
            return e;
          }
        }
        return null;
      }
      startTrackingMode() {
        if ((0, vo.lastMouseOrTouchEventInfo)().isTouch) {
          this.exitTrackingMode();
          this.updateCrossHairPositionIfNeeded();
          const e = this.maximizedPaneWidget() || this._paneWidgets.value()[0];
          const t = this.model().model().crosshairSource().currentPoint();
          e.startTrackingMode(t, t);
        }
      }
      exitTrackingMode() {
        if ((0, vo.lastMouseOrTouchEventInfo)().isTouch && this.paneWidgets().some(e => e.trackingModeEnabled())) {
          this.paneWidgets().forEach(e => e.exitTrackingMode());
          this.model().model().clearCurrentPosition();
        }
      }
      onToolChanged() {
        const e = this.model().model();
        if (e.lineBeingCreated() && !e.lineBeingCreateFromExternal()) {
          this._cancelCreatingLine();
        }
        if (this.selectPointMode().value() !== lt.SelectPointMode.None) {
          this.cancelRequestSelectPoint();
        }
        this.exitTrackingMode();
      }
      setInLoadingState(e) {
        this._inLoadingState = e;
      }
      paint(e) {
        const t = e ?? yo.InvalidationMask.full();
        t.validationActions().forEach(e => e());
        const i = this.maximizedPaneWidget();
        this._paneWidgets.value().forEach((e, s) => {
          if (i === null || i === e) {
            e.paint(t.invalidateForPane(s));
          }
        });
        if (this._timeAxisWidget) {
          this._timeAxisWidget.paint(t.invalidateForTimeScale());
        }
        this._redraw.fire();
      }
      GUIResetScales() {
        (0, ne.trackEvent)("GUI", "Reset Scales");
        if (this._model !== null) {
          this._model.resetScales();
        }
      }
      applyOverrides(e) {
        const t = {};
        for (const [i, s] of Object.entries(e)) {
          if (!i.startsWith("mainSeriesProperties.priceAxisProperties")) {
            t[i] = s;
          }
        }
        (0, h.applyPropertiesOverrides)(this.properties(), undefined, false, t, undefined);
        if (l.enabled("use_localstorage_for_settings")) {
          this.properties().saveDefaults();
        }
        if (this._model) {
          (0, h.applyPropertiesOverrides)(this._model.model().properties(), undefined, false, t);
          (0, h.applyPropertiesOverrides)(this._model.mainSeries().properties(), undefined, false, t, "mainSeriesProperties");
          this._model.model().sessions().applyOverrides(t);
          const e = this._model.model().watermarkSource();
          if (e !== null) {
            e.applyOverrides(t);
          }
          if (l.enabled("use_localstorage_for_settings")) {
            this._model.model().properties().saveDefaults();
            this._model.mainSeries().properties().saveDefaults();
          }
        }
      }
      showFundamentals(e) {
        this.showIndicators(e ? [e] : undefined, "financials");
      }
      maximizedPaneWidget() {
        return this._paneWidgets.value().find(e => e.maximized().value()) ?? null;
      }
      hasMaximizedPane() {
        return this.maximizedPaneWidget() !== null;
      }
      setActive(e) {
        if ((0, vo.lastMouseOrTouchEventInfo)().isTouch) {
          if (e && this.selectPointMode().value() !== lt.SelectPointMode.None) {
            this.startTrackingMode();
          } else {
            this.exitTrackingMode();
          }
        }
        for (const e of this._paneWidgets.value()) {
          e.update();
        }
        if (!e) {
          this.model().selectionMacro(e => {
            e.clearSelection();
          });
        }
        this._isActive.setValue(e);
      }
      justActivated() {
        return this._justActivated;
      }
      unsetActivePaneWidget() {
        this.activePaneWidget = null;
      }
      setActivePaneWidget(e) {
        this.activePaneWidget = e;
      }
      onPaneWidgetDestroyed(e) {
        if (this.activePaneWidget === e) {
          this.activePaneWidget = null;
        }
      }
      getResizerDetacher() {
        return this._options;
      }
      toggleFullscreen() {
        const e = this.getResizerDetacher();
        if (e.fullscreenable.value()) {
          if (e.fullscreen.value()) {
            e.exitFullscreen();
          } else {
            e.requestFullscreen();
          }
        }
      }
      generalPropertiesDefinitions() {
        return this._getChartPropertyDefinitionsViewModel().then(e => e.propertyPages());
      }
      propertiesDefinitionsForSource(e) {
        if ((0, eo.isLineTool)(e) || (0, Js.isStudy)(e) || (0, eo.isStudyLineTool)(e)) {
          return e.getPropertyDefinitionsViewModel().then(e => e === null ? null : e.propertyPages()).catch(e => {
            Om.logWarn(e);
            return null;
          });
        } else {
          return Promise.resolve(null);
        }
      }
      backgroundTopTheme() {
        return this._backgroundTopTheme.readonly();
      }
      backgroundBasedTheme() {
        return this._backgroundBasedTheme.readonly();
      }
      backgroundBottomTheme() {
        return this._backgroundBottomTheme.readonly();
      }
      state(e, t, i, s) {
        if (this._model) {
          const o = this._model.state(e, t, i, s);
          o.chartId = this.id();
          return o;
        }
        return this._content;
      }
      lineToolsAndGroupsDTO() {
        return (0, n.ensureNotNull)(this._lineToolsSynchronizer).prepareDTO();
      }
      applyLineToolUpdateNotification(e, t) {
        (0, n.ensureNotNull)(this._lineToolsSynchronizer).applyLineToolUpdateNotification(e, t);
      }
      reloadAllLineTools() {
        (0, n.ensureNotNull)(this._lineToolsSynchronizer).reloadAllLineTools();
      }
      startApplyingLineToolUpdateNotification() {
        this._lineToolsSynchronizer?.startApplyingLineToolUpdateNotification();
      }
      endApplyingLineToolUpdateNotification() {
        this._lineToolsSynchronizer?.endApplyingLineToolUpdateNotification();
      }
      applyAlertIdByExternalSource(e, t) {
        this._lineToolsSynchronizer?.applyAlertIdByExternalSource(e, t);
      }
      deleteAlertByExternalSource(e, t) {
        this._lineToolsSynchronizer?.deleteAlertByExternalSource(e);
      }
      shouldBeSavedEvenIfHidden() {
        if (this._model) {
          return this.model().model().shouldBeSavedEvenIfHidden();
        } else {
          return !!this._options.content.shouldBeSavedEvenIfHidden;
        }
      }
      getTimeScale() {
        return this._timeAxisWidget;
      }
      showObjectsTreePanelOrDialog() {
        let e = false;
        const t = window.widgetbar;
        if (t && t.isVisible()) {
          const i = (0, n.ensureNotNull)(t.setPage("object_tree"));
          (0, n.ensureNotNull)(i.widget("object_tree"));
          0;
          e = i.name === "object_tree";
        }
        if (!e) {
          this.showObjectsTreeDialog();
        }
      }
      showObjectsTreeDialog() {
        this._objectTreeDialogController?.show();
      }
      addCustomWidgetToLegend(e, t) {
        this._customLegendWidgetsFactoryMap.set(e, t);
        for (const i of this.paneWidgets()) {
          i.addCustomWidgetToLegend(e, t);
        }
      }
      applyIndicatorsToAllChartsAvailable() {
        if (!this.chartWidgetCollection().applyIndicatorsToAllChartsAvailable()) {
          return false;
        }
        for (const e of this.model().model().panes()) {
          if (e.sourcesByGroup().all().some(e => (0, Js.isStudy)(e) && true)) {
            return true;
          }
        }
        return false;
      }
      widget() {
        return (0, n.ensureNotNull)(this._mainDiv);
      }
      restoreState(e, t, i) {
        this._adjustSize();
        const s = (0, n.ensureNotNull)(this._model);
        s.restoreState(this._content, t, i);
        const o = s.mainSeries().properties().childs();
        this._symbolWV.setValue(o.symbol.value());
        this._resolutionWV.setValue(o.interval.value());
      }
      addCompareAsOverlay(e, t, i) {
        const s = this.model();
        return (0, n.ensureDefined)(this._options.isSymbolAvailable)(e).then(async o => {
          if (!o) {
            return null;
          }
          await (0, ts.studyMetaInfoRepository)().requestMetaInfo();
          const n = s.createStudyInserter({
            type: "java",
            studyId: "Overlay@tv-basicstudies"
          }, []);
          n.setForceOverlay(true);
          n.setPreferredPriceScale("as-series");
          if (i !== true) {
            n.setTargetPriceScaleMode({
              percentage: true
            });
          }
          if (t !== undefined) {
            n.setPropertiesState({
              allowExtendTimeScale: t
            });
          }
          return n.insert(async () => ({
            inputs: {
              symbol: e
            },
            parentSources: []
          }));
        });
      }
      scrollHelper() {
        return this._scrollHelper;
      }
      resize() {
        const e = this._height() + "px";
        const t = this._width() + "px";
        const i = (0, n.ensureNotNull)(this._mainDiv);
        i.style.height = e;
        i.style.width = t;
        this._elMainTable.style.height = e;
        this._elMainTable.style.width = t;
        if (this._resizeHandler && this._mainDiv) {
          this._resizeHandler();
        }
      }
      chartPainted() {
        if (this._drawPlanned) {
          if (this._chartPaintedPromise === null) {
            this._chartPaintedPromise = (0, me.createDeferredPromise)();
          }
          return this._chartPaintedPromise.promise;
        } else {
          return Promise.resolve();
        }
      }
      setDataWindowWidget(e) {
        this._dataWindowWidget = e;
      }
      removeDataWindowWidget() {
        this._dataWindowWidget = null;
      }
      showSelectedSourcesProperties(e) {
        const t = (0, n.ensureNotNull)(this._model).selection().dataSources();
        if (t.length === 1) {
          this.showSourceProperties(t[0], e);
        } else {
          const i = t.filter(eo.isLineTool);
          if (i.length > 0) {
            this.showChartPropertiesForSources({
              sources: i,
              tabName: e
            });
          }
        }
      }
      setTimingsMeter(e) {
        this._timingsMeter = e;
        this._updateTimingsMeterState();
      }
      onAboutToBeDestroyed() {
        return this._aboutToBeDestroyed;
      }
      executeActionById(e) {
        if (e === "takeScreenshot") {
          console.warn("Action \"takeScreenshot\" is deprecated. Use method \"takeScreenshot\" instead");
          this._chartWidgetCollection.takeScreenshot();
          return;
        }
        const t = this.actions()[e];
        if (t) {
          t.execute();
        } else {
          console.warn("Unknown action id: " + e);
        }
      }
      getCheckableActionState(e) {
        const t = this.actions()[e];
        if (t) {
          if (t.isCheckable()) {
            return t.isChecked();
          }
          console.warn("Action " + e + " has no state");
        } else {
          console.warn("Unknown action id: " + e);
        }
        return null;
      }
      connect() {
        this._chartSession.isConnected().subscribe(this._onChartSessionIsConnectedChanged);
        this._chartSession.criticalError().subscribe(this, this._onChartSessionCriticalError);
        this._chartSession.connect(this._onData.bind(this));
      }
      finishInitWithoutConnect() {
        this._chartSession.disable();
        this._init();
        this._chartWidgetInitialized.fire();
      }
      reconnect() {
        this._chartSession.disconnect();
        this._chartSession.connect();
      }
      update() {
        if (this.hasModel()) {
          for (const e of this._paneWidgets.value()) {
            e.update();
          }
          if (this._timeAxisWidget) {
            this._timeAxisWidget.update();
          }
        }
      }
      setPriceAxisHovered(e, t) {
        if (t) {
          this._hoveredPriceAxes.add(e);
        } else {
          this._hoveredPriceAxes.delete(e);
        }
        this._anyAxisHovered.setValue(this._hoveredPriceAxes.size > 0);
      }
      anyPriceAxisHovered() {
        return this._anyAxisHovered.readonly();
      }
      linkingGroupIndex() {
        return this._linkingGroupIndex;
      }
      offsetInDocument(e) {
        const t = this.paneByState(e);
        if (!t) {
          return {
            left: NaN,
            top: NaN
          };
        }
        const i = t.getElement().getBoundingClientRect();
        return {
          left: Math.round(i.left + document.body.scrollLeft),
          top: Math.round(i.top + document.body.scrollTop)
        };
      }
      showHint(e, ...t) {
        if (e === 0) {
          this._showEventHint(...t);
        } else if (e === 1) {
          throw new Error("Warning hint not implemented");
        }
      }
      hotkeys() {
        return this._hotkeys;
      }
      onAboutToLoadContent() {
        this._chartSession.disconnect();
      }
      async loadContent(e, t) {
        this.screen.show();
        const i = this.model();
        i.model().setMaximizedPane(null);
        const s = i.mainSeries();
        if (i.model().isInReplay().value()) {
          i.model().switchToRealtime();
        }
        i.crosshairSource().clearMeasure();
        this._lineToolsSynchronizer?.destroy();
        this._lineToolsSynchronizer = null;
        this._chartSession.disconnect();
        const o = i.model().dataSources().filter(e => !!(0, Js.isStudy)(e) || (0, eo.isLineTool)(e));
        let n;
        let r;
        new Yr.RemoveSourcesUndoCommand(i.model(), o, null).redo();
        this._chartSession.connect(this._onData.bind(this));
        this.activePaneWidget = null;
        s.purgeSymbolInfo();
        e.loading = true;
        await (0, eo.ensureAllLineToolsLoadedForLayout)([e]);
        this._content = e;
        this._setSymbolIntervalContentOverrides = {};
        this._initialLoading = t;
        const a = this._contentSeriesProperties();
        if (a) {
          n = a;
          r = e.chartProperties.priceScaleSelectionStrategyName;
        }
        if (!n) {
          throw Error("An error occurred while determining main series on the chart");
        }
        this._mainSeriesProperties.mergeAndFire({
          visible: true,
          symbol: n.symbol,
          timeframe: "",
          interval: n.interval || "D",
          style: n.style
        });
        if (r !== undefined) {
          this._properties.childs().priceScaleSelectionStrategyName.setValue(r);
        }
        this._init();
        i.undoHistory().clearStack();
      }
      resetDrawingState() {
        (0, lt.resetToCursor)(true);
        const e = (0, n.ensureNotNull)(this._model?.crosshairSource().pane ?? null);
        (0, n.ensureNotNull)(this.paneByState(e)).cancelCreatingLineTool();
        this._model?.selectionMacro(e => {
          e.clearSelection();
        });
      }
      _clearSelectionHotkey() {
        return {
          desc: "Cancel selection",
          hotkey: 27,
          handler: () => {
            if (this.selectPointMode().value() !== lt.SelectPointMode.None) {
              if (this.selectPointMode().value() === lt.SelectPointMode.Replay) {
                this._chartWidgetCollection.getAll().forEach(e => {
                  if (e !== this && e.selectPointMode().value() === lt.SelectPointMode.Replay) {
                    e.cancelRequestSelectPoint();
                  }
                });
              }
              this.cancelRequestSelectPoint();
              return;
            }
            this._model?.selectionMacro(e => {
              this._cancelCreatingLine();
              e.clearSelection();
            });
            const e = this._model?.model().customSourceMovingHitTestData();
            if (e && e.cancelMoveHandler && e.cancelMoveHandler()) {
              e.cancelled = true;
              this._model?.model().setMovingCustomSource(null, null);
              this._model?.model().lightUpdate();
            }
          },
          isDisabled: () => {
            const e = this._model;
            if (!e) {
              return true;
            }
            const t = e.selection().allSources().length === 0;
            const i = e.crosshairSource().measurePane().value() === null;
            const s = this.selectPointMode().value() === lt.SelectPointMode.None;
            return t && i && s;
          }
        };
      }
      _insertStudyOrReplaceStub(e, t, i, s, o, n) {
        const r = e.type === "java";
        return new Promise(async a => {
          if (t.length === 0) {
            n?.();
            if (r) {
              await (0, ts.studyMetaInfoRepository)().requestMetaInfo();
            }
            a(this._insertOrReplaceStubByStudyImpl(e, t, i, s, o));
            return;
          }
          window.runOrSignIn(async () => {
            n?.();
            if (r) {
              await (0, ts.studyMetaInfoRepository)().requestMetaInfo();
            }
            a(this._insertOrReplaceStubByStudyImpl(e, t, i, s, o));
          }, {
            source: "study on study"
          });
        }).catch(() => null);
      }
      _insertOrReplaceStubByStudyImpl(e, t, i, s, o) {
        const r = (0, n.ensureNotNull)(this._model).createStudyInserter(e, t, s);
        r.setForceOverlay(e.type === "java" && e.studyId === "Volume@tv-basicstudies" && l.enabled("volume_force_overlay"));
        const a = r.insert((e, i, s) => new Promise((n, r) => {
          if (this.selectPointMode().value() !== lt.SelectPointMode.None) {
            this.cancelRequestSelectPoint();
          }
          if (o) {
            n(o(e, i, s));
          } else if ((0, Js.isSymbolicStudy)(s)) {
            (0, ne.trackEvent)("GUI", "Confirmation dialogs", "Symbol confirmation dialog");
            Ns(this, e, s, n, r, "symbol");
          } else if ((0, Js.hasConfirmInputs)(i)) {
            (0, ne.trackEvent)("GUI", "Confirmation dialogs", "Inputs confirmation dialog");
            Ns(this, e, s, n, r);
          } else {
            n({
              inputs: {},
              parentSources: t
            });
          }
        }), undefined, i);
        a.then(() => {
          if ((0, lt.hideAllIndicators)().value()) {
            (0, ks.toggleHideMode)();
          }
        }).catch(e => { });
        return a;
      }
      async _showChartProperties(e, t, i, s) {
        if (!this._model) {
          return null;
        }
        if (t) {
          (0, d.setValue)("properties_dialog.active_tab.chart", t);
          i.tabName = t;
        }
        const o = await so(e, this._model, i, this._options.chartWidgetCollection, s);
        if (o?.visible().value()) {
          return o;
        } else {
          return null;
        }
      }
      _createLineToolsSynchronizerIfNeeded() {
        if (l.enabled("saveload_separate_drawings_storage")) {
          this._lineToolsSynchronizer?.destroy();
          this._lineToolsSynchronizerHasChanges ??= new F.WatchedValue(false);
          this._lineToolsSynchronizerHasChanges.setValue(false);
          const e = {
            readOnlyMode: this.readOnly(),
            migrateSyncedLineTools: this === this._options.chartWidgetCollection.getAll()[0]
          };
          const t = {
            layoutId: this.layoutId(),
            chartId: this._id,
            clientId: this._chartWidgetCollection.clientId
          };
          const i = function () {
            if (!lm) {
              throw new Error("LineToolsSynchronizer Class not loaded");
            }
            return lm;
          }();
          this._lineToolsSynchronizer = new i(t, this.model().model(), e, this._lineToolsSynchronizerHasChanges);
          if (this._saveChartService !== null) {
            this._lineToolsSynchronizer.setSaveChartService(this._saveChartService);
          }
          this._lineToolsSynchronizer.invalidateAll();
          this._model?.model().setLineToolsSynchronizer(this._lineToolsSynchronizer);
        }
      }
      _updateThemedColor() {
        const e = this.model().model();
        const t = e.backgroundColorAtYPercentFromTop(0.5);
        let i = e.backgroundTopColor().value();
        let s = e.backgroundColor().value();
        const o = (0, Is.isColorDark)(t);
        const n = (0, Is.isColorDark)(i);
        const r = (0, Is.isColorDark)(s);
        this.widget().classList.toggle("chart-widget--themed-dark", o);
        this.widget().classList.toggle("chart-widget--themed-light", !o);
        this.widget().classList.toggle("chart-widget__top--themed-dark", n);
        this.widget().classList.toggle("chart-widget__top--themed-light", !n);
        this.widget().classList.toggle("chart-widget__bottom--themed-dark", r);
        this.widget().classList.toggle("chart-widget__bottom--themed-light", !r);
        this._backgroundTopTheme.setValue(n ? "dark" : "light");
        this._backgroundBasedTheme.setValue(o ? "dark" : "light");
        this._backgroundBottomTheme.setValue(r ? "dark" : "light");
        if (i === s && (0, k.isStdThemedDefaultValue)("chartProperties.paneProperties.background", i, this._backgroundBasedTheme.value())) {
          i = null;
          s = null;
        }
        for (const e of this._paneWidgets.value()) {
          e.updateThemedColors({
            topColor: i,
            bottomColor: s
          });
        }
      }
      _isLineToolModeExceptBrush() {
        const e = lt.tool.value();
        return (0, wt.isLineToolName)(e) && !(0, wt.isLineDrawnWithPressedButton)(e) && this.selectPointMode().value() === lt.SelectPointMode.None;
      }
      _cancelCreatingLine() {
        const e = (0, n.ensureNotNull)(this._model).model();
        const t = e.lineBeingCreated();
        if (t !== null) {
          const i = (0, n.ensureNotNull)(e.paneForSource(t));
          (0, n.ensureNotNull)(this.paneByState(i)).cancelCreatingLineTool();
          if (t.toolname === lt.tool.value()) {
            (0, lt.resetToCursor)();
          }
        }
        const i = e.crosshairSource().measurePane().value();
        if (i !== null) {
          (0, n.ensureNotNull)(this.paneByState(i)).cancelMeasuring();
        }
      }
      _adjustSize(e) {
        let t = 0;
        const i = this._model === null ? null : this._model.model().priceScaleSlotsCount();
        const s = new Uint32Array(i === null ? 0 : i.left);
        const o = new Uint32Array(i === null ? 0 : i.right);
        const n = {
          value: 0
        };
        const r = {
          value: 0
        };
        const a = (0, fo.getCanvasDevicePixelRatio)(document.body);
        const l = (e, t) => e + t;
        const c = (e, t, i) => {
          if (Array.isArray(i)) {
            i.forEach((t, i) => {
              e[i] = Math.max(e[i], t);
            });
          } else {
            t.value = Math.max(t.value, i);
          }
        };
        const h = (e, t, i) => {
          if (i.value > t) {
            const s = i.value / t;
            let o = 0;
            for (let t = 0; t < e.length; t++) {
              e[t] = Math.ceil(e[t] * s);
              o += e[t];
            }
            return o;
          }
          return t;
        };
        const d = this._width();
        const u = this._height();
        const _ = this._paneSeparators.length;
        const p = this.hasMaximizedPane() ? 0 : Ao.height() * _;
        const m = this._timeAxisWidget !== null ? this._timeAxisWidget.optimalHeight() : 0;
        let g = u - m >= 61 ? m : 0;
        if (g % 2) {
          g += 1;
        }
        const f = this._paneWidgets.value();
        const y = Math.max(1, Math.floor((u - p - g) / f.length));
        let v = 0;
        let S = null;
        const b = this.maximizedPaneWidget();
        for (const e of f) {
          if (!b || b === e) {
            e.leftPriceAxisesContainer().updateCurrencyLabels();
            const i = e.leftPriceAxisesContainer().optimalWidths();
            e.rightPriceAxisesContainer().updateCurrencyLabels();
            const a = e.rightPriceAxisesContainer().optimalWidths();
            c(s, n, i);
            c(o, r, a);
            if (b !== e && e.state().collapsed().value()) {
              v += Math.min(y, e.collapsedHeight());
            } else {
              t += e.stretchFactor();
              S = e;
            }
          }
        }
        let w = s.reduce(l, 0);
        let C = o.reduce(l, 0);
        w = h(s, w, n);
        C = h(o, C, r);
        let P = Math.max(d - w - C, 0);
        if (P <= 102) {
          w = 0;
          C = 0;
          P = d;
          for (let e = 0; e < s.length; e++) {
            s[e] = 0;
          }
          for (let e = 0; e < o.length; e++) {
            o[e] = 0;
          }
        }
        for (const e of this._paneSeparators) {
          e.adjustSize();
        }
        const T = p + v + g;
        const x = u < T ? 0 : u - T;
        const I = x / t;
        let M = 0;
        let A = false;
        const L = this._model?.model();
        this._paneWidgets.value().forEach((e, t) => {
          if (L !== undefined) {
            e.setState(L.panes()[t]);
          }
          let i = 0;
          if (this.hasMaximizedPane()) {
            i = this.maximizedPaneWidget() === e ? x : 0;
          } else if (e.state().collapsed().value()) {
            i = Math.min(y, e.collapsedHeight());
          } else {
            const t = e === S ? Math.ceil((x - M) * a) / a : Math.round(e.stretchFactor() * I * a) / a;
            i = Math.max(t, 2);
            M += i;
          }
          e.setPriceAxisSizes("left", i, s);
          e.setPriceAxisSizes("right", i, o);
          A = A || i !== e.height();
          e.setSize((0, Dt.size)({
            width: P,
            height: i
          }));
          if (L && e.state()) {
            L.setPaneHeight(e.state(), i);
          }
        });
        if (this._timeAxisWidget !== null) {
          this._timeAxisWidget.setSizes((0, Dt.size)({
            width: P,
            height: g
          }), s, o);
        }
        if (L) {
          L.setWidth(P, e);
        }
        if (this._controlBarNavigation) {
          this._controlBarNavigation.updatePosition();
        }
        if (this._lhsAxesWidth !== w) {
          this._lhsAxesWidth = w;
          this._lhsPriceAxisWidthChanged.fire(w);
        }
        if (this._rhsAxesWidth !== C) {
          this._rhsAxesWidth = C;
          this._rhsPriceAxisWidthChanged.fire(C);
        }
        if (A) {
          W.emit("panes_height_changed");
        }
      }
      _makePaneWidgetsAndSeparators() {
        const e = this.model().model().panes();
        const t = e.length;
        const i = this._paneWidgets.value().length;
        const s = this._paneWidgets.value().slice();
        for (let e = t; e < i; e++) {
          (0, n.ensureDefined)(s.pop()).destroy();
          const e = this._paneSeparators.pop();
          if (e) {
            e.destroy();
          }
        }
        const o = this._options.containsData;
        for (let n = 0; n < t; n++) {
          const t = n >= i;
          const r = {
            contextMenuEnabled: this._options.paneContextMenuEnabled,
            currencyConversionEnabled: this._options.currencyConversionEnabled,
            unitConversionEnabled: this._options.unitConversionEnabled,
            handleScale: this._options.handleScale,
            handleScroll: this._options.handleScroll,
            priceScaleContextMenuEnabled: this._options.priceScaleContextMenuEnabled,
            legendWidgetEnabled: this._options.legendWidgetEnabled && e[n].mode() === Bi.PaneMode.Regular,
            sourceStatusesWidgetEnabled: !o,
            sourceStatusesWidget: this._options.sourceStatusesWidget,
            marketStatusWidgetEnabled: this._options.marketStatusWidgetEnabled && !o,
            chartWarningWidgetEnabled: this._options.chartWarningWidgetEnabled && !o,
            chartWarningWidget: this._options.chartWarningWidget,
            dataProblemWidgetEnabled: this._options.dataProblemWidgetEnabled && !o,
            legendWidget: this._options.legendWidget,
            propertyPagesEnabled: this._options.propertyPagesEnabled,
            sourceSelectionEnabled: this._options.sourceSelectionEnabled,
            controlsEnabled: this._options.paneControlsEnabled,
            croppedTickMarks: this._options.croppedTickMarks,
            countdownEnabled: this._options.countdownEnabled,
            customLegendWidgetFactories: new Map(this._customLegendWidgetsFactoryMap),
            useKineticScroll: this._options.useKineticScroll,
            pineSourceStatusEnabled: !this.readOnly()
          };
          if (this._options.paneContextMenu !== undefined) {
            r.contextMenu = this._options.paneContextMenu;
          }
          if (this._options.priceScaleContextMenu !== undefined) {
            r.priceScaleContextMenu = this._options.priceScaleContextMenu;
          }
          if (t) {
            const t = new fr(this, e[n], r, this._paneWidgetsSharedState);
            s.push(t);
            if (n > 0) {
              const e = new Ao(this, n - 1, n);
              this._paneSeparators.push(e);
              if (this._timeAxisWidget) {
                this._elMainTable.insertBefore(e.getElement(), this._timeAxisWidget.getElement());
              } else {
                this._elMainTable.appendChild(e.getElement());
              }
            }
            if (this._timeAxisWidget) {
              this._elMainTable.insertBefore(t.getElement(), this._timeAxisWidget.getElement());
            } else {
              this._elMainTable.appendChild(t.getElement());
            }
          } else {
            s[n].updateOptions(r);
          }
        }
        const r = this.maximizedPaneWidget();
        for (const e of this._paneSeparators) {
          if (r) {
            e.hide();
          } else {
            e.show();
          }
        }
        for (let i = 0; i < t; i++) {
          const t = e[i];
          const o = s[i];
          if (o.hasState() && o.state() === t) {
            o.updatePriceAxisWidgetsStates();
          } else {
            o.setState(t);
          }
        }
        for (let e = t; e--;) {
          s[e].updateControls();
        }
        this._paneWidgets.setValue([...s]);
        this._errorRenderer.updatePaneWidgets();
        this._updateThemedColor();
      }
      _width() {
        return this._options.width.value();
      }
      _height() {
        return this._options.height.value();
      }
      _update(e, t) {
        const i = e ? e.fullInvalidation() : yo.InvalidationLevel.Full;
        const s = !!e && e.isVisibleTimeRangeLockedOnResize();
        if (this._timingsMeter !== null) {
          this._timingsMeter.startDraw(i);
        }
        if (i === yo.InvalidationLevel.Full) {
          if (this._model) {
            this._updateGui(s);
          } else {
            this._adjustSize(s);
          }
        }
        if (i > yo.InvalidationLevel.Cursor) {
          this._timeAxisWidget?.update();
          this._paneWidgets.value().forEach(e => {
            e.updatePriceAxisWidgets();
          });
          for (let i = 0; i < this._paneWidgets.value().length; i++) {
            for (const [s, o] of e.invalidateForPane(i).priceScaleRangeAnimations()) {
              const e = this.model().model().panes()[i];
              if (e && o) {
                const i = e.getPriceScaleById(s);
                if (i) {
                  const s = o.getPosition(t);
                  i.setPriceRange(s);
                  i.updateAllViews((0, Bt.viewportChangeEvent)(e));
                }
              }
            }
          }
          this._applyTimeScaleInvalidations(e, t);
          if (this._invalidationMask?.fullInvalidation() === yo.InvalidationLevel.Full) {
            this._invalidationMask.merge(e);
            this._adjustSize(this._invalidationMask.isVisibleTimeRangeLockedOnResize());
            this._applyTimeScaleInvalidations(this._invalidationMask, t);
            e = this._invalidationMask;
            this._invalidationMask = null;
          }
        }
        this.paint(e);
        if (this._dataWindowWidget) {
          const t = e.maxPaneInvalidation();
          if (t === yo.InvalidationLevel.Full) {
            this._dataWindowWidget.fullUpdate();
          } else if (t > yo.InvalidationLevel.None) {
            this._dataWindowWidget.update();
          }
        }
        this._paneWidgets.value().forEach((t, i) => {
          t.updateStatusWidget(e.invalidateForPane(i));
        });
        if (this._timingsMeter !== null) {
          this._timingsMeter.stopDraw();
        }
        if (e && e.panesOrderInvalidated()) {
          W.emit("panes_order_changed");
        }
      }
      _initMaximizeHotkey(e) {
        const t = e => !e.defaultPrevented && (0, V.modifiersFromEvent)(e) === V.Modifiers.Alt && !(0, lt.toolIsDemonstration)(lt.tool.value());
        const i = e => {
          if (t(e)) {
            e.stopPropagation();
          }
        };
        const s = e => {
          if (t(e)) {
            e.preventDefault();
            e.stopPropagation();
            this.toggleFullscreen();
          }
        };
        e.addEventListener("mousedown", i, true);
        e.addEventListener("click", s, true);
        return () => {
          e.removeEventListener("mousedown", i, true);
          e.removeEventListener("click", s, true);
        };
      }
      _onMousewheel(e) {
        if (!this.model().model().zoomEnabled() || this._mouseWheelHelper === null) {
          return;
        }
        if (!(0, ze.onWidget)() && !Wm && parent && parent !== window && parent.IS_DEMO_PAGE) {
          return;
        }
        if (this._model === null) {
          return;
        }
        if (this.model().timeScale().isEmpty()) {
          return;
        }
        const t = this._mouseWheelHelper.processWheel(e);
        const i = t.deltaX;
        const s = -t.deltaY;
        if (i !== 0 && this._options.handleScroll.mouseWheel || s !== 0 && this._options.handleScale.mouseWheel) {
          if (e.cancelable) {
            e.preventDefault();
          }
          if (s !== 0 && this._options.handleScale.mouseWheel) {
            const t = Math.sign(s) * Math.min(1, Math.abs(s));
            const i = (0, n.ensureNotNull)(this._mainDiv).getBoundingClientRect();
            const o = e.clientX - this._lhsAxesWidth - i.left;
            if (!Number.isFinite(o) || !Number.isFinite(t)) {
              Om.logWarn("Incorrect mouse wheel processing: scrollPosition: " + o + ", zoomScale: " + t);
              return;
            }
            const r = new Bo.EnvironmentState(e).mod();
            this.model().model().zoomTime(o, t, !!r || undefined);
            this._onZoom.fire(r);
          }
          if (i !== 0 && this._options.handleScroll.mouseWheel) {
            this.model().scrollChart(i * -80);
          }
        }
      }
      _beginRequestActive() {
        const e = this._chartWidgetCollection.activeChartWidget.value() !== this;
        this._chartWidgetCollection.activeChartWidget.setValue(this);
        if (e) {
          this._chartWidgetCollection.ariaDescribeChart(this._chartWidgetCollection.activeChartWidget.value());
          const e = (0, vo.lastMouseOrTouchEventInfo)();
          if (e.isTouch && !e.stylus && this._isLineToolModeExceptBrush()) {
            this.updateCrossHairPositionIfNeeded();
          }
          this._justActivated = true;
        }
      }
      _endRequestActive() {
        if (this._justActivated) {
          setTimeout(() => this._justActivated = false, 0);
        }
      }
      _requestActive() {
        this._beginRequestActive();
        this._endRequestActive();
      }
      _createSessions(e) {
        {
          const t = this.showGeneralChartProperties.bind(this, Zs.TabNames.timezoneSessions);
          e.createSessions(t);
          return;
        }
      }
      _createPrePostMarket(e) {
        0;
      }
      _createVolumeIfNeeded() {
        const e = l.enabled("create_volume_indicator_by_default") && this._options.addVolume;
        const t = !this._content;
        const i = l.enabled("create_volume_indicator_by_default_once");
        const s = this._content && !this._content.loading;
        if (e && (t || s && !i)) {
          const e = () => {
            setTimeout(async () => {
              const e = this.model().model();
              const t = e.mainSeries().symbolInfo();
              if (!t) {
                return;
              }
              const i = (0, yt.hasVolume)(t);
              if (!this.containsVolume() && i) {
                const t = (0, h.factoryDefaults)("chartproperties.volumePaneSize");
                await (0, ts.studyMetaInfoRepository)().requestMetaInfo();
                const i = e.createStudyInserter({
                  type: "java",
                  studyId: "Volume@tv-basicstudies"
                });
                i.setForceOverlay(l.enabled("volume_force_overlay"));
                i.setPaneSize(t);
                if (l.enabled("hide_volume_ma")) {
                  i.setPropertiesState({
                    styles: {
                      vol_ma: {
                        display: 0
                      }
                    }
                  });
                }
                i.insert();
              } else if (!i && this.containsVolume()) {
                const t = this.model().dataSources().filter(e => (0, Js.isStudy)(e) && e.metaInfo().shortId === "Volume")[0];
                e.removeSource(t);
              }
            });
          };
          this.model().mainSeries().dataEvents().symbolResolved().subscribe(this, e, i);
        }
      }
      onModelTagsChanged() {
        this._tagsChanged.fire();
      }
      _initBackgroundColor() {
        if (this._backgroundTopColorSpawn === null) {
          this._backgroundTopColorSpawn = this.model().model().backgroundTopColor().spawn();
          this._backgroundTopColorSpawn.subscribe(this._onBackgroundColorChanged.bind(this));
        }
        if (this._backgroundBottomColorSpawn === null) {
          this._backgroundBottomColorSpawn = this.model().model().backgroundColor().spawn();
          this._backgroundBottomColorSpawn.subscribe(this._onBackgroundColorChanged.bind(this));
        }
      }
      _updateGui(e) {
        if (this._model) {
          this._makeTimeAxisWidget();
          this._makePaneWidgetsAndSeparators();
          this._elMainTable.style.userSelect = "none";
          this._adjustSize(e);
        }
      }
      _onChartStyleChanged() {
        (0, ne.trackEvent)("Chart", `Chart Style ${this.model().mainSeries().getStyleShortName().toUpperCase()}`);
      }
      _addPerfMark(e) {
        (0, Rm.addPerfMark)(`ChartWidget.${this._id}.${e}`);
      }
      _setElement(e) {
        if (!e) {
          return;
        }
        if (this._mainDiv) {
          this._mainDiv.remove();
          const e = document.createRange();
          e.selectNodeContents((0, n.ensureNotNull)(this._parent));
          e.deleteContents();
        }
        if (this._controlBarNavigation) {
          this._controlBarNavigation.destroy();
          this._controlBarNavigation = null;
        }
        if (this._removeMaximizeHotkey !== null) {
          this._removeMaximizeHotkey();
        }
        this._removeMaximizeHotkey = this._initMaximizeHotkey(e);
        const t = e.ownerDocument;
        const s = t.createElement("div");
        s.classList.add("chart-container-border");
        e.insertBefore(s, e.firstChild);
        this._parent = s;
        const o = t.createElement("div");
        o.classList.add("chart-widget");
        this._mainDiv = o;
        this._elTooltipDiv = t.createElement("div");
        this._elTooltipDiv.className = "tooltip-wrapper";
        this._mainDiv.appendChild(this._elTooltipDiv);
        this._elMainTable = t.createElement("div");
        this._elMainTable.className = "chart-markup-table";
        this._mainDiv.appendChild(this._elMainTable);
        o.setAttribute("role", "region");
        o.setAttribute("aria-label", a.t(null, {
          replace: {
            index: this.id()
          }
        }, i(56275)));
        if (this._hotkeysListener) {
          this._hotkeysListener.destroy();
        }
        this._errorRenderer.setContainer(this._parent);
        this._hotkeysListener = new Gs.ChartHotkeysListener(this, this._mainDiv);
        if (this._options.controlBarEnabled || l.enabled("control_bar")) {
          this._createControlBar();
        }
        if (this._options.handleScale.mouseWheel || this._options.handleScroll.mouseWheel) {
          this._mouseWheelHelper = new To();
          const e = this._onMousewheel.bind(this);
          this._onWheelBound = e;
          this._mainDiv.addEventListener("wheel", e, {
            passive: false
          });
        }
        this._mainDiv.addEventListener("mouseenter", () => this._isHovered.setValue(true));
        this._mainDiv.addEventListener("mouseleave", () => this._isHovered.setValue(false));
        this.resize();
        this._justActivated = false;
        this.withModel(this, () => {
          s.appendChild(o);
          o.addEventListener("mousedown", this._beginRequestActive.bind(this));
          o.addEventListener("mouseup", this._endRequestActive.bind(this));
          o.addEventListener("touchstart", this._beginRequestActive.bind(this));
          o.addEventListener("touchmove", this._endRequestActive.bind(this));
          o.addEventListener("touchend", this._endRequestActive.bind(this));
          o.addEventListener("click", this._requestActive.bind(this));
        });
        if (this._inited) {
          if (this._timeAxisWidget !== null) {
            this._timeAxisWidget.destroy();
            this._timeAxisWidget = null;
          }
          this._paneWidgets.value().forEach(e => {
            e.destroy();
          });
          this._paneWidgets.setValue([]);
          this._paneSeparators.forEach(e => {
            e.destroy();
          });
          this._paneSeparators.length = 0;
          this._update(yo.InvalidationMask.full(), performance.now());
        }
      }
      _init() {
        if (this.hasModel()) {
          this.model().mainSeries().clearData();
        }
        this._initColors();
        this._makeDefaultGui();
        this._makeDefaultModel();
        (() => {
          this._checkObsoleteTimezone();
          if (this._chartSession && this._chartSession.connected()) {
            this.model().model().restart();
          }
          if (this._content) {
            this._initColors();
            this._updateGui();
            this.update();
          }
          this._resizeHandler = () => {
            this._invalidationHandler(yo.InvalidationMask.full());
          };
          this._resizeHandler();
          (0, n.ensureNotNull)(this._parent).appendChild((0, n.ensureNotNull)(this._mainDiv));
          if (this._spinner) {
            this._spinner.stop();
            this._spinner = null;
          }
          this._activateSymbolSearchHotkeys();
          this.model().timeScale().onScroll().subscribe(this, () => this._onScroll.fire());
          this._inited = true;
        })();
      }
      _makeDefaultModel() {
        let e;
        if (this._content && this._content.timeScale.points) {
          const t = this._content.timeScale.points.items[0];
          e = {
            startDate: t
          };
        }
        const t = () => {
          const t = {
            readOnly: this.readOnly(),
            isSnapshot: !!this._containsData,
            ...As(this._options, ["timeScale", "crossHair", "chartEventsEnabled", "newsNotificationsEnabled", "esdEnabled", "latestUpdatesEnabled", "continuousContractSwitchesEnabled", "futuresContractExpirationEnabled", "countdownEnabled", "lastPriceAnimationEnabled", "currencyConversionEnabled", "unitConversionEnabled", "watermarkEnabled", "shiftVisibleRangeOnNewBar", "hideIdeas", "onWidget"])
          };
          const i = function (e, t, i, s, o, n, r, a, l, c, h, d) {
            const u = new qp(e, t, i, s, o, n, r, a, l, c, h, d);
            u.model().fullUpdate();
            return u;
          }(this._chartSession, this._invalidationHandler, this._properties, this._mainSeriesProperties, e, this, this._options.undoHistory, this._options.barsMarksContainersFactory, t, this._collapsed, this._linkingGroupIndex, this._saveChartService?.autoSaveEnabled() ?? new F.WatchedValue(true));
          this._createSessions(i.model());
          return i;
        };
        if (l.enabled("lean_chart_load")) {
          this._model = this._model || t();
        } else {
          this._model = t();
        }
        this._model.model().setChartSaveTime(this._chartWidgetCollection.metaInfo.lastModified.value() * 1000);
        this._createVolumeIfNeeded();
        if (this._content) {
          let e = this._setSymbolIntervalContentOverrides;
          if (Fm && this._initialLoading) {
            e = {
              ...e,
              symbol: this._defSymbol,
              interval: this._defInterval ?? undefined,
              style: this._defStyle ?? undefined
            };
            if (this._defInterval && Re.Interval.isRange(this._defInterval)) {
              e.style = 11;
            }
          }
          this.restoreState(this._content, this._containsData, e);
          this._setSymbolIntervalContentOverrides = {};
          if (Fm && this._defSymbol) {
            this.model().model().recalculatePriceRangeOnce();
          }
        }
        this._setActions();
        this._createLineToolsSynchronizerIfNeeded();
        (() => {
          const e = (0, n.ensureNotNull)(this._model);
          e.onTagsChanged().subscribe(this, () => this.onModelTagsChanged());
          this._initBackgroundColor();
          this._updateGui();
          this._modelCreated.fire(e);
          this._tagsChanged.fire();
          if (l.enabled("determine_first_data_request_size_using_visible_range")) {
            this._setFirstRequestNumbarsUsingTimeframeAndInterval(e);
          }
          const t = e.mainSeries();
          const i = t.properties().childs();
          if (this._defTimeframe) {
            t.setDefaultTimeframe(this._defTimeframe);
          }
          t.dataEvents().symbolNotPermitted().subscribe(null, e => t.setSymbolParams({
            symbol: e
          }));
          this._symbolWV.setValue(i.symbol.value());
          i.symbol.subscribe(this, e => this._symbolWV.setValue(e.value()));
          this._resolutionWV.setValue(i.interval.value());
          i.interval.subscribe(this, e => this._resolutionWV.setValue(e.value()));
          i.style.unsubscribe(this, this._onChartStyleChanged);
          i.style.subscribe(this, this._onChartStyleChanged);
          t.dataEvents().completed().subscribe(this, () => this._addPerfMark("SeriesCompleted"), true);
          t.dataEvents().barReceived().subscribe(this, () => this._addPerfMark("SeriesFirstDataReceived"), true);
          this._options;
          t.dataEvents().chartTypeNotPermitted().subscribe(null, () => {
            t.setSymbolParams({
              interval: "D"
            });
          });
          t.dataEvents().intradaySpreadNotPermitted().subscribe(null, () => {
            t.setSymbolParams({
              interval: "D"
            });
          });
          t.dataEvents().customIntervalNotPermitted().subscribe(null, i => {
            const s = e.model().defaultResolutions();
            const o = s.find(e => (0, es.compareResolutions)(e, i) >= 0) ?? s[s.length - 1];
            t.setSymbolParams({
              interval: o
            });
          });
          t.dataEvents().intradayExchangeNotPermitted().subscribe(null, () => {
            t.setSymbolParams({
              interval: "D"
            });
          });
          t.requestingStyleIsNotSupported.subscribe(null, () => {
            const i = t.interval();
            const s = e.model().defaultResolutions();
            const o = (0, yt.getLastUsedSingleValueBasedStyle)();
            const n = (0, es.getResolutionByChartStyle)(o, i, s);
            t.setChartStyleWithIntervalIfNeeded(o, n);
          });
          t.requestingStyleSupportRecovered.subscribe(null, i => {
            const s = t.interval();
            const o = e.model().defaultResolutions();
            const n = (0, es.getResolutionByChartStyle)(i, s, o);
            t.setChartStyleWithIntervalIfNeeded(i, n);
          });
        })();
      }
      _addHotkeys() {
        this._hotkeys.add({
          desc: "Maximize",
          hotkey: V.Modifiers.Alt + 13,
          handler: () => this.toggleFullscreen(),
          isDisabled: () => !this.getResizerDetacher().fullscreenable.value()
        });
        this._hotkeys.add(this._clearSelectionHotkey());
        if (this._options.indicatorsDialogShortcutEnabled) {
          this._hotkeys.add({
            desc: "Show insert indicator dialog",
            hotkey: 111,
            handler: () => this.showIndicators()
          });
        }
        if (!this.readOnly()) {
          this._hotkeys.add({
            desc: "Remove selected source",
            hotkey: V.isMacKeyboard ? 46 : 8,
            handler: () => this.removeSelectedSources()
          });
          this._hotkeys.add({
            desc: "Switch between sessions",
            hotkey: V.Modifiers.Shift + V.Modifiers.Alt + 69,
            handler: () => this._switchSubSession()
          });
          {
            const e = async (e, t) => {
              if (this.activePaneWidget) {
                if (t.action === "drawRightThere") {
                  await this.activePaneWidget.drawRightThere(e);
                } else {
                  lt.tool.setValue(e);
                }
              }
            };
            const t = (t, i) => () => e(t, i);
            Object.entries(Kp.lineToolsSelectHotkeys).map(([e, i]) => ({
              desc: i.description,
              hotkey: i.hash,
              handler: t(e, i)
            })).forEach(e => this._hotkeys.add(e));
          }
        }
        this._hotkeys.add({
          desc: "Hide all drawing tools",
          hotkey: V.Modifiers.Mod + V.Modifiers.Alt + 72,
          handler: () => (0, ks.toggleHideMode)()
        });
        this.withModel(null, () => {
          const e = () => this._hotkeys.promote();
          this.model().onSelectedSourceChanged().subscribe(null, e);
          this.model().crosshairSource().measurePane().subscribe(t => {
            if (t !== null) {
              e();
            }
          });
        });
      }
      _switchSubSession() {
        if (!this.hasModel()) {
          return;
        }
        const e = this.model().mainSeries();
        if (!Re.Interval.parse(e.interval()).isIntraday()) {
          return;
        }
        const t = e.symbolInfo();
        if (t === null) {
          return;
        }
        const i = t.subsessions?.filter(e => !e.private) ?? [];
        if (i.length === 0) {
          return;
        }
        const s = (i.findIndex(t => t.id === e.properties().childs().sessionId.value()) + 1) % i.length;
        this.model().setProperty(e.properties().childs().sessionId, i[s].id, jm);
      }
      _startSpinner(e) {
        if (!this._spinner) {
          if (e) {
            this._spinner = new zs().spin(e);
          }
        }
      }
      _handleLoginStateChanged() {
        0;
      }
      _checkObsoleteTimezone() {
        const e = this.properties().childs().timezone.value();
        if (!(0, Pe.timezoneIsAvailable)(e)) {
          this.properties().childs().timezone.setValue({
            UTC: "Etc/UTC",
            EST: "America/New_York",
            CST: "America/Chicago",
            PST: "America/Los_Angeles"
          }[e] || "exchange");
        }
      }
      _initColors() {
        const e = this.properties().childs();
        const t = e.scalesProperties.childs();
        t.lineColor.subscribe(this, this._updateAndPaint);
        t.textColor.subscribe(this, this._updateAndPaint);
        e.paneProperties.childs().separatorColor.subscribe(this, this._setPaneSeparatorLineColor);
      }
      _setPaneSeparatorLineColor() {
        this._paneSeparators.forEach(e => e.update());
        this._updateAndPaint();
      }
      _updateAndPaint() {
        this.update();
        this.paint();
      }
      _makeDefaultGui() {
        this._makeLoadingScreen();
        if ((0, r.getChartingLibraryGlobalContext)().configurationData.is_tradingview_data || this.onWidget()) {
          this._makeAvailableOnTVPopup();
        }
        if (this.hasModel()) {
          this._makeTimeAxisWidget();
          this._makePaneWidgetsAndSeparators();
          this._updateScalesActions();
        }
        this._adjustSize();
        (0, Wt.disableSelection)(this._elMainTable);
        this._updateAndPaint();
      }
      _makeLoadingScreen() {
        if (l.enabled("lean_chart_load")) {
          if (this.screen) {
            return;
          }
          this.screen = new Co(this, (0, n.ensureNotNull)(this._parent));
        } else {
          this.screen?.destroy();
          this.screen = new Co(this, (0, n.ensureNotNull)(this._mainDiv));
        }
      }
      _makeAvailableOnTVPopup() {
        this._availableScreen ||= new Xp(this);
      }
      _activateSymbolSearchHotkeys() {
        if (!this.readOnly() && !this._options.hideSymbolSearch) {
          (0, Ls.activateKeyPressHandler)();
        }
      }
      _makeTimeAxisWidget() {
        if (this._timeAxisWidget) {
          this._timeAxisWidget.updatePriceAxisStubs();
          return;
        }
        const e = this.model();
        this._timeAxisWidget = new Tr(this, this._options.timeScaleWidget, this._titlesProvider.bind(this), this._menuItemsProvider.bind(this), this._backgroundBasedTheme.spawnOwnership());
        this._elMainTable.appendChild(this._timeAxisWidget.getElement());
        this._timeAxisWidget.updatePriceAxisStubs();
        this._timeAxisWidget.onLabelHovered().subscribe(this, (t, i) => {
          const s = this.maximizedPaneWidget();
          const o = s ? s.state() : e.paneForSource(e.mainSeries());
          const r = (0, n.ensureNotNull)(this.paneByState((0, n.ensureNotNull)(o))).highlightedPriceAxis();
          const a = r.value();
          if (i || a.owner === t.owner) {
            r.setValue({
              owner: t.owner,
              axis: i ? t.axis : null
            });
            this.model().model().lightUpdate();
          }
        });
      }
      _updateAriaPriceDescription(e) {
        if (this._ariaPriceDescription && l.enabled("aria_crosshair_price_description")) {
          const t = this.model().mainSeries().nearestData(e.index, Yh.PlotRowSearchMode.Exact);
          if (!t) {
            return;
          }
          const i = t.value[4];
          if (!(0, dt.isNumber)(i)) {
            return;
          }
          const s = this.model().timeScale().indexToUserTime(t.index);
          const o = Re.Interval.parse(this.model().mainSeries().interval());
          this._ariaPriceDescription.updateChartDescription(this.model().mainSeries(), i, s?.getTime() ?? null, o.isIntraday());
        }
      }
      _titlesProvider(e, t) {
        const i = this.model();
        const s = this.maximizedPaneWidget();
        const o = (0, n.ensureNotNull)(s ? s.state() : i.paneForSource(i.mainSeries()));
        const r = e === "right" ? o.rightPriceScales() : o.leftPriceScales();
        if (r.length < t + 1) {
          return [];
        }
        let a = r[t].orderedSources().filter(e => e === i.mainSeries() || (0, Js.isStudy)(e));
        a.reverse();
        a = (0, ft.moveToHead)(a, i.mainSeries());
        return a.map(e => e.title(ua.TitleDisplayTarget.StatusLine, true, undefined, false));
      }
      _menuItemsProvider(e, t) {
        const i = this.model();
        const s = this.maximizedPaneWidget();
        const o = (0, n.ensureNotNull)(s ? s.state() : i.paneForSource(i.mainSeries()));
        const r = e === "right" ? o.visibleRightPriceScales() : o.visibleLeftPriceScales();
        if (r.length < t + 1) {
          return [];
        }
        const a = r[t];
        const l = i.model().panes().indexOf(o);
        const c = this._paneWidgets.value()[l];
        const h = e === "right" ? c.rightPriceAxisesContainer() : c.leftPriceAxisesContainer();
        const d = (0, n.ensureNotNull)(h).findAxisWidgetForScale(a);
        return d?.getContextMenuActions() ?? [];
      }
      _invalidationRAFCallback(e) {
        this._drawPlanned = false;
        this._drawRafId = 0;
        if (!this._inLoadingState) {
          if (this._invalidationMask) {
            const t = this._invalidationMask;
            this._invalidationMask = null;
            this._update(t, e);
            for (const i of t.timeScaleInvalidations()) {
              if (i.type === 0 && !i.value.finished(e)) {
                this.model().model().setTimeScaleAnimation(i.value, i.rightOffsetPx);
                break;
              }
            }
            for (let i = 0; i < this._paneWidgets.value().length; i++) {
              for (const [s, o] of t.invalidateForPane(i).priceScaleRangeAnimations()) {
                if (o && !o.finished(e)) {
                  const e = this.model().model().panes()[i];
                  if (e) {
                    const t = e.getPriceScaleById(s);
                    if (t) {
                      e.setPriceScaleRangeAnimation(t, o);
                    }
                  }
                }
              }
            }
          }
          if (this._chartPaintedPromise !== null) {
            this._chartPaintedPromise.resolve();
            this._chartPaintedPromise = null;
          }
        }
      }
      _applyTimeScaleInvalidations(e, t) {
        for (const i of e.timeScaleInvalidations()) {
          this._applyTimeScaleInvalidation(i, t);
        }
      }
      _applyTimeScaleInvalidation(e, t) {
        const i = this._model?.timeScale();
        if (i && e.type === 0) {
          const s = e.value.getStartPosition() - e.value.getPosition(t);
          const o = e.rightOffsetPx + s;
          const n = i.width() - o;
          const r = i.indexToCoordinate(i.baseIndex());
          i.startScroll(r);
          i.scrollTo(n);
          i.endScroll();
          i.requestHistoryPointsIfNeeded();
          if (e.value.finished(t)) {
            e.value.onFinish?.(true);
          }
        }
      }
      _onChartSessionCriticalError(e, t) {
        this._disconnected.fire(true);
      }
      _onData(e) {
        if (e.method === "reconnect_bailout") {
          this._reconnectBailout.fire();
        } else {
          this.model().model().onData(e);
        }
      }
      _onConnection() {
        if (this.hasModel()) {
          this.model().model().restart();
          this.model().model().fullUpdate();
          this._connected.fire();
        } else {
          this._requestMetadataAndProcessModel();
        }
      }
      _onDisconnect() {
        if (this.hasModel()) {
          this.model().model().disconnect();
        }
        if (this._model) {
          this._model.model().fullUpdate();
        }
        this._disconnected.fire();
      }
      async _requestMetadataAndProcessModel() {
        await this._requestMetadata();
        if (!this._inited) {
          await (0, eo.initAllLineToolsFromContent)(this._content);
          this._init();
          this._chartWidgetInitialized.fire();
        }
      }
      async _requestMetadata() {
        this._addPerfMark("RequestMetadataStart");
        await (0, ts.studyMetaInfoRepository)().requestMetaInfo();
        this._addPerfMark("RequestMetadataEnd");
      }
      async _createControlBar() {
        const e = await Promise.all([i.e(2199), i.e(4178), i.e(8985), i.e(6489), i.e(9753), i.e(4170), i.e(2227), i.e(7973), i.e(5093)]).then(i.bind(i, 22136));
        this._controlBarNavigation = new e.ControlBarNavigation(this, (0, n.ensureNotNull)(this._mainDiv), this._options.controlBar);
        if (this._model) {
          this._adjustSize();
        }
      }
      _subscribeToDrawingState() {
        if (this.readOnly()) {
          return;
        }
        (0, lt.init)();
        const e = (e, t) => {
          const i = this._model;
          if (i === null) {
            return;
          }
          const s = i.model();
          if (e.model !== s) {
            if (this._lineToolsSynchronizer) {
              this._lineToolsSynchronizer.executeSyncedAction(() => t(s, i));
            } else {
              t(s, i);
            }
          }
        };
        lt.createdLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            const s = (0, n.ensureNotNull)(e.paneForSource(e.mainSeries()));
            let o;
            let r = null;
            if (t.pointPositionPercents === undefined) {
              r = Km(e, t.model, t.point.timeStamp);
              if (r === null) {
                return;
              }
              o = t.point.price;
            } else {
              const i = t.pointPositionPercents.x * e.timeScale().width();
              const s = e.mainSeries().priceScale();
              const n = t.pointPositionPercents.y * s.height();
              const a = e.mainSeries().firstValue();
              if (a === null) {
                return;
              }
              r = e.timeScale().coordinateToIndex(i);
              o = s.coordinateToPrice(n, a);
            }
            const a = {
              index: (0, n.ensureNotNull)(r),
              price: o
            };
            const l = i.createLineTool({
              pane: s,
              point: a,
              linetool: t.linetool,
              properties: t.properties,
              linkKey: t.linkKey,
              ownerSource: e.mainSeries(),
              synchronizationMode: Lr.CreateLineToolSyncMode.ForceOff,
              id: t.id,
              sharingMode: t.sharingMode
            });
            if (l !== null && !Boolean(this.model().lineBeingCreated()) && t.finalState) {
              l.restoreExternalPoints(t.finalState, {
                indexesChanged: true,
                pricesChanged: true
              });
            }
          });
        });
        lt.continuedLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            const s = Km(e, t.model, t.point.timeStamp);
            if (s === null) {
              return;
            }
            const o = {
              index: s,
              price: t.point.price
            };
            const n = e.lineBeingCreated();
            if (n === null) {
              return;
            }
            if (i.continueExternalLine(o, t.envState ?? undefined, !!t.finalState) && t.finalState) {
              n.restoreExternalPoints(t.finalState, {
                indexesChanged: true,
                pricesChanged: true
              });
            }
          });
        });
        lt.cancelledLineTool.subscribe(this, t => {
          e(t, (e, t) => {
            e.cancelCreatingLine();
          });
        });
        lt.beenSetLineToolLastPoint.subscribe(this, t => {
          e(t, (e, i) => {
            const s = e.lineBeingCreated();
            if (s === null || s.linkKey().value() !== t.linkKey) {
              return;
            }
            const o = Km(e, t.model, t.point.timeStamp);
            if (o === null) {
              return;
            }
            const n = {
              index: o,
              price: t.point.price
            };
            s.setLastPoint(n);
            s.updateAllViews((0, Bt.sourceChangeEvent)(s.id()));
            e.lightUpdate();
          });
        });
        lt.startedMovingLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            const s = t.linkKeys.filter(dt.notNull).map(t => e.lineToolByLinkKey(t)).filter(dt.notNull);
            if (s.length) {
              const i = Km(e, t.model, t.point.timeStamp);
              if (i === null) {
                return;
              }
              const o = {
                index: i,
                price: t.point.price
              };
              const n = t.activeItem ?? null;
              const r = s[0].pointToScreenPoint(o);
              if (r) {
                e.startMovingSources(s, {
                  logical: o,
                  screen: r
                }, n, t.pointPositionPercents, t.envState === null ? undefined : t.envState, true);
              }
            }
          });
        });
        lt.movedLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            const s = e.sourcesBeingMoved().filter(eo.isLineTool).filter(e => (e => t.linkKeys.some(t => e.linkKey().value() === t))(e));
            if (!s.length) {
              return;
            }
            const o = Km(e, t.model, t.point.timeStamp);
            if (o === null) {
              return;
            }
            const n = {
              index: o,
              price: t.point.price
            };
            const r = s[0].pointToScreenPoint(n);
            if (r) {
              e.moveSources({
                logical: n,
                screen: r
              }, t.pointPositionPercents, t.envState ?? undefined, true);
            }
          });
        });
        lt.finishedMovingLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            const s = e.sourcesBeingMoved().filter(eo.isLineTool);
            if (s.length === 0) {
              return;
            }
            s.forEach(i => {
              const s = (e => {
                for (let i = 0; i < t.linkKeys.length; i++) {
                  if (t.linkKeys[i] === e.linkKey().value()) {
                    return {
                      state: t.finalStates[i],
                      changes: t.changes[i]
                    };
                  }
                }
                return null;
              })(i);
              e.endMovingSources(s !== null, true);
              if (s !== null) {
                i.restoreExternalPoints(s.state, s.changes);
                if (s.state.pointPositionPercents) {
                  i.restorePositionPercents(s.state.pointPositionPercents);
                }
              }
            });
          });
        });
        lt.startedChangingLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            const s = e.lineToolByLinkKey(t.linkKey);
            if (s !== null) {
              let i = null;
              if (t.positionPercents) {
                const o = e.timeScale().positionPercentToCoordinate(t.positionPercents.x);
                const r = (0, n.ensureNotNull)(s.priceScale()).positionPercentToCoordinate(t.positionPercents.y);
                i = s.screenPointToPoint((0, At.point)(o, r), true);
                if (!i) {
                  return;
                }
              } else {
                const o = s.getPoint(t.pointIndex);
                const n = o ? o.index : Km(e, t.model, t.point.timeStamp);
                if (n === null) {
                  return;
                }
                i = {
                  index: n,
                  price: t.point.price
                };
              }
              if (s.isActualSymbol() && s.isActualCurrency() && s.isActualUnit()) {
                e.startChangingLinetool(s, i, t.pointIndex, t.envState ?? undefined, true);
              }
            }
          });
        });
        lt.changedLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            const s = e.lineBeingEdited();
            if (s === null || s.linkKey().value() !== t.linkKey) {
              return;
            }
            let o = null;
            if (t.positionPercents) {
              const i = e.timeScale().positionPercentToCoordinate(t.positionPercents.x);
              const r = (0, n.ensureNotNull)(s.priceScale()).positionPercentToCoordinate(t.positionPercents.y);
              o = s.screenPointToPoint((0, At.point)(i, r), true);
              if (!o) {
                return;
              }
            } else {
              let i = null;
              i = t.changes.indexesChanged ? Km(e, t.model, t.point.timeStamp) : (0, n.ensureNotNull)(e.linePointBeingChanged()).index;
              if (i === null) {
                return;
              }
              o = {
                index: i,
                price: t.point.price
              };
            }
            if (s.isActualSymbol() && s.isActualCurrency() && s.isActualUnit()) {
              e.changeLinePoint(o, undefined, true);
            }
          });
        });
        lt.finishedChangingLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            const s = e.lineToolByLinkKey(t.linkKey);
            if (s !== null && s.isActualSymbol() && s.isActualCurrency() && s.isActualUnit() && e.lineBeingEdited() !== null) {
              e.endChangingLinetool(!!t.finalState, true);
            }
            if (s !== null && t.finalState) {
              if (t.finalState.pointPositionPercents) {
                s.restorePositionPercents(t.finalState.pointPositionPercents);
              } else {
                s.restoreExternalPoints(t.finalState, t.changes);
              }
            }
          });
        });
        lt.removedLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            const {
              withUndo: s,
              unlink: o,
              linkKey: n
            } = t;
            const r = e.lineToolByLinkKey(n);
            if (r !== null) {
              if (o) {
                r.detachAlert();
              }
              if (s) {
                i.removeSource(r, false);
              } else {
                e.lineToolsGroupModel().removeLineTools([r]);
                e.removeSource(r);
              }
            }
          });
        });
        lt.finishedLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            const s = e.lineToolByLinkKey(t.linkKey);
            if (s !== null && (0, wt.isLineToolFinishRequiredWhenCreatedByApi)(s.toolname)) {
              s.finish();
            }
          });
        });
        lt.changedLineStyle.subscribe(this, t => {
          e(t, (e, i) => {
            const s = e.lineToolByLinkKey(t.linkKey);
            if (s !== null) {
              const {
                zOrder: e,
                ...i
              } = t.state;
              if (e !== undefined) {
                s.setZorder(e);
              }
              if (!(0, Ts.default)(i)) {
                s.restoreExternalState(i);
                s.propertiesChanged(true);
              }
              if (t.alertId) {
                s.syncAlert(t.alertId);
              }
            }
          });
        });
        lt.restoredLineToolState.subscribe(this, t => {
          e(t, async (e, i) => {
            const s = e.lineToolByLinkKey(t.linkKey);
            if (s !== null) {
              const i = {
                ...t.state
              };
              i.indexes = t.state.points.map(i => ({
                index: Km(e, t.model, i.time_t),
                price: i.price
              }));
              await (0, Ro.ensureLineToolLoaded)(s.toolname);
              e.restoreLineToolState(s, i, false);
            }
          });
        });
        lt.restoredLineTool.subscribe(this, t => {
          e(t, (e, i) => {
            e.restoreSource(t.state.restorePane, t.state.paneIndex, t.state.paneState, t.state.sourceState, null);
          });
        });
        lt.copiedLineTool.subscribe(this, async t => {
          await (0, Ro.ensureLineToolLoaded)(t.linetool);
          e(t, (e, i) => {
            const s = (0, n.ensureNotNull)(e.paneForSource(e.mainSeries()));
            let o;
            const r = {
              ...t.state,
              intervalsVisibilities: (0, Ch.mergeIntervalVisibilitiesDefaults)(t.state.intervalsVisibilities)
            };
            const a = (0, eo.createLineToolProperties)(e.backgroundTheme().spawnOwnership(), t.linetool, !e.readOnly(), r);
            const l = e.dataSourceForId(t.id);
            if (l) {
              if (!(0, eo.isLineTool)(l)) {
                Om.logError(`Error sync creating line tool. Object with id ${t.id} is already in use and it is not a line tool`);
                return;
              }
              if (l.toolname !== t.linetool) {
                Om.logError(`Error sync creating line tool. Object with id ${t.id} is already in use and its type differs: ${l.toolname} and ${t.linetool}`);
                return;
              }
            }
            if (l) {
              l.linkKey().setValue(t.linkKey);
              l.share(t.sharingMode);
            }
            if (t.pointPositionPercents) {
              const e = {
                index: 0,
                price: 0
              };
              o = l ?? i.createLineTool({
                pane: s,
                point: e,
                linetool: t.linetool,
                properties: a,
                linkKey: t.linkKey,
                synchronizationMode: Lr.CreateLineToolSyncMode.ForceOff,
                id: t.id
              });
              if (o === null) {
                return;
              }
              o.restorePositionPercents((0, n.ensureDefined)(t.pointPositionPercents));
            } else {
              const r = i => ({
                index: (0, n.ensureNotNull)(Km(e, t.model, i.timeStamp)),
                price: i.price
              });
              const c = t.points.map(r);
              const h = t.pointsForCreating.map(r);
              const d = c[0];
              if (l) {
                o = l;
              } else if (t.withUndo) {
                o = i.createLineTool({
                  pane: s,
                  point: d,
                  linetool: t.linetool,
                  properties: a,
                  linkKey: t.linkKey,
                  sharingMode: t.sharingMode,
                  synchronizationMode: Lr.CreateLineToolSyncMode.ForceOff,
                  id: t.id
                });
              } else {
                const e = new da({
                  model: i.model(),
                  pane: s,
                  lineTool: t.linetool,
                  ownerSource: (0, n.ensureNotNull)(s.mainDataSource()),
                  drawOnAllChartsMode: t.sharingMode,
                  id: t.id
                });
                e.redo();
                e.startCreatingLine(d, a, t.linkKey || null, t.sharingMode, true);
                o = (0, n.ensureNotNull)(e.line());
              }
              if (o === null) {
                return;
              }
              const u = (e, s) => {
                if (t.withUndo) {
                  i.continueCreatingLine(e, new Bo.EnvironmentState(undefined, true), s, true);
                } else {
                  i.model().continueCreatingLine(e, new Bo.EnvironmentState(undefined, true), s, true);
                }
              };
              const _ = (0, wt.isLineToolFinishRequiredWhenCreatedByApi)(t.linetool);
              if (e.lineBeingCreated()) {
                if (h.length > 1) {
                  for (let e = 1; e < h.length; e++) {
                    u(h[e], e < h.length - 1 && !_);
                    if (e === h.length - 1 && _) {
                      o.finish();
                      u(h[e], true);
                    }
                  }
                } else if (_) {
                  o.finish();
                  u(h[0], true);
                }
              }
            }
            o.properties().interval.setValue(t.state.interval);
            o.restoreExternalState(t.state);
            if (o.restoreData) {
              o.restoreData(t);
            }
            o.setZorder(t.zOrder);
            o.propertiesChanged(true);
            if (t.finalState) {
              o.calcIsActualSymbol();
              o.restoreExternalPoints(t.finalState, {
                pricesChanged: true,
                indexesChanged: true
              });
            }
            if (t.alertId) {
              o.syncAlert(t.alertId);
            }
          });
        });
      }
      _setFirstRequestNumbarsUsingTimeframeAndInterval(e) {
        const t = function (e) {
          const t = e.numberExtraBars ?? 0;
          const i = e.barSpacing || 6;
          const s = Math.ceil(e.width / i) + t;
          if (e.timeFrame) {
            if (!e.interval) {
              return {
                barCount: s
              };
            }
            const i = Re.Interval.parse(e.interval);
            if (typeof e.timeFrame == "string") {
              if (e.timeFrame === "ALL") {
                return {
                  barCount: s
                };
              }
              let o = e.timeFrame;
              if (e.timeFrame === "YTD") {
                o = `${Math.floor((new Date().valueOf() - new Date(new Date().getFullYear(), 0, 0).valueOf()) / 1000 / 60 / 60 / 24)}D`;
              }
              const n = Re.Interval.parse(o);
              const r = Date.now().valueOf();
              const a = r - n.inMilliseconds();
              return {
                barCount: (0, rd.getPeriodsBetweenDates)(e.symbolInfo?.session ?? "24x7", e.symbolInfo?.session_holidays ?? "", e.symbolInfo?.corrections ?? "", i.letter(), i.multiplier(), a, r) + t,
                message: `based on period of ${o}`,
                shouldAdjustBarSpacing: true
              };
            }
            if (e.timeFrame.type === "time-range") {
              return {
                barCount: (0, rd.getPeriodsBetweenDates)(e.symbolInfo?.session ?? "24x7", e.symbolInfo?.session_holidays ?? "", e.symbolInfo?.corrections ?? "", i.letter(), i.multiplier(), e.timeFrame.from * 1000, e.timeFrame.to * 1000) + t,
                message: `based on time range: ${e.timeFrame.from} ... ${e.timeFrame.to}`,
                shouldAdjustBarSpacing: true
              };
            }
          }
          return {
            barCount: s
          };
        }({
          width: e.timeScale().width(),
          barSpacing: e.timeScale().barSpacing(),
          timeFrame: this.options().defTimeframe,
          interval: this.options().defInterval
        });
        if (l.enabled("charting_library_debug_mode")) {
          console.log(`${new Date().toISOString()} Setting initial data request count to ${t.barCount} bars${t.message ? ` (${t.message})` : ""}`);
        }
        e.mainSeries().seriesSource().setInitialRequestOptions({
          count: t.barCount
        });
        if (t.shouldAdjustBarSpacing && typeof t.barCount == "number" && t.barCount > 0) {
          const i = Math.ceil(e.timeScale().width() / t.barCount);
          e.timeScale().setBarSpacing(i);
        }
      }
      _createEventHint() {
        if (this._eventHintDeferredPromise === null) {
          const e = (0, me.createDeferredPromise)();
          this._eventHintDeferredPromise = e;
          Promise.all([i.e(1737), i.e(2227), i.e(6166)]).then(i.bind(i, 5015)).then(t => {
            e.resolve(new t.ChartEventHintRenderer(this._chartWidgetCollection.getContainer()));
          });
        }
        return this._eventHintDeferredPromise.promise;
      }
      async _createWarningHint() {
        return null;
      }
      _showEventHint(e) {
        if (l.enabled("popup_hints")) {
          if (this._activeHint !== null && this._activeHint.type === 0) {
            this._activeHint.show(e);
          } else {
            this._hideHint();
            this._createEventHint().then(t => {
              this._activeHint = t;
              if (e !== undefined) {
                this._activeHint.show(e);
              }
            });
          }
        }
      }
      _showWarningHint(e) {
        0;
      }
      _hideHint() {
        if (this._activeHint !== null) {
          this._activeHint.hide();
        }
      }
      _checkIsTradedGroupSelected() {
        const e = this.model();
        const t = e.model();
        return e.selection().customSources().some(e => t.customSourceName(e)?.startsWith(tradedGroupPlaceOrderPrefix));
      }
      _setActions() {
        this._unsetActions();
        this._addHotkeys();
        this._actions = Vm(this);
        this.withModel(null, () => {
          const e = this.model().mainSeries();
          const t = e.properties();
          t.childs().priceAxisProperties.subscribe(this, this._updateScalesActions);
          e.priceScaleAboutToBeChanged().subscribe(this, () => {
            t.childs().priceAxisProperties.unsubscribeAll(this);
          });
          e.priceScaleChanged().subscribe(this, () => {
            t.childs().priceAxisProperties.subscribe(this, this._updateScalesActions);
            this._updateScalesActions();
          });
        });
        this._updateScalesActions();
        return this._actions;
      }
      _unsetActions() {
        if (this._actions) {
          Object.values(this._actions).forEach(e => {
            e.destroy();
          });
          this._actions = null;
        }
      }
      _updateTimingsMeterState() {
        const e = this._options.visible.value();
        if (this._timingsMeter !== null) {
          if (e) {
            this._timingsMeter.startCollect();
          } else {
            this._timingsMeter.stopCollect();
          }
        }
      }
      _onBackgroundColorChanged() {
        this._paneWidgets.value().forEach(e => {
          e.setCursorForTool();
        });
        this.update();
        this.model().model().fullUpdate();
      }
      _contentSeriesProperties() {
        if (this._content) {
          for (let e = this._content.panes.length; e-- > 0;) {
            const t = this._content.panes[e].sources;
            for (let e = t.length; e-- > 0;) {
              const i = t[e];
              if ((0, pt.isMainSeriesState)(i)) {
                return i.state ?? null;
              }
            }
          }
        }
        return null;
      }
      async _getChartPropertyDefinitionsViewModel() {
        if (this._definitionsViewModel === null) {
          const e = await Promise.all([i.e(2499), i.e(3889), i.e(4482), i.e(3596)]).then(i.bind(i, 61857));
          if (this._isDestroyed) {
            throw new Error("Chart widget already destroyed");
          }
          await new Promise(e => this.withModel(null, e));
          if (this._definitionsViewModel === null) {
            this._definitionsViewModel = new e.ChartPropertyDefinitionsViewModel(this.model(), this.properties(), this._options);
          }
        }
        return this._definitionsViewModel;
      }
    }
    var Jm = i(87489);
    var Qm = i(76351);
    const eg = !l.enabled("widget_logo") || false;
    var tg;
    function ig(e, t = null, i = null) {
      let s = {};
      if (typeof e == "number") {
        return {
          relativePositions: {
            [e]: {
              l: t,
              t: i
            }
          },
          nextElementLeft: e,
          nextElementTop: e
        };
      }
      const [o, ...n] = e;
      if (o === "v") {
        let e = null;
        for (const o of n) {
          const n = ig(o, t, i);
          s = {
            ...s,
            ...n.relativePositions
          };
          i = n.nextElementTop;
          e = n.nextElementLeft;
        }
        t = e;
      }
      if (o === "h") {
        let e = null;
        for (const o of n) {
          const n = ig(o, t, i);
          s = {
            ...s,
            ...n.relativePositions
          };
          t = n.nextElementLeft;
          e = n.nextElementTop;
        }
        i = e;
      }
      return {
        relativePositions: s,
        nextElementTop: i,
        nextElementLeft: t
      };
    }
    (function (e) {
      e[e.LegendTopMargin = 10] = "LegendTopMargin";
      e[e.LegendLeftMargin = 8] = "LegendLeftMargin";
      e[e.LegendLineSpacingCoeff = 1.4] = "LegendLineSpacingCoeff";
      e[e.LegendItemSpacingCoeff = 1.4] = "LegendItemSpacingCoeff";
      e[e.LegendTextFontSize = 12] = "LegendTextFontSize";
      e[e.FooterTextFontSize = 13] = "FooterTextFontSize";
      e[e.Padding = 10] = "Padding";
      e[e.ChartsSpacing = 5] = "ChartsSpacing";
      e[e.FooterHeight = 35] = "FooterHeight";
      e[e.LogoHeight = 15] = "LogoHeight";
      e[e.LogoWidth = 20] = "LogoWidth";
      e[e.LogoTextMargin = 3] = "LogoTextMargin";
    })(tg ||= {});
    const sg = function (e) {
      const t = {};
      for (const i of Object.keys(e)) {
        const s = ig(e[i]).relativePositions;
        t[i] = s;
      }
      return t;
    }(Jm);
    function og(e, t, i, s) {
      let o = Math.round(s * 10);
      let n = Math.round(s * 10);
      const r = i[e];
      if (r.l !== null) {
        const e = og(r.l, t, i, s);
        o = e.x + e.width + Math.round(s * 5);
      }
      if (r.t !== null) {
        const e = og(r.t, t, i, s);
        n = e.y + e.height + Math.round(s * 5);
      }
      const a = t[e];
      return {
        x: o,
        y: n,
        width: a.width,
        height: a.height
      };
    }
    function ng(e, t, i) {
      const s = new DOMParser().parseFromString(Qm, "image/svg+xml");
      s?.firstElementChild?.setAttribute("color", i);
      const o = URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(s)], {
        type: "image/svg+xml"
      }));
      return new Promise(i => {
        const s = new Image();
        s.width = e;
        s.height = t;
        s.onload = () => {
          i({
            image: s,
            width: e,
            height: t
          });
        };
        s.src = o;
      });
    }
    function rg(e, t, i, s, o) {
      e.save();
      e.drawImage(s.image, t, i, s.width, s.height);
      e.textBaseline = "bottom";
      const n = (t + s.width) / o + 3;
      const r = (i + s.height) / o;
      (0, Wt.drawScaled)(e, o, o, () => {
        e.fillText("TradingView", n, r);
      });
      e.restore();
    }
    function ag(e, t, i, s) {
      (0, Wt.drawScaled)(e, s, s, () => {
        e.fillText(i, t.x / s, t.y / s);
      });
      return e.measureText(i).width * s;
    }
    function lg(e, t, i, s, o, n) {
      const r = o.map(e => e.text).join("");
      let a = i.x;
      const l = function (e, t, i, s) {
        if (e.measureText(t).width * s <= i) {
          return {
            text: t,
            elided: false
          };
        }
        const o = e.measureText("...").width * s;
        const n = [];
        for (let e = 0; e < t.length; ++e) {
          n.push(e);
        }
        const r = (0, ft.upperbound)(n, i, (n, r) => e.measureText(t.slice(0, r + 1)).width * s + o > i);
        return {
          text: (t = t.slice(0, r)).trim(),
          elided: true
        };
      }(e, r, s - a, t);
      if (l.elided && !n) {
        return null;
      }
      const c = [];
      let h = 0;
      for (const e of o) {
        if (h + e.text.length > l.text.length) {
          break;
        }
        c.push(e.text);
        h += e.text.length;
      }
      const d = c.join("").trim().length;
      h = 0;
      for (const s of o) {
        if (h + s.text.length > d) {
          break;
        }
        if (s.color) {
          e.save();
          e.fillStyle = s.color;
        }
        a += ag(e, new At.Point(a, i.y), s.text, t);
        if (s.color) {
          e.restore();
        }
        h += s.text.length;
      }
      if (l.elided) {
        a += ag(e, new At.Point(a, i.y), "...", t);
      }
      return a;
    }
    function cg(e) {
      return e.map(e => ({
        ...e,
        title: ""
      }));
    }
    function hg(e, t) {
      const i = [{
        text: e.trim()
      }];
      for (const e of t) {
        if (e.visible) {
          if (i[i.length - 1].text !== "") {
            i.push({
              text: "  "
            });
          }
          if (e.title) {
            i.push({
              text: e.title
            });
          }
          i.push({
            text: e.value,
            color: e.color
          });
        }
      }
      return i;
    }
    class dg {
      constructor(e, t) {
        this._logoTextColor = null;
        this._snapshotData = e;
        t = t || {};
        this._options = {
          backgroundColor: k.themes[e.theme].getThemedColor("color-bg-primary"),
          borderColor: k.themes[e.theme].getThemedColor("color-border"),
          font: g.CHART_FONT_FAMILY,
          fontSize: 12,
          legendMode: "vertical",
          hideResolution: false,
          hideStudiesFromLegend: false,
          showHeaderPublishedBy: false,
          showHeaderMainSymbol: false,
          ...t
        };
        const i = sg[e.layout];
        const s = e.charts.map(e => function (e) {
          const t = e.panes[0];
          const i = t.canvas.width + t.leftAxis.canvas.width + t.rightAxis.canvas.width;
          let s = 0;
          for (const t of e.panes) {
            s += t.canvas.height;
          }
          if (e.timeAxis !== undefined && e.timeAxis.contentHeight !== 0) {
            s += e.timeAxis.canvas.height;
          }
          return (0, Dt.size)({
            width: i,
            height: s
          });
        }(e));
        this._pixelRatio = e.hidpiRatio;
        this._chartsGeometry = e.charts.map((e, t) => og(t, s, i, this._pixelRatio));
        if (!eg) {
          let i = e.theme;
          if (t.backgroundColor !== undefined) {
            i = (0, kt.rgbToBlackWhiteString)((0, kt.parseRgb)(t.backgroundColor), 150) === "black" ? oo.StdTheme.Dark : oo.StdTheme.Light;
          }
          this._logoTextColor = k.themes[i].getThemedColor("color-text-primary");
        }
        this._headerDefaultTextColor = k.themes[e.theme].getThemedColor("color-text-primary");
      }
      async getImage() {
        const e = this._pixelRatio;
        let t = 0;
        let i = 0;
        let s = 0;
        const o = this._headerItems();
        if (o.length > 0) {
          s = Math.ceil(this._options.fontSize * 1.4 * e) * o.length;
        }
        i += s;
        let n = 0;
        let r = 0;
        for (const e of this._chartsGeometry) {
          n = Math.max(n, e.x + e.width);
          r = Math.max(r, e.y + e.height);
        }
        const a = i;
        t += n;
        i += r;
        t += Math.round(e * 10);
        const l = eg ? Math.round(e * 10) : Math.round(e * 35);
        const c = i;
        i += l;
        const h = (0, Wt.createDisconnectedCanvas)(document, (0, Dt.size)({
          width: t,
          height: i
        }), 1);
        const d = (0, Wt.getContext2D)(h);
        d.font = (0, Yt.makeFont)(this._options.fontSize, this._options.font);
        d.textBaseline = "top";
        d.fillStyle = this._options.backgroundColor;
        d.fillRect(0, 0, t, i);
        if (o.length > 0) {
          this._drawHeader(d, o, t, new At.Point(Math.round(e * 10), Math.round(e * 10)));
        }
        for (let e = 0; e < this._snapshotData.charts.length; ++e) {
          const t = this._snapshotData.charts[e];
          const i = this._chartsGeometry[e];
          this._drawChart(t, i, d, new At.Point(0, a));
        }
        if (this._logoTextColor !== null) {
          const t = await ng(Math.round(e * 20), Math.round(e * 15), this._logoTextColor);
          d.fillStyle = this._logoTextColor;
          d.font = (0, Yt.makeFont)(13, g.CHART_FONT_FAMILY);
          const i = c + Math.round(l / 2 - t.height / 2);
          rg(d, Math.round(e * 10), i, t, e);
        }
        return h;
      }
      _drawChart(e, t, i, s) {
        i.save();
        i.translate(t.x + s.x, t.y + s.y);
        let o = 0;
        for (const t of e.panes) {
          let s = 0;
          const n = t.leftAxis.canvas.width + Math.round(this._pixelRatio * 8);
          const r = o;
          const a = o + Math.round(this._pixelRatio * 10);
          if (t.leftAxis.contentWidth > 0 && t.leftAxis.contentHeight > 0) {
            i.drawImage(t.leftAxis.canvas, s, o);
            s += t.leftAxis.canvas.width;
          }
          i.drawImage(t.canvas, s, o);
          s += t.canvas.width;
          if (t.rightAxis.contentWidth > 0 && t.rightAxis.contentHeight > 0) {
            i.drawImage(t.rightAxis.canvas, s, o);
          }
          if (t.type === "pane") {
            i.fillStyle = e.colors.text;
            this._drawLegend(t, i, new At.Point(n, a), r);
          }
          o += t.canvas.height;
        }
        if (e.timeAxis !== undefined && e.timeAxis.contentHeight !== 0) {
          let t = 0;
          if (e.timeAxis.lhsStub.contentWidth > 0 && e.timeAxis.lhsStub.contentHeight > 0) {
            i.drawImage(e.timeAxis.lhsStub.canvas, t, o);
            t += e.timeAxis.lhsStub.canvas.width;
          }
          i.drawImage(e.timeAxis.canvas, t, o);
          t += e.timeAxis.canvas.width;
          if (e.timeAxis.rhsStub.contentWidth > 0 && e.timeAxis.rhsStub.contentHeight > 0) {
            i.drawImage(e.timeAxis.rhsStub.canvas, t, o);
          }
        }
        i.strokeStyle = this._options.borderColor;
        i.strokeRect(0, 0, t.width, t.height);
        i.restore();
      }
      _headerItems() {
        const e = [];
        if (this._options.showHeaderPublishedBy && this._snapshotData.publishedBy) {
          for (const t of this._snapshotData.publishedBy) {
            e.push([{
              text: t
            }]);
          }
        }
        if (this._options.showHeaderMainSymbol) {
          const t = this._snapshotData.charts[0];
          const i = `${t.meta?.symbol}, ${t.meta?.resolution}`;
          e.push(hg(i, t.meta?.values ?? []));
        }
        return e;
      }
      _drawHeader(e, t, i, s) {
        e.save();
        e.fillStyle = this._headerDefaultTextColor;
        const o = Math.ceil(this._options.fontSize * 1.4 * this._pixelRatio);
        t.forEach((t, n) => {
          lg(e, this._pixelRatio, new At.Point(s.x, s.y + o * n), i, t, true);
        });
        e.restore();
      }
      _drawLegend(e, t, i, s) {
        let o = true;
        const r = Math.ceil(this._options.fontSize * 1.4 * this._pixelRatio);
        let a = i.x;
        let l = i.y;
        if (e.mainSeriesText && l + r < s + e.canvas.height) {
          const i = lg(t, this._pixelRatio, new At.Point(a, l), e.contentWidth * this._pixelRatio, hg(e.mainSeriesText, e.mainSeriesValues), true);
          if (this._options.legendMode !== "horizontal") {
            l += r;
          } else {
            a = (0, n.ensureNotNull)(i) + this._options.fontSize * 1.4 * this._pixelRatio;
            o = false;
          }
        }
        for (let n = 0; n < e.studies.length; ++n) {
          if (l + r < s + e.canvas.height) {
            const s = e.studies[n];
            const c = e.studiesValues[n];
            let h = null;
            while (h === null) {
              h = lg(t, this._pixelRatio, new At.Point(a, l), e.contentWidth * this._pixelRatio, this._options.hideStudiesFromLegend ? [] : hg(s, cg(c)), o);
              if (this._options.legendMode !== "horizontal") {
                l += r;
              } else if (h === null) {
                o = true;
                a = i.x;
                l += r;
              } else {
                a = h + this._options.fontSize * 1.4 * this._pixelRatio;
                o = false;
              }
            }
          }
        }
      }
    }
    var ug = i(18832);
    var _g = i(63844);
    function pg(e) {
      return `chart-widget-collection-border-${e}`;
    }
    const mg = new Di.TranslatedString("resize layout", cm.t(null, undefined, i(47418)));
    const gg = new Di.TranslatedString("reset layout sizes", cm.t(null, undefined, i(85366)));
    var fg;
    function yg(e, t) {
      return e.selected === t.selected && e.withShift === t.withShift;
    }
    (function (e) {
      e[e.EDGE = 0] = "EDGE";
      e[e.BORDER = 0] = "BORDER";
      e[e.PADDING = 2] = "PADDING";
    })(fg ||= {});
    class vg {
      constructor(e) {
        this._selected = new ht.WatchedObject({
          selected: false,
          withShift: false
        }, yg);
        this._onShiftPressed = e => {
          const t = this._state.currentLayoutResizeAction.value();
          if (t) {
            this._applyMouseMove(t.delta, e);
          }
        };
        this._state = e.state;
        this._splitterElement = e.splitterElement;
        this._splitter = e.splitter;
        this._computeContentBox = e.computeContentBox;
        (0, Gs.shiftPressed)().subscribe(this._onShiftPressed);
        this._selected.subscribe(e => {
          if (e.selected) {
            const t = pg(this._splitter.className);
            Array.from(this._state.parent.getElementsByClassName(t)).forEach(e => e.classList.remove(_g.hovered));
            (e.withShift ? Array.from(this._state.parent.getElementsByClassName(t)) : [this._splitterElement]).forEach(e => e.classList.add(_g.hovered));
          } else {
            const e = pg(this._splitter.className);
            Array.from(this._state.parent.getElementsByClassName(e)).forEach(e => e.classList.remove(_g.hovered));
          }
        });
      }
      destroy() {
        (0, Gs.shiftPressed)().unsubscribe(this._onShiftPressed);
      }
      mouseDownEvent(e) {
        this._mouseDownOrTouchStartEvent(e);
      }
      touchStartEvent(e) {
        if (this._selected.value().selected) {
          this._mouseDownOrTouchStartEvent(e);
        }
      }
      pressedMouseMoveEvent(e) {
        this._pressedMouseOrTouchMoveEvent(e);
      }
      touchMoveEvent(e) {
        if (this._selected.value().selected) {
          this._pressedMouseOrTouchMoveEvent(e);
        }
      }
      mouseUpEvent(e) {
        this._mouseUpOrTouchEndEvent(e);
      }
      touchEndEvent(e) {
        this._mouseUpOrTouchEndEvent(e);
      }
      mouseEnterEvent(e) {
        this._selected.setValue({
          selected: true,
          withShift: e.shiftKey
        });
      }
      mouseLeaveEvent() {
        this._selected.setValue({
          selected: false,
          withShift: false
        });
      }
      mouseDoubleClickEvent(e) {
        this._resetLayoutSizes();
      }
      doubleTapEvent() {
        this._resetLayoutSizes();
      }
      tapEvent(e) {
        this._selected.setValue({
          selected: !this._selected.value().selected,
          withShift: e.shiftKey
        });
      }
      touchStartOutsideEvent(e) {
        this._selected.setValue({
          selected: false,
          withShift: false
        });
      }
      _mouseDownOrTouchStartEvent(e) {
        const t = new At.Point(e.localX + this._splitterElement.offsetLeft, e.localY + this._splitterElement.offsetTop);
        const i = (0, ug.deepCopy)(this._state.sizingState.value());
        this._state.currentLayoutResizeAction.setValue({
          point: t,
          splitter: this._splitter,
          initialState: i,
          alignedState: this._state.layoutTemplate.value().syncSublayoutsBySplitter(this._splitter, (0, ug.deepCopy)(i)),
          shiftState: e.shiftKey,
          delta: 0
        });
        this._selected.setValue({
          selected: true,
          withShift: e.shiftKey
        });
      }
      _pressedMouseOrTouchMoveEvent(e) {
        const t = this._state.currentLayoutResizeAction.value();
        if (!t) {
          return;
        }
        if (t.shiftState !== e.shiftKey) {
          this._selected.setValue({
            selected: true,
            withShift: e.shiftKey
          });
          t.shiftState = e.shiftKey;
        }
        const i = new At.Point(e.localX + this._splitterElement.offsetLeft, e.localY + this._splitterElement.offsetTop);
        t.delta = t.splitter.orientation === "v" ? i.y - t.point.y : i.x - t.point.x;
        this._applyMouseMove(t.delta, e.shiftKey);
      }
      _mouseUpOrTouchEndEvent(e) {
        const t = this._state.currentLayoutResizeAction.value();
        if (t && (this._splitterElement.classList.remove(_g["i-active"]), this._state.currentLayoutResizeAction.setValue(null), t.currentState)) {
          this._state.undoHistory.beginUndoMacro(mg);
          this._state.undoHistory.pushUndoCommand(new rt(this._state.sizingState, t.initialState, t.currentState, mg));
          const e = this._state.layoutTemplate.value().layoutType;
          this._state.undoHistory.pushUndoCommand(new nt(t => t ? this._state.allLayoutSizesState.set(e, t) : this._state.allLayoutSizesState.delete(e), this._state.allLayoutSizesState.get(this._state.layoutTemplate.value().layoutType), this._state.sizingState.value(), gg));
          this._state.undoHistory.endUndoMacro();
          this._state.layoutSizesChanged.setValue(true);
        }
      }
      _applyMouseMove(e, t) {
        const i = (0, n.ensureNotNull)(this._state.currentLayoutResizeAction.value());
        const s = t ? i.alignedState : i.initialState;
        const o = this._state.options.padding ?? 2;
        const r = this._computeContentBox();
        i.currentState = this._state.layoutTemplate.value().resizeApplier(r, o, e, i.splitter, (0, ug.deepCopy)(s), t);
        this._state.sizingState.setValue(i.currentState);
      }
      _resetLayoutSizes(e) {
        const t = (0, $i.layoutInitialSizingState)(this._state.layoutTemplate.value().expression);
        const i = this._state.layoutTemplate.value().layoutType;
        const s = e => e ? this._state.allLayoutSizesState.set(i, e) : this._state.allLayoutSizesState.delete(i);
        if (e) {
          this._state.sizingState.setValue(t);
          s(t);
          return;
        }
        this._state.undoHistory.beginUndoMacro(gg);
        this._state.undoHistory.pushUndoCommand(new rt(this._state.sizingState, this._state.sizingState.value(), t, gg));
        this._state.undoHistory.pushUndoCommand(new nt(s, this._state.allLayoutSizesState.get(this._state.layoutTemplate.value().layoutType), t, gg));
        this._state.undoHistory.endUndoMacro();
      }
    }
    const Sg = (0, ae.getLogger)("Chart.ChartWidgetCollection");
    a.t(null, undefined, i(40947));
    a.t(null, undefined, i(55801));
    a.t(null, undefined, i(32482));
    const bg = function (e, t) {
      const i = t.model().model().studyTemplate();
      e.undoHistory.beginUndoMacro(ss);
      for (let s = 0; s < e.chartWidgetsDefs.length; s++) {
        const o = e.chartWidgetsDefs[s].chartWidget;
        if (o !== t) {
          if (o.hasModel()) {
            o.model().applyStudyTemplate(i, "");
          }
        }
      }
      e.undoHistory.endUndoMacro();
    };
    const wg = async function (e, t, i, s, o) {
      e.undoHistory.beginUndoMacro(o);
      for (let r = 0; r < e.chartWidgetsDefs.length; r++) {
        const a = e.chartWidgetsDefs[r].chartWidget;
        if (a !== t && a && a.hasModel()) {
          const t = a.model();
          if (!us(i, t)) {
            continue;
          }
          let r;
          if (s.isOnMainPane) {
            r = (0, n.ensureNotNull)(t.model().paneForSource(a.model().model().mainSeries()));
          } else {
            const i = new Vi(t.model(), s.paneIndex);
            e.undoHistory.pushUndoCommand(i);
            const o = (0, n.ensureDefined)(i.createdPaneId());
            r = (0, n.ensureDefined)(t.model().panes().find(e => e.id() === o));
          }
          const l = await t.pasteSourceFromClip(r, i, true);
          if (l && l.length === 1) {
            const e = l[0];
            if (s.asCompare) {
              const i = (0, n.ensureNotNull)(t.mainSeries().priceScale());
              t.moveToScale(e, (0, n.ensureDefined)(r), i, o);
              t.setPriceScaleMode({
                percentage: true
              }, i, null);
            }
          }
          t.model().lightUpdate();
        }
      }
      e.undoHistory.endUndoMacro();
    };
    const Cg = function (e, t, i, s) {
      const o = e.map(e => e.chartWidget).filter(e => e.hasModel()).filter(e => e.id() === t || s !== 0);
      try {
        o.forEach(e => e.startApplyingLineToolUpdateNotification());
        o.forEach(e => e.applyLineToolUpdateNotification(i, s));
      } finally {
        o.forEach(e => e.endApplyingLineToolUpdateNotification());
      }
    };
    const Pg = function (e) {
      return new qi({
        copyRequested: (t, i) => {
          e.activeChartWidget.value().model().clipboardCopy(t, i);
        },
        cutRequested: (t, i) => {
          e.activeChartWidget.value().model().clipboardCut(t, i);
        },
        pasteRequested: (t, i) => {
          if (i?.mode() === Bi.PaneMode.Widget) {
            return;
          }
          (i ? i.model().undoModel() : e.activeChartWidget.value().model()).clipboardPaste(t, i);
        }
      });
    };
    const Tg = function (e) {
      const t = {};
      e.chartWidgetsDefs.map(e => e.chartWidget).forEach(e => t[e.id()] = function (e) {
        const t = {};
        if (!e.hasModel()) {
          const i = e.options().content;
          if (!i) {
            return t;
          }
          const s = (0, n.ensureNotNull)(i.panes.reduce((e, t) => e ?? t.sources.find(e => e.type === "MainSeries") ?? null, null));
          t.resolution = s.state?.interval;
          t.symbol = s.state?.symbol;
          t.short_name = s.state?.shortName;
          return t;
        }
        const i = e.model().mainSeries();
        const s = i.properties().childs();
        const o = i.symbolInfo();
        t.resolution = s.interval.value();
        t.symbol_type = o !== null && o.type || "";
        t.exchange = o !== null && o.exchange || "";
        t.listed_exchange = o !== null && o.listed_exchange || "";
        const r = o?.legs ?? [];
        if (o !== null && i.isSpread()) {
          const e = r[0];
          let i = o.base_name[0];
          i = i.split(":")[1];
          t.symbol = e;
          t.short_name = i;
          t.expression = o.full_name;
        } else {
          t.symbol = o !== null && o.ticker || s.symbol.value();
          t.short_name = s.shortName.value();
        }
        const a = o?.base_name ?? [];
        t.legs = r.map((e, t) => ({
          symbol: e,
          pro_symbol: a[t]
        }));
        return t;
      }(e));
      return t;
    };
    const xg = function (e, t, i) {
      const s = e.chartWidgetsDefs.slice(0, e.layoutTemplate.value().count).map((t, i, s) => ({
        def: t,
        metrics: e.layoutTemplate.value().sizer({
          top: 0,
          left: 0,
          width: 256,
          height: 256
        }, i, s.length, 0)
      })).sort((e, t) => e.metrics.top - t.metrics.top || e.metrics.left - t.metrics.left).map(e => e.def);
      if (s.length < 2) {
        return null;
      }
      let o = s.indexOf(t);
      if (o === -1) {
        return null;
      } else {
        o = (o + (i ? s.length - 1 : 1)) % s.length;
        return s[o];
      }
    };
    const Ig = function (e) {
      let t = 1;
      while (e("" + t)) {
        t++;
      }
      return "" + t;
    };
    const Mg = function (e, t, i, s) {
      if (gs(e, t, i, s)) {
        const i = e.crossHairSyncBroadcast;
        if (i) {
          const e = {
            type: "crosshair",
            payload: {
              point: t,
              envState: s,
              sourceUniqueId: i.uniqueId
            }
          };
          i.channel.postMessage(e);
        }
      }
    };
    const Ag = function (e) {
      e.crossHairSyncBroadcast?.channel.close();
    };
    const Lg = function (e, t, i) {
      if (!e.combinedTrackTimeLock.value() || e.dateRangeLock.value()) {
        return;
      }
      const s = e.layoutTemplate.value().count;
      e.undoHistory.beginUndoMacro(os);
      e.chartWidgetsDefs.slice(0, s).filter(e => e.chartWidget.hasModel() && e.chartWidget.model().model() !== i).forEach(e => {
        const i = e.chartWidget.model().model();
        const s = i.mainSeries().syncModel();
        if (s) {
          i.syncTimeWithModel(s.syncSourceTarget(), t);
        }
      });
      e.undoHistory.endUndoMacro();
      (0, W.emit)("sync_time", t);
    };
    const kg = function e(t) {
      if (t.chartWidgetsDefs.every(e => e.chartWidget.hasModel())) {
        return Promise.resolve(t.chartWidgetsDefs.map(e => e.chartWidget));
      } else {
        return Promise.all(t.chartWidgetsDefs.map(e => e.chartWidget.hasModel() || Ei(e.chartWidget.modelCreated()).promise)).then(() => e(t));
      }
    };
    const Dg = function (e) {
      return Promise.all(e.map(e => {
        const t = e.model().mainSeries();
        if (t.symbolResolvingActive().value()) {
          return Ei(t.dataEvents().symbolResolved()).promise;
        } else {
          return t.symbolInfo();
        }
      }));
    };
    const Eg = async function (e, t, i) {
      const {
        theme: s,
        onlyActiveChart: o,
        restoreNonThemeDefaults: n,
        themeName: r,
        standardTheme: a,
        syncState: l = true,
        noUndo: c
      } = i;
      const h = (0, k.getCurrentTheme)().name;
      let d;
      if (o) {
        d = [e.activeChartWidget.value()];
      } else {
        await Promise.all(e.savedChartWidgetOptions.map((e, t) => t).map(t => new Promise(i => {
          const s = function (e, t, i) {
            return e.addNewChartWidget(t, i);
          }(e, t, i);
          e.hideChart(s);
        })));
        d = e.chartWidgetsDefs.map(e => e.chartWidget);
      }
      if (c) {
        if (a) {
          new Xi(h, r, l).redo();
        }
        d.forEach(e => {
          e.model().model().restoreTheme(s, n, c);
        });
      } else {
        e.undoHistory.beginUndoMacro(rs);
        if (a) {
          e.undoHistory.pushUndoCommand(new Xi(h, r, l));
        }
        d.forEach(e => {
          e.model().model().restoreTheme(s, n);
        });
        e.undoHistory.endUndoMacro();
      }
      await Promise.all(d.map(e => e.model().model().colorStudiesPropertiesReady()));
    };
    const Bg = function (e, t) {
      const {
        internalDateRangeLock: i,
        undoHistory: s,
        loadingContent: o
      } = e;
      if (o) {
        i.setValue(t);
      } else {
        s.setWatchedValue(i, t, cs);
      }
    };
    const Vg = function (e, t) {
      const i = e.activeChartWidget.value();
      if (i && i.hasModel()) {
        const s = i.model();
        if (t) {
          e.subscribeToEventsForDateRangeSync(s);
          e.syncChartsDateRangesWithActiveChartRange(i);
        } else {
          e.unsubscribeFromEventsForDateRangeSync(s);
        }
      }
      e.dateRangeLock.setValue(t);
    };
    const Rg = function (e, t) {
      const {
        internalTrackTimeLock: i,
        undoHistory: s,
        loadingContent: o
      } = e;
      if (o) {
        i.setValue(t);
      } else {
        s.setWatchedValue(i, t, hs);
      }
    };
    const Ng = function (e, t) {
      e.trackTimeLock.setValue(t);
    };
    const Og = function (e, t) {
      const {
        internalIntervalLock: i,
        activeChartWidget: s,
        undoHistory: o,
        dateRangeLock: n,
        loadingContent: r,
        chartWidgetsDefs: a,
        linkingGroupsCharts: l
      } = e;
      if (t !== i.value()) {
        if (r) {
          i.setValue(t);
        } else {
          o.beginUndoMacro(ls);
          if (t && t) {
            const t = s.value();
            a.map(e => e.chartWidget);
            l.forEach((i, s) => {
              t.linkingGroupIndex().value();
              const o = t;
              if (o !== undefined) {
                (0, ki.muteLinkingGroup)(s, true);
                for (const t of i.value()) {
                  if (t !== o && t.resolutionWV().value() !== o.resolutionWV().value()) {
                    t.setResolution(o.resolutionWV().value());
                    if (n.value()) {
                      e.subscribeToCompletedEventForDateRangeSync(t, true);
                    }
                  }
                }
                (0, ki.muteLinkingGroup)(s, false);
              }
            });
          }
          o.setWatchedValue(i, t, ls);
          o.endUndoMacro();
        }
      }
    };
    const Fg = function (e, t) {
      e.intervalLock.setValue(t);
    };
    const Wg = function (e, t) {
      const {
        internalSymbolLock: i,
        activeChartWidget: s,
        undoHistory: o,
        dateRangeLock: n,
        loadingContent: r,
        linkingGroupsCharts: a,
        chartWidgetsDefs: l
      } = e;
      if (t !== i.value()) {
        if (r) {
          i.setValue(t);
        } else {
          e.undoHistory.beginUndoMacro(as);
          if (t) {
            const t = s.value();
            l.map(e => e.chartWidget);
            a.forEach((i, s) => {
              t.linkingGroupIndex().value();
              const o = t;
              if (o !== undefined) {
                (0, ki.muteLinkingGroup)(s, true);
                for (const t of i.value()) {
                  if (t !== o && t.symbolWV().value() !== o.symbolWV().value()) {
                    t.setSymbol(o.symbolWV().value());
                    if (n.value()) {
                      e.subscribeToCompletedEventForDateRangeSync(t, true);
                    }
                  }
                }
                (0, ki.muteLinkingGroup)(s, false);
              }
            });
          }
          o.setWatchedValue(i, t, as);
          o.endUndoMacro();
        }
      }
    };
    const Hg = function (e, t) {
      e.symbolLock.setValue(t);
    };
    const zg = function (e, t, i, s) {
      let o = 0;
      const n = (0, Qi.createWVFromGetterAndSubscriptions)(() => ++o, [i, s]);
      return (0, Ji.combine)(t => e()[ms[t]] ?? null, t.weakReference(), n.ownership());
    };
    const Ug = function (e, t) {
      t.timeScale().visibleBarsStrictRangeChanged().subscribe(Ps(t), ws.bind(null, e));
    };
    const jg = function (e, t) {
      t.timeScale().visibleBarsStrictRangeChanged().unsubscribeAll(Ps(t));
      e.chartWidgetIdToCompletedCallbackMap.forEach(e => {
        const t = e.cw;
        const i = e.callback;
        t.model().mainSeries().dataEvents().completed().unsubscribe(null, i);
      });
      e.chartWidgetIdToCompletedCallbackMap.clear();
    };
    const Gg = function (e, t) {
      (function (e, t) {
        const i = (0, $i.layoutInitialSizingState)(e.layoutTemplate.value().expression);
        const s = e.layoutTemplate.value().layoutType;
        const o = t => t ? e.allLayoutSizesState.set(s, t) : e.allLayoutSizesState.delete(s);
        if (t) {
          e.sizingState.setValue(i);
          o(i);
          return;
        }
        e.undoHistory.beginUndoMacro(ns);
        e.undoHistory.pushUndoCommand(new rt(e.sizingState, e.sizingState.value(), i, ns));
        e.undoHistory.pushUndoCommand(new nt(o, e.allLayoutSizesState.get(e.layoutTemplate.value().layoutType), i, ns));
        e.undoHistory.endUndoMacro();
      })(e, t);
    };
    const qg = function (e) {
      is.StudyMetaInfo.mergeDefaultsOverrides(e);
      if ((0, ts.studyMetaInfoRepository)().isReady()) {
        is.StudyMetaInfo.overrideDefaults((0, ts.studyMetaInfoRepository)().getInternalMetaInfoArray());
      }
    };
    const $g = new Map();
    var Kg;
    function Yg(e) {
      if (e.value()) {
        return 1;
      } else {
        return 0;
      }
    }
    (function (e) {
      e[e.EDGE = 0] = "EDGE";
      e[e.BORDER = 0] = "BORDER";
      e[e.PADDING = 2] = "PADDING";
    })(Kg ||= {});
    const Zg = {
      saveChartEnabled: true,
      takeScreenshotEnabled: true,
      publishedChartsEnabled: true
    };
    class Xg {
      constructor(e) {
        this.activeChartStyle = new F.WatchedValue();
        this.activeChartWidget = new F.WatchedValue();
        this.onAboutToBeDestroyed = new re.Delegate();
        this.clientId = (0, fe.randomHash)();
        this._destroyed = false;
        this._chartWidgetsDefs = [];
        this._activeIndex = 0;
        this._globalDetachable = new F.WatchedValue();
        this._layoutTemplate = new F.WatchedValue();
        this._layoutType = "s";
        this._layoutWV = new F.WatchedValue(this._layoutType);
        this._currentLayoutResizeAction = new F.WatchedValue(null);
        this._inlineChartsCount = new F.WatchedValue();
        this._selectedSources = new F.WatchedValue([]);
        this._lineToolsSynchronizerHasChanges = new F.WatchedValue(false);
        this._viewMode = new F.WatchedValue(undefined);
        this._allLayoutSizesState = new Map();
        this._splitters = new F.WatchedValue([]);
        this._savedChartWidgetOptions = [];
        this._flags = {
          isConfirmationAboutReplayLocked: false,
          loadingChart: false,
          setTimeFrameActive: false,
          setNewResolution: false
        };
        this._loadingContent = false;
        this._initialLoading = false;
        this._isPhoneSize = new F.WatchedValue(false);
        this._sizingState = new F.WatchedValue();
        this._layoutSizesChangedWV = new F.WatchedValue(false);
        this._symbolLock = new F.WatchedValue(false);
        this._internalSymbolLock = new F.WatchedValue(this._symbolLock.value());
        this._intervalLock = new F.WatchedValue(false);
        this._internalIntervalLock = new F.WatchedValue(this._intervalLock.value());
        this._trackTimeLock = new F.WatchedValue(false);
        this._combinedTrackTimeLock = bs(this._layoutWV, this._trackTimeLock, this._chartWidgetsDefs);
        this._internalTrackTimeLock = new F.WatchedValue(this._combinedTrackTimeLock.value());
        this._dateRangeLock = new F.WatchedValue(false);
        this._internalDateRangeLock = new F.WatchedValue(this._dateRangeLock.value());
        this._crosshairLock = new F.WatchedValue(d.getBool("chart.syncCrosshair", true));
        this._activeChartCanBeMoved = new F.WatchedValue(false);
        this._symbolLockSpawn = this._symbolLock.spawn();
        this._intervalLockSpawn = this._intervalLock.spawn();
        this._dateRangeLockSpawn = this._dateRangeLock.spawn();
        this._trackTimeLockSpawn = this._trackTimeLock.spawn();
        this._crosshairLockSpawn = this._crosshairLock.spawn();
        this._hotkeys = (0, B.createGroup)({
          desc: "Layout"
        });
        this._saveChartService = null;
        this._chartStorageNotification = null;
        this._newsNotifier = null;
        this._crossHairSyncBroadcast = null;
        this._crossHairSyncEnabledSubscriptionId = null;
        this._maximizedChartDef = new F.WatchedValue(null);
        this._maximizedChart = new F.WatchedValue(null);
        this._chartWidgetCreatedDelegate = new re.Delegate();
        this._onZoom = new re.Delegate();
        this._onScroll = new re.Delegate();
        this._bottomToolbar = new F.WatchedValue(null);
        this._bottomToolbarWidget = null;
        this._bottomToolbarDestroyer = null;
        this._linkingGroupsCharts = new Map();
        this._chartModels = new ht.WatchedObject([], ft.compareTwoCollectionsByIds);
        this._customLegendWidgetsFactoriesMap = new Map();
        this._customSources = new Map();
        this._replayContainer = null;
        this._prevMaximizedChartDef = null;
        this._phoneStates = [];
        this._chartsSwappedDelegate = new re.Delegate();
        this._saveKeysPressedDelegate = new re.Delegate();
        this._subscribedChartWidget = null;
        this._tool = lt.tool.spawn();
        this._hasChanges = new F.WatchedValue(false);
        this._hasChangesSpawn = null;
        this._pendingSetSymbolCancellationToken = {
          cancelled: true
        };
        this._onResizeActionChanged = e => {
          if (this._dateRangeLock.value() && e === null) {
            this._syncChartsDateRangesWithActiveChartRange();
          }
        };
        this._recalcHasChanges = () => {
          this._lineToolsSynchronizerHasChanges.setValue(this._chartWidgetsDefs.some(e => {
            const t = e.chartWidget.lineToolsSynchronizer();
            return t !== null && t.hasChanges().value();
          }));
        };
        this._updateLinkingGroupCharts = () => {
          (function (e) {
            const t = new Map();
            for (const i of e.chartWidgetsDefs) {
              const e = null;
              let s = t.get(e);
              if (s === undefined) {
                s = [];
                t.set(e, s);
              }
              s.push(i.chartWidget);
            }
            for (const i of (0, ft.join)(new Set(e.linkingGroupsCharts.keys()), new Set(t.keys()))) {
              Ss(e, i).setValue(t.get(i) ?? []);
            }
          })(this._stateImpl());
        };
        this._handlePhoneSize = (e, t) => {
          0;
        };
        this._handlePhoneForceFullscreen = () => {
          if (!window.is_authenticated) {
            return;
          }
          const e = (0, l.enabled)("app_phone");
          if (!(0, l.enabled)("app_tablet") && (e || this._isPhoneSize.value())) {
            if (this._viewMode.value() === CollectionViewMode.ForceFullscreen) {
              this._prevMaximizedChartDef = this._maximizedChartDef.value();
              this.activeChartWidget.value().requestFullscreen();
            }
          } else if (!this._prevMaximizedChartDef) {
            this._setMaximized(null);
            this._updateViewMode();
          }
        };
        this._updateActiveChartCanBeMoved = () => { };
        this._updateLayout = () => {
          let e;
          const t = this._layoutTemplate.value();
          const i = this._maximizedChartDef.value();
          e = i ? [i] : this._chartWidgetsDefs.slice(0, t.count).filter(e => !e.hiddenInLayout.value());
          e.forEach((t, i) => this._updateLayoutPartial(t, i, e.length));
          if (!this._maximizedChartDef.value()) {
            const {
              padding: e = 2,
              border: i = 0
            } = this._options;
            const s = this._computeContentBox();
            const o = t.splitters(s, e + i, this._sizingState.value());
            const n = this._splitters.value() ?? [];
            n.forEach((e, t) => {
              if (t >= o.length) {
                e.splitterElement.remove();
                e.mouseHandler.destroy();
                e.mouseListener.destroy();
              }
            });
            const r = o.map((e, t) => {
              const i = t < n.length ? n[t].splitterElement : document.createElement("div");
              let s;
              let o;
              if (t < n.length) {
                s = n[t].mouseListener;
                o = n[t].mouseHandler;
              } else {
                s = new vg({
                  state: this._stateImpl(),
                  splitterElement: i,
                  splitter: e,
                  computeContentBox: this._computeContentBox.bind(this)
                });
                o = new Et.MouseEventHandler(i, s);
              }
              const r = e.metrics;
              const a = i.classList.contains(_g.hovered);
              const l = i.classList.contains(_g["i-active"]);
              i.className = "";
              i.classList.add(_g.chartsSplitter);
              i.classList.add(`chart-widget-collection-border-${e.className}`);
              if (a) {
                i.classList.add(_g.hovered);
              }
              if (l) {
                i.classList.add(_g["i-active"]);
              }
              i.style.left = r.left + "px";
              i.style.top = r.top + "px";
              i.style.width = r.width + "px";
              i.style.height = r.height + "px";
              i.setAttribute("aria-hidden", "true");
              if (e.orientation === "v") {
                i.style.cursor = "ns-resize";
              } else {
                i.style.cursor = "ew-resize";
              }
              this._parent.insertBefore(i, this._bottomToolbar.value());
              return {
                splitter: e,
                splitterElement: i,
                mouseHandler: o,
                mouseListener: s
              };
            });
            this._splitters.setValue(r);
          }
        };
        this.undoHistory = function (e) {
          const t = [];
          const i = new st();
          const s = new st();
          const o = {
            chartWidgetCollection: e
          };
          const r = new re.Delegate();
          function a(e) {
            if (t.length > 0) {
              t[t.length - 1].addCommand(e);
            } else {
              s.clear();
              const t = i.head();
              const o = t && t.text().originalText();
              if (t && t.canMerge(e)) {
                t.merge(e);
              } else {
                i.push(e);
              }
              const n = e.text().originalText();
              if (n !== "" && n !== o) {
                at.logNormal("DO: " + n);
              }
            }
            if (e.executeOnPush()) {
              e.redo(o);
            }
            if (!t.length) {
              r.fire(l());
            }
          }
          function l() {
            const e = i.head();
            const t = s.head();
            const o = e === undefined ? undefined : e.text();
            const n = t === undefined ? undefined : t.text();
            return {
              enableUndo: !i.isEmpty(),
              undoCommandCount: i.size(),
              undoText: o !== undefined ? o.translatedText() : o,
              enableRedo: !s.isEmpty(),
              redoCommandCount: s.size(),
              redoText: n !== undefined ? n.translatedText() : n,
              originalUndoText: o !== undefined ? o.originalText() : undefined,
              originalRedoText: n !== undefined ? n.originalText() : undefined
            };
          }
          return {
            beginUndoMacro: function (e) {
              const i = new ot(e);
              t.push(i);
              return i;
            },
            clearStack: function () {
              i.clear();
              s.clear();
              r.fire(l());
            },
            createUndoCheckpoint: function () {
              return {
                lastActualCommand: i.isEmpty() ? null : i.head()
              };
            },
            endUndoMacro: function () {
              const e = (0, n.ensureDefined)(t.pop());
              if (!e.isEmpty()) {
                a(e);
              }
            },
            pushUndoCommand: a,
            redo: function () {
              if (s.isEmpty()) {
                return false;
              }
              const e = s.pop();
              return !!e && (e.redo(o), i.push(e), at.logNormal("REDO: " + e.text().originalText()), r.fire(l()), true);
            },
            redoStack: function () {
              return s;
            },
            setWatchedValue: function (e, t, i, s) {
              const o = e.value();
              if (o !== t) {
                const n = new rt(e, o, t, i, !s);
                a(n);
                n.redo();
              }
            },
            undo: function () {
              if (i.isEmpty()) {
                return false;
              }
              const e = i.pop();
              return !!e && (e.undo(o), s.push(e), at.logNormal("UNDO: " + e.text().originalText()), r.fire(l()), true);
            },
            undoStack: function () {
              return i;
            },
            undoToCheckpoint: function (e) {
              while (!i.isEmpty() && e.lastActualCommand !== i.head()) {
                i.pop().undo(o);
              }
              s.clear();
              r.fire(l());
            },
            state: l,
            onChange: function () {
              return r;
            }
          };
        }(this);
        this._options = (0, Qe.default)({}, Zg, e);
        this._readOnly = this._options.readOnly || false;
        this.layout = this._layoutWV.readonly();
        this.selectedSources = this._selectedSources.readonly();
        this.inlineChartsCount = this._inlineChartsCount.readonly();
        this.lineToolsSynchronizerHasChanges = this._lineToolsSynchronizerHasChanges.readonly();
        this.viewMode = this._viewMode.readonly();
        this.lock = {
          symbol: this._symbolLockSpawn,
          interval: this._intervalLockSpawn,
          dateRange: this._dateRangeLockSpawn,
          crosshair: this._crosshairLockSpawn,
          trackTime: this._trackTimeLockSpawn
        };
        this._symbolLock.subscribe(e => Wg(this._stateImpl(), e));
        this._internalSymbolLock.subscribe(e => Hg(this._stateImpl(), e));
        this._intervalLock.subscribe(e => Og(this._stateImpl(), e));
        this._internalIntervalLock.subscribe(e => Fg(this._stateImpl(), e));
        this._trackTimeLock.subscribe(e => Rg(this._stateImpl(), e));
        this._internalTrackTimeLock.subscribe(e => Ng(this._stateImpl(), e));
        this._dateRangeLock.subscribe(e => Bg(this._stateImpl(), e));
        this._internalDateRangeLock.subscribe(e => Vg(this._stateImpl(), e));
        this._currentLayoutResizeAction.subscribe(this._onResizeActionChanged);
        this._crosshairLock.subscribe(e => {
          d.setValue("chart.syncCrosshair", e);
          for (let e = 0; e < this._chartWidgetsDefs.length; ++e) {
            const t = this._chartWidgetsDefs[e].chartWidget;
            if (t.hasModel()) {
              t.model().model().lightUpdate();
            }
          }
        });
        this._widthWV = this._options.resizerBridge.width;
        this._heightWV = this._options.resizerBridge.height;
        this._maximizedChartDef.subscribe(e => {
          this._maximizedChart.setValue(e === null ? null : e.chartWidget);
        });
        this._widgetOptions = this._options.widgetOptions || {};
        this.onWidget = !!this._widgetOptions.onWidget;
        const t = this._options.metaInfo || {};
        this.metaInfo = {
          id: new F.WatchedValue(t.id || null),
          name: new F.WatchedValue(t.name),
          description: new F.WatchedValue(t.description),
          username: new F.WatchedValue(t.username),
          uid: new F.WatchedValue(t.uid),
          lastModified: new F.WatchedValue(t.lastModified)
        };
        this.undoHistory.onChange().subscribe(null, e => {
          W.emit("undo_redo_state_changed", e);
        });
        this._parent = this._options.resizerBridge.container.value();
        this._parent.addEventListener("contextmenu", ut.preventDefaultForContextMenu);
        if (this._options.seriesControlBarEnabled) {
          this._createSeriesControlWidget();
        }
        this._chartPropertiesDialogRenderer = new mt(this);
        this._compareDialogRenderer = new gt(this);
        this._sizingState.subscribe(() => this._updateLayout());
        this._widthWV.subscribe(this._updateLayout);
        this._heightWV.subscribe(this._updateLayout);
        this._activeLinkingGroupWV = (this.activeChartWidget, new F.WatchedValue(null).spawn());
        this._allLinkingGroupsWV = function (e) {
          const t = new ht.WatchedObject((e.chartWidgetsDefs, [null]));
          const i = () => {
            t.setValue((e.chartWidgetsDefs, [null]));
          };
          e.chartWidgetsDefs.forEach(e => e.chartWidget.linkingGroupIndex().subscribe(i));
          const s = e => {
            e.linkingGroupIndex().subscribe(i);
            i();
          };
          e.chartWidgetCreatedDelegate.subscribe(null, s);
          return t.spawn(() => {
            e.chartWidgetsDefs.forEach(e => e.chartWidget.linkingGroupIndex().unsubscribe(i));
            e.chartWidgetCreatedDelegate.unsubscribe(null, s);
          });
        }(this._stateImpl());
        this.activeChartWidget.subscribe(e => {
          if (!e) {
            return;
          }
          let t = NaN;
          for (let i = this._chartWidgetsDefs.length; i--;) {
            if (this._chartWidgetsDefs[i].chartWidget === e) {
              t = i;
              break;
            }
          }
          if (!isFinite(t)) {
            throw new Error("Cannot make detached ChartWidget active");
          }
          if (this._activeIndex !== t) {
            if (this._maximizedChartDef.value()) {
              if (!this._isDetached(this._chartWidgetsDefs[t])) {
                this._maximizedChartDef.setValue(this._chartWidgetsDefs[t]);
              }
            }
            this._activeIndex = t;
            this._updateActivityView();
            for (let t = this._chartWidgetsDefs.length; t--;) {
              if (this._chartWidgetsDefs[t].chartWidget !== e) {
                this._chartWidgetsDefs[t].chartWidget.setActive(false);
              }
            }
            this._updateCrossHairPositionIfNeeded();
            e.setActive(true);
            lt.activePointSelectionMode.setValue(e.selectPointMode().value());
          }
          this._updateActiveChartCanBeMoved();
          this._subscribeToProperties(e);
        }, {
          callWithLast: true
        });
        if (!this._readOnly) {
          this._hotkeys.add({
            desc: "Switch active chart",
            hotkey: (0, l.enabled)("accessible_keyboard_shortcuts") ? B.Modifiers.Shift + 39 : 9,
            handler: () => this.switchChart(false)
          });
          this._hotkeys.add({
            desc: "Switch active chart",
            hotkey: (0, l.enabled)("accessible_keyboard_shortcuts") ? B.Modifiers.Shift + 37 : ct.Modifiers.Shift + 9,
            handler: () => this.switchChart(true)
          });
        }
        this._hotkeys.add({
          desc: "Fullscreen mode",
          hotkey: B.Modifiers.Shift + 70,
          isDisabled: (0, l.enabled)("widget") || !this.fullscreenable().value(),
          handler: () => {
            if (this.fullscreen().value()) {
              this.exitFullscreen();
            } else {
              this.startFullscreen();
            }
          }
        });
        if (this._options.takeScreenshotEnabled) {
          this._hotkeys.add({
            desc: "Screenshot server",
            hotkey: B.Modifiers.Alt + 83,
            handler: this.takeServerScreenshot.bind(this)
          });
          if (!(0, He.isOnMobileAppPage)("any")) {
            this._hotkeys.add({
              desc: "Download client screenshot",
              hotkey: B.Modifiers.Mod + B.Modifiers.Alt + 83,
              handler: _s.bind(this, this)
            });
            this._hotkeys.add({
              desc: "Copy client screenshot",
              hotkey: B.Modifiers.Mod + B.Modifiers.Shift + 83,
              handler: ps.bind(this, this)
            });
          }
        }
        if (this._options.saveChartEnabled) {
          this._hotkeys.add({
            desc: "Save Chart Layout",
            hotkey: B.Modifiers.Mod + 83,
            handler: () => this._saveKeysPressedDelegate.fire()
          });
        }
        this._clipboardHandler = Pg(this._stateImpl());
        this.clipboard = this._clipboardHandler;
        if (this._options.globalEvents) {
          this._clipboardHandler.listen();
        }
        this._leftBottomChartWidget = zg(this.getAll.bind(this), this._layoutWV.readonly(), this._chartsSwappedDelegate, this._chartWidgetCreatedDelegate);
        this.loadContent(this._options.content, true);
        this._layoutWV.subscribe(() => this._updateActivityView());
        this._inlineChartsCount.subscribe(this._updateActiveChartCanBeMoved);
        if (this._readOnly) {
          this._layoutWV.writeLock = true;
        }
        window.addEventListener("resize", this._updateLayout);
        let i = 0;
        const s = () => {
          --i;
          if (i === 0) {
            W.emitOnce("onChartReady");
          }
        };
        this._chartWidgetsDefs.forEach(e => {
          if (!e) {
            return;
          }
          i++;
          const t = e.chartWidget;
          t.withModel(null, () => {
            if (this._options.metaInfo) {
              t.model().model().setChartSaveTime(this._options.metaInfo.lastModified * 1000);
            }
            const e = t.model().mainSeries();
            if (e.bars().size() > 0 || e.isFailed()) {
              s();
            } else {
              const t = e.dataEvents();
              const i = () => {
                s();
                t.barReceived().unsubscribe(null, i);
                t.completed().unsubscribe(null, i);
                t.error().unsubscribe(null, i);
                t.unsupportedResolutionRequested().unsubscribe(null, i);
              };
              t.barReceived().subscribe(null, i);
              t.completed().subscribe(null, i);
              t.error().subscribe(null, i);
              t.unsupportedResolutionRequested().subscribe(null, i);
            }
          });
        });
        kg(this._stateImpl()).then(Dg).then(() => {
          if (window.saver && window.is_authenticated && this._options.widgetOptions.justCloned) {
            window.saver.saveChartSilently();
          }
        }).catch(Sg.logError.bind(Sg));
      }
      destroy() {
        this.onAboutToBeDestroyed.fire();
        this.setActive(false);
        this._bottomToolbarDestroyer?.();
        this._bottomToolbarDestroyer = null;
        this._symbolLockSpawn.destroy();
        this._intervalLockSpawn.destroy();
        this._trackTimeLockSpawn.destroy();
        this._dateRangeLockSpawn.destroy();
        this._combinedTrackTimeLock.destroy();
        this._crosshairLockSpawn.destroy();
        this._currentLayoutResizeAction.unsubscribe(this._onResizeActionChanged);
        this._chartWidgetsDefs.forEach(e => e.destroy());
        this._options.resizerBridge.remove();
        this._splitters.value().forEach(e => {
          e.mouseHandler.destroy();
          e.mouseListener.destroy();
        });
        window.removeEventListener("resize", this._updateLayout);
        this._tool.destroy();
        this._parent.remove();
        this._customSources.clear();
        this._customLegendWidgetsFactoriesMap.clear();
        this._hotkeys.destroy();
        if (this._chartStorageNotification) {
          this._chartStorageNotification.destroy();
        }
        if (this._clipboardHandler) {
          this._clipboardHandler.destroy();
        }
        if (this._newsNotifier) {
          this._newsNotifier.destroy();
        }
        this._activeLinkingGroupWV.destroy();
        this._allLinkingGroupsWV.destroy();
        if (window.TVD && this._crossHairSyncEnabledSubscriptionId !== null) {
          const e = window.TVD.crosshairSyncEnabled;
          if (e) {
            e.unsubscribe(this._crossHairSyncEnabledSubscriptionId);
          }
          Ag(this._stateImpl());
        }
        this._hasChangesSpawn?.destroy();
        this._leftBottomChartWidget.destroy();
        this._destroyed = true;
      }
      innerState() {
        return this._stateImpl();
      }
      getAll() {
        return this._chartWidgetsDefs.map(e => e.chartWidget);
      }
      maximizedChartWidget() {
        return this._maximizedChart.readonly();
      }
      leftBottomChartWidget() {
        return this._leftBottomChartWidget;
      }
      activeLinkingGroup() {
        return this._activeLinkingGroupWV;
      }
      allLinkingGroups() {
        return this._allLinkingGroupsWV;
      }
      linkingGroupsCharts(e) {
        return this._getLinkingGroupCharts(e).readonly();
      }
      async setLayout(e) {
        if (!((e = this._checkProFeature(e)) in Ct.layouts)) {
          e = "s";
        }
        const t = this._layoutType;
        const i = Ct.layouts[e].count;
        W.emit("layout_about_to_be_changed", e);
        (this._splitters.value() ?? []).forEach((e, t) => {
          e.splitterElement.remove();
          e.mouseHandler.destroy();
        });
        this._splitters.setValue([]);
        const s = Ct.layouts[e];
        this._layoutTemplate.setValue(s);
        const o = this._allLayoutSizesState.get(s.layoutType) ?? (0, $i.layoutInitialSizingState)(s.expression);
        this._allLayoutSizesState.set(s.layoutType, o);
        this._sizingState.setValue(o);
        const r = this._maximizedChartDef.value();
        if (t !== e && this._maximizedChartDef.value()) {
          this._maximizedChartDef.setValue(null);
        }
        if (r) {
          this.activeChartWidget.setValue((0, n.ensureNotNull)(r.chartWidget));
        }
        for (let e = 0; e < i || e < this._chartWidgetsDefs.length; e++) {
          let t;
          let s = this._chartWidgetsDefs[e];
          const o = e >= i;
          t = this._maximizedChartDef.value() ? this._maximizedChartDef.value() === s : e < i;
          if (t) {
            if (s) {
              this._parent.insertBefore(s.container.value(), this._bottomToolbar.value());
              s.hiddenInLayout.setValue(false);
              if (this._loadingContent) {
                const e = this._savedChartWidgetOptions.shift();
                if (e) {
                  await (0, n.ensureNotNull)(s.chartWidget).loadContent(e.content, this._initialLoading);
                }
              }
            } else {
              this._addNewChartWidget(e, undefined);
              s = this._chartWidgetsDefs[e];
            }
            s.container.value().classList.toggle("multiple", i > 1);
            s.fullscreen.setValue(this._maximizedChartDef.value() === s);
            s.collapsed.setValue(o);
          } else if (s) {
            this._hideChart(s);
            s.collapsed.setValue(o);
          }
        }
        this._sizingState.setValue(o);
        this._updateLayout();
        this._layoutWV.setValue(e);
        this._setLayoutType(e);
        this._updateWatchedValue();
        this._updateInlineChartsCount();
        this._checkAllPendingModelsAlreadyCreated();
        if (this._inlineChartsCount.value() < 1 && i > 0) {
          this._chartWidgetsDefs[i - 1].rdState.bridge().attach();
        }
      }
      setChartStyleToWidget(e, t) {
        return ys.call(this, e, t);
      }
      state(e, t, i, s, o) {
        let n = o ? this.getAll().indexOf(this.activeChartWidget.value()) : 0;
        const r = o ? n + 1 : this._chartsCountToSave();
        const a = [];
        for (; n < r; n++) {
          const o = this._getStateForChartImpl(n, e, t, i, s);
          if (o) {
            let e = o;
            0;
            a.push(e);
          }
        }
        const l = o ? undefined : Array.from(this._allLayoutSizesState.entries()).reduce((e, [t, i]) => {
          e[t] = i;
          return e;
        }, {});
        return {
          name: this.metaInfo.name.value(),
          layout: o ? "s" : this._layoutType,
          charts: a,
          symbolLock: Yg(this._symbolLock),
          intervalLock: Yg(this._intervalLock),
          trackTimeLock: Yg(this._trackTimeLock),
          dateRangeLock: Yg(this._dateRangeLock),
          crosshairLock: Yg(this._crosshairLock),
          layoutsSizes: l,
          studyMetaInfoMap: undefined
        };
      }
      applyLineToolUpdateNotification(e, t, i) {
        Cg.call(this, this._chartWidgetsDefs, e, t, i);
      }
      readOnly() {
        return this._readOnly;
      }
      onZoom() {
        return this._onZoom;
      }
      onScroll() {
        return this._onScroll;
      }
      resizerBridge() {
        return this._options.resizerBridge;
      }
      setSymbol(e, t, i) {
        return this._setSymbolImpl(e, t, i);
      }
      setSymbolAll(e) {
        const t = this._chartWidgetsDefs.map(e => e.chartWidget);
        return this._setSymbolImpl(e, undefined, undefined, t);
      }
      setResolution(e, t, i) {
        return vs(this._stateImpl(), e, t, i);
      }
      setTimeFrame(e) {
        if (!this._flags.loadingChart && !this._flags.setTimeFrameActive) {
          this._flags.setTimeFrameActive = true;
          if (this._intervalLock.value()) {
            this._chartWidgetsDefs.forEach(t => {
              t.chartWidget.loadRange(e);
            });
          } else {
            this.activeChartWidget.value().loadRange(e);
          }
          this._flags.setTimeFrameActive = false;
        }
      }
      setChartLayoutWithUndo(e) {
        return async function (e, t, i) {
          i = fs(0, i);
          return e.layoutWV.value() !== i && (e.undoHistory.pushUndoCommand(new Yi(t, i)), true);
        }(this._stateImpl(), this, e);
      }
      images(e) {
        const t = Math.max(1, window.devicePixelRatio || 1);
        const i = this.getAll();
        let s;
        const o = this.maximizedChartWidget().value();
        if (e && e.onlyActiveChart || o) {
          return {
            layout: "s",
            hidpiRatio: t,
            theme: (0, k.getCurrentTheme)().name,
            charts: [this.activeChartWidget.value().images(e)],
            publishedBy: s
          };
        }
        const n = [];
        const r = Ct.layouts[this.layout.value()].count;
        const a = {
          showCollapsedStudies: (e = e || {}).showCollapsedStudies,
          status: e.status
        };
        for (let e = 0; e < i.length && e < r; e++) {
          n.push(i[e].images(a));
        }
        return {
          layout: this.layout.value(),
          hidpiRatio: t,
          theme: (0, k.getCurrentTheme)().name,
          charts: n,
          publishedBy: s
        };
      }
      clientSnapshot(e = {}) {
        const t = {
          hideResolution: Boolean(e.hideResolution)
        };
        return async function (e, t) {
          return new dg(e, t).getImage();
        }(this.images({
          showCollapsedStudies: true,
          status: t
        }), e);
      }
      tags() {
        let e = [];
        for (let t = 0; t < this._chartWidgetsDefs.length && t < this._layoutTemplate.value().count; t++) {
          e = e.concat(this._chartWidgetsDefs[t].chartWidget.tags());
        }
        e = Array.from(new Set(e));
        e = e.map(e => e.toLowerCase().replace(/\W+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, ""));
        return e;
      }
      syncCrosshair(e, t, i) {
        Mg(this._stateImpl(), e, t, i);
      }
      syncScroll(e, t) {
        Lg(this._stateImpl(), e, t);
      }
      clearChartMetaInfo() {
        this.metaInfo.id.setValue(null);
        this.metaInfo.uid.setValue("");
        this.metaInfo.name.setValue("");
      }
      async takeScreenshot() {
        const e = {
          snapshotUrl: this._options.snapshotUrl
        };
        const t = await bt(this, e);
        W.emit("onScreenshotReady", t);
        return t;
      }
      async takeServerScreenshot() {
        const e = {
          snapshotUrl: this._options.snapshotUrl
        };
        const t = (0, He.isOnMobileAppPage)("any");
        const i = t ? bt : St;
        const s = await i(this, e);
        W.emit("onScreenshotReady", s);
        if (!t) {
          W.emit("onServerScreenshotCopiedToClipboard");
        }
        return s;
      }
      async loadLayoutState(e) {
        this.metaInfo.id.setValue(e.id);
        this.metaInfo.uid.setValue(e.uid);
        this.metaInfo.name.setValue(e.name);
        this.metaInfo.description.setValue(e.description);
        this.metaInfo.username.setValue(e.username);
        this.metaInfo.lastModified.setValue(e.lastModified);
        await this.loadContent(e.chartWidgetCollectionState);
        this.unloadUnusedCharts();
        this.undoHistory.clearStack();
        W.emit("layout_loaded");
      }
      saveLayoutState() {
        return new Promise((e, t) => {
          this._saveChartService?.saveChartOrShowTitleDialog(() => { }, e, t);
        });
      }
      async loadContent(e, t) {
        Sg.logNormal("Loading layout content");
        this.getAll().forEach(e => e.onAboutToLoadContent());
        this._loadingContent = true;
        this._initialLoading = Boolean(t);
        this._savedChartWidgetOptions.splice(0);
        lt.init();
        if (e) {
          const t = function (e) {
            return "charts" in e;
          }(e) ? e : {
            layout: "s",
            charts: [e],
            name: ""
          };
          if (t.layoutsSizes) {
            for (const e of Object.keys(t.layoutsSizes)) {
              this._allLayoutSizesState.set(e, t.layoutsSizes[e]);
            }
          }
          const i = new Set();
          t.charts.forEach(e => {
            if (e.chartId) {
              i.add(e.chartId);
            }
          });
          t.charts.forEach(e => {
            if (!e.chartId) {
              const t = Ig(e => i.has(e));
              i.add(t);
              e.chartId = t;
            }
          });
          let s = t.layout;
          if (!(0, Ct.isSupportedLayout)(s)) {
            const e = (0, Ct.tryGuessingTheMostSuitableLayout)(s);
            Sg.logError(`Loading unsupported layout ${s}. Force migration to ${e}`);
            s = e;
          }
          this._layoutType = this._checkProFeature(s || "s");
          for (const e of t.charts) {
            if ("studyMetaInfoMap" in t) {
              const i = t;
              e.panes.forEach(e => {
                e.sources.forEach(e => {
                  if ("metaInfo" in e && (0, et.default)(e.metaInfo)) {
                    e.metaInfo = (0, dt.clone)((0, n.ensureDefined)(i.studyMetaInfoMap)[e.metaInfo]);
                  }
                });
              });
            }
            this._savedChartWidgetOptions.push({
              content: e
            });
          }
          if (t.symbolLock !== undefined) {
            this._symbolLock.setValue(Boolean(t.symbolLock));
          }
          if (t.intervalLock !== undefined) {
            this._intervalLock.setValue(Boolean(t.intervalLock));
          }
          if (t.trackTimeLock !== undefined) {
            this._trackTimeLock.setValue(Boolean(t.trackTimeLock));
          }
          if (t.dateRangeLock !== undefined) {
            this._dateRangeLock.setValue(Boolean(t.dateRangeLock));
          }
          if (t.crosshairLock !== undefined) {
            this._crosshairLock.setValue(Boolean(t.crosshairLock));
          }
        }
        this._maximizedChartDef.setValue(null);
        await this.setLayout(this._layoutType);
        this._tool.subscribe(this._onToolChanged.bind(this));
        this._tool.subscribe(this._updateCrossHairPositionIfNeeded.bind(this));
        this._loadingContent = false;
        this._initialLoading = false;
      }
      applyOverrides(e) {
        for (let t = 0; t < this._chartWidgetsDefs.length; t++) {
          this._chartWidgetsDefs[t].chartWidget.applyOverrides(e);
        }
      }
      applyStudiesOverrides(e) {
        qg(e);
      }
      switchChart(e) {
        this.ariaDescribeChart(this.activeChartWidget.value());
      }
      startFullscreen() {
        this._options.resizerBridge.requestFullscreen();
      }
      exitFullscreen() {
        this._options.resizerBridge.exitFullscreen();
      }
      fullscreenable() {
        return this._options.resizerBridge.fullscreenable;
      }
      fullscreen() {
        return this.resizerBridge().fullscreen;
      }
      chartWidgetCreated() {
        return this._chartWidgetCreatedDelegate;
      }
      saveKeysPressed() {
        return this._saveKeysPressedDelegate;
      }
      getContainer() {
        return this._parent;
      }
      applyTheme(e) {
        return Eg(this._stateImpl(), this, e);
      }
      applyIndicatorsToAllCharts(e) {
        bg(this._stateImpl(), e);
      }
      applyIndicatorsToAllChartsAvailable() {
        return !this._readOnly && this._actualLayoutCount() > 1;
      }
      async applyIndicatorToAllCharts(e, t, i, s) {
        await wg(this._stateImpl(), e, t, i, s);
      }
      setActive(e) {
        if (this._chartWidgetsDefs.length !== 0) {
          for (let e = this._chartWidgetsDefs.length; e--;) {
            this._chartWidgetsDefs[e].chartWidget.setActive(false);
          }
          this._chartWidgetsDefs[this._activeIndex].chartWidget.setActive(e);
        }
      }
      revertToInline() {
        this._setMaximized(null);
        for (let e = 0; e < this._chartWidgetsDefs.length; e++) {
          this._chartWidgetsDefs[e].rdState.bridge().attach();
        }
      }
      hasChanges() {
        return this._hasChanges.readonly();
      }
      chartMarketStatuses() {
        return this._chartWidgetsDefs.map(e => "-");
      }
      chartSeriesStatuses() {
        return this._chartWidgetsDefs.map(e => {
          const t = e.chartWidget.hasModel() ? e.chartWidget.model().mainSeries().status() : null;
          return (t === null ? "" : _t.SERIES_STATUS_TEXT[t]) + " (" + t + ")";
        });
      }
      applyPreferencesToAllCharts(e) {
        0;
      }
      addCustomSource(e, t, i) {
        (0, n.assert)(!this._customSources.has(e), "Cannot create the same custom source multiple times");
        this._customSources.set(e, {
          factory: t,
          layer: i
        });
        for (let s = 0; s < this._chartWidgetsDefs.length; ++s) {
          const o = this._chartWidgetsDefs[s].chartWidget;
          if (o.hasModel()) {
            o.model().model().addCustomSource(e, t, i);
          }
        }
      }
      removeCustomSource(e) {
        (0, n.assert)(this._customSources.has(e), "Cannot remove not created custom source");
        this._customSources.delete(e);
        for (let t = 0; t < this._chartWidgetsDefs.length; ++t) {
          const i = this._chartWidgetsDefs[t].chartWidget;
          if (i.hasModel()) {
            i.model().model().removeCustomSource(e);
          }
        }
      }
      addCustomWidgetToLegend(e, t) {
        (0, n.assert)(!this._customLegendWidgetsFactoriesMap.has(e), "Cannot create the same custom widget in legend multiple times");
        this._customLegendWidgetsFactoriesMap.set(e, t);
        for (let i = 0; i < this._chartWidgetsDefs.length; ++i) {
          this._chartWidgetsDefs[i].chartWidget.addCustomWidgetToLegend(e, t);
        }
      }
      addReplayWidget(e) {
        (0, n.assert)(this._replayContainer === null, "Cannot create replay container multiple times");
        this._replayContainer = document.createElement("div");
        this._replayContainer.style.position = "absolute";
        this._replayContainer.style.minHeight = "49px";
        this._replayContainer.style.overflow = "hidden";
        this._replayContainer.style.left = "0px";
        this._replayContainer.style.right = "0px";
        const t = this._bottomToolbar.value()?.offsetHeight ?? 0;
        this._replayContainer.style.bottom = `${t}px`;
        this._replayContainer.setAttribute("data-is-chart-toolbar-component", "true");
        this._parent.prepend(this._replayContainer);
        e(this._replayContainer, () => this._updateLayout());
        this._updateLayout();
      }
      destroyReplayWidget() {
        (0, n.assert)(this._replayContainer !== null, "Cannot remove replay container, container is not created");
        this._replayContainer.remove();
        this._replayContainer = null;
        this._updateLayout();
      }
      setViewMode(e) {
        this._viewMode.setValue(e);
      }
      moveActiveChartWithUndo(e) { }
      activeChartCanBeMoved() {
        return this._activeChartCanBeMoved.readonly();
      }
      generalPropertiesDefinitions() {
        return this.activeChartWidget.value().generalPropertiesDefinitions();
      }
      reconnectChartApi(e) {
        reconnectChartApiHelper(e);
      }
      setBroker(e) {
        0;
      }
      setSaveChartService(e) {
        this._saveChartService = e;
        this._hasChangesSpawn?.destroy();
        this._hasChangesSpawn = e.hasChangesWV().spawn();
        this._hasChangesSpawn.subscribe(e => this._hasChanges.setValue(e), {
          callWithLast: true
        });
        for (let t = 0; t < this._chartWidgetsDefs.length; ++t) {
          this._chartWidgetsDefs[t].chartWidget.setSaveChartService(e);
        }
      }
      getCompareDialogRenderer() {
        return this._compareDialogRenderer;
      }
      getChartPropertiesDialogRenderer() {
        return this._chartPropertiesDialogRenderer;
      }
      chartsSymbols() {
        return Tg(this._stateImpl());
      }
      resetLayoutSizes(e) {
        Gg(this._stateImpl(), e);
      }
      unloadUnusedCharts() {
        const e = this._chartWidgetsDefs.splice(Ct.layouts[this._layoutType].count);
        for (const t of e) {
          t.destroy();
        }
        this._updateLinkingGroupCharts();
      }
      layoutSizesChanged() {
        return this._layoutSizesChangedWV.readonly();
      }
      ariaDescribeChart(e) {
        {
          const t = this.getAll().indexOf(e);
          xt.getInstance().updateChartDescription(e, t, this._layoutType);
        }
      }
      chartModels() {
        return this._chartModels.readonly();
      }
      _stateImpl() {
        return {
          undoHistory: this.undoHistory,
          chartWidgetsDefs: this._chartWidgetsDefs,
          actualLayoutCount: this._actualLayoutCount.bind(this),
          savedChartWidgetOptions: this._savedChartWidgetOptions,
          activeChartWidget: this.activeChartWidget,
          options: this._options,
          parent: this._parent,
          crosshairLockRaw: this._crosshairLock.value(),
          crossHairSyncBroadcast: this._crossHairSyncBroadcast,
          setChartStorageNotificationSubscription: e => {
            this._chartStorageNotification = e;
          },
          maximizedChartDef: this._maximizedChartDef,
          setMaximized: this._setMaximized.bind(this),
          layoutTemplate: this._layoutTemplate,
          widthWV: this._widthWV,
          heightWV: this._heightWV,
          checkProFeature: this._checkProFeature.bind(this),
          lineToolsSynchronizerHasChanges: this._lineToolsSynchronizerHasChanges,
          recalcHasChanges: this._recalcHasChanges.bind(this),
          onZoom: this._onZoom,
          onScroll: this._onScroll,
          layoutType: this._layoutType,
          layoutWV: this._layoutWV,
          setLayoutType: this._setLayoutType.bind(this),
          isPhoneSize: this._isPhoneSize,
          viewMode: this._viewMode,
          updateViewMode: this._updateViewMode.bind(this),
          loadingContent: this._loadingContent,
          initialLoading: this._initialLoading,
          inlineChartsCount: this._inlineChartsCount,
          updateWatchedValue: this._updateWatchedValue.bind(this),
          checkAllPendingModelsAlreadyCreated: this._checkAllPendingModelsAlreadyCreated.bind(this),
          readOnly: this._readOnly,
          symbolLock: this._symbolLock,
          internalSymbolLock: this._internalSymbolLock,
          intervalLock: this._intervalLock,
          internalIntervalLock: this._internalIntervalLock,
          dateRangeLock: this._dateRangeLock,
          internalDateRangeLock: this._internalDateRangeLock,
          trackTimeLock: this._trackTimeLock,
          internalTrackTimeLock: this._internalTrackTimeLock,
          crosshairLock: this._crosshairLock,
          customLegendWidgetsFactoriesMap: this._customLegendWidgetsFactoriesMap,
          globalDetachable: this._globalDetachable,
          saveChartService: this._saveChartService,
          customSources: this._customSources,
          updateActivityView: this._updateActivityView.bind(this),
          chartWidgetCreatedDelegate: this._chartWidgetCreatedDelegate,
          sizingState: this._sizingState,
          currentLayoutResizeAction: this._currentLayoutResizeAction,
          allLayoutSizesState: this._allLayoutSizesState,
          splitters: this._splitters,
          widgetOptions: this._widgetOptions,
          bottomToolbar: this._bottomToolbar,
          replayContainer: this._replayContainer,
          layoutSizesChanged: this._layoutSizesChangedWV,
          subscribeToCompletedEventForDateRangeSync: this._subscribeToCompletedEventForDateRangeSync.bind(this),
          subscribeToEventsForDateRangeSync: e => Ug(this._stateImpl(), e),
          unsubscribeFromEventsForDateRangeSync: e => jg(this._stateImpl(), e),
          syncChartsDateRangesWithActiveChartRange: this._syncChartsDateRangesWithActiveChartRange.bind(this),
          combinedTrackTimeLock: this._combinedTrackTimeLock,
          chartWidgetIdToCompletedCallbackMap: $g,
          flags: this._flags,
          linkingGroupsCharts: this._linkingGroupsCharts,
          chartModels: this._chartModels,
          updateLinkingGroupCharts: this._updateLinkingGroupCharts.bind(this),
          hideChart: this._hideChart.bind(this),
          addNewChartWidget: this._addNewChartWidget.bind(this)
        };
      }
      async _createSeriesControlWidget() {
        const e = "0px";
        const t = document.createElement("div");
        this._bottomToolbar.setValue(t);
        t.style.left = e;
        t.style.right = e;
        t.style.bottom = e;
        t.classList.add("chart-toolbar", "chart-controls-bar");
        t.setAttribute("data-is-chart-toolbar-component", "true");
        this._parent.appendChild(t);
        const {
          BottomToolbarRenderer: s
        } = await Promise.all([i.e(6822), i.e(3703), i.e(3953), i.e(9258), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(7384), i.e(2197), i.e(6489), i.e(4353), i.e(3362), i.e(7001), i.e(3745), i.e(1252), i.e(2227), i.e(2544), i.e(653), i.e(7260)]).then(i.bind(i, 68426));
        if (this._destroyed) {
          return;
        }
        const o = this._options.resizerBridge;
        const r = [o.container.spawn(), o.width.spawn(), o.height.spawn()];
        const a = o.container.value();
        const l = new re.Delegate();
        const c = () => {
          l.fire();
        };
        r.forEach(e => {
          e.subscribe(c);
        });
        this._bottomToolbarWidget = new s((0, n.ensureNotNull)(this._bottomToolbar.value()), l, () => {
          const e = a.getBoundingClientRect();
          const t = this._computeContentBox();
          t.top = e.top + t.top;
          t.left = e.left + t.left;
          return t;
        }, this, window.ChartApiInstance, this._widgetOptions, this._options.seriesControlBar);
        this._bottomToolbarDestroyer = () => {
          if (this._bottomToolbarWidget !== null) {
            this._bottomToolbarWidget.destroy();
            this._bottomToolbarWidget = null;
            this._bottomToolbar.setValue(null);
          }
          r.forEach(e => {
            e.destroy();
          });
          l.destroy();
        };
      }
      _checkProFeature(e) {
        return fs(this._stateImpl(), e);
      }
      _actualLayoutCount() {
        return Ct.layouts[this._layoutType].count;
      }
      _setMaximized(e) {
        if (this._maximizedChartDef.value() !== e) {
          this._maximizedChartDef.setValue(e);
          this.setLayout(this._layoutType);
        }
      }
      _updateViewMode() {
        if (this._layoutType === "s" || this._maximizedChartDef.value()) {
          this._viewMode.setValue(CollectionViewMode.ForceFullscreen);
        } else {
          this._viewMode.setValue(CollectionViewMode.Multichart);
        }
      }
      _updateWatchedValue() {
        const e = Math.min(this._layoutTemplate.value().count, this._chartWidgetsDefs.length) - 1;
        if (e < 0) {
          this.activeChartWidget.deleteValue();
          return;
        }
        const t = Math.min(Math.max(0, this._activeIndex), e);
        this.activeChartWidget.setValue(this._chartWidgetsDefs[t].chartWidget);
      }
      _checkAllPendingModelsAlreadyCreated() {
        if (this._chartWidgetsDefs.every(e => e.chartWidget.hasModel())) {
          this._updateWatchedValue();
          W.emit("layout_changed");
        }
      }
      _updateActivityView() {
        for (let e = this._chartWidgetsDefs.length; e--;) {
          const t = e === this._activeIndex;
          this._chartWidgetsDefs[e].container.value().classList.toggle("active", t);
          this._chartWidgetsDefs[e].container.value().classList.toggle("inactive", !t);
        }
      }
      _isDetached(e) {
        return e.rdState.owner.value() !== e;
      }
      _getVisuallyAdjacentDef(e, t) {
        return xg(this._stateImpl(), e, t);
      }
      _swapCharts(e, t) { }
      _subscribeToProperties(e) {
        if (this._subscribedChartWidget !== e) {
          if (this._subscribedChartWidget && (this._subscribedChartWidget.modelCreated().unsubscribe(null, this._onmodel), this._subscribedChartWidget.hasModel())) {
            const e = this._subscribedChartWidget.model();
            if (this._dateRangeLock.value()) {
              jg(this._stateImpl(), e);
            }
            e.mainSeries().properties().childs().style.unsubscribe(this, this._onstyle);
            e.model().onSelectedSourceChanged().unsubscribe(this, this._onselectedsource);
            this._subscribedChartWidget = null;
          }
          if (e) {
            this._subscribedChartWidget = e;
            if (e.hasModel()) {
              this._onmodel(e.model());
            } else {
              e.modelCreated().subscribe(this, this._onmodel);
            }
          }
        }
      }
      _onmodel(e) {
        const t = e.mainSeries().properties().childs();
        t.style.subscribe(this, this._onstyle);
        this._onstyle(t.style);
        e.model().onSelectedSourceChanged().subscribe(this, this._onselectedsource);
        if (this._dateRangeLock.value()) {
          Ug(this._stateImpl(), e);
          this._syncChartsDateRangesWithActiveChartRange();
        }
        this._onselectedsource();
      }
      _onstyle(e) {
        this.activeChartStyle.setValue(e.value());
      }
      _onselectedsource() {
        const e = (0, n.ensureNotNull)(this._subscribedChartWidget).model();
        this._selectedSources.setValue(e.selection().allSources().slice());
      }
      _onToolChanged() {
        this._chartWidgetsDefs.forEach(e => {
          e.chartWidget.onToolChanged();
        });
      }
      _updateCrossHairPositionIfNeeded() {
        const e = this.activeChartWidget.value();
        this._chartWidgetsDefs.forEach(t => {
          if (t.chartWidget !== e && this._crosshairLock.value()) {
            t.chartWidget.updateCrossHairPositionIfNeeded();
          }
        });
        if (e) {
          e.updateCrossHairPositionIfNeeded();
        }
      }
      async _setSymbolImpl(e, t, i, s) {
        const o = i ?? this.activeChartWidget.value();
        if (t === undefined) {
          t = o.linkingGroupIndex().value();
        }
        s = s ?? (this._symbolLock.value() ? this._chartWidgetsDefs.map(e => e.chartWidget) : [o]);
        this._pendingSetSymbolCancellationToken.cancelled = true;
        this._pendingSetSymbolCancellationToken = {
          cancelled: false
        };
        (() => {
          for (const t of s) {
            if (!(t.hasModel() ? t.model().mainSeries().symbolSameAsResolved(e) : t.symbolWV().value() === e)) {
              t.setSymbol(e);
            }
          }
        })();
        return true;
      }
      _alreadyHasId(e) {
        return this._chartWidgetsDefs.some(t => t.chartWidget?.id() === e);
      }
      _getCopiedChartStateAsWidgetContent() {
        const e = this.activeChartWidget.value();
        if (e) {
          const t = e.state();
          t.chartId = Ig(e => this._alreadyHasId(e));
          t.shouldBeSavedEvenIfHidden = false;
          t.panes.forEach(e => {
            e.sources.forEach(e => {
              if ((0, pt.isLineToolState)(e) && !e.linkKey) {
                e.alertId = undefined;
              }
            });
          });
          return {
            content: t
          };
        }
      }
      _onIdeaClickedHandler(e) {
        0;
      }
      _barsMarksContainersFactory(e) {
        const t = [];
        {
          const i = new Li(e);
          t.push(i);
          const s = new vi(e);
          t.push(s);
        }
        return t;
      }
      _getLinkingGroupCharts(e) {
        e = null;
        let t = this._linkingGroupsCharts.get(e);
        if (t === undefined) {
          t = new ht.WatchedObject([], ft.compareTwoCollectionsByIds);
          this._linkingGroupsCharts.set(e, t);
        }
        return t;
      }
      _computeContentBox() {
        const {
          border: e = 0,
          edge: t = 0
        } = this._options;
        const i = t + e;
        const s = this._bottomToolbar.value()?.offsetHeight ?? 0;
        const o = this._replayContainer?.offsetHeight ?? 0;
        return {
          width: this._widthWV.value() - i * 2,
          height: this._heightWV.value() - s - o - i,
          top: 0,
          left: i
        };
      }
      _updateLayoutPartial(e, t, i, s = this._layoutTemplate.value()) {
        const o = this._computeContentBox();
        const {
          padding: n = 2,
          border: r = 0
        } = this._options;
        const a = s.sizer(o, t, i, n + r, this._sizingState.value());
        a.width = Math.max(Math.round(a.width), 0);
        a.height = Math.max(Math.round(a.height), 0);
        a.top = Math.round(a.top);
        a.left = Math.round(a.left);
        e.metrics = a;
        const l = e.container.value();
        if (l) {
          l.style.width = a.width + "px";
          l.style.height = a.height + "px";
          l.style.top = a.top + "px";
          l.style.left = a.left + "px";
          const e = i === 1;
          false;
          const t = Math.round(o.width);
          const s = a.top === 0 && a.left === 0;
          const n = a.top === 0 && a.left + a.width === t;
          const r = a.top === 0 && a.width === t;
          l.classList.toggle("top-left-chart", !e && !r && s);
          l.classList.toggle("top-right-chart", !e && !r && n);
          l.classList.toggle("top-full-width-chart", e || r);
        }
        e.width.setValue(a.width);
        e.height.setValue(a.height);
      }
      _setInitialSizes(e) {
        let t = 0;
        let i = 0;
        const s = this._layoutTemplate.value();
        for (let o = 0; o < s.count; o++) {
          if (this._chartWidgetsDefs[o] === e) {
            i = t;
          }
          t++;
        }
        this._updateLayoutPartial(e, i, t, s);
      }
      _createChartWidget(e) {
        let t = {
          chartWidgetCollection: this,
          isActive: this._chartWidgetsDefs.length === 0,
          barsMarksContainersFactory: e => this._barsMarksContainersFactory(e),
          undoHistory: this.undoHistory,
          readOnly: this._readOnly,
          initialLoading: this._initialLoading,
          ...(e ?? {})
        };
        if (this._customLegendWidgetsFactoriesMap !== undefined) {
          t.customLegendWidgetFactories = new Map(this._customLegendWidgetsFactoriesMap);
        }
        const i = document.createElement("div");
        i.classList.add("chart-container");
        i.style.position = "absolute";
        i.style.overflow = "hidden";
        this._parent.insertBefore(i, this._bottomToolbar.value());
        if (ze.isEdge) {
          i.style.touchAction = "none";
          i.style.msTouchAction = "none";
        }
        if (t.className) {
          i.classList.add(t.className);
        }
        const s = {
          alive: new F.WatchedValue(true),
          container: new F.WatchedValue(i),
          width: new F.WatchedValue(),
          height: new F.WatchedValue(),
          collapsed: new F.WatchedValue(false),
          hiddenInLayout: new F.WatchedValue(false),
          visible: new F.WatchedValue(),
          rdState: new Ne(),
          requestFullscreen: () => {
            if (this._globalDetachable.value()) {
              this._setMaximized(s);
              this.activeChartWidget.setValue((0, n.ensureNotNull)(s.chartWidget));
            }
          },
          exitFullscreen: () => {
            if (this.activeChartWidget.value() === s.chartWidget) {
              this._setMaximized(null);
            }
          },
          detachable: this._globalDetachable,
          fullscreenable: this._globalDetachable,
          fullscreen: new F.WatchedValue(),
          chartWidget: null
        };
        s.rdState.pushOwner(s);
        const o = () => {
          if (s.chartWidget.isActive()) {
            this._updateActiveChartCanBeMoved();
          }
        };
        s.rdState.owner.subscribe(o);
        this._chartWidgetsDefs.push(s);
        const r = () => {
          (0, n.ensureNotNull)(s.chartWidget).setVisible(!s.hiddenInLayout.value());
          l();
        };
        const a = () => {
          (0, n.ensureNotNull)(s.chartWidget).setCollapsed(s.collapsed.value());
        };
        const l = () => {
          s.visible.setValue(!s.hiddenInLayout.value() && this._options.resizerBridge.visible.value());
        };
        s.hiddenInLayout.subscribe(r);
        s.collapsed.subscribe(a);
        this._options.resizerBridge.visible.subscribe(l);
        l();
        this._setInitialSizes(s);
        t = {
          ...t,
          ...s.rdState.bridge()
        };
        const c = t.content ? (0, n.ensureDefined)(t.content.chartId) : Ig(e => this._alreadyHasId(e));
        const h = s.chartWidget = new Xm(t, c);
        if (this._saveChartService) {
          h.setSaveChartService(this._saveChartService);
        }
        if (t.containsData) {
          h.finishInitWithoutConnect();
        } else {
          h.connect();
        }
        h.withModel(null, () => {
          const e = h.model().model();
          this._customSources.forEach((t, i) => {
            e.addCustomSource(i, t.factory, t.layer);
          });
        });
        this._updateWatchedValue();
        this._updateActivityView();
        const d = t?.content?.linkingGroup ?? null;
        h.linkingGroupIndex().setValue(d);
        h.linkingGroupIndex().subscribe(this._updateLinkingGroupCharts);
        const u = this._getLinkingGroupCharts(d).value();
        if (u.length > 0) {
          if (this._symbolLock.value()) {
            h.setSymbol(u[0].symbolWV().value());
          }
          if (this._intervalLock.value()) {
            h.setResolution(u[0].resolutionWV().value());
          }
        }
        this._updateLinkingGroupCharts();
        h.onZoom().subscribe(this, e => this._onZoom.fire(e));
        h.onScroll().subscribe(this, () => this._onScroll.fire());
        h.withModel(null, () => {
          h.lineToolsSynchronizer()?.hasChanges().subscribe(this._recalcHasChanges, {
            callWithLast: true
          });
        });
        s.destroy = () => {
          s.rdState.owner.unsubscribe(o);
          s.hiddenInLayout.unsubscribe(r);
          s.collapsed.unsubscribe(a);
          this._options.resizerBridge.visible.unsubscribe(l);
          h.linkingGroupIndex().unsubscribe(this._updateLinkingGroupCharts);
          h.onZoom().unsubscribeAll(this);
          h.onScroll().unsubscribeAll(this);
          h.lineToolsSynchronizer()?.hasChanges().unsubscribe(this._recalcHasChanges);
          s.timingsMeter?.destroy();
          s.rdState.destroy();
          h.destroy();
        };
        this._chartWidgetCreatedDelegate.fire(h);
        return s;
      }
      _addNewChartWidget(e, t) {
        let i;
        let s = this._savedChartWidgetOptions.shift();
        if (s !== undefined) {
          const e = this.activeChartWidget.value();
          if (e && e.lineToolsSynchronizer()) {
            i = e.lineToolsAndGroupsDTO();
          }
        } else {
          s = this._getCopiedChartStateAsWidgetContent();
        }
        const o = {
          ...this._widgetOptions,
          ...s,
          ...(e === 0 || this._symbolLock.value() ? undefined : {
            defSymbol: null
          })
        };
        const n = this._createChartWidget(o);
        const {
          chartWidget: r
        } = n;
        r.modelCreated().subscribe(null, () => {
          if (t) {
            t();
          } else {
            this._checkAllPendingModelsAlreadyCreated();
          }
          if (this._dateRangeLock.value() && r === this.activeChartWidget.value()) {
            this._subscribeToCompletedEventForDateRangeSync(r, true);
          }
          const e = r.lineToolsSynchronizer();
          if (i !== undefined && e) {
            [...i.entries()].map(([t, i]) => {
              if (t !== 0) {
                e.applyDTO(i, t).then(() => {
                  e.invalidateAll();
                });
              }
            });
          }
          let s = false;
          const o = () => {
            const e = this._chartWidgetsDefs.filter(e => (e.chartWidget !== r || !s) && e.chartWidget.hasModel()).map(e => e.chartWidget.model());
            this._chartModels.setValue(e);
          };
          o();
          r.onAboutToBeDestroyed().subscribe(null, () => {
            s = true;
            o();
          });
        }, true);
        return n;
      }
      _subscribeToCompletedEventForDateRangeSync(e, t) {
        const i = e.id();
        if ($g.has(i)) {
          return;
        }
        const s = () => {
          if ($g.has(i)) {
            $g.delete(i);
            this._syncChartsDateRangesWithActiveChartRange(t ? e : undefined);
          }
        };
        e.model().mainSeries().dataEvents().completed().subscribe(null, s, true);
        $g.set(i, {
          cw: e,
          callback: s
        });
      }
      _syncChartsDateRangesWithActiveChartRange(e) {
        if (!this._dateRangeLock.value() || this._currentLayoutResizeAction.value() !== null) {
          return;
        }
        const t = this.activeChartWidget.value();
        const i = t.model().mainSeries();
        if (!(0, yt.isTimeBasedStyle)(i.style())) {
          return;
        }
        const s = t.model().timeScale();
        const o = s.visibleBarsStrictRange();
        if (o === null) {
          return;
        }
        const r = (0, n.ensureNotNull)(s.points().range().value());
        let a = s.indexToTimePoint(o.firstBar());
        if (a === null && i.endOfData()) {
          a = s.indexToTimePoint(r.firstIndex);
        }
        let l = s.indexToTimePoint(o.lastBar());
        if (l === null) {
          l = s.indexToTimePoint(r.lastIndex);
        }
        if (a === null || l === null) {
          this._subscribeToCompletedEventForDateRangeSync(t, false);
          return;
        }
        $g.delete(t.id());
        let c = a * 1000;
        let h = l * 1000;
        if (i.isDWM()) {
          const e = new Date(c);
          const t = new Date(h);
          (0, Ce.set_hms)(e, 0, 0, 0, 0);
          (0, Ce.set_hms)(t, 0, 0, 0, 0);
          c = e.getTime();
          h = t.getTime();
        }
        for (let i = 0; i < this._chartWidgetsDefs.length; i++) {
          const s = this._chartWidgetsDefs[i].chartWidget;
          if (s.hasModel() && s !== t && (e === undefined || s === e) && (0, yt.isTimeBasedStyle)(s.model().mainSeries().style())) {
            setTimeout(this._chartWidgetGotoTimeRange.bind(null, s, c, h));
          }
        }
      }
      _chartWidgetGotoTimeRange(e, t, i) {
        e.model().model().gotoTimeRange(t, i);
        W.emit("sync_date_range", t, i);
      }
      _hideChart(e) {
        e.hiddenInLayout.setValue(true);
        const t = e.container.value();
        if (t.parentNode) {
          t.parentNode.removeChild(t);
        }
        e.fullscreen.setValue(false);
      }
      _setLayoutType(e) {
        this._layoutType = e;
      }
      _updateInlineChartsCount() {
        const e = this._layoutTemplate.value().count;
        this._inlineChartsCount.setValue(e);
        this._globalDetachable.setValue(e > 1);
      }
      _getStateForChartImpl(e, t, i, s, o) {
        const n = this.innerState();
        if (e < n.chartWidgetsDefs.length) {
          const r = n.chartWidgetsDefs[e].chartWidget;
          if (e < n.actualLayoutCount() || r.shouldBeSavedEvenIfHidden()) {
            return r.state(t, i, s, o);
          } else {
            return null;
          }
        }
        const r = n.savedChartWidgetOptions[e - n.chartWidgetsDefs.length].content;
        if (o) {
          a = r;
          return {
            ...a,
            panes: (l = a.panes, l.map(e => {
              return {
                ...e,
                sources: (t = e.sources, t.filter(e => !(0, wt.isLineToolName)(e.type)))
              };
              var t;
            }))
          };
        } else {
          return r;
        }
        var a;
        var l;
      }
      _chartsCountToSave() {
        return this._actualLayoutCount();
      }
    }
    var Jg = i(9726);
    const Qg = ["LineToolTrendLine", "LineToolRay", "LineToolInfoLine", "LineToolExtended", "LineToolRegressionTrend", "LineToolRotatedRectangle", "LineToolParallelChannel", "LineToolFlatBottom", "LineToolDisjointAngle", "LineToolPitchfork", "LineToolSchiffPitchfork", "LineToolSchiffPitchfork2", "LineToolInsidePitchfork", "LineToolVertLine", "LineToolCrossLine", "LineToolHorzLine", "LineToolHorzRay", "LineToolTrendAngle"];
    function ef(e, t = false, s = false) {
      if (!l.enabled("popup_hints")) {
        return () => { };
      }
      const o = e.getContainer();
      let r = null;
      let c = null;
      lt.tool.subscribe(h);
      lt.createdLineTool.subscribe(null, u);
      lt.finishedLineTool.subscribe(null, _);
      e.layoutSizesChanged().subscribe(p);
      if (!t && !ze.CheckMobile.any() && !!g("hint.startFocusedZoom")) {
        c = function (e, t) {
          let i = false;
          const s = o => {
            if (o) {
              if (i) {
                t(o);
              }
              e.onZoom().unsubscribe(null, s);
            } else if (!i) {
              t(o);
              i = true;
            }
          };
          e.onZoom().subscribe(null, s);
          return () => e.onZoom().unsubscribe(null, s);
        }(e, function (e) {
          if (!g("hint.startFocusedZoom")) {
            return;
          }
          if (e) {
            if (r) {
              c = null;
              f("hint.startFocusedZoom");
            }
          } else {
            const e = ct.isMacKeyboard ? "⌘" : "Ctrl";
            m(a.t(null, undefined, i(81712)).format({
              key: e
            }), "hint.startFocusedZoom");
          }
        });
      }
      return () => {
        lt.tool.unsubscribe(h);
        lt.createdLineTool.unsubscribe(null, u);
        lt.finishedLineTool.unsubscribe(null, _);
        e.layoutSizesChanged().unsubscribe(p);
        c?.();
      };
      function h() {
        const e = lt.tool.value();
        const t = ze.CheckMobile.any();
        if (s && t && (o = e, Qg.includes(o))) {
          (async function () {
            0;
          })();
          return;
        }
        var o;
        if (!g("hint.touchPainting")) {
          return;
        }
        const n = (0, wt.isLineToolDrawWithoutPoints)(e);
        if (!(0, wt.isStudyLineToolName)(e) || e === "LineToolRegressionTrend" || n || t) {
          if ((0, wt.isLineToolName)(e) && !(0, wt.isLineDrawnWithPressedButton)(e) && !n && t) {
            m(a.t(null, undefined, i(60663)), "hint.touchPainting");
          } else if (r) {
            r.hide();
          }
        } else {
          m(a.t(null, undefined, i(14985)), "hint.touchPainting");
        }
      }
      function u() {
        const e = lt.tool.value();
        if (e === "LineToolPath" && g("hint.finishBuildPathByDblClick")) {
          m(a.t(null, undefined, i(75296)), "hint.finishBuildPathByDblClick");
        } else if (e === "LineToolPolyline" && g("hint.finishBuildPolylineByDblClick")) {
          m(a.t(null, undefined, i(17409)), "hint.finishBuildPolylineByDblClick");
        }
      }
      function _() {
        if (r) {
          const e = lt.tool.value();
          if (e === "LineToolPath") {
            f("hint.finishBuildPathByDblClick");
          } else if (e === "LineToolPolyline") {
            f("hint.finishBuildPolylineByDblClick");
          }
        }
      }
      function p() {
        if (!g("hint.startResizingChartInLayout")) {
          return;
        }
        m(ze.CheckMobile.any() ? a.t(null, undefined, i(36539)) : a.t(null, undefined, i(9430)), "hint.startResizingChartInLayout");
      }
      function m(e, t) {
        if (r) {
          r.show(e, f.bind(null, t));
        } else {
          const s = lt.tool.value();
          Promise.all([i.e(1737), i.e(2227), i.e(6166)]).then(i.bind(i, 5015)).then(i => {
            r = new i.ChartEventHintRenderer(o);
            if (s === lt.tool.value()) {
              r.show(e, f.bind(null, t));
            }
          });
        }
      }
      function g(e) {
        return !Boolean(d.getBool(e));
      }
      function f(e) {
        d.setValue(e, true, {
          forceFlush: true
        });
        (0, n.ensureNotNull)(r).destroy();
        if (c !== null) {
          c();
        }
        r = null;
      }
    }
    var tf = i(51243);
    var sf = i.n(tf);
    var of = i(58519);
    class nf {
      constructor(e) {
        this._toolbarThemeChanged = new re.Delegate();
        this._onWatchedThemeChanged = e => {
          this._toolbarThemeChanged.fire(e);
        };
        this._opts = e;
        D.watchedTheme.subscribe(this._onWatchedThemeChanged);
      }
      destroy() {
        D.watchedTheme.unsubscribe(this._onWatchedThemeChanged);
      }
      isStdTheme() {
        const e = this._opts.chartWidgetCollection.getAll().every(e => e.model().model().getThemeNameIfStdTheme() !== null);
        return Promise.resolve(e);
      }
      async setStdTheme(e, t = true, i) {
        await (0, of.loadTheme)(this._opts.chartWidgetCollection, {
          themeName: e,
          standardTheme: true,
          syncState: t,
          noUndo: i
        });
      }
      setStdThemeForLayout(e, t = true) {
        (0, D.setTheme)(e);
        if (t) {
          (0, k.syncTheme)();
        }
      }
      getCurrentThemeName() {
        return (0, k.getCurrentTheme)().name;
      }
      toolbarThemeChanged() {
        return this._toolbarThemeChanged;
      }
    }
    function rf(e) {
      return e in af;
    }
    const af = {
      cursor: {
        name: "cursor",
        onlySelectable: true
      },
      dot: {
        name: "dot",
        onlySelectable: true
      },
      arrow_cursor: {
        name: "arrow",
        onlySelectable: true
      },
      eraser: {
        name: "eraser",
        onlySelectable: true
      },
      measure: {
        name: "measure",
        onlySelectable: true
      },
      zoom: {
        name: "zoom",
        onlySelectable: true
      },
      brush: {
        name: "LineToolBrush"
      },
      highlighter: {
        name: "LineToolHighlighter"
      },
      text: {
        name: "LineToolText"
      },
      anchored_text: {
        name: "LineToolTextAbsolute",
        isAnchored: true
      },
      note: {
        name: "LineToolNote"
      },
      text_note: {
        name: "LineToolTextNote"
      },
      anchored_note: {
        name: "LineToolNoteAbsolute",
        isAnchored: true
      },
      signpost: {
        name: "LineToolSignpost"
      },
      callout: {
        name: "LineToolCallout"
      },
      balloon: {
        name: "LineToolBalloon"
      },
      comment: {
        name: "LineToolComment"
      },
      arrow_up: {
        name: "LineToolArrowMarkUp"
      },
      arrow_down: {
        name: "LineToolArrowMarkDown"
      },
      arrow_left: {
        name: "LineToolArrowMarkLeft"
      },
      arrow_right: {
        name: "LineToolArrowMarkRight"
      },
      price_label: {
        name: "LineToolPriceLabel"
      },
      price_note: {
        name: "LineToolPriceNote"
      },
      arrow_marker: {
        name: "LineToolArrowMarker"
      },
      flag: {
        name: "LineToolFlagMark"
      },
      image: {
        name: "LineToolImage"
      },
      table: {
        name: "LineToolTable"
      },
      vertical_line: {
        name: "LineToolVertLine"
      },
      horizontal_line: {
        name: "LineToolHorzLine"
      },
      cross_line: {
        name: "LineToolCrossLine"
      },
      horizontal_ray: {
        name: "LineToolHorzRay"
      },
      trend_line: {
        name: "LineToolTrendLine"
      },
      info_line: {
        name: "LineToolInfoLine"
      },
      trend_angle: {
        name: "LineToolTrendAngle"
      },
      arrow: {
        name: "LineToolArrow"
      },
      ray: {
        name: "LineToolRay"
      },
      extended: {
        name: "LineToolExtended"
      },
      parallel_channel: {
        name: "LineToolParallelChannel"
      },
      disjoint_angle: {
        name: "LineToolDisjointAngle"
      },
      flat_bottom: {
        name: "LineToolFlatBottom"
      },
      anchored_vwap: {
        name: "LineToolAnchoredVWAP"
      },
      pitchfork: {
        name: "LineToolPitchfork"
      },
      schiff_pitchfork_modified: {
        name: "LineToolSchiffPitchfork"
      },
      schiff_pitchfork: {
        name: "LineToolSchiffPitchfork2"
      },
      inside_pitchfork: {
        name: "LineToolInsidePitchfork"
      },
      pitchfan: {
        name: "LineToolPitchfan"
      },
      gannbox: {
        name: "LineToolGannSquare"
      },
      gannbox_square: {
        name: "LineToolGannComplex"
      },
      gannbox_fixed: {
        name: "LineToolGannFixed"
      },
      gannbox_fan: {
        name: "LineToolGannFan"
      },
      fib_retracement: {
        name: "LineToolFibRetracement"
      },
      fib_trend_ext: {
        name: "LineToolTrendBasedFibExtension"
      },
      fib_speed_resist_fan: {
        name: "LineToolFibSpeedResistanceFan"
      },
      fib_timezone: {
        name: "LineToolFibTimeZone"
      },
      fib_trend_time: {
        name: "LineToolTrendBasedFibTime"
      },
      fib_circles: {
        name: "LineToolFibCircles"
      },
      fib_spiral: {
        name: "LineToolFibSpiral"
      },
      fib_speed_resist_arcs: {
        name: "LineToolFibSpeedResistanceArcs"
      },
      fib_wedge: {
        name: "LineToolFibWedge"
      },
      fib_channel: {
        name: "LineToolFibChannel"
      },
      xabcd_pattern: {
        name: "LineTool5PointsPattern"
      },
      cypher_pattern: {
        name: "LineToolCypherPattern"
      },
      abcd_pattern: {
        name: "LineToolABCD"
      },
      triangle_pattern: {
        name: "LineToolTrianglePattern"
      },
      "3divers_pattern": {
        name: "LineToolThreeDrivers"
      },
      head_and_shoulders: {
        name: "LineToolHeadAndShoulders"
      },
      elliott_impulse_wave: {
        name: "LineToolElliottImpulse"
      },
      elliott_triangle_wave: {
        name: "LineToolElliottTriangle"
      },
      elliott_triple_combo: {
        name: "LineToolElliottTripleCombo"
      },
      elliott_correction: {
        name: "LineToolElliottCorrection"
      },
      elliott_double_combo: {
        name: "LineToolElliottDoubleCombo"
      },
      cyclic_lines: {
        name: "LineToolCircleLines"
      },
      time_cycles: {
        name: "LineToolTimeCycles"
      },
      sine_line: {
        name: "LineToolSineLine"
      },
      long_position: {
        name: "LineToolRiskRewardLong"
      },
      short_position: {
        name: "LineToolRiskRewardShort"
      },
      forecast: {
        name: "LineToolPrediction"
      },
      date_range: {
        name: "LineToolDateRange"
      },
      price_range: {
        name: "LineToolPriceRange"
      },
      date_and_price_range: {
        name: "LineToolDateAndPriceRange"
      },
      bars_pattern: {
        name: "LineToolBarsPattern"
      },
      ghost_feed: {
        name: "LineToolGhostFeed"
      },
      projection: {
        name: "LineToolProjection"
      },
      rectangle: {
        name: "LineToolRectangle"
      },
      rotated_rectangle: {
        name: "LineToolRotatedRectangle"
      },
      circle: {
        name: "LineToolCircle"
      },
      ellipse: {
        name: "LineToolEllipse"
      },
      triangle: {
        name: "LineToolTriangle"
      },
      polyline: {
        name: "LineToolPolyline"
      },
      path: {
        name: "LineToolPath"
      },
      curve: {
        name: "LineToolBezierQuadro"
      },
      double_curve: {
        name: "LineToolBezierCubic"
      },
      arc: {
        name: "LineToolArc"
      },
      icon: {
        name: "LineToolIcon"
      },
      emoji: {
        name: "LineToolEmoji"
      },
      sticker: {
        name: "LineToolSticker"
      },
      regression_trend: {
        name: "LineToolRegressionTrend"
      },
      fixed_range_volume_profile: {
        name: "LineToolFixedRangeVolumeProfile"
      }
    };
    const lf = new re.Delegate();
    var cf = i(78749);
    var hf = i(9447);
    class df {
      constructor(e) {
        this._timeScale = e;
      }
      coordinateToTime(e) {
        const t = this._timeScale.coordinateToIndex(e);
        return this._timeScale.indexToTimePoint(t);
      }
      barSpacingChanged() {
        return this._timeScale.barSpacingChanged();
      }
      rightOffsetChanged() {
        return this._timeScale.rightOffsetChanged();
      }
      setRightOffset(e) {
        this._timeScale.setRightOffset(e);
      }
      setBarSpacing(e) {
        this._timeScale.setBarSpacing(e);
      }
      barSpacing() {
        return this._timeScale.barSpacing();
      }
      rightOffset() {
        return this._timeScale.rightOffset();
      }
      width() {
        return this._timeScale.width();
      }
      defaultRightOffset() {
        return this._timeScale.defaultRightOffset().spawn();
      }
      defaultRightOffsetPercentage() {
        return this._timeScale.defaultRightOffsetPercentage().spawn();
      }
      usePercentageRightOffset() {
        return this._timeScale.usePercentageRightOffset().spawn();
      }
      isEmpty() {
        return this._timeScale.isEmpty();
      }
      scrollToFirstBar(e) {
        this._timeScale.scrollToFirstBar(e);
      }
      scrollToRealtime(e) {
        this._timeScale.scrollToRealtime(false, e);
      }
      pointsCount() {
        return this._timeScale.points().size();
      }
      leftVisibleBarUTCTime() {
        const e = this._timeScale.visibleBarsStrictRange()?.firstBar() ?? null;
        if (e === null) {
          return null;
        } else {
          return this._timeScale.indexToTimePoint(e);
        }
      }
    }
    const uf = new Di.TranslatedString("change timezone", a.t(null, undefined, i(20137)));
    class _f {
      constructor(e) {
        this._onTimezoneChanged = new re.Delegate();
        this._chartWidget = e;
        this._timezoneProperty = e.properties().childs().timezone;
        this._timezoneProperty.subscribe(this, e => {
          this._onTimezoneChanged.fire(e.value());
        });
        e.onAboutToBeDestroyed().subscribe(this, () => {
          this._timezoneProperty.unsubscribeAll(this);
        }, true);
      }
      availableTimezones() {
        return Pe.availableTimezones;
      }
      getTimezone() {
        const e = this._timezoneProperty.value();
        return (0, n.ensureDefined)(this.availableTimezones().find(t => t.id === e));
      }
      setTimezone(e, t) {
        (0, n.assert)((0, Pe.timezoneIsAvailable)(e), `Incorrect timezone: ${e}`);
        if (t?.disableUndo) {
          this._timezoneProperty.setValue(e);
        } else {
          this._chartWidget.model().setProperty(this._timezoneProperty, e, uf);
        }
      }
      onTimezoneChanged() {
        return this._onTimezoneChanged;
      }
    }
    class pf {
      constructor(e, t) {
        this._chartUndoModel = e;
        this._chartModel = e.model();
        this._priceScale = t;
      }
      getMode() {
        const e = this._priceScale.properties().childs();
        if (e.percentage.value()) {
          return 2;
        } else if (e.indexedTo100.value()) {
          return 3;
        } else if (e.log.value()) {
          return 1;
        } else {
          return 0;
        }
      }
      setMode(e) {
        this._priceScale.setMode({
          percentage: e === 2,
          log: e === 1,
          indexedTo100: e === 3
        });
      }
      isInverted() {
        return this._priceScale.isInverted();
      }
      setInverted(e) {
        this._priceScale.properties().childs().isInverted.setValue(e);
      }
      isLocked() {
        return this._priceScale.isLockScale();
      }
      setLocked(e) {
        this._priceScale.setMode({
          lockScale: e
        });
      }
      isAutoScale() {
        return this._priceScale.isAutoScale();
      }
      setAutoScale(e) {
        this._priceScale.setMode({
          autoScale: e
        });
      }
      getVisiblePriceRange() {
        return this._priceScale.priceRangeInPrice();
      }
      setVisiblePriceRange(e) {
        this._priceScale.setPriceRangeInPrice(e);
        this._chartModel.lightUpdate();
      }
      hasMainSeries() {
        return this._priceScale.hasMainSeries();
      }
      getStudies() {
        return this._priceScale.getStudies().map(e => e.id());
      }
      currency() {
        const e = this._chartModel.availableCurrencies();
        const t = this._priceScale.currency(e);
        if (t === null) {
          return null;
        } else {
          return {
            readOnly: t.readOnly,
            selectedCurrency: t.selectedCurrency,
            originalCurrencies: Array.from(t.originalCurrencies),
            currencies: e.getItems().filter(e => !t.baseCurrencies.has(e)),
            symbols: Array.from(t.symbols)
          };
        }
      }
      setCurrency(e) {
        const t = this.currency()?.currencies;
        if (t && e && !t.includes(e)) {
          console.warn("The provided currency is not supported by your datafeed!");
        } else {
          this._chartUndoModel.setPriceScaleCurrency(this._priceScale, e);
        }
      }
      unit() {
        const e = this._chartModel.availableUnits();
        const t = this._priceScale.unit(e);
        if (t === null) {
          return null;
        } else {
          return {
            readOnly: t.availableGroups.size === 0,
            selectedUnit: t.selectedUnit,
            originalUnits: Array.from(t.originalUnits),
            availableGroups: Array.from(t.availableGroups),
            symbols: Array.from(t.symbols)
          };
        }
      }
      setUnit(e) {
        if (!e || this._chartModel.availableUnits().unitGroupById(e)) {
          this._chartUndoModel.setPriceScaleUnit(this._priceScale, e);
        } else {
          console.warn("The provided unit is not supported by your datafeed!");
        }
      }
      coordinateToPrice(e) {
        const t = this._priceScale.mainSource()?.firstValue();
        if (t == null) {
          return null;
        } else {
          return this._priceScale.coordinateToPrice(e, t);
        }
      }
      measureUnitId() {
        const e = this._priceScale.measureUnitId(this._chartModel.availableUnits());
        if (e === null) {
          return null;
        } else {
          return {
            selectedMeasureUnitId: e.selectedMeasureUnitId
          };
        }
      }
    }
    function mf(e) {
      return {
        id: e.id(),
        name: (t = e.toolname, Object.keys(af).find(e => af[e].name === t) || null)
      };
      var t;
    }
    function gf(e) {
      return {
        id: e.id(),
        name: e.metaInfo().description
      };
    }
    const ff = new Di.TranslatedString("change pane height", a.t(null, undefined, i(14691)));
    class yf extends tt.UndoCommand {
      constructor(e, t, i) {
        super(ff);
        this._model = e;
        this._paneIndex = t;
        this._paneHeight = i;
        this._prevStretchFactors = this._model.panes().map(e => e.stretchFactor());
      }
      redo() {
        this._model.changePanesHeight(this._paneIndex, this._paneHeight);
      }
      undo() {
        const e = this._model.panes();
        for (let t = 0; t < e.length; ++t) {
          e[t].setStretchFactor((0, n.ensureDefined)(this._prevStretchFactors[t]));
        }
        this._model.fullUpdate();
      }
    }
    class vf {
      constructor(e, t) {
        this._priceScales = new WeakMap();
        this._pane = e;
        this._chartWidget = t;
      }
      hasMainSeries() {
        return this._pane.containsMainSeries();
      }
      getLeftPriceScales() {
        return this._pane.leftPriceScales().map(this._getPriceScaleApi, this);
      }
      getRightPriceScales() {
        return this._pane.rightPriceScales().map(this._getPriceScaleApi, this);
      }
      getMainSourcePriceScale() {
        const e = this._pane.mainDataSource();
        if (e === null) {
          return null;
        }
        const t = e.priceScale();
        if (t === null || this._pane.isOverlay(e)) {
          return null;
        } else {
          return this._getPriceScaleApi(t);
        }
      }
      getPriceScaleById(e) {
        const t = this._pane.getPriceScaleById(e);
        if (t === null) {
          return null;
        } else {
          return this._getPriceScaleApi(t);
        }
      }
      setMaximized(e) {
        if (this._pane.maximized().value() !== e) {
          this._chartWidget.model().toggleMaximizedPane(this._pane);
        }
      }
      isMaximized() {
        return this._pane.maximized().value();
      }
      legendLoaded() {
        const e = this._chartWidget.paneByState(this._pane);
        return Boolean(e && e.statusWidget());
      }
      getAllEntities() {
        const e = this._pane.model();
        return this._pane.sourcesByGroup().allIncludingHidden().filter(e => !e.isSpeciallyZOrderedSource()).map(t => function (e, t) {
          if (t === e.mainSeries()) {
            return function (e) {
              return {
                id: e.id(),
                name: "Main Series"
              };
            }(e.mainSeries());
          } else if ((0, Js.isStudy)(t)) {
            return gf(t);
          } else if ((0, eo.isLineTool)(t)) {
            return mf(t);
          } else {
            return null;
          }
        }(e, t)).filter(dt.notNull).filter(e => e.name !== null);
      }
      getHeight() {
        return this._pane.height();
      }
      setHeight(e) {
        const t = this._chartWidget.model().model();
        const i = t.panes();
        (0, n.assert)(i.length > 1, "Unable to change pane's height if there is only one pane");
        const s = i.indexOf(this._pane);
        (0, n.assert)(s !== -1, "Invalid pane index");
        const o = new yf(t, s, e);
        this._chartWidget.model().undoHistory().pushUndoCommand(o);
      }
      moveTo(e) {
        const t = this.paneIndex();
        if (t !== e) {
          (0, n.assert)(e >= 0 && e < this._chartWidget.paneWidgets().length, "Invalid pane index");
          this._chartWidget.model().movePane(t, e);
        }
      }
      paneIndex() {
        return this._chartWidget.model().model().panes().indexOf(this._pane);
      }
      collapse() {
        if (this._chartWidget.model().panes().length === 1) {
          throw new Error("Cannot collapse a single pane!");
        }
        if (this._pane.collapsed().value()) {
          throw new Error("Cannot collapse current pane!");
        }
        this._chartWidget.model().toggleCollapsedPane(this._pane);
      }
      restore() {
        if (this._chartWidget.paneWidgets().length === 1) {
          throw new Error("Cannot restore a single pane!");
        }
        if (!this._pane.collapsed().value()) {
          throw new Error("Cannot restore current pane!");
        }
        this._chartWidget.model().toggleCollapsedPane(this._pane);
      }
      isCollapsed() {
        return this._pane.collapsed().value();
      }
      _getPriceScaleApi(e) {
        let t = this._priceScales.get(e);
        if (t === undefined) {
          t = new pf(this._chartWidget.model(), e);
          this._priceScales.set(e, t);
        }
        return t;
      }
    }
    var Sf = i(56530);
    function bf(e) {
      if (e.inputs === undefined) {
        return [];
      } else {
        return e.inputs.map(e => ({
          ...e,
          id: e.id,
          localizedName: e.name !== undefined ? (0, Sf.getTranslatedInputTitle)(e.name) : ""
        }));
      }
    }
    function wf(e) {
      const t = {};
      if (e.defaults) {
        const i = (0, hc.default)(e.defaults);
        t.defaults = i;
      }
      if (e.plots !== undefined) {
        t.plots = (0, hc.default)(e.plots);
      }
      if (e.styles !== undefined) {
        t.styles = (0, hc.default)(e.styles);
      }
      if (e.bands !== undefined) {
        t.bands = (0, hc.default)(e.bands);
      }
      if (e.filledAreas !== undefined) {
        t.filledAreas = (0, hc.default)(e.filledAreas);
      }
      if (e.palettes !== undefined) {
        t.palettes = (0, hc.default)(e.palettes);
      }
      return t;
    }
    var Cf = i(58137);
    class Pf {
      constructor(e, t) {
        this._onStudyCompleted = new re.Delegate();
        this._onStudyError = new re.Delegate();
        this._study = e;
        this._chartWidget = t;
        this._undoModel = this._chartWidget.model();
        this._model = this._undoModel.model();
        this._study.onAboutToBeDestroyed().subscribe(this, () => {
          this._study.onStatusChanged().unsubscribeAll(this);
          this._study.onAboutToBeDestroyed().unsubscribeAll(this);
        });
        this._study.onStatusChanged().subscribe(this, e => {
          switch (e.type) {
            case yh.StudyStatusType.Completed:
              this._onStudyCompleted.fire();
              break;
            case yh.StudyStatusType.Error:
              this._onStudyError.fire();
          }
        });
      }
      isUserEditEnabled() {
        return this._study.userEditEnabled();
      }
      setUserEditEnabled(e) {
        this._study.setUserEditEnabled(e);
      }
      getInputsInfo() {
        return bf(this._study.metaInfo());
      }
      getInputValues() {
        const e = this._study.inputs({
          symbolsForChartApi: false,
          asObject: true
        });
        return Object.keys(e).map(t => {
          const i = e[t];
          return {
            id: t,
            value: (0, dt.isObject)(i) ? i.v : i
          };
        });
      }
      getStyleInfo() {
        return wf(this._study.metaInfo());
      }
      getStyleValues() {
        const {
          styles: e,
          bands: t,
          filledAreas: i,
          palettes: s,
          graphics: o,
          ohlcPlots: n,
          filledAreasStyle: r
        } = this._study.properties().state();
        return {
          styles: e,
          bands: t,
          filledAreas: i,
          palettes: s,
          graphics: o,
          ohlcPlots: n,
          filledAreasStyle: r
        };
      }
      setInputValues(e) {
        const t = this.getInputValues();
        for (const i of e) {
          if (t.find(e => e.id === i.id) !== undefined) {
            this._study.properties().childs().inputs.childs()[i.id].setValue(i.value);
          } else {
            console.warn(`There is no such input: "${i.id}"`);
          }
        }
      }
      mergeUp() {
        if (this._model.isMergeUpAvailableForSource(this._study)) {
          new na(this._model, this._study, null).redo();
        }
      }
      mergeDown() {
        if (this._model.isMergeDownAvailableForSource(this._study)) {
          new ra(this._model, this._study, null).redo();
        }
      }
      unmergeUp() {
        if (this._model.isUnmergeAvailableForSource(this._study)) {
          new ia(this._model, this._study, null).redo();
        }
      }
      unmergeDown() {
        if (this._model.isUnmergeAvailableForSource(this._study)) {
          new ta(this._model, this._study, null).redo();
        }
      }
      paneIndex() {
        return this._model.panes().indexOf(this._model.paneForSource(this._study));
      }
      onDataLoaded() {
        return this._onStudyCompleted;
      }
      onStudyError() {
        return this._onStudyError;
      }
      mergeUpWithUndo() {
        if (this._model.isMergeUpAvailableForSource(this._study)) {
          this._undoModel.mergeSourceUp(this._study);
        }
      }
      mergeDownWithUndo() {
        if (this._model.isMergeDownAvailableForSource(this._study)) {
          this._undoModel.mergeSourceDown(this._study);
        }
      }
      unmergeUpWithUndo() {
        if (this._model.isUnmergeAvailableForSource(this._study)) {
          this._undoModel.unmergeSourceUp(this._study);
        }
      }
      unmergeDownWithUndo() {
        if (this._model.isUnmergeAvailableForSource(this._study)) {
          this._undoModel.unmergeSourceDown(this._study);
        }
      }
      priceScale() {
        return new pf(this._undoModel, (0, n.ensureNotNull)(this._study.priceScale()));
      }
      symbolSource() {
        const e = (0, n.ensureNotNull)(this._study.symbolSource());
        return {
          symbol: e.symbol(),
          currencyId: e.currency(),
          unitId: e.unit()
        };
      }
      currency() {
        return this._study.currency();
      }
      changePriceScale(e) {
        const t = (0, n.ensureNotNull)(this._model.paneForSource(this._model.mainSeries()));
        const i = (0, n.ensureNotNull)(this._model.paneForSource(this._study));
        switch (e) {
          case "no-scale":
            (0, n.assert)(i.actionNoScaleIsEnabled(this._study), "Unable to leave a pane without any non-overlay price scale");
            new Zl(this._model, this._study, i, "overlay", null).redo();
            break;
          case "as-series":
            (0, n.assert)(i === t, "Study should be on the main pane");
            new Xl(this._model, this._study, i, this._model.mainSeries().priceScale(), null).redo();
            break;
          case "new-left":
            new Zl(this._model, this._study, i, "left", null).redo();
            break;
          case "new-right":
            new Zl(this._model, this._study, i, "right", null).redo();
            break;
          default:
            const s = this._model.dataSourceForId(e);
            if (s === null) {
              throw new Error(`There is no study with entityId='${e}'`);
            }
            const o = i === this._model.paneForSource(s);
            (0, n.assert)(o, "Both studies should be on the same pane");
            const r = (0, n.ensureNotNull)(s.priceScale());
            const a = Or(this._study, r, this._model);
            const l = oh(this._study, r, this._model);
            new Xl(this._model, this._study, i, r, null).redo();
            if (a !== null) {
              new $l(this._model, r, a, null).redo();
            }
            if (l !== null) {
              new Kl(this._model, r, l, null).redo();
            }
        }
      }
      isVisible() {
        return this._study.properties().childs().visible.value();
      }
      setVisible(e) {
        this._study.properties().childs().visible.setValue(e);
      }
      bringToFront() {
        this._model.bringToFront([this._study]);
      }
      sendToBack() {
        this._model.sendToBack([this._study]);
      }
      applyOverrides(e) {
        (0, cf.applyOverridesToStudy)(this._study, e);
      }
      hasPlots() {
        return this._study.metaInfo().plots.length > 0;
      }
      dataLength() {
        if (this._study.status().type !== yh.StudyStatusType.Completed) {
          return 0;
        } else if (this._study.metaInfo().plots.length > 0) {
          return this._study.data().size();
        } else {
          return this._model.mainSeries().bars().size();
        }
      }
      isLoading() {
        const e = this._study.status();
        return e.type === yh.StudyStatusType.Undefined || e.type === yh.StudyStatusType.Loading;
      }
      hasError() {
        return this._study.status().type === yh.StudyStatusType.Error;
      }
      hasPendingUnresolvedSymbols() {
        return this._study.hasPendingUnresolvedSymbols();
      }
      anyGraphicsReady() {
        return !(0, Cf.isStudyGraphicsEmpty)(this._study.graphics());
      }
      graphicsViewsReady() {
        return this._study.graphicsViewsReady();
      }
      properties() {
        return this._study.properties();
      }
      setProperties(e) {
        this._study.properties().mergeAndFire(e);
      }
      async applyToEntireLayout() {
        const e = new sn.ActionsProvider(this._chartWidget);
        const t = (await e.contextMenuActionsForSources([this._study], (0, n.ensureNotNull)(this._chartWidget.model().paneForSource(this._study)))).find(e => e.id === "applyStudyToEntireLayout");
        if (t) {
          t.execute();
        }
      }
      status() {
        return {
          ...this._study.status()
        };
      }
      title() {
        return this._study.title(ua.TitleDisplayTarget.StatusLine);
      }
      symbolsResolved() {
        return this._study.symbolsResolved();
      }
      study() {
        return this._study;
      }
    }
    const Tf = new Map([["LineToolBezierQuadro", 3], ["LineToolBezierCubic", 4]]);
    function xf(e) {
      const t = Tf.get(e.toolname);
      if (t !== undefined) {
        return t;
      }
      const i = e.pointsCount();
      if (i === -1) {
        return e.points().length;
      } else {
        return i;
      }
    }
    function If(e) {
      return e === "LineToolRiskRewardLong" || e === "LineToolRiskRewardShort";
    }
    const Mf = ["alwaysShowStats", "entryPrice", "inputs.first bar time", "inputs.last bar time", "interval", "linesWidths", "points", "snapTo45Degrees", "stopPrice", "symbol", "symbolStateVersion", "currencyId", "unitId", "targetPrice", "zOrderVersion"];
    class Af {
      constructor(e, t, i) {
        this._source = e;
        this._undoModel = t;
        this._model = t.model();
        this._pointsConverter = i;
      }
      isSelectionEnabled() {
        return this._source.isSelectionEnabled();
      }
      setSelectionEnabled(e) {
        this._source.setSelectionEnabled(e);
      }
      isSavingEnabled() {
        return this._source.isSavedInChart();
      }
      setSavingEnabled(e) {
        this._source.setSavingInChartEnabled(e);
      }
      isShowInObjectsTreeEnabled() {
        return this._source.showInObjectTree();
      }
      setShowInObjectsTreeEnabled(e) {
        this._source.setShowInObjectsTreeEnabled(e);
      }
      isUserEditEnabled() {
        return this._source.userEditEnabled();
      }
      setUserEditEnabled(e) {
        this._source.setUserEditEnabled(e);
      }
      bringToFront() {
        this._model.bringToFront([this._source]);
      }
      sendToBack() {
        this._model.sendToBack([this._source]);
      }
      getProperties() {
        return this._source.properties().state(Mf);
      }
      setProperties(e, t) {
        (0, li.allowSavingDefaults)(!!t);
        this._source.properties().mergeAndFire(e);
        (0, li.allowSavingDefaults)(false);
      }
      getPoints() {
        let e = this._source.points();
        const t = xf(this._source);
        if (e.length > t) {
          (0, n.assert)(If(this._source.toolname));
          e = e.slice(0, t);
        }
        return this._pointsConverter.dataSourcePointsToPriced(e);
      }
      setPoints(e) {
        if (this._source.isFixed()) {
          return;
        }
        const t = xf(this._source);
        if (t !== e.length) {
          throw new Error(`Wrong points count. Required: ${t}, provided: ${e.length}`);
        }
        const i = this._pointsConverter.apiPointsToDataSource(e);
        this._model.startChangingLinetool(this._source);
        this._model.changeLinePoints(this._source, i);
        this._model.endChangingLinetool(true);
        this._source.createServerPoints();
      }
      getAnchoredPosition() {
        return this._source.positionPercents();
      }
      setAnchoredPosition(e) {
        const t = this._source.fixedPoint();
        const i = this._source.linkKey().value();
        const s = t === undefined ? null : this._source.screenPointToPoint(t);
        if (!this._source.isFixed() || t === undefined || i === null || s === null) {
          return;
        }
        const o = {
          logical: s,
          screen: t
        };
        const n = new Map();
        n.set(i, e);
        this._model.startMovingSources([this._source], o, null, new Map());
        this._model.moveSources(o, n);
        this._model.endMovingSources(true);
      }
      ownerSourceId() {
        return (0, n.ensureNotNull)(this._source.ownerSource()).id();
      }
      changePoint(e, t) {
        if (this._source.isFixed()) {
          return;
        }
        const i = this._pointsConverter.apiPointsToDataSource([e])[0];
        this._model.startChangingLinetool(this._source, {
          ...i
        }, t);
        this._model.changeLinePoint({
          ...i
        });
        this._model.endChangingLinetool(false);
        this._source.createServerPoints();
      }
      isHidden() {
        return this._source.isSourceHidden();
      }
      getRawPoints() {
        return this._source.points();
      }
      getNormalizedPoints() {
        return this._source.normalizedPoints();
      }
      setRawPoint(e, t) {
        this._model.startChangingLinetool(this._source, {
          ...t
        }, e);
        this._model.changeLinePoint({
          ...t
        });
        this._model.endChangingLinetool(false);
      }
      move(e, t) {
        this._model.startMovingSources([this._source], {
          logical: e,
          screen: (0, n.ensureNotNull)(this._source.pointToScreenPoint(e))
        }, null, new Map());
        this._model.moveSources({
          logical: t,
          screen: (0, n.ensureNotNull)(this._source.pointToScreenPoint(t))
        }, new Map());
        this._model.endMovingSources(false);
      }
      dataAndViewsReady() {
        return this._source.dataAndViewsReady();
      }
      zorder() {
        return this._source.zorder();
      }
      symbol() {
        return this._source.properties().symbol.value();
      }
      currency() {
        return this._source.properties().currencyId.value();
      }
      unit() {
        return this._source.properties().unitId.value();
      }
      share(e) {
        this._undoModel.shareLineTools([this._source], e);
      }
      setVisible(e, t = false) {
        this._undoModel.setProperty(this._source.properties().visible, e, null, t);
      }
      sharingMode() {
        return this._source.sharingMode().value();
      }
      lineDataSource() {
        return this._source;
      }
      template() {
        return this._source.template();
      }
    }
    class Lf {
      constructor(e, t) {
        this._series = e;
        this._undoModel = t;
        this._model = t.model();
      }
      isUserEditEnabled() {
        return this._series.userEditEnabled();
      }
      setUserEditEnabled(e) {
        this._series.setUserEditEnabled(e);
      }
      mergeUp() {
        if (this._model.isMergeUpAvailableForSource(this._series)) {
          new na(this._model, this._series, null).redo();
        }
      }
      mergeDown() {
        if (this._model.isMergeDownAvailableForSource(this._series)) {
          new ra(this._model, this._series, null).redo();
        }
      }
      unmergeUp() {
        if (this._model.isUnmergeAvailableForSource(this._series)) {
          new ia(this._model, this._series, null).redo();
        }
      }
      unmergeDown() {
        if (this._model.isUnmergeAvailableForSource(this._series)) {
          new ta(this._model, this._series, null).redo();
        }
      }
      mergeUpWithUndo() {
        if (this._model.isMergeUpAvailableForSource(this._series)) {
          this._undoModel.mergeSourceUp(this._series);
        }
      }
      mergeDownWithUndo() {
        if (this._model.isMergeDownAvailableForSource(this._series)) {
          this._undoModel.mergeSourceDown(this._series);
        }
      }
      unmergeUpWithUndo() {
        if (this._model.isUnmergeAvailableForSource(this._series)) {
          this._undoModel.unmergeSourceUp(this._series);
        }
      }
      unmergeDownWithUndo() {
        if (this._model.isUnmergeAvailableForSource(this._series)) {
          this._undoModel.unmergeSourceDown(this._series);
        }
      }
      detachToRight() {
        new Zl(this._model, this._series, this._pane(), "right", null).redo();
      }
      detachToLeft() {
        new Zl(this._model, this._series, this._pane(), "left", null).redo();
      }
      detachNoScale() {
        new Zl(this._model, this._series, this._pane(), "overlay", null).redo();
      }
      changePriceScale(e) {
        const t = (0, n.ensureNotNull)(this._model.paneForSource(this._series));
        switch (e) {
          case "new-left":
            new Zl(this._model, this._series, t, "left", null).redo();
            break;
          case "new-right":
            new Zl(this._model, this._series, t, "right", null).redo();
            break;
          case "no-scale":
            (0, n.assert)(t.actionNoScaleIsEnabled(this._series), "Unable to leave a pane without any non-overlay price scale");
            new Zl(this._model, this._series, t, "overlay", null).redo();
            break;
          default:
            const i = this._model.dataSourceForId(e);
            if (i === null) {
              throw new Error(`There is no study with entityId='${e}'`);
            }
            const s = this._model.paneForSource(i) === t;
            (0, n.assert)(s, "Study should be on the main pane");
            const o = (0, n.ensureNotNull)(i.priceScale());
            new Xl(this._model, this._series, t, o, null).redo();
        }
      }
      isVisible() {
        return this._series.properties().childs().visible.value();
      }
      setVisible(e) {
        this._series.properties().childs().visible.setValue(e);
      }
      bringToFront() {
        this._model.bringToFront([this._series]);
      }
      sendToBack() {
        this._model.sendToBack([this._series]);
      }
      entityId() {
        return this._series.id();
      }
      chartStyleProperties(e, t) {
        if (t) {
          return this._series.properties().childs()[kf(e)].state();
        } else {
          return this._series.properties().childs()[kf(e)].state(["inputs", "inputsInfo"]);
        }
      }
      setChartStyleProperties(e, t) {
        this._series.properties().childs()[kf(e)].mergeAndFire(t);
      }
      barsCount() {
        return this._series.bars().size();
      }
      endOfData() {
        return this._series.endOfData();
      }
      symbolSource() {
        return {
          symbol: this._series.symbol(),
          currencyId: this._series.currency(),
          unitId: this._series.unit()
        };
      }
      isLoading() {
        return this._series.isLoading();
      }
      isInReplay() {
        return this._series.isInReplay();
      }
      data() {
        return this._series.data();
      }
      priceScale() {
        return new pf(this._undoModel, this._series.priceScale());
      }
      seriesErrorMessage() {
        return this._series.seriesErrorMessage();
      }
      compositeStatusVW() {
        return this._series.compositeStatusVW();
      }
      properties() {
        return this._series.properties();
      }
      lastConfirmedBarUTCTime() {
        return this._series.bars().last()?.value[0] ?? null;
      }
      _pane() {
        return (0, n.ensureNotNull)(this._model.paneForSource(this._series));
      }
    }
    function kf(e) {
      switch (e) {
        case 0:
          return "barStyle";
        case 1:
          return "candleStyle";
        case 2:
          return "lineStyle";
        case 14:
          return "lineWithMarkersStyle";
        case 15:
          return "steplineStyle";
        case 3:
          return "areaStyle";
        case 16:
          return "hlcAreaStyle";
        case 4:
          return "renkoStyle";
        case 5:
          return "kagiStyle";
        case 6:
          return "pnfStyle";
        case 7:
          return "pbStyle";
        case 8:
          return "haStyle";
        case 9:
          return "hollowCandleStyle";
        case 10:
          return "baselineStyle";
        case 11:
          return "rangeStyle";
        case 12:
          return "hiloStyle";
        case 13:
          return "columnStyle";
        case 17:
          return "volFootprintStyle";
        case 18:
          return "tpoStyle";
        case 19:
          return "volCandlesStyle";
        case 20:
          return "svpStyle";
        case 21:
          return "hlcBarsStyle";
        default:
          (0, n.ensureNever)(e);
      }
      throw new Error(`unsupported chart style: ${e}`);
    }
    var Df = i(32112);
    function Ef(e, t) {
      const {
        symbolChanged: i,
        currencyChanged: s,
        unitChanged: o,
        styleChangeRequiresRestart: n
      } = e.compareSymbolParams(t);
      return !i && !s && !o && !n;
    }
    function Bf(e, t) {
      if (!e.isLoading() || !!e.isFailed()) {
        t(e.isFailed());
      }
      const i = e.seriesSource().symbolInstanceId();
      const s = e.dataEvents();
      const o = e.symbolParams();
      const n = () => {
        s.completed().unsubscribe(null, r);
        if (Ef(e, o) || e.seriesSource().symbolInstanceId() === i) {
          t(false);
        }
      };
      const r = () => {
        s.error().unsubscribe(null, n);
        if (Ef(e, o) || e.seriesSource().symbolInstanceId() === i) {
          t(true);
        }
      };
      s.completed().subscribe(null, n, true);
      s.error().subscribe(null, r, true);
    }
    class Vf {
      constructor(e, t) {
        this._controller = e;
        this._model = t;
      }
      createGroupFromSelection() {
        return this._controller.createGroupFromSelection().id;
      }
      removeGroup(e) {
        const t = (0, n.ensureDefined)(this._groupById(e));
        this._controller.removeGroup(t);
      }
      groups() {
        return this._controller.groups().map(e => e.id);
      }
      shapesInGroup(e) {
        const t = (0, n.ensureDefined)(this._groupById(e));
        return (0, ci.sortSources)(t.lineTools()).map(e => e.id());
      }
      excludeShapeFromGroup(e, t) {
        const i = (0, n.ensureDefined)(this._groupById(e));
        const s = (0, n.ensureNotNull)(this._model.dataSourceForId(t));
        (0, n.assert)((0, eo.isLineTool)(s), "Passed shapeId is not a line tool");
        this._controller.excludeLineToolFromGroup(i, s);
      }
      addShapeToGroup(e, t) {
        const i = (0, n.ensureDefined)(this._groupById(e));
        const s = (0, n.ensureNotNull)(this._model.dataSourceForId(t));
        (0, n.assert)((0, eo.isLineTool)(s), "Passed shapeId is not a line tool");
        this._controller.addLineToolToGroup(i, s);
      }
      availableZOrderOperations(e) {
        const t = (0, n.ensureDefined)(this._groupById(e));
        return this._controller.availableZOrderOperations(t);
      }
      bringToFront(e) {
        const t = (0, n.ensureDefined)(this._groupById(e));
        this._controller.bringToFront(t);
      }
      bringForward(e) {
        const t = (0, n.ensureDefined)(this._groupById(e));
        this._controller.bringForward(t);
      }
      sendBackward(e) {
        const t = (0, n.ensureDefined)(this._groupById(e));
        this._controller.sendBackward(t);
      }
      sendToBack(e) {
        const t = (0, n.ensureDefined)(this._groupById(e));
        this._controller.sendToBack(t);
      }
      insertAfter(e, t) {
        const i = (0, n.ensureDefined)(this._groupById(e));
        const s = (0, n.ensureNotNull)(this._groupById(t) || this._model.dataSourceForId(t));
        this._controller.insertAfter(i, s);
      }
      insertBefore(e, t) {
        const i = (0, n.ensureDefined)(this._groupById(e));
        const s = (0, n.ensureNotNull)(this._groupById(t) || this._model.dataSourceForId(t));
        this._controller.insertBefore(i, s);
      }
      groupVisibility(e) {
        return (0, n.ensureDefined)(this._groupById(e)).visibility();
      }
      setGroupVisibility(e, t) {
        const i = (0, n.ensureDefined)(this._groupById(e));
        this._controller.setGroupVisibility(i, t);
      }
      groupLock(e) {
        return (0, n.ensureDefined)(this._groupById(e)).locked();
      }
      setGroupLock(e, t) {
        const i = (0, n.ensureDefined)(this._groupById(e));
        this._controller.setGroupLock(i, t);
      }
      getGroupName(e) {
        return (0, n.ensureDefined)(this._groupById(e)).name().value();
      }
      setGroupName(e, t) {
        const i = (0, n.ensureDefined)(this._groupById(e));
        this._controller.setGroupName(i, t);
      }
      canBeGroupped(e) {
        const t = e.map(e => (0, n.ensureNotNull)(this._model.dataSourceForId(e)));
        return !t.some(e => !(0, eo.isLineTool)(e)) && this._controller.canBeGroupped(t);
      }
      _groupById(e) {
        return this._controller.groups().find(t => t.id === e);
      }
    }
    var Rf = i(76032);
    const Nf = new Di.TranslatedString("change price to bar ratio", a.t(null, undefined, i(2509)));
    const Of = new Di.TranslatedString("toggle lock scale", a.t(null, undefined, i(49695)));
    function Ff(e, t) {
      return t.map(t => (0, n.ensureNotNull)(e.dataSourceForId(t)));
    }
    class Wf {
      constructor(e, t) {
        this._visibleBarsChanged = new re.Delegate();
        this._crosshairMoved = new re.Delegate();
        this._dataSourceHovered = new re.Delegate();
        this._ranges = null;
        this._panes = new WeakMap();
        this._studies = new WeakMap();
        this._lineDataSources = new WeakMap();
        this._selectionApi = null;
        this._lollipopSourcesApi = null;
        this._prevVisibleRange = null;
        this._prevHoveredSourceId = null;
        this._chartWidget = e;
        this._activateChart = t;
        this._timezoneApi = new _f(e);
        this._chartWidget.withModel(this, () => {
          this._chartWidget.model().crosshairSource().moved().subscribe(this, this._onCrosshairMoved);
          this._chartWidget.model().model().hoveredSourceChanged().subscribe(this, this._onHoveredSourceChanged);
          this._chartWidget.model().timeScale().logicalRangeChanged().subscribe(this, this._onLogicalRangeChanged);
        });
        this._widgetLinkingGroupIndex = e.linkingGroupIndex().spawn();
        this._widgetLinkingGroupIndex.subscribe(e => this._apiLinkingGroupIndex.setValue(e));
        this._apiLinkingGroupIndex = new F.WatchedValue(this._widgetLinkingGroupIndex.value());
        this._apiLinkingGroupIndex.subscribe(e => {
          if (this._widgetLinkingGroupIndex.value() !== e) {
            if (this._chartWidget.hasModel()) {
              this._chartWidget.model().setLinkingGroupIndex(e);
            } else {
              this._widgetLinkingGroupIndex.setValue(e);
            }
          }
        });
        this._chartWidget.onAboutToBeDestroyed().subscribe(this, this._destroy, true);
      }
      setActive() {
        this._activateChart();
      }
      getPriceToBarRatio() {
        return this._chartWidget.model().model().mainSeriesScaleRatioProperty().value();
      }
      setPriceToBarRatio(e, t) {
        const i = this._chartWidget.model();
        const s = i.model();
        const o = s.mainSeriesScaleRatioProperty();
        if (t?.disableUndo) {
          new H_(o, e, null, s).redo();
        } else {
          i.setScaleRatioProperty(o, e, Nf);
        }
      }
      isPriceToBarRatioLocked() {
        return this._chartWidget.model().model().mainSeries().priceScale().isLockScale();
      }
      setPriceToBarRatioLocked(e, t) {
        const i = this._chartWidget.model();
        const s = i.model();
        const o = s.mainSeries().priceScale();
        if (t?.disableUndo) {
          new lc({
            lockScale: e
          }, o, null, s).redo();
        } else {
          i.setPriceScaleMode({
            lockScale: e
          }, o, Of);
        }
      }
      id() {
        return this._chartWidget.id();
      }
      onDataLoaded() {
        return this._makeSubscriptionFromDelegate(this._chartWidget.model().mainSeries().dataEvents().completed());
      }
      onSymbolChanged() {
        return this._makeSubscriptionFromDelegate(this._chartWidget.model().mainSeries().dataEvents().symbolResolved());
      }
      onIntervalChanged() {
        return this._makeSubscriptionFromDelegate(this._chartWidget.model().mainSeries().onIntervalChanged());
      }
      onVisibleRangeChanged() {
        return this._makeSubscriptionFromDelegate(this._visibleBarsChanged);
      }
      onChartTypeChanged() {
        const e = this._chartWidget.model().mainSeries().onStyleChanged();
        return this._makeSubscriptionFromDelegate(e);
      }
      onSeriesTimeframe() {
        return this._makeSubscriptionFromDelegate(this._chartWidget.model().mainSeries().dataEvents().seriesTimeFrame());
      }
      onSeriesError() {
        return this._makeSubscriptionFromDelegate(this._chartWidget.model().mainSeries().dataEvents().seriesError());
      }
      dataReady(e) {
        const t = !this._chartWidget.hasModel() || !this._chartWidget.model().mainSeries() || this._chartWidget.model().mainSeries().data().isEmpty();
        if (e) {
          if (t) {
            this.onDataLoaded().subscribe(null, e, true);
          } else {
            e();
          }
        }
        return !t;
      }
      whenChartReady(e) {
        this._chartWidget.withModel(this, e);
      }
      crossHairMoved() {
        return this._makeSubscriptionFromDelegate(this._crosshairMoved);
      }
      onHoveredSourceChanged() {
        return this._makeSubscriptionFromDelegate(this._dataSourceHovered);
      }
      setVisibleRange(e, t) {
        return new Promise((i, s) => {
          const o = e => {
            clearTimeout(n);
            s(e);
          };
          const n = setTimeout(() => o(new Error("Rejected by timeout")), t?.rejectByTimeout ?? 10000);
          this._chartWidget.setVisibleTimeRange(e.from, e.to, t, () => {
            clearTimeout(n);
            i();
          }, o);
        });
      }
      async setSymbol(e, t) {
        if ((0, dt.isFunction)(t)) {
          t = {
            dataReady: t
          };
        }
        const {
          dataReady: i,
          doNotActivateChart: s
        } = t || {};
        if (e === this.symbol() || this._chartWidget.hasModel() && this._chartWidget.model().mainSeries().symbolSameAsResolved(e)) {
          i?.();
          return true;
        }
        if (!s) {
          this._activateChart();
        }
        const o = await this._chartWidget.chartWidgetCollection().setSymbol(e, undefined, this._chartWidget);
        if (o) {
          Bf(this._chartWidget.model().mainSeries(), e => {
            if (!e && i) {
              i();
            }
          });
        }
        return o;
      }
      async setResolution(e, t) {
        if ((0, dt.isFunction)(t)) {
          t = {
            dataReady: t
          };
        }
        const {
          dataReady: i,
          doNotActivateChart: s
        } = t || {};
        const o = Re.Interval.normalize(e);
        if (o === null || o === this.resolution()) {
          i?.();
          return true;
        }
        if (!s) {
          this._activateChart();
        }
        const n = await this._chartWidget.chartWidgetCollection().setResolution(o, undefined, this._chartWidget);
        if (n) {
          Bf(this._chartWidget.model().mainSeries(), e => {
            if (!e && i) {
              i();
            }
          });
        }
        return n;
      }
      async setChartType(e, t) {
        if (this._chartWidget.model().mainSeries().properties().childs().style.value() === e) {
          t?.();
          return true;
        }
        const i = this._chartWidget.chartWidgetCollection().setChartStyleToWidget(e, this._chartWidget);
        Bf(this._chartWidget.model().mainSeries(), e => {
          if (!e && t) {
            t();
          }
        });
        return i;
      }
      resetData() {
        this._chartWidget.model().mainSeries().rerequestData();
      }
      executeActionById(e) {
        this._chartWidget.executeActionById(e);
      }
      getCheckableActionState(e) {
        return this._chartWidget.getCheckableActionState(e);
      }
      refreshMarks() {
        this._chartWidget.refreshMarks();
      }
      clearMarks(e) {
        this._chartWidget.clearMarks(e);
      }
      getBarsMarksSources() {
        return this._chartWidget.model().barsMarksSources();
      }
      getAllShapes() {
        return this._chartWidget.model().model().allLineTools().map(mf).filter(e => e.name !== null);
      }
      getAllStudies() {
        return this._chartWidget.model().model().allStudies(true).map(gf);
      }
      getStudyTemplateSnapshot(e, t, i) {
        return (0, Rf.getStudyTemplateSaveData)(e, this._chartWidget.model().model(), t, i);
      }
      getStudyTemplateDescString() {
        const e = (0, Rf.getStudyTemplateMetaInfo)(this._chartWidget.model().model());
        return (0, Rf.getStudyTemplateDescString)(e.indicators);
      }
      applyStudyTemplateByRecord(e) {
        if (!e) {
          return;
        }
        const t = t => this._chartWidget.model().applyStudyTemplate(JSON.parse(t.content), e.name);
        if (e.is_default) {
          j.backend.getStandardStudyTemplateById(e.id, t);
        } else {
          j.backend.getStudyTemplateById(e.id).then(t);
        }
      }
      chartTemplate() {
        return this._chartWidget.model().model().template();
      }
      applyChartTempalte(e) {
        this._chartWidget.chartWidgetCollection().applyTheme(e);
      }
      getAllPanesHeight() {
        const e = this._chartWidget.model().model().panes();
        if (this._chartWidget.hasMaximizedPane()) {
          let t = 0;
          let i = 0;
          e.forEach(e => {
            t += e.height();
            i += e.stretchFactor();
          });
          const s = i / t;
          return e.map(e => Math.round(e.stretchFactor() / s * 100) / 100);
        }
        return e.map(e => e.height());
      }
      setAllPanesHeight(e) {
        const t = this._chartWidget.model().model();
        const i = t.panes();
        (0, n.assert)(i.length === e.length, "There`s a mismatch between the number of heights you provided and the number of panes.");
        const s = i.reduce((e, t) => e + t.stretchFactor(), 0) / e.reduce((e, t) => e + t);
        e.forEach((e, t) => {
          const o = e * s;
          i[t].setStretchFactor(o);
        });
        t.fullUpdate();
      }
      maximizeChart() {
        this._chartWidget.requestFullscreen();
      }
      isMaximized() {
        return this._chartWidget.inFullscreen();
      }
      restoreChart() {
        this._chartWidget.exitFullscreen();
      }
      restoreChartPreferences() {
        this._chartWidget.model().restorePreferences();
      }
      availableZOrderOperations(e) {
        const t = Ff(this._chartWidget.model().model(), e);
        return this._chartWidget.model().availableZOrderOperations(t);
      }
      sendToBack(e) {
        const t = Ff(this._chartWidget.model().model(), e);
        this._chartWidget.model().sendToBack(t);
      }
      bringToFront(e) {
        const t = Ff(this._chartWidget.model().model(), e);
        this._chartWidget.model().bringToFront(t);
      }
      bringForward(e) {
        const t = Ff(this._chartWidget.model().model(), e);
        this._chartWidget.model().bringForward(t);
      }
      sendBackward(e) {
        const t = Ff(this._chartWidget.model().model(), e);
        this._chartWidget.model().sendBackward(t);
      }
      insertAfter(e, t) {
        const i = this._chartWidget.model().model();
        const s = Ff(i, e);
        const o = (0, n.ensureNotNull)(i.dataSourceForId(t));
        this._chartWidget.model().insertAfter(s, o);
      }
      insertBefore(e, t) {
        const i = this._chartWidget.model().model();
        const s = Ff(i, e);
        const o = (0, n.ensureNotNull)(i.dataSourceForId(t));
        this._chartWidget.model().insertBefore(s, o);
      }
      sessions() {
        return this._chartWidget.model().model().sessions()?.get() ?? null;
      }
      chartModel() {
        return this._chartWidget.model().model();
      }
      chartUndoModel() {
        return this._chartWidget.model();
      }
      chartWidget() {
        return this._chartWidget;
      }
      getTimeScaleLogicalRange() {
        return this._chartWidget.model().timeScale().logicalRange();
      }
      setEntityVisibility(e, t) {
        console.warn("`setEntityVisibility` is deprecated. Use shape/study API instead");
        const i = this._chartWidget.model().model().dataSourceForId(e);
        if (!i) {
          return;
        }
        const s = i.properties();
        if (s && s.visible) {
          s.visible.setValue(t);
        }
      }
      async createStudy(e, t, i, s, o, n) {
        if (typeof o == "function") {
          console.warn("\"createStudy\" does not take \"callback\" parameter anymore");
          return Promise.resolve(null);
        }
        n = n || {};
        if (typeof e != "string") {
          return this._createStudy(e);
        }
        e = e.toLowerCase();
        const r = await (0, ts.studyMetaInfoRepository)().findAllJavaStudies();
        const a = is.StudyMetaInfo.findStudyMetaInfoByDescription(r, e);
        if (n.checkLimit) {
          const e = this._chartWidget.model().canCreateStudy({
            id: a.id
          });
          if (!e.success) {
            (0, Ar.showTooManyStudiesNotice)(e.limitValue);
            return Promise.resolve(null);
          }
        }
        const l = (n.disableUndo ? this._chartWidget.model().model() : this._chartWidget.model()).createStudyInserter({
          type: "java",
          studyId: a.id
        }, []);
        l.setForceOverlay(!!t);
        if (n.priceScale) {
          l.setPreferredPriceScale(function (e) {
            switch (e) {
              case "no-scale":
                return "overlay";
              case "as-series":
                return "as-series";
              case "new-left":
                return "left";
              case "new-right":
                return "right";
              default:
                throw new Error(`The pricescale "${e}" is invalid, the only valid options are "no-scale", "as-series", "new-left" and "new-right".`);
            }
          }(n.priceScale));
        }
        if (n.allowChangeCurrency) {
          l.setAllowChangeCurrency(true);
        }
        if (n.allowChangeUnit) {
          l.setAllowChangeUnit(true);
        }
        if (Array.isArray(s)) {
          console.warn("Passing study inputs as an ordered array is now deprecated. Please use an object where keys correspond to the inputs of your study instead.");
          const e = {};
          for (let t = 0; t < a.inputs.length; ++t) {
            e[a.inputs[t].id] = s[t];
          }
          s = e;
        }
        return l.insert(() => Promise.resolve({
          inputs: s || {},
          parentSources: []
        })).then(e => {
          if (o) {
            (0, cf.applyOverridesToStudy)(e, o);
          }
          if (i) {
            e.setUserEditEnabled(false);
          }
          return e.id();
        });
      }
      waitForStudyCreated(e) {
        return this._chartWidget.model().model().waitForStudy(e);
      }
      compileFailedStudies() {
        return this._chartWidget.model().model().studiesWV().value().filter(e => e.isPine() && e.hasCompileError());
      }
      getStudyById(e) {
        const t = this._chartWidget.model().model().getStudyById(e);
        if (t === null) {
          throw new Error("There is no such study");
        }
        return this._getStudyApi(t);
      }
      getSeries() {
        const e = this._chartWidget.model();
        const t = e.mainSeries();
        return new Lf(t, e);
      }
      createShape(e, t) {
        return this.createMultipointShape([e], t);
      }
      async createMultipointShape(e, t) {
        const i = () => new Error(`Cannot create "${s.shape}" shape`);
        const s = Object.assign({}, {
          filled: true
        }, t);
        const o = af[s.shape] || af.flag;
        const r = this._chartWidget.model().model();
        const a = r.mainSeries();
        if (r.timeScale().isEmpty()) {
          throw i();
        }
        const l = s.ownerStudyId !== undefined ? r.dataSourceForId(s.ownerStudyId) ?? a : a;
        const c = r.paneForSource(l);
        const h = this._convertUserPointsToDataSource(e);
        if (h === null || c === null) {
          throw i();
        }
        if (o.onlySelectable) {
          throw new Error(`Cannot create "${s.shape}" shape`);
        }
        if (o.name === "LineToolIcon") {
          const e = s;
          e.icon = e.icon || e.overrides && e.overrides.icon;
          if (!s.hasOwnProperty("icon")) {
            throw new Error("icon must be specified in options");
          }
          e.overrides = e.overrides || {};
          e.overrides.icon = e.icon;
        }
        await (0, Ro.ensureLineToolLoaded)(o.name);
        const d = (0, eo.createLineToolProperties)(r.backgroundTheme().spawnOwnership(), o.name, !r.readOnly());
        (0, eo.prepareLineToolPropertiesByOwnerSource)(d, l);
        if (s.overrides) {
          for (const e in s.overrides) {
            if (d.hasChild(e)) {
              (0, n.ensureDefined)(d.child(e)).mergeAndFire(s.overrides[e]);
            } else if (If(o.name) && ["profitLevel", "stopLevel"].indexOf(e) !== -1) {
              d.addProperty(e, s.overrides[e]);
            }
          }
        }
        let u;
        if (d.hasChild("text") !== undefined && s.text) {
          (0, n.ensureDefined)(d.child("text")).setValue(s.text);
        }
        if (d.hasChild("filled") && s.filled) {
          (0, n.ensureDefined)(d.child("filled")).setValue(true);
        }
        u = s.disableUndo ? this._chartWidget.model().model() : this._chartWidget.model();
        const _ = u.createLineTool({
          pane: c,
          point: h[0],
          linetool: o.name,
          properties: d,
          ownerSource: l
        });
        if (_ === null) {
          d.destroy();
          throw i();
        }
        if (_.properties() !== d) {
          d.destroy();
        }
        if (If(o.name)) {
          if (h.length > 2) {
            throw new Error(`Wrong points count for ${s.shape}. Required 1 or 2`);
          }
          if (h.length === 2) {
            _.startChanging(1, h[1]);
            _.setPoint(1, h[1]);
            _.endChanging(true, false);
          }
        } else {
          const e = _.pointsCount();
          if (e !== h.length && e !== -1) {
            throw new Error(`Wrong points count for ${s.shape}. Required ${e}`);
          }
          const t = new Bo.EnvironmentState(undefined, true);
          const i = (0, wt.isLineDrawnWithPressedButton)(o.name);
          for (let e = 1; e < h.length && this._chartWidget.model().lineBeingCreated(); e++) {
            _.setLastPoint(h[e]);
            u.continueCreatingLine(h[e], t, e < h.length - 1 || i);
          }
          if ((0, wt.isLineToolFinishRequiredWhenCreatedByApi)(o.name)) {
            _.finish();
            u.finishLineTool(_);
            u.continueCreatingLine(h[h.length - 1], t, false);
          }
        }
        if (s.lock) {
          _.setUserEditEnabled(false);
        }
        if (s.disableSelection) {
          _.setSelectionEnabled(false);
        }
        if (s.disableSave) {
          if (_.customization === undefined) {
            _.customization = {};
          }
          _.customization.disableSave = true;
        }
        if (s.hasOwnProperty("showInObjectsTree")) {
          if (_.customization === undefined) {
            _.customization = {};
          }
          _.customization.showInObjectsTree = s.showInObjectsTree;
        }
        if (s.zOrder) {
          const e = this._chartWidget.model().availableZOrderOperations([_]);
          if (s.zOrder === "top" && e.bringToFrontEnabled) {
            u.bringToFront([_]);
          } else if (s.zOrder === "bottom" && e.sendToBackEnabled) {
            u.sendToBack([_]);
          }
        }
        return _.id();
      }
      getShapeById(e) {
        const t = this._chartWidget.model().model().getLineToolById(e);
        if (t === null) {
          throw new Error("There is no such shape");
        }
        return this._getLineDataSourceApi(t);
      }
      removeEntity(e, t) {
        const i = this._chartWidget.model().model().dataSourceForId(e);
        if (i) {
          if (t && t.disableUndo) {
            new Yr.RemoveSourcesUndoCommand(this._chartWidget.model().model(), [i], null).redo();
          } else {
            this._chartWidget.model().removeSource(i, true, true);
          }
        } else {
          console.warn(`Can't find a source with id: ${e}`);
        }
      }
      removeEntityWithUndo(e) {
        const t = this._chartWidget.model().model().dataSourceForId(e);
        if (t) {
          this._chartWidget.model().removeSource(t, false);
        }
      }
      removeAllShapes() {
        this._chartWidget.removeAllDrawingTools();
      }
      removeAllStudies() {
        this._chartWidget.removeAllStudies();
      }
      selection() {
        if (this._selectionApi === null) {
          this._selectionApi = new Df.SelectionApi(this._chartWidget.model().model());
        }
        return this._selectionApi;
      }
      showPropertiesDialog(e) {
        const t = this._chartWidget.model().model().dataSourceForId(e);
        if (t === null) {
          throw new Error(`Study or shape ${e} does not exist`);
        }
        this._chartWidget.showChartPropertiesForSource(t);
      }
      createStudyTemplate(e) {
        return this._chartWidget.model().model().studyTemplate(e.saveSymbol, e.saveInterval);
      }
      applyStudyTemplate(e) {
        this._chartWidget.model().applyStudyTemplate(e, "" + Math.random() * 1000);
      }
      drawOnAllCharts(e) {
        (0, lt.drawOnAllCharts)().setValue(e);
      }
      createOrderLine() {
        throw new Error("createOrderLine is only available on Trading Platform");
      }
      createPositionLine() {
        throw new Error("createPositionLine is only available on Trading Platform");
      }
      createExecutionShape() {
        throw new Error("createExecutionShape is only available on Trading Platform");
      }
      symbol() {
        return this._chartWidget.symbolWV().value();
      }
      symbolExt() {
        const e = this._chartWidget.model().mainSeries().symbolInfo();
        if (e === null) {
          return null;
        }
        const t = ((e, t) => {
          const i = {};
          t.forEach(t => {
            if (e[t] !== undefined) {
              i[t] = e[t];
            }
          });
          return i;
        })(e, ["name", "base_name", "ticker", "description", "long_description", "type", "session", "session_display", "session_holidays", "corrections", "exchange", "exchange", "listed_exchange", "timezone", "format", "pricescale", "minmov", "fractional", "minmove2", "variable_tick_size", "has_intraday", "supported_resolutions", "intraday_multipliers", "has_seconds", "has_ticks", "seconds_multipliers", "has_daily", "daily_multipliers", "has_weekly_and_monthly", "weekly_multipliers", "monthly_multipliers", "has_empty_bars", "visible_plots_set", "volume_precision", "data_status", "delay", "expired", "expiration_date", "sector", "industry", "currency_code", "original_currency_code", "unit_id", "original_unit_id", "unit_conversion_types", "subsession_id", "subsessions", "price_source_id", "price_sources", "logo_urls", "exchange_logo", "pro_name", "library_custom_fields"]);
        t.pro_name = e.pro_name;
        return t;
      }
      resolution() {
        return this._chartWidget.model().mainSeries().interval();
      }
      marketStatus() {
        return this._chartWidget.model().mainSeries().marketStatusModel().currentSession().spawn();
      }
      getVisibleRange() {
        const e = {
          from: 0,
          to: 0
        };
        const t = this._chartWidget.model().timeScale();
        const i = t.visibleBarsStrictRange();
        if (i === null) {
          return e;
        }
        const s = i.firstBar();
        const o = i.lastBar();
        const r = this._convertIndexToPublicTime(o);
        if (r === null) {
          return e;
        }
        const a = Math.max((0, n.ensureNotNull)(t.points().range().value()).firstIndex, s);
        e.from = (0, n.ensureNotNull)(this._convertIndexToPublicTime(a));
        e.to = r;
        return e;
      }
      getVisiblePriceRange() {
        console.warn("`getVisiblePriceRange` is deprecated. Use Price Scale API instead");
        if (!this._chartWidget.model().mainSeries()) {
          return null;
        }
        return this._chartWidget.model().mainSeries().priceScale().priceRangeInPrice();
      }
      scrollPosition() {
        console.warn("`scrollPosition` is deprecated. Use rightOffset from Time Scale API instead");
        return this._chartWidget.model().timeScale().rightOffset();
      }
      defaultScrollPosition() {
        console.warn("`defaultScrollPosition` is deprecated. Use defaultRightOffset from Time Scale API instead");
        return this._chartWidget.model().timeScale().defaultRightOffset().value();
      }
      priceFormatter() {
        return this._chartWidget.model().mainSeries().priceScale().formatter();
      }
      chartType() {
        return this._chartWidget.model().mainSeries().properties().childs().style.value();
      }
      setTimezone(e) {
        this._chartWidget.setTimezone(e);
      }
      getTimezone() {
        return this._chartWidget.getTimezone();
      }
      getTimezoneApi() {
        return this._timezoneApi;
      }
      getPanes() {
        return this._chartWidget.model().model().panes().map(e => this._getPaneApi(e));
      }
      exportData(e) {
        if (!l.enabled("charting_library_export_chart_data")) {
          return Promise.reject("Data export is not supported");
        }
        const t = {
          ...e
        };
        if (t.from !== undefined) {
          t.from = this._convertTimeFromPublic(t.from);
        }
        if (t.to !== undefined) {
          t.to = this._convertTimeFromPublic(t.to);
        }
        return i.e(9498).then(i.bind(i, 99992)).then(e => e.exportData(this._chartWidget.model().model(), t));
      }
      setDragExportEnabled(e) {
        if (l.enabled("chart_drag_export")) {
          this._chartWidget.model().model().setDragExportEnabled(e);
        } else {
          console.error("feature is not enabled");
        }
      }
      canZoomOut() {
        return !this._chartWidget.model().zoomStack().isEmpty();
      }
      zoomOut() {
        if (this.canZoomOut()) {
          this._chartWidget.model().zoomFromViewport();
        }
      }
      setZoomEnabled(e) {
        this._chartWidget.model().model().setZoomEnabled(e);
      }
      setScrollEnabled(e) {
        this._chartWidget.model().model().setScrollEnabled(e);
      }
      shapesGroupController() {
        return new Vf(this._chartWidget.model().lineToolsGroupController(), this._chartWidget.model().model());
      }
      isSelectBarRequested() {
        return this._chartWidget.selectPointMode().value() !== lt.SelectPointMode.None;
      }
      requestSelectBar() {
        if (this.isSelectBarRequested()) {
          return Promise.reject("already requested");
        } else {
          return new Promise((e, t) => {
            this._chartWidget.requestSelectPoint({
              pointType: "time"
            }).then(t => {
              e(this._convertTimeToPublic((0, n.ensureDefined)(t.point.time)));
            }).catch(() => {
              t("cancelled");
            });
          });
        }
      }
      cancelSelectBar() {
        if (this.isSelectBarRequested()) {
          this._chartWidget.cancelRequestSelectPoint();
        }
      }
      barTimeToEndOfPeriod(e) {
        const t = this._prepareEndOfPeriodArgs();
        return (0, hf.barTimeToEndOfPeriod)(t.barBuilder, e, t.intervalObj);
      }
      endOfPeriodToBarTime(e) {
        const t = this._prepareEndOfPeriodArgs();
        return (0, hf.endOfPeriodToBarTime)(t.barBuilder, e, t.intervalObj);
      }
      createAnchoredShape(e, t) {
        const i = () => new Error(`Cannot create "${t.shape}" shape`);
        const s = t.shape;
        if (rf(s) && af[s].isAnchored !== true) {
          console.warn(`${s} is not an anchored shape. It can be created using createShape or createMultipointShape`);
          throw i();
        }
        const o = this._chartWidget.model().model();
        const n = o.mainSeries();
        if (o.timeScale().isEmpty()) {
          throw i();
        }
        const r = t.ownerStudyId !== undefined ? o.dataSourceForId(t.ownerStudyId) : n;
        const a = this._convertPositionPercentToPricedPoint(e, r);
        if (a === null) {
          throw i();
        }
        return this.createMultipointShape([a], t);
      }
      properties() {
        return this._chartWidget.properties();
      }
      setBarSpacing(e) {
        this._chartWidget.model().timeScale().setBarSpacing(e);
      }
      scrollChartByBar(e) {
        this._chartWidget.model().scrollChartByBar(e);
      }
      mergeAllScales(e) {
        this._chartWidget.model().mergeAllScales(e);
      }
      chartPainted() {
        return this._chartWidget.chartPainted();
      }
      applyOverrides(e) {
        this._chartWidget.applyOverrides(e);
      }
      addOverlayStudy(e, t, i) {
        return this._chartWidget.addOverlayStudy(e, t, i);
      }
      lineToolsSynchronizer() {
        return this._chartWidget.lineToolsSynchronizer();
      }
      cloneLineTool(e) {
        const t = this._chartWidget.model();
        const i = t.model().dataSourceForId(e);
        return t.cloneLineTools([i], false)[0];
      }
      shareLineTools(e, t) {
        const i = this._chartWidget.model();
        const s = e.map(e => i.model().dataSourceForId(e));
        i.shareLineTools(s, t);
      }
      getLollipopSourcesApi() {
        throw new Error("getLollipopSourcesApi is not supported");
      }
      clickAtLatestUpdatesLollipop() {
        throw new Error("clickAtLatestUpdatesLollipop is not supported");
      }
      linkingGroupIndex() {
        return this._apiLinkingGroupIndex.spawn();
      }
      loadingScreenActive() {
        return this._chartWidget.screen.isShown();
      }
      symbolResolvingActive() {
        for (const e of this._chartWidget.model().model().symbolSources()) {
          if (e.symbolResolvingActive().value()) {
            return true;
          }
        }
        return false;
      }
      hasModel() {
        return this._chartWidget.hasModel();
      }
      disableAllUtilitySources() {
        0;
      }
      chartProto() {
        return Xm.prototype;
      }
      ranges() {
        throw new Error("not implemented");
      }
      getTimeScale() {
        return new df(this._chartWidget.model().timeScale());
      }
      async loadChartTemplate(e) {
        await (0, of.loadTheme)(this._chartWidget.chartWidgetCollection(), {
          themeName: e,
          standardTheme: false,
          noUndo: false,
          onlyActiveChart: true
        });
      }
      setTimeFrame(e) {
        this.setActive();
        this._chartWidget.loadRange(e);
      }
      async syncTime(e) {
        if (this._chartWidget.hasModel()) {
          const t = this._chartWidget.model().model();
          const i = t.mainSeries().syncModel();
          if (i) {
            return t.syncTimeWithModel(i.syncSourceTarget(), e);
          }
        }
      }
      syncDateRange(e, t) {
        if (this._chartWidget.hasModel()) {
          this._chartWidget.model().model().gotoTimeRange(e, t);
        }
      }
      getLineToolsState(e = 1, t, i) {
        this._canUseLineToolsSynchronizer("getLineToolsState");
        const s = i ?? true;
        const o = (0, n.ensureNotNull)(this.lineToolsSynchronizer()).getDTO(e, t, s);
        delete o.clientId;
        return o;
      }
      async applyLineToolsState(e) {
        this._canUseLineToolsSynchronizer("applyLineToolsState");
        await (0, n.ensureNotNull)(this.lineToolsSynchronizer()).applyDTO(e);
      }
      reloadLineToolsFromServer() {
        this._canUseLineToolsSynchronizer("reloadLineToolsFromServer");
        (0, n.ensureNotNull)(this.lineToolsSynchronizer()).reloadAllLineTools();
      }
      studyMetaIntoRepository() {
        return (0, ts.studyMetaInfoRepository)();
      }
      replayStatus() {
        return this._chartWidget.model().model().replayStatus();
      }
      replayStudyStrategyProperties() {
        return this._chartWidget.model().model().replayStudyStrategyProperties();
      }
      insertStudyWithoutCheck(e, t, i, s, o) {
        return this._chartWidget.model().insertStudyWithoutCheck(new is.StudyMetaInfo(e, o), t, i, s);
      }
      _destroy() {
        if (this._chartWidget.hasModel()) {
          this._chartWidget.model().crosshairSource().moved().unsubscribeAll(this);
          this._chartWidget.model().timeScale().logicalRangeChanged().unsubscribe(this, this._onLogicalRangeChanged);
        }
        this._widgetLinkingGroupIndex.destroy();
      }
      async _createTradingPrimitive(e) {
        const t = this._chartWidget.model();
        const i = t.model();
        const s = (0, n.ensureNotNull)(i.paneForSource(i.mainSeries()));
        await (0, Ro.ensureLineToolLoaded)(e);
        const o = {
          pane: s,
          point: (() => {
            const e = (0, n.ensureNotNull)(t.mainSeries().bars().last());
            return {
              index: e.index,
              price: e.value[4],
              interval: i.mainSeries().interval()
            };
          })(),
          linetool: e
        };
        return i.createLineTool(o).adapter();
      }
      _createStudy(e) {
        return Promise.reject("Pine Script™ and java studies are not supported");
      }
      _convertTimeToPublic(e) {
        return this._getTimeConverter().convertInternalTimeToPublicTime(e);
      }
      _convertIndexToPublicTime(e) {
        if (this._chartWidget.model().mainSeries().symbolInfo() === null) {
          return null;
        } else {
          return this._getTimeConverter().convertTimePointIndexToPublicTime(e);
        }
      }
      _convertPositionPercentToPricedPoint(e, t) {
        const i = this._chartWidget.model().timeScale();
        const s = t.priceScale();
        const o = t.firstValue();
        if (o == null || !isFinite(o) || s === null) {
          return null;
        }
        const n = i.coordinateToIndex(e.x * i.width());
        const r = i.indexToTimePoint(n);
        if (r === null) {
          return null;
        }
        return {
          price: s.coordinateToPrice(e.y * s.height(), o),
          time: r
        };
      }
      _convertUserPointsToDataSource(e) {
        const t = this._chartWidget.model().model();
        const i = t.mainSeries();
        const s = t.timeScale().points();
        const o = i.data();
        if (t.timeScale().isEmpty()) {
          return null;
        }
        const r = e.map(e => e.time || 0);
        const a = this._alignPoints(r);
        const l = (e, t, r) => {
          const a = s.closestIndexLeft(e) || 0;
          const l = {
            index: a,
            price: NaN
          };
          const c = (0, n.ensureNotNull)(s.valueAt(a));
          const h = (0, n.ensureNotNull)(s.range().value());
          if (e > c && a === h.lastIndex) {
            const t = (0, n.ensureNotNull)(i.syncModel()).distance(c, e);
            if (t.success) {
              l.index = l.index + t.result;
            }
          } else if (e < c && a === h.firstIndex) {
            const t = (0, n.ensureNotNull)(i.syncModel()).distance(e, c);
            if (t.success) {
              l.index = l.index - t.result;
            }
          }
          if ((0, dt.isNumber)(t)) {
            l.price = t;
          } else {
            let e = r ? ["open", "high", "low", "close"].indexOf(r) + 1 : 1;
            if (e <= 0) {
              e = 1;
            }
            l.price = (0, n.ensure)((0, n.ensureNotNull)(o.valueAt(a))[e]);
          }
          return l;
        };
        const c = [];
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          c.push(l(a[t], i.price, i.channel));
        }
        return c;
      }
      _convertTimeFromPublic(e) {
        return this._getTimeConverter().convertPublicTimeToInternalTime(e);
      }
      _getTimeConverter() {
        const e = this._chartWidget.model().mainSeries();
        return (0, Kn.getChartWidgetApiTimeConverter)(e.interval(), (0, n.ensureNotNull)(e.symbolInfo(), "main series symbol info"), this._chartWidget.model().model());
      }
      _onHoveredSourceChanged(e) {
        const t = e !== null && (0, Fn.isPriceDataSource)(e) ? e.id() : null;
        const i = this._prevHoveredSourceId;
        this._prevHoveredSourceId = t;
        if (t !== i) {
          this._dataSourceHovered.fire(t);
        }
      }
      _onCrosshairMoved(e) {
        const t = this.chartModel().crosshairSource().pane;
        if (t === null) {
          return;
        }
        const i = this._chartWidget.offsetInDocument(t);
        const s = this.chartModel().timeScale();
        const o = t.mainDataSource()?.priceScale();
        const n = s.indexToUserTime(e.index);
        const r = this._convertIndexToPublicTime(e.index);
        const a = s.indexToCoordinate(e.index);
        const l = o?.priceToCoordinate(e.price, t.mainDataSource()?.firstValue() || 0);
        if (a === undefined || l === undefined || n === null || r === null) {
          return;
        }
        const c = {
          price: e.price,
          time: r,
          userTime: n.getTime() / 1000,
          entityValues: {},
          offsetX: a + i.left,
          offsetY: l + i.top
        };
        const h = this.chartModel().priceDataSources();
        const d = (0, Bt.sourceChangeEvent)(this._chartWidget.model().crosshairSource().id());
        for (let e = 0; e < h.length; e++) {
          const t = h[e];
          const i = t.dataWindowView();
          if (i === null) {
            continue;
          }
          i.update(d);
          const s = t === this.chartModel().hoveredSource();
          const o = i.items().filter(e => e.visible() && e.title().length !== 0).map(e => ({
            title: e.title(),
            value: e.value()
          }));
          c.entityValues[t.id()] = {
            isHovered: s,
            values: o,
            title: i.header()
          };
        }
        this._crosshairMoved.fire(c);
      }
      _makeSubscriptionFromDelegate(e) {
        return {
          subscribe: e.subscribe.bind(e),
          unsubscribe: e.unsubscribe.bind(e),
          unsubscribeAll: e.unsubscribeAll.bind(e)
        };
      }
      _prepareEndOfPeriodArgs() {
        const e = this._chartWidget.model().model();
        const t = e.timezone();
        const i = (0, n.ensureNotNull)(e.mainSeries().symbolInfo());
        const s = e.mainSeries().interval();
        const o = new rd.SessionInfo(t, i.session, i.session_holidays, i.corrections);
        return {
          barBuilder: (0, rd.newBarBuilder)(s, o, o),
          intervalObj: Re.Interval.parse(s)
        };
      }
      _getPaneApi(e) {
        let t = this._panes.get(e);
        if (t === undefined) {
          t = new vf(e, this._chartWidget);
          this._panes.set(e, t);
        }
        return t;
      }
      _getStudyApi(e) {
        let t = this._studies.get(e);
        if (t === undefined) {
          t = new Pf(e, this._chartWidget);
          this._studies.set(e, t);
        }
        return t;
      }
      _getLineDataSourceApi(e) {
        let t = this._lineDataSources.get(e);
        if (t === undefined) {
          t = new Af(e, this._chartWidget.model(), {
            apiPointsToDataSource: this._convertUserPointsToDataSource.bind(this),
            dataSourcePointsToPriced: e => {
              const t = (0, n.ensureNotNull)(this._chartWidget.model().mainSeries().syncModel());
              const i = this._chartWidget.model().timeScale();
              return e.map(e => {
                const s = i.normalizeBarIndex(e.index);
                return {
                  price: e.price,
                  time: this._convertTimeToPublic(t.projectTime(s.time_t, s.offset))
                };
              });
            }
          });
          this._lineDataSources.set(e, t);
        }
        return t;
      }
      _alignPoints(e) {
        const t = this._chartWidget.model().model();
        const i = t.mainSeries();
        const s = i.interval();
        const o = i.symbolInfo();
        if (t.timeScale().isEmpty() || !Re.Interval.isDWM(s) || o === null) {
          return e;
        }
        const n = (0, Md.createDwmAligner)(s, o);
        if (n === null) {
          return e;
        } else {
          return e.map(e => n.timeToSessionStart(e * 1000) / 1000);
        }
      }
      _onLogicalRangeChanged() {
        const e = this._chartWidget.model().mainSeries();
        const t = e.data().isEmpty();
        if (this._chartWidget.model().timeScale().visibleBarsStrictRange() !== null && t) {
          e.dataEvents().completed().subscribe(this, this._onLogicalRangeChanged, true);
          return;
        }
        const i = this.getVisibleRange();
        if (this._prevVisibleRange === null || !(0, dt.deepEquals)(this._prevVisibleRange, i)[0]) {
          this._prevVisibleRange = i;
          this._visibleBarsChanged.fire(i);
        }
      }
      _canUseLineToolsSynchronizer(e) {
        if (!l.enabled("saveload_separate_drawings_storage")) {
          throw new Error(`${e} can only be used when 'saveload_separate_drawings_storage' featureset is enabled`);
        }
      }
    }
    var Hf = i(52092);
    class zf {
      loginRequired() {
        throw new Error("Not implemented");
      }
      onGoProDialog(e, t) {
        throw new Error("Not implemented");
      }
    }
    function Uf() {
      throw new Error("not implemented");
    }
    class jf extends zf {
      constructor(e) {
        super();
        this.linking = de.linking;
        this._lockDrawingsWatchedValue = null;
        this._hideDrawingsWatchedValue = null;
        this._hideIndicatorsWatchedValue = null;
        this._studyTemplatesDrawer = null;
        this._fontIconsSettingsDrawer = null;
        this._favoriteDrawingsToolbar = null;
        this._webview = null;
        this._themesApi = null;
        this._newsApiDeferredPromise = null;
        this._newsApiRejectionReason = null;
        this._watchlistApiDeferredPromise = null;
        this._watchlistApiRejectionReason = null;
        this._widgetbarApiDeferredPromise = null;
        this._widgetbarApiRejectionReason = null;
        this._isDestroyed = false;
        this._widgebarApi = null;
        this._chartWidgets = new WeakMap();
        this._layoutSettingsDrawer = null;
        this._magnetEnabledWatchedValue = null;
        this._magnetModeWatchedValue = null;
        this._drawOnAllCharts = (0, ye.convertPropertyToWatchedValue)((0, lt.drawOnAllCharts)());
        this._replayApi = null;
        this._pineEditorApi = null;
        this._backtestingStrategyApi = null;
        this._supportTicketData = null;
        this._activeChangedChangedDelegate = new re.Delegate();
        this._activateChart = e => {
          this.setActiveChart(this._chartIndex(e));
        };
        const {
          chartApiInstance: t,
          chartWidgetCollection: i,
          studyMarket: s,
          saveChartService: o,
          loadChartService: n,
          sharingChartService: r = null,
          webview: a = null,
          favoriteServices: l,
          alertsServices: c,
          supportTicketData: h = null
        } = e;
        this._chartApiInstance = t;
        this._chartWidgetCollection = i;
        this._studyMarket = s;
        this._saveChartService = o;
        this._sharingChartService = r;
        this._loadChartService = n;
        this._favoriteServices = l;
        this._intervalsService = null;
        this._alertsWidgetDialog = null;
        this._detailsDialogController = null;
        this._supportedChartStylesSpawn = de.linking.supportedChartStyles.spawn();
        this._chartWidgetCollection.onAboutToBeDestroyed.subscribe(null, () => this.destroy(), true);
        this._webview = a;
        this._alertService = null;
        this._supportTicketData = h;
        const d = i.lock;
        this._symbolSync = d.symbol.spawn();
        this._intervalSync = d.interval.spawn();
        this._dateRangeSync = d.dateRange.spawn();
        this._crosshairSync = d.crosshair.spawn();
        this._timeSync = d.trackTime.spawn();
        this._chartWidgetCollection.activeChartWidget.subscribe(() => {
          this._activeChangedChangedDelegate.fire();
        });
        W.subscribe("toggle_currency_menu_inner", (...e) => {
          this._toggleUnitConversionMenu("toggle_currency_menu", ...e);
        }, this);
        W.subscribe("toggle_unit_menu_inner", (...e) => {
          this._toggleUnitConversionMenu("toggle_unit_menu", ...e);
        }, this);
      }
      destroy() {
        this._supportedChartStylesSpawn.destroy();
        this._intervalsService?.destroy();
        this._themesApi?.destroy();
        this._widgebarApi?.destroy();
        this._widgetbarApiRejectionReason = "This ITradingViewApi instance has been destroyed";
        this._symbolSync.destroy();
        this._intervalSync.destroy();
        this._dateRangeSync.destroy();
        this._crosshairSync.destroy();
        this._timeSync.destroy();
        this._drawOnAllCharts.destroy();
        this._pineEditorApi?.destroy();
        this._isDestroyed = true;
        (0, lt.properties)().childs().magnet.unsubscribeAll(this);
        (0, lt.properties)().childs().magnetMode.unsubscribeAll(this);
        W.unsubscribeAll("toggle_currency_menu_inner", this);
        W.unsubscribeAll("toggle_unit_menu_inner", this);
      }
      themes() {
        if (this._themesApi === null) {
          this._themesApi = new nf({
            chartWidgetCollection: this._chartWidgetCollection
          });
        }
        return this._themesApi;
      }
      dialogs() {
        return {
          Indicators: this._studyMarket,
          Compare: this._chartWidgetCollection.getCompareDialogRenderer(),
          ObjectsTree: null,
          ChartProperties: this._chartWidgetCollection.getChartPropertiesDialogRenderer(),
          ChartLayoutSaveAs: this._saveChartService?.getSaveAsController() ?? null,
          ChartLayoutRename: this._saveChartService?.getRenameController() ?? null,
          ChartLayoutCreate: this._saveChartService?.getCreateController() ?? null,
          ChartLayoutLoad: this._loadChartService,
          Alerts: this._alertsWidgetDialog,
          Details: this._detailsDialogController,
          FinancialsCharts: null,
          Technicals: null,
          Forecast: null
        };
      }
      subscribe(e, t) {
        W.subscribe(e, t, undefined);
      }
      unsubscribe(e, t) {
        W.unsubscribe(e, t, undefined);
      }
      onActiveChartChanged() {
        return this._activeChangedChangedDelegate;
      }
      webview() {
        Uf();
        return this._webview;
      }
      connect() {
        Uf();
      }
      disconnect() {
        Uf();
      }
      onConnectionStatusChanged(e) {
        Uf();
      }
      isConnected() {
        Uf();
      }
      supportTicketData() {
        return this._supportTicketData;
      }
      setPublishChartOptions(e) {
        Uf();
      }
      publishChart(e) {
        Uf();
      }
      studyTemplatesDrawerApi() {
        Uf();
      }
      fontIconsSettingsDrawer() {
        Uf();
      }
      intervalsService() {
        Uf();
      }
      alertService() {
        Uf();
      }
      supportedChartTypes() {
        return this._supportedChartStylesSpawn;
      }
      setBrokerName(e) {
        this._chartWidgetCollection.setBroker(e);
      }
      getDrawOnAllCharts() {
        return (0, lt.drawOnAllCharts)().value();
      }
      drawOnAllCharts(e) {
        return (0, lt.drawOnAllCharts)().setValue(e);
      }
      drawOnAllChartsEnabled() {
        return this._drawOnAllCharts;
      }
      getDrawOnAllChartsMode() {
        return (0, lt.drawOnAllChartsMode)().value();
      }
      drawOnAllChartsMode(e) {
        (0, lt.drawOnAllChartsMode)().setValue(e);
      }
      currencies() {
        return this._chartApiInstance?.availableCurrencies() ?? Promise.reject();
      }
      units() {
        return this._chartApiInstance?.availableUnits() ?? Promise.reject();
      }
      disableTrackingEvents() {
        (0, ne.disableTrackingEvents)();
      }
      getSaveChartService() {
        return this._saveChartService;
      }
      symbolSync() {
        return this._symbolSync;
      }
      intervalSync() {
        return this._intervalSync;
      }
      dateRangeSync() {
        return this._dateRangeSync;
      }
      crosshairSync() {
        return this._crosshairSync;
      }
      timeSync() {
        return this._timeSync;
      }
      setSymbolSearchUI(e) {
        Uf();
      }
      chart(e = 0) {
        if (e < 0 || e >= this.chartsCount()) {
          throw Error("Incorrect index: " + e);
        }
        return this._getChartWidgetApi(this._chartWidgetCollection.getAll()[e]);
      }
      activeChart() {
        return this._getChartWidgetApi(this._activeChartWidget());
      }
      setActiveChart(e) {
        if (e >= 0 && e < this.chartsCount()) {
          const t = this._chartWidgetCollection.getAll()[e];
          if (t) {
            if (this._activeChartWidget().inFullscreen()) {
              t.requestFullscreen();
            } else {
              this._chartWidgetCollection.activeChartWidget.setValue(t);
            }
          }
        }
      }
      async replayApi() {
        Uf();
      }
      async backtestingStrategyApi() {
        Uf();
      }
      pineEditorApi() {
        Uf();
      }
      activeChartIndex() {
        return this._chartIndex(this._activeChartWidget());
      }
      chartsCount() {
        return Ct.layouts[this.layout()].count;
      }
      layout() {
        return this._chartWidgetCollection.layout.value();
      }
      layoutName() {
        return this._chartWidgetCollection.metaInfo.name.value();
      }
      layoutNameWatchedValue() {
        return this._chartWidgetCollection.metaInfo.name.readonly();
      }
      async layoutSettingsDrawer() {
        Uf();
      }
      setLayout(e, t) {
        if (t?.withUndo) {
          this._chartWidgetCollection.setChartLayoutWithUndo(e);
        } else {
          this._chartWidgetCollection.setLayout(e);
        }
      }
      resetLayoutSizes(e) {
        throw new Error("Unsupported. This API is only applicable to the Trading Edition of the library");
      }
      unloadUnusedCharts() {
        throw new Error("Unsupported. This API is only applicable to the Trading Edition of the library");
      }
      moveActiveChart(e) {
        this._chartWidgetCollection.moveActiveChartWithUndo(e);
      }
      undoRedoState() {
        return this._chartWidgetCollection.undoHistory.state();
      }
      clearUndoHistory() {
        return this._chartWidgetCollection.undoHistory.clearStack();
      }
      undo() {
        this._chartWidgetCollection.undoHistory.undo();
      }
      redo() {
        this._chartWidgetCollection.undoHistory.redo();
      }
      async selectLineTool(e, t) {
        if (!rf(e)) {
          return;
        }
        const i = af[e].name;
        if (e === "icon") {
          const e = t?.icon;
          if (e !== undefined) {
            lt.iconTool.setValue(e);
          }
        }
        await (0, eo.initLineTool)(i);
        if (e === "emoji") {
          const e = t?.emoji;
          if (e !== undefined) {
            lt.emojiTool.setValue(e);
          }
        }
        if (e === "sticker") {
          const e = t?.sticker;
          if (e !== undefined) {
            lt.stickerTool.setValue(e);
          }
        }
        lt.tool.setValue(i);
      }
      favoriteDrawingsToolbar() {
        return i.e(5551).then(i.bind(i, 17072)).then(e => {
          this._favoriteDrawingsToolbar ||= new e.FavoriteDrawingsApi();
          return this._favoriteDrawingsToolbar;
        });
      }
      sharingChart() {
        return this._sharingChartService;
      }
      watchlist() {
        Uf();
      }
      setWatchlistApiPromise(e) {
        Uf();
      }
      news() {
        Uf();
      }
      setNewsApiPromise(e) {
        Uf();
      }
      widgetbar() {
        Uf();
      }
      setWidgetbarApiPromise(e) {
        Uf();
      }
      getChartStorage() {
        return getChartStorage();
      }
      setDebugMode(e) {
        l.setEnabled("charting_library_debug_mode", e);
      }
      setFeatureEnabled(e, t) {
        if (e !== "chart_crosshair_menu") {
          l.setEnabled(e, t);
        } else {
          Od.addPlusButtonProperty.setValue(t);
        }
      }
      magnetEnabled() {
        if (this._magnetEnabledWatchedValue === null) {
          this._magnetEnabledWatchedValue = new F.WatchedValue((0, lt.properties)().childs().magnet.value());
          this._magnetEnabledWatchedValue.subscribe(e => {
            (0, li.allowSavingDefaults)(true);
            (0, lt.properties)().childs().magnet.setValue(e);
            (0, li.allowSavingDefaults)(false);
          });
          (0, lt.properties)().childs().magnet.subscribe(this, () => {
            (0, n.ensureNotNull)(this._magnetEnabledWatchedValue).setValue((0, lt.properties)().childs().magnet.value());
          });
        }
        return this._magnetEnabledWatchedValue;
      }
      magnetMode() {
        if (this._magnetModeWatchedValue === null) {
          this._magnetModeWatchedValue = new F.WatchedValue((0, lt.properties)().childs().magnetMode.value());
          this._magnetModeWatchedValue.subscribe(e => {
            (0, li.allowSavingDefaults)(true);
            (0, lt.properties)().childs().magnetMode.setValue(e);
            (0, li.allowSavingDefaults)(false);
          });
          (0, lt.properties)().childs().magnetMode.subscribe(this, () => {
            (0, n.ensureNotNull)(this._magnetModeWatchedValue).setValue((0, lt.properties)().childs().magnetMode.value());
          });
        }
        return this._magnetModeWatchedValue;
      }
      flushBufferedData() {
        lf.fire();
      }
      chartWidgetCollectionState(...e) {
        return this._chartWidgetCollection.state(...e);
      }
      chartWidgetCollectionSeriesStatuses() {
        return this._chartWidgetCollection.chartSeriesStatuses();
      }
      initAllLineTools() {
        const e = Array.from(wt.simpleLineToolNames).concat(["LineToolAnchoredVWAP", "LineToolRegressionTrend", "LineToolAnchoredVolumeProfile", "LineToolFixedRangeVolumeProfile", "LineToolVbPFixed", "LineToolRiskRewardLong", "LineToolRiskRewardShort"]);
        return Promise.all(e.map(e => (0, eo.initLineTool)(e))).then(() => { });
      }
      watermark() {
        {
          const e = i_.getInstance();
          if (!e.ready()) {
            throw new Error("Watermark API is not initialised yet.");
          }
          return e;
        }
      }
      setContextMenuOptions(e) {
        jf.setContextMenuOptions(e);
      }
      changeSymbol(e, t, i) {
        de.linking.interval.setValue((0, n.ensureNotNull)(Re.Interval.normalize(t)));
        de.linking.setSymbolAndLogInitiator(e, "API");
        if (i) {
          this.activeChart().onDataLoaded().subscribe(null, i, true);
        }
      }
      closePopupsAndDialogs() {
        Oo.ContextMenuManager.hideAll();
        W.emit(Hf.CLOSE_POPUPS_AND_DIALOGS_COMMAND);
      }
      startFullscreen() {
        return this._chartWidgetCollection.startFullscreen();
      }
      exitFullscreen() {
        return this._chartWidgetCollection.exitFullscreen();
      }
      getFavoriteChartStylesService() {
        Uf();
      }
      getFavoriteIntervalsService() {
        Uf();
      }
      getFavoriteCurrencyUnitConversionApi() {
        Uf();
      }
      getIntervals() {
        let e = [];
        const t = (0, es.getCustomResolutions)();
        if (this._chartApiInstance !== null) {
          e = this._chartApiInstance.defaultResolutions();
        }
        return (0, es.mergeResolutions)(e, t);
      }
      getLinetoolsFavoritesStore() {
        Uf();
      }
      getSavedCharts(e) {
        j.backend.getCharts().then(e);
      }
      getStudiesList() {
        return (0, n.ensureNotNull)(this._chartApiInstance).allStudiesMetadata().filter(e => !e.is_hidden_study).map(e => e.description);
      }
      getStudyInputs(e) {
        return bf(is.StudyMetaInfo.findStudyMetaInfoByDescription((0, n.ensureNotNull)(this._chartApiInstance).allStudiesMetadata(), e));
      }
      getStudyStyles(e) {
        return wf(is.StudyMetaInfo.findStudyMetaInfoByDescription((0, n.ensureNotNull)(this._chartApiInstance).allStudiesMetadata(), e));
      }
      getSymbolInterval(e) {
        const t = {
          symbol: this.linking.proSymbol.value(),
          interval: this.linking.interval.value()
        };
        e?.(t);
        return t;
      }
      hasChartChanges() {
        return this._chartWidgetCollection.hasChanges();
      }
      async loadChart(e) {
        this._chartApiInstance?.disconnect();
        if (e.extendedData) {
          this._chartWidgetCollection.metaInfo.id.setValue(e.extendedData.uid);
          this._chartWidgetCollection.metaInfo.uid.setValue(e.extendedData.uid);
          this._chartWidgetCollection.metaInfo.name.setValue(e.extendedData.name);
        }
        await this._chartWidgetCollection.loadContent(e.json);
        this._chartWidgetCollection.unloadUnusedCharts();
        this._chartApiInstance?.connect();
        de.linking.setSymbolAndLogInitiator(this.activeChart().symbol(), "API");
        W.emit("chart_loaded");
      }
      async loadChartFromServer(e) {
        await this._loadChartService?.loadChart(e, false);
      }
      async loadLayoutFromServerByLayoutId(e, t, i) {
        await this._loadChartService?.loadChartByUrl(e, !!t, i);
      }
      layoutId() {
        return this._chartWidgetCollection.metaInfo.uid.value();
      }
      async createNewLayout(e) {
        Uf();
      }
      lockAllDrawingTools() {
        if (this._lockDrawingsWatchedValue === null) {
          this._lockDrawingsWatchedValue = new F.WatchedValue((0, lt.lockDrawings)().value());
          this._lockDrawingsWatchedValue.subscribe(e => {
            (0, lt.lockDrawings)().setValue(e);
          });
          (0, lt.lockDrawings)().subscribe(this, () => {
            (0, n.ensureNotNull)(this._lockDrawingsWatchedValue).setValue((0, lt.lockDrawings)().value());
          });
        }
        return this._lockDrawingsWatchedValue;
      }
      hideAllDrawingTools() {
        if (this._hideDrawingsWatchedValue === null) {
          this._hideDrawingsWatchedValue = new F.WatchedValue((0, lt.hideAllDrawings)().value());
          this._hideDrawingsWatchedValue.subscribe(e => {
            (0, lt.hideAllDrawings)().setValue(e);
          });
          (0, lt.hideAllDrawings)().subscribe(this, () => {
            (0, n.ensureNotNull)(this._hideDrawingsWatchedValue).setValue((0, lt.hideAllDrawings)().value());
          });
        }
        return this._hideDrawingsWatchedValue;
      }
      hideAllIndicators() {
        if (this._hideIndicatorsWatchedValue === null) {
          this._hideIndicatorsWatchedValue = new F.WatchedValue((0, lt.hideAllIndicators)().value());
          this._hideIndicatorsWatchedValue.subscribe(e => {
            (0, lt.hideAllIndicators)().setValue(e);
          });
          (0, lt.hideAllIndicators)().subscribe(this, () => {
            (0, n.ensureNotNull)(this._hideIndicatorsWatchedValue).setValue((0, lt.hideAllIndicators)().value());
          });
        }
        return this._hideIndicatorsWatchedValue;
      }
      logs() {
        return {
          getLogHistory: ae.getLogHistory,
          enable: ae.loggingOn,
          disable: ae.loggingOff
        };
      }
      mainSeriesPriceFormatter() {
        return this._chartWidgetCollection.activeChartWidget.value().model().mainSeries().priceScale().formatter();
      }
      onContextMenu(e) {
        W.subscribe("onContextMenu", t => {
          t.callback(e(t.unixtime, t.price));
        }, undefined);
      }
      onGrayedObjectClicked(e) {
        W.subscribe("onGrayedObjectClicked", e, undefined);
      }
      removeChartFromServer(e, t) {
        j.backend.removeChart(e).then(t);
      }
      saveChart(e, t) {
        if (!this._saveChartService) {
          return;
        }
        const i = this._saveChartService.saveToJSON(t);
        return e && e(JSON.parse(i.content));
      }
      saveChartToServer(e, t, i) {
        if (this._saveChartService) {
          this._saveChartService.saveChartSilently(e, t, i);
        }
      }
      selectedLineTool() {
        const e = Object.keys(af);
        const t = lt.tool.value();
        for (let i = 0; i < e.length; ++i) {
          if (af[e[i]].name === t) {
            return e[i];
          }
        }
        throw new Error("Unknown tool");
      }
      autosave() {
        if (!this._saveChartService) {
          throw new Error("Saving service is not available");
        }
        return this._saveChartService.autoSaveEnabled();
      }
      setForceFullscreenMode() {
        Uf();
      }
      setMultichartMode() {
        Uf();
      }
      setDateRangeLinkingEnabled(e) {
        this._chartWidgetCollection.lock.dateRange.setValue(e);
      }
      studyMetaIntoRepository() {
        return (0, ts.studyMetaInfoRepository)();
      }
      deferredStudiesReady() {
        return bh.ready();
      }
      hasPendingStudiesModuleLoading() {
        return (0, Js.hasPendingStudiesModuleLoading)();
      }
      shouldBeSaved() {
        return !this._chartWidgetCollection.readOnly() && (this._saveChartService?.hasChanges() || false);
      }
      setIntervalLinkingEnabled(e) {
        this._chartWidgetCollection.lock.interval.setValue(e);
      }
      setTimeFrame(e) {
        this._chartWidgetCollection.setTimeFrame(e);
      }
      showConfirmDialog(e) {
        let t = e.callback;
        const i = e => {
          if (t) {
            t(e);
            t = null;
          }
        };
        (0, q.showConfirm)({
          title: e.title,
          text: e.body || "",
          onClose: () => {
            i(false);
          },
          onConfirm: e => {
            i(true);
            e.dialogClose();
          }
        });
      }
      showLoadChartDialog() {
        this._loadChartService?.showLoadDialog();
      }
      persistentLogger() {
        return null;
      }
      showNoticeDialog(e) {
        (0, q.showWarning)({
          title: e.title,
          text: e.body || "",
          onClose: e.callback
        });
      }
      showSupportDialog() {
        Uf();
      }
      showSaveAsChartDialog() {
        const e = this._saveChartService;
        if (e) {
          window.runOrSignIn(() => {
            e.saveChartAs();
          }, {
            source: "Save as chart dialogue"
          });
        }
      }
      showRenameChartDialog() {
        Uf();
      }
      saveChartOrShowTitleDialog(e, t, i) {
        Uf();
      }
      showCreateAlertDialog() {
        Uf();
      }
      createGoProDialog(e) {
        Uf();
      }
      setUserInfo(e) {
        Uf();
      }
      openMobileChartPicker() {
        Uf();
      }
      closeMobileChartPicker() {
        Uf();
      }
      takeClientScreenshot(e) {
        return this._chartWidgetCollection.clientSnapshot(e);
      }
      takeScreenshot() {
        return this._chartWidgetCollection.takeScreenshot();
      }
      trading() {
        Uf();
      }
      waitTrading() {
        Uf();
      }
      viewMode() {
        Uf();
      }
      viewModeWatchedValue() {
        Uf();
      }
      async dummyBrokerController() {
        return Promise.reject("Not implemented");
      }
      pineLibApi() {
        Uf();
        return {
          saveNew,
          saveNext,
          requestBuiltinScripts
        };
      }
      resetCache() {
        window.ChartApiInstance.resetCache();
      }
      static setContextMenuOptions(e) {
        if (e.items_processor !== undefined) {
          Oo.ContextMenuManager.setCustomItemsProcessor(e.items_processor);
        }
        if (e.renderer_factory !== undefined) {
          Oo.ContextMenuManager.setCustomRendererFactory(e.renderer_factory);
        }
      }
      _getChartWidgetApi(e) {
        let t = this._chartWidgets.get(e);
        if (t === undefined) {
          t = new Wf(e, this._activateChart.bind(null, e));
          this._chartWidgets.set(e, t);
        }
        return t;
      }
      _chartIndex(e) {
        return this._chartWidgetCollection.getAll().indexOf(e);
      }
      _activeChartWidget() {
        return this._chartWidgetCollection.activeChartWidget.value();
      }
      _toggleUnitConversionMenu(e, t, i, s, o) {
        if (t) {
          W.emit(e, t, -1, -1, "");
          return;
        }
        const r = this._chartWidgetCollection.getAll();
        const a = r.findIndex(e => e.model().model().id() === i);
        if (a === -1) {
          return;
        }
        const l = (0, n.ensureDefined)(r[a]).paneWidgets().findIndex(e => e.state().id() === s);
        if (l !== -1) {
          W.emit(e, t, a, l, o);
        }
      }
    }
    i(42924);
    i(23863);
    var Gf = i(78136);
    var qf = i(73772);
    var $f = i(64034);
    var Kf = i(70893);
    var Yf = i(50946);
    i(25043);
    const Zf = {
      customBrandingTradingViewText: Lt.colorsPalette["color-brand"],
      customBrandingText: Lt.colorsPalette["color-cold-gray-850"],
      background: Lt.colorsPalette["color-cold-gray-900"],
      shadow: Lt.colorsPalette["color-cold-gray-700"],
      text: Lt.colorsPalette["color-white"],
      staticTextBackground: (0, Is.generateColor)(Lt.colorsPalette["color-cold-gray-800"], 20),
      logo: Lt.colorsPalette["color-white"],
      platformBgColor: Lt.colorsPalette["color-cold-gray-900"],
      platformFgColor: Lt.colorsPalette["color-cold-gray-200"]
    };
    const Xf = {
      customBrandingTradingViewText: Lt.colorsPalette["color-brand"],
      customBrandingText: Lt.colorsPalette["color-cold-gray-850"],
      background: Lt.colorsPalette["color-white"],
      shadow: Lt.colorsPalette["color-cold-gray-150"],
      text: Lt.colorsPalette["color-cold-gray-900"],
      staticTextBackground: (0, Is.generateColor)(Lt.colorsPalette["color-white"], 20),
      logo: Lt.colorsPalette["color-cold-gray-900"],
      platformBgColor: Lt.colorsPalette["color-white"],
      platformFgColor: Lt.colorsPalette["color-cold-gray-900"]
    };
    const Jf = new Map([["logo-old-style", Yf], ["tradingview-old-style", Kf]]);
    const Qf = l.enabled("adaptive_logo");
    const ey = l.enabled("small_no_display");
    const ty = l.enabled("38914");
    const iy = "site_branding";
    const sy = "widget_branding";
    const oy = "widget_referral_branding";
    const ny = "widget_custom_branding";
    const ry = "widget_custom_no_powered_branding";
    const ay = "fundamental_branding";
    const ly = "fundamental_custom_branding";
    const cy = "fundamental_custom_no_powered_branding";
    const hy = "library_branding";
    const dy = "library_custom_branding";
    const uy = "library_custom_no_powered_branding";
    const _y = navigator.userAgent.toLowerCase().indexOf("chrome") > -1 && navigator.userAgent.toLowerCase().indexOf("edge") === -1;
    const py = window.urlParams || {};
    const my = window.initData || {};
    if (py.no_referral_id) {
      enable(py.referral_id || "", "aggressive");
    }
    const gy = a.t(null, undefined, i(98856));
    const fy = ty ? a.t(null, undefined, i(44676)) : a.t(null, undefined, i(92800));
    a.t(null, undefined, i(46768));
    a.t(null, undefined, i(83470));
    a.t(null, undefined, i(3140));
    var yy;
    (function (e) {
      e[e.OldFontAdditionalVerticalOffset = 0] = "OldFontAdditionalVerticalOffset";
      e[e.NewFontAdditionalVerticalOffset = 0.1] = "NewFontAdditionalVerticalOffset";
      e[e.StrokeWidth = 4] = "StrokeWidth";
      e[e.StaticLogoHorizontalTextOffset = 5] = "StaticLogoHorizontalTextOffset";
      e[e.TextWidthCompensation = 2] = "TextWidthCompensation";
      e[e.AdaptiveWidthToHideText = 500] = "AdaptiveWidthToHideText";
      e[e.WidthToHideLogoIfSmallNoDisplayEnabled = 480] = "WidthToHideLogoIfSmallNoDisplayEnabled";
      e[e.TextAdditionalCropWidth = 11] = "TextAdditionalCropWidth";
      e[e.BadgeLogoMargin = -11] = "BadgeLogoMargin";
      e[e.BadgeTextMargin = -8] = "BadgeTextMargin";
      e[e.TextAnimatedAlphaStart = 0.3] = "TextAnimatedAlphaStart";
      e[e.TextAnimatedAlphaEnd = 1] = "TextAnimatedAlphaEnd";
      e[e.AnimationDuration = 200] = "AnimationDuration";
    })(yy ||= {});
    (0, ze.onWidget)();
    class vy extends hd.CustomSourceBase {
      constructor(e, t, i) {
        super(e, t);
        this._canvasWidth = 0;
        this._paneHeight = 0;
        this._left = 13;
        this._bottom = 36;
        this._layout = iy;
        this._needToShow = true;
        this._showBranding = false;
        this._customLogoSrc = "";
        this._customLogoLink = "";
        this._tradingviewLogoLinkToPath = "";
        this._cubicBezier = new Mr.CubicBezier(0.4, 0.01, 0.22, 1);
        this._openAnimation = null;
        this._closeAnimation = null;
        this._powBy = null;
        this._custom = null;
        this._destroyed = false;
        this._mainSeries = this._model.mainSeries();
        this._visible = i;
        this._showForPro = !t.onWidget();
        const s = () => this._model.updateSource(this);
        this._visible.subscribe(s);
        this._dark = t.dark().spawn();
        this._dark.subscribe(s);
        this._checkLayout();
        if (this._layout === ny || this._layout === ly) {
          this._left = 8;
          this._bottom = 5;
        }
        const o = () => {
          if (this._needToShow) {
            this._showBranding = true;
          } else {
            this._showBranding = false;
          }
        };
        this._resizeHandlerDelayed = (0, cc.default)(o, 200);
        o();
        window.addEventListener("resize", this._resizeHandlerDelayed);
        if (this._model.isSnapshot()) {
          this._init();
        } else {
          this._mainSeries.dataEvents().symbolResolved().subscribe(this, this._init);
          if (this._mainSeries.symbolInfo() !== null) {
            this._init();
          }
        }
        this._renderer = {
          draw: this.draw.bind(this),
          hitTest: this.hitTest.bind(this)
        };
        if (!t.onWidget()) {
          window.loginStateChange.subscribe(this, this._init);
        }
      }
      destroy() {
        window.removeEventListener("resize", this._resizeHandlerDelayed);
        this._mainSeries.dataEvents().symbolResolved().unsubscribeAll(this);
        if (this._powBy) {
          this._powBy.destroy();
        }
        if (!this._model.onWidget()) {
          window.loginStateChange.unsubscribeAll(this);
        }
        this._visible.release();
        this._dark.destroy();
        this._destroyed = true;
      }
      paneViews(e) {
        if (window.TradingView.printing && this._layout !== ry && this._layout !== cy) {
          return [];
        }
        if (!this._visible.value()) {
          return [];
        }
        if (this._layout === iy && !this._showForPro && window.user && window.user.is_pro) {
          return [];
        }
        const t = this._model.mainPane();
        if (!t) {
          return [];
        }
        const i = l.enabled("move_logo_to_main_pane");
        let s = false;
        if (e.maximized().value()) {
          s = true;
        } else if (i) {
          s = t.collapsed().value() ? e === this._model.panes().find(e => !e.collapsed().value()) : e.isMainPane().value();
        } else if (this._model.lastPane().collapsed().value()) {
          const t = this._model.panes();
          for (let i = t.length - 1; i >= 0; --i) {
            const o = t[i];
            if (!o.collapsed().value()) {
              s = o === e;
              break;
            }
          }
        } else {
          s = e.isLast();
        }
        if (s) {
          return [{
            renderer: this.renderer.bind(this)
          }];
        } else {
          return [];
        }
      }
      labelPaneViews(e) {
        return [];
      }
      priceAxisViews(e, t) {
        return [];
      }
      updateAllViews() { }
      updateViewsForPane(e) { }
      priceScale() {
        return null;
      }
      renderer(e) {
        this._paneHeight = e.mediaSize.height;
        this._canvasWidth = e.mediaSize.width;
        return this._renderer;
      }
      hasContextMenu() {
        return false;
      }
      onClickOutside() {
        if (this._hasAnimation()) {
          this._startCloseAnimation();
        }
      }
      hitTest(e) {
        if (!this._showBranding || l.enabled("logo_without_link")) {
          return null;
        }
        if (this._powBy && this._layout !== ry && this._layout !== cy && (this._powBy.hitTest(e) || this._custom && this._custom.hitTest(e))) {
          const e = true;
          return new Vt.HitTestResult(Vt.HitTarget.Custom, {
            hideCrosshairLinesOnHover: true,
            cursorType: e ? qt.PaneCursorType.Pointer : qt.PaneCursorType.Default,
            clickHandler: () => {
              this._openLink();
            },
            tapHandler: () => {
              if (this._hasAnimation()) {
                this._toggleOpenAnimatedOrOpenLink();
              } else {
                this._openLink();
              }
            },
            mouseEnterHandler: () => {
              if (this._hasAnimation()) {
                this._startOpenAnimation();
              }
            },
            mouseLeaveHandler: () => {
              if (this._hasAnimation()) {
                this._startCloseAnimation();
              }
            },
            mouseDownHandler: () => {
              0;
            },
            mouseUpHandler: () => {
              0;
            }
          });
        }
        return null;
      }
      tvUrl() {
        const e = "https://" + function (e) {
          return ({
            ar_AE: "ar",
            de_DE: "de",
            en: "www",
            es: "es",
            ca_ES: "es",
            fr: "fr",
            he_IL: "il",
            id: "id",
            in: "in",
            it: "it",
            ja: "jp",
            kr: "kr",
            ms_MY: "my",
            pl: "pl",
            br: "br",
            ru: "ru",
            th_TH: "th",
            tr: "tr",
            uk: "uk",
            vi_VN: "vn",
            zh_CN: "cn",
            zh_TW: "tw"
          }[e] || "www") + ".tradingview.com";
        }((my.querySettings?.locale ?? my.currentLocaleInfo?.language) || "en");
        let t = new URL(e);
        if (this._customLogoLink) {
          return this._customLogoLink;
        }
        if (this._layout === hy || this._layout === dy) {
          let e;
          switch (true) {
            case l.enabled("charting_library"):
              e = "library";
              break;
            case l.enabled("trading_terminal"):
              e = "trading-terminal";
          }
          if (this._tradingviewLogoLinkToPath) {
            t.pathname = this._tradingviewLogoLinkToPath;
          }
          t.searchParams.append("utm_source", window.location.origin);
          t.searchParams.append("utm_medium", "library");
          if (e) {
            t.searchParams.append("utm_campaign", e);
          }
        }
        return t.toString();
      }
      draw(e, t) {
        if (!this._showBranding) {
          return;
        }
        let i = 0;
        py.utm = true;
        (0, Wt.drawScaled)(e, t.horizontalPixelRatio, t.verticalPixelRatio, () => {
          if (this._powBy && this._powBy.show) {
            i = this._powBy.height;
            e.save();
            const s = new At.Point(this._left, this._paneHeight - this._bottom - i);
            this._powBy.draw(s, e, t, this._canvasWidth);
            e.restore();
          }
          if (this._custom && this._custom.show) {
            e.save();
            const s = new At.Point(this._left, this._paneHeight - this._bottom - i - this._custom.height);
            this._custom.draw(s, e, t);
            e.restore();
          }
        });
      }
      _init() {
        this._checkLayout();
        const e = this._mainSeries.symbolInfo();
        if (this._powBy) {
          this._powBy.destroy();
        }
        this._powBy = new Ty(this._layout, e?.name || "", this._model, () => this._model.fullUpdate());
        this._custom = new xy(this._layout, this._customLogoSrc, () => this._model.fullUpdate());
        this._openAnimation = null;
        this._closeAnimation = null;
        this._model.lightUpdate();
      }
      _checkLayout() {
        if (l.enabled("widget")) {
          0;
        } else {
          {
            const e = JSON.parse(py.logo) || {};
            if (e.image) {
              this._customLogoSrc = e.image;
              this._customLogoLink = e.link;
              this._needToShow = l.enabled("widget_logo");
              if (l.enabled("link_to_tradingview")) {
                this._layout = dy;
              } else {
                this._layout = uy;
              }
            } else {
              if (e.tradingviewLogoLinkToPath) {
                this._tradingviewLogoLinkToPath = e.tradingviewLogoLinkToPath.replace(/^\//, "");
              }
              this._layout = hy;
              this._needToShow = l.enabled("widget_logo");
            }
          }
        }
      }
      _startOpenAnimation() {
        if (this._openAnimation !== null) {
          return;
        }
        if (this._closeAnimation !== null) {
          this._closeAnimation.stop();
          this._closeAnimation = null;
        }
        const e = (0, n.ensureNotNull)(this._powBy).animationStep();
        this._openAnimation = (0, Er.doAnimate)({
          from: e,
          to: 1,
          duration: (1 - e) * 200,
          easing: this._cubicBezier.easingFunc,
          onStep: this._animatedDrawStep.bind(this)
        });
      }
      _startCloseAnimation() {
        if (this._closeAnimation !== null) {
          return;
        }
        if (this._openAnimation !== null) {
          this._openAnimation.stop();
          this._openAnimation = null;
        }
        const e = (0, n.ensureNotNull)(this._powBy).animationStep();
        this._closeAnimation = (0, Er.doAnimate)({
          from: e,
          to: 0,
          duration: e * 200,
          easing: this._cubicBezier.easingFunc,
          onStep: this._animatedDrawStep.bind(this)
        });
      }
      _animatedDrawStep(e, t) {
        (0, n.ensureNotNull)(this._powBy).animatedDrawStep(t);
        this._model.lightUpdate();
      }
      _hasAnimation() {
        return this._powBy !== null && this._powBy.hasAnimation();
      }
      _openGoPro() {
        0;
      }
      _openLink() {
        if ((0, ze.isSymphonyEmbed)()) {
          return false;
        }
        if (this._layout === iy) {
          if (!this._model.isSnapshot()) {
            this._openGoPro();
          }
          return false;
        }
        l.enabled("widget");
        (0, n.ensureNotNull)(window.open(this.tvUrl(), "_blank")).opener = null;
        return true;
      }
      _toggleOpenAnimatedOrOpenLink() {
        if (this._openAnimation !== null && this._openAnimation.completed()) {
          if (!this._openLink()) {
            this._startCloseAnimation();
          }
        } else {
          this._startOpenAnimation();
        }
      }
    }
    function Sy(e) {
      return !ey || e > 480;
    }
    function by(e) {
      return !Qf || e > 500;
    }
    let wy = {};
    let Cy = {};
    class Py {
      constructor() {
        this._topLeftPoint = null;
        this._hitTestHeight = null;
      }
      hitTest(e) {
        const t = this._getHitTestBox();
        if (t) {
          return (0, Nt.pointInBox)(e, t);
        }
      }
      _getHitTestBox() {
        const e = this._topLeftPoint;
        if (e) {
          const {
            x: t,
            y: i
          } = e;
          return (0, At.box)(e, new At.Point(t + this.width, i + (this._hitTestHeight ?? this.height)));
        }
      }
    }
    class Ty extends Py {
      constructor(e, t, i, s) {
        super();
        this.show = true;
        this.hovered = false;
        this.active = false;
        this._needDisplayImage = false;
        this._textAnimatedAlpha = 1;
        this._textAnimatedAlphaStart = 1;
        this._textAdditionalCropWidth = 0;
        this._textAnimatedAlphaEnd = 1;
        this._badgeData = {
          logoMargin: 0,
          textMargin: 0,
          width: 0
        };
        this._invertTextCropDirection = false;
        this._font = `px ${g.CHART_FONT_FAMILY}`;
        this._txt = "TradingView";
        this._maximizedAnimationTextWidth = 0;
        this._logoWidth = 0;
        this._textWidthCache = new Gt.TextWidthCache();
        this._pixelRatio = {
          horizontalPixelRatio: NaN,
          verticalPixelRatio: NaN
        };
        this._model = i;
        this._layout = e;
        this._symbol = t;
        this._showTradeWithLogo = false;
        this._showAnimatedBranding = l.enabled("show_animated_logo") || e === sy;
        this._alwaysMaximized = l.enabled("logo_always_maximized") || this._model.isSnapshot() && !ze.CheckMobile.any() || false;
        this._fontSize = this._showAnimatedBranding || this._layout === oy ? 11 : 14;
        if (!this._showAnimatedBranding && (this._layout === ny || this._layout === ly)) {
          this._fontSize = 12;
        }
        this._sizeConstants = (this._model.isSnapshot(), {
          brandCircleSize: 32,
          textAsImageWidthCompensation: 0,
          leftOffset: 0,
          bottomOffset: -23,
          logoLeftOffset: 1,
          logoTextOffset: 6
        });
        this.width = this._minimizedAnimationWidth();
        this._animatedWidth = this.width;
        this.height = this._fontSize + 2;
        this._requestRepaint = s;
        this._init();
        this._checkFontLoaded();
        this._recalculateMetrics();
      }
      destroy() {
        this._model.properties().childs().paneProperties.childs().background.unsubscribeAll(this);
        this._model.onChartThemeLoaded().unsubscribeAll(this);
      }
      hasAnimation() {
        return this._showAnimatedBranding && !this._alwaysMaximized;
      }
      animationStep() {
        const e = this._minimizedAnimationWidth();
        const t = this._maximizedAnimationWidth();
        return (this._animatedWidth - e) / (t - e);
      }
      animatedDrawStep(e) {
        const t = this._minimizedAnimationWidth();
        const i = this._maximizedAnimationWidth();
        this._animatedWidth = t + e * (i - t);
        this._textAnimatedAlpha = this._textAnimatedAlphaStart + e * (this._textAnimatedAlphaEnd - this._textAnimatedAlphaStart);
      }
      draw(e, t, i, s) {
        const {
          brandCircleSize: o,
          logoLeftOffset: n,
          leftOffset: r,
          bottomOffset: a
        } = this._sizeConstants;
        if (this._needDisplayImage && Sy(s)) {
          e = new At.Point(e.x + r, e.y - a);
        }
        this._topLeftPoint = e;
        t.translate(e.x, e.y);
        const {
          horizontalPixelRatio: l,
          verticalPixelRatio: c
        } = i;
        if (!(0, $f.equalPixelRatios)(i, this._pixelRatio)) {
          this._textWidthCache.reset();
          this._pixelRatio = {
            horizontalPixelRatio: l,
            verticalPixelRatio: c
          };
        }
        const h = this._colors;
        if (this._showAnimatedBranding) {
          if (this._needDisplayImage) {
            const e = this._getLogoImage(h.logo);
            this.width = this._animatedWidth;
            this._drawLogo(t, e, this._animatedWidth, this._animatedWidth, this._animatedWidth > this._sizeConstants.brandCircleSize);
          }
        } else if (this._layout === ny || this._layout === ly) {
          t.font = this._fontSize + this._font;
          const e = t.measureText(this._txt).width + 2;
          this.width = e + t.measureText("TradingView").width + 2;
          t.save();
          t.globalAlpha = 0.7;
          t.fillStyle = this._colors.customBrandingText;
          t.fillText(this._txt, 0, 12);
          t.fillStyle = this._colors.customBrandingTradingViewText;
          t.fillText("TradingView", e, 12);
          t.restore();
        } else if (Sy(s)) {
          if (this._needDisplayImage) {
            const e = this._getLogoImage(h.logo);
            t.save();
            this._drawBgCircle(t, o / 2);
            const {
              width: i,
              height: r
            } = e.logoImage.viewBox();
            const a = new At.Point(Math.round((o - i) / 2) - 1 + n, Math.floor((o - r) / 2) + 1);
            this._drawLogoImage(t, a, e.logoImage);
            const l = by(s);
            if (l) {
              t.translate(o + 5, Math.round(this._fontSize * (this._font === "px EuclidCircular" ? 0.1 : 0)));
              this._drawTextStroke(t);
              this._drawTextFill(t);
            }
            t.restore();
            this.width = o;
            if (l) {
              this.width += this._maximizedAnimationTextWidth;
            }
          } else {
            const e = by(s);
            if (e) {
              t.save();
              t.translate(_y ? -0.5 : 0, -0.5);
              this._drawTextStroke(t);
              this._drawTextFill(t);
              t.restore();
            }
            if (e) {
              this.width = this._maximizedAnimationTextWidth;
            }
          }
        } else {
          this.width = 0;
        }
      }
      showTradeWithLogo(e) {
        this._showTradeWithLogo = e;
      }
      _minimizedAnimationWidth() {
        return this._sizeConstants.brandCircleSize + this._badgeData.logoMargin + this._badgeData.width;
      }
      _maximizedAnimationWidth() {
        return this._sizeConstants.brandCircleSize + this._sizeConstants.logoTextOffset + this._maximizedAnimationTextWidth + this._badgeData.width + this._badgeData.textMargin;
      }
      _drawTradeWithLogo(e, t, i) {
        0;
      }
      _drawLogo(e, t, i, s, o) {
        const {
          brandCircleSize: n,
          logoLeftOffset: r,
          logoTextOffset: a
        } = this._sizeConstants;
        e.save();
        this._drawFillRectWithRoundedCorner(e, -0.5, 0, i, n, n / 2);
        const {
          logoImage: l,
          textImage: c,
          proBadgeImage: h
        } = t;
        const {
          width: d,
          height: u
        } = l.viewBox();
        const _ = new At.Point(Math.round((n - d) / 2) - 1 + r, Math.floor((n - u) / 2) + 1);
        if (o) {
          const t = new At.Point(_.x + d + a, _.y);
          const i = e.globalAlpha;
          e.globalAlpha *= this._textAnimatedAlpha;
          const o = s - this._sizeConstants.brandCircleSize - a - this._badgeData.logoMargin - this._badgeData.width;
          this._drawImageCropWidth(e, t, c, o);
          e.globalAlpha = i;
        }
        if (h) {
          const {
            width: t,
            height: i
          } = h.viewBox();
          h.render(e, {
            targetViewBox: {
              x: _.x + this.width - t,
              y: Math.floor((n - i) / 2) + 1,
              width: t,
              height: i
            }
          });
        }
        this._drawLogoImage(e, _, l);
        e.restore();
      }
      _init() {
        Cy = {};
        wy = {};
        this._checkLayout();
        if (this.show) {
          this._updateColors();
          this._updateHeight();
          this._model.properties().childs().paneProperties.childs().background.subscribe(this, this._updateColors);
          this._model.onChartThemeLoaded().subscribe(this, this._updateColors);
        }
      }
      _updateHeight() {
        if (this._needDisplayImage) {
          this.height = this._sizeConstants.brandCircleSize;
        } else {
          this.height = this._fontSize + 2;
        }
      }
      _checkFontLoaded() {
        if (!this._showAnimatedBranding && document.fonts && document.fonts.check && document.fonts.load) {
          if (document.fonts.check(`${this._fontSize}px EuclidCircular`)) {
            this._font = "px EuclidCircular";
          } else {
            document.fonts.load(`${this._fontSize}px EuclidCircular`, this._txt).then(() => {
              this._font = "px EuclidCircular";
              this._recalculateMetrics();
              this._requestRepaint();
            });
          }
        }
      }
      _recalculateMetrics() {
        const e = (0, Wt.createDisconnectedCanvas)(document, (0, Dt.size)({
          width: 0,
          height: 0
        }));
        const t = (0, Wt.getPrescaledContext2D)(e);
        t.font = this._fontSize + this._font;
        const i = this._needDisplayImage ? this._getLogoImage(this._colors.logo) : null;
        let s = i ? i.textImage.viewBox().width + this._sizeConstants.textAsImageWidthCompensation : Math.ceil(t.measureText(this._txt).width) + 2 + 8;
        if (s % 2 == 0) {
          s += 1;
        }
        this._maximizedAnimationTextWidth = s;
        this._textWidthCache.reset();
        this._logoWidth = i?.logoImage.viewBox().width ?? 0;
        this._animatedWidth = this._alwaysMaximized ? this._maximizedAnimationWidth() : this._minimizedAnimationWidth();
      }
      _updateColors() {
        this._colors = this._model.dark().value() ? Zf : Xf;
      }
      _getLogoImage(e) {
        return function (e, t, i, s, o) {
          const r = Cy;
          const a = [t, i, o && "tradeWith"].filter(Boolean).join("-");
          const l = r[a];
          if (l !== undefined) {
            return l;
          }
          const [c, h, d] = function (e, t, i) {
            if (i) {
              return ["logo-trade-with", "tradingview-trade-with"];
            } else {
              return ["logo-old-style", "tradingview-old-style", undefined];
            }
          }(0, 0, o);
          const u = e => e.replace(/fill="#[\da-f]{6}"/gi, `fill="${i}"`);
          const _ = {
            logoImage: e(u((0, n.ensureDefined)(Jf.get(c)))),
            textImage: e(u((0, n.ensureDefined)(Jf.get(h)))),
            proBadgeImage: d ? e(u((0, n.ensureDefined)(Jf.get(d)))) : undefined
          };
          r[a] = _;
          return _;
        }(No.svgRenderer, this._model.dark().value() ? "dark" : "light", e, 0, this._showTradeWithLogo);
      }
      _checkLayout() {
        switch (this._layout) {
          case sy:
          case oy:
          case ny:
          case ay:
          case ly:
          case dy:
          case hy:
          case iy:
            this.show = true;
            break;
          case ry:
          case cy:
          case uy:
            this.show = false;
        }
        switch (this._layout) {
          case hy:
            this._needDisplayImage = true;
            this._txt = gy;
            break;
          case dy:
            this._txt = fy;
        }
      }
      _drawTextStroke(e) {
        e.save();
        e.textBaseline = "middle";
        e.textAlign = "start";
        e.font = this._fontSize + this._font;
        e.strokeStyle = this._colors.staticTextBackground;
        e.lineWidth = 4;
        e.lineJoin = "round";
        e.strokeText(this._txt, 0, this._sizeConstants.brandCircleSize / 2 + this._textWidthCache.yMidCorrection(e, this._txt));
        e.restore();
      }
      _drawTextFill(e) {
        e.save();
        e.textBaseline = "middle";
        e.textAlign = "start";
        e.font = this._fontSize + this._font;
        e.fillStyle = this._colors.text;
        e.fillText(this._txt, 0, this._sizeConstants.brandCircleSize / 2 + this._textWidthCache.yMidCorrection(e, this._txt));
        e.restore();
      }
      _drawImageCropWidth(e, t, i, s) {
        e.save();
        const {
          logoMargin: o,
          textMargin: n
        } = this._badgeData;
        e.beginPath();
        const {
          width: r,
          height: a
        } = i.viewBox();
        e.rect(t.x - this._textAdditionalCropWidth, t.y, s + this._textAdditionalCropWidth, a);
        e.clip();
        i.render(e, {
          targetViewBox: {
            x: t.x - (this._invertTextCropDirection ? r - s - o + n : 0),
            y: t.y,
            width: r,
            height: a
          }
        });
        e.restore();
      }
      _drawBgCircle(e, t) {
        const i = Math.PI * 2;
        e.save();
        e.beginPath();
        e.fillStyle = this._colors.shadow;
        e.arc(t, t, t + 1, 0, i);
        e.fill();
        e.closePath();
        e.restore();
        e.save();
        e.beginPath();
        e.fillStyle = this._colors.background;
        e.arc(t, t, t, 0, i, false);
        e.fill();
        e.closePath();
        e.restore();
      }
      _drawFillRectWithRoundedCorner(e, t, i, s, o, n, r) {
        e.save();
        (0, Ft.drawRoundRect)(e, t - 1, i - 1, s + 2, o + 2, n);
        e.fillStyle = this._backgroundShadowFillStyle();
        e.fill();
        e.closePath();
        e.restore();
        e.save();
        (0, Ft.drawRoundRect)(e, t, i, s, o, r ?? n);
        e.fillStyle = this._backgroundFillStyle();
        e.fill();
        e.closePath();
        e.restore();
      }
      _tradeWithLogoBackgroundColor() {
        return "";
      }
      _backgroundShadowFillStyle() {
        return this._colors.shadow;
      }
      _backgroundFillStyle() {
        return this._colors.background;
      }
      _drawLogoImage(e, t, i) {
        const {
          width: s,
          height: o
        } = i.viewBox();
        i.render(e, {
          targetViewBox: {
            x: t.x,
            y: t.y,
            width: s,
            height: o
          }
        });
      }
    }
    class xy extends Py {
      constructor(e, t, i) {
        super();
        this.show = false;
        this.width = 0;
        this.height = 0;
        this._ready = false;
        this._layout = e;
        this._src = t;
        this._onReadyCallback = i;
        this._checkLayout();
        const s = new Image();
        this._img = s;
        if (this.show) {
          s.addEventListener("load", () => {
            this.width = Math.round(s.width);
            this.height = Math.round(s.height);
            this._ready = true;
            if (this._onReadyCallback) {
              this._onReadyCallback();
            }
          });
          s.crossOrigin = "anonymous";
          s.src = this._src;
        }
      }
      draw(e, t, i) {
        this._topLeftPoint = e;
        if (this._ready) {
          t.translate(e.x, e.y);
          t.drawImage(this._img, -0.5, -0.5, this.width, this.height);
        }
      }
      _checkLayout() {
        switch (this._layout) {
          case ny:
          case ry:
          case ly:
          case cy:
          case dy:
          case uy:
            this.show = true;
            break;
          case iy:
          case sy:
          case oy:
          case ay:
          case hy:
            this.show = false;
        }
      }
    }
    var Iy = i(4454);
    var My = i(94664);
    class Ay {
      constructor(e, t) {
        this._headerToolbar = e;
        this._dropdownId = t;
      }
      applyOptions(e) {
        this._headerToolbar.updateDropdown(this._dropdownId, e);
      }
      remove() {
        this._headerToolbar.removeDropdown(this._dropdownId);
      }
    }
    var Ly = i(38119);
    class ky {
      constructor(e) {
        this._symbolModel = e;
      }
      getVisible() {
        return this._symbolModel.visible().value();
      }
      setVisible(e) {
        this._symbolModel.visible().setValue(e);
        return this;
      }
      getIcon() {
        return this._symbolModel.icon().value();
      }
      setIcon(e) {
        this._symbolModel.icon().setValue(e);
        return this;
      }
      getColor() {
        return this._symbolModel.color().value();
      }
      setColor(e) {
        this._symbolModel.color().setValue(e);
        return this;
      }
      getTooltip() {
        return this._symbolModel.tooltip().value();
      }
      setTooltip(e) {
        this._symbolModel.tooltip().setValue(e);
        return this;
      }
      getDropDownContent() {
        return this._symbolModel.tooltipContent().value();
      }
      setDropDownContent(e) {
        this._symbolModel.tooltipContent().setValue(e);
        return this;
      }
    }
    class Dy {
      symbol(e) {
        return new ky(this._model().getSymbolCustomStatus(e));
      }
      hideAll() {
        this._model().hideAll();
      }
      static getInstance() {
        if (this._instance === null) {
          this._instance = new Dy();
        }
        return this._instance;
      }
      _model() {
        return Ly.CustomStatusModel.getInstance();
      }
    }
    Dy._instance = null;
    var Ey = i(19291);
    var By = i(15754);
    var Vy = i(27514);
    var Ry = i(25931);
    var Ny = i(43222);
    (0, L.setClasses)();
    const Oy = (0, r.getChartingLibraryGlobalContext)();
    const Fy = (0, r.getChartingLibraryOwner)();
    const Wy = new class {
      constructor(e, t) {
        this._updateDocumentHeight = e => {
          if (this._viewportType === "visual") {
            this._window.document.documentElement.style.setProperty("height", `${e}px`, "important");
          }
        };
        this._window = e;
        this._fullscreenApi = new Oe(e.document);
        this._viewportType = ze.CheckMobile.iOS() && !(0, He.isOnMobileAppPage)("any") && this._window.visualViewport ? "visual" : "quirks";
        if (this._viewportType === "visual") {
          this._viewport = (0, n.ensure)(this._window.visualViewport);
        } else {
          this._viewport = this._window;
        }
        const i = this._layoutSizeSensor = this._window.document.createElement("div");
        i.id = "layout-size-sensor";
        i.style.position = "fixed";
        i.style.top = "0";
        i.style.left = "0";
        i.style.right = "0";
        i.style.bottom = "0";
        i.style.pointerEvents = "none";
        i.style.visibility = "hidden";
        this._initFullscreen();
      }
      allocate() {
        this.free();
        const e = this._window.document;
        const t = e.createElement("div");
        t.classList.add("js-rootresizer__contents");
        t.style.position = "relative";
        t.style.width = "100%";
        t.style.height = "100%";
        e.body.insertAdjacentElement("afterbegin", t);
        e.body.insertAdjacentElement("afterbegin", this._layoutSizeSensor);
        this._visibilityApi = new Fe(this._window.document);
        const i = {
          alive: new F.WatchedValue(true),
          fullscreenable: new F.WatchedValue(true),
          container: new F.WatchedValue(t),
          width: new F.WatchedValue(),
          height: new F.WatchedValue(),
          availWidth: new F.WatchedValue(),
          availHeight: new F.WatchedValue(),
          visible: this._visibilityApi.isVisible,
          fullscreen: this._fullscreenApi.isFullscreen,
          remove: () => {
            i.alive.setValue(false);
          },
          attach: () => {
            i.alive.setValue(false);
            this._window.close();
          },
          requestFullscreen: () => {
            this._requestFullscreen();
          },
          exitFullscreen: () => {
            this._exitFullscreen();
          }
        };
        i.alive.subscribe(e => {
          if (!e && i === this._area) {
            this.free();
          }
        });
        this._area = i;
        this._resizeHandler = () => {
          const e = this._width(i) || 800;
          const t = this._height(i) || 600;
          i.availHeight.setValue(t);
          i.availWidth.setValue(e);
          i.height.setValue(t);
          i.width.setValue(e);
        };
        this._area.height.subscribe(this._updateDocumentHeight, {
          callWithLast: true
        });
        this._resizeHandler();
        this._viewport.addEventListener("resize", this._resizeHandler);
        return new Ne(i).bridge();
      }
      free() {
        if (this._resizeHandler) {
          this._viewport.removeEventListener("resize", this._resizeHandler);
          this._resizeHandler = undefined;
        }
        if (this._visibilityApi) {
          this._visibilityApi.destroy();
          this._visibilityApi = undefined;
        }
        if (this._area) {
          const e = this._area;
          this._area = undefined;
          e.height.unsubscribe(this._updateDocumentHeight);
          e.alive.setValue(false);
          const t = e.container.value();
          const i = t?.parentElement;
          if (i) {
            i.removeChild(t);
            i.removeChild(this._layoutSizeSensor);
          }
        }
      }
      _height(e) {
        if (this._viewportType === "visual") {
          return this._layoutSizeSensor.clientHeight;
        }
        return e.container.value().clientHeight;
      }
      _width(e) {
        return e.container.value().clientWidth;
      }
      _requestFullscreen() {
        this._fullscreenApi.enter();
      }
      _exitFullscreen() {
        this._fullscreenApi.exit();
      }
      _initFullscreen() {
        this._fullscreenApi.isFullscreen.subscribe(e => {
          if (this._resizeHandler) {
            this._resizeHandler();
          }
        });
      }
    }(window);
    const Hy = new class {
      constructor(e) {
        this._processVisibility = e => {
          const t = e.container.value();
          if (this.affectsLayout(e.name)) {
            if (t) {
              t.classList.toggle("js-hidden", false);
            }
            return true;
          } else {
            if (t) {
              t.classList.toggle("js-hidden", true);
            }
            return false;
          }
        };
        this._setWidth = (e, t, i) => {
          let s = i;
          if (this._fullscreenArea !== e.name) {
            e.availWidth.setValue(i);
            if (e.canNegotiate.width) {
              s = Ue(i, e.negotiations.width);
            }
          }
          if (!t) {
            s = 0;
          }
          const o = e.container.value();
          if (o && t) {
            o.style.width = s + "px";
          }
          e.width.setValue(s);
          return s;
        };
        this._setHeight = (e, t, i) => {
          let s = i;
          if (this._fullscreenArea !== e.name) {
            e.availHeight.setValue(i);
            if (e.canNegotiate.height) {
              s = Ue(i, e.negotiations.height);
            }
          }
          if (!t) {
            s = 0;
          }
          const o = e.container.value();
          if (o && t) {
            o.style.height = s + "px";
          }
          e.height.setValue(s);
          return s;
        };
        const t = e.container.value();
        if (!t) {
          throw new Error("bridge.container.value() must be an element");
        }
        this._container = t;
        this._availableAreas = ["left", "tradingpanel", "right", "top", "bottom", "center", "topleft", "extratop"];
        this._areas = {};
        this._bridge = e;
        this._width = e.width;
        this._height = e.height;
        this._width.subscribe(() => this.recalculate());
        this._height.subscribe(() => this.recalculate());
        this._bridge.visible.subscribe(() => this._updateVisibility());
        this._bridge.fullscreen.subscribe(() => this._onParentFullscreenChange());
        this.recalculate();
      }
      allocate(e) {
        const t = e && e.areaName;
        if (this._availableAreas.indexOf(t) === -1) {
          throw new Error("unknown options.areaName");
        }
        this.free(t);
        const i = this._createDOM(t);
        const s = {
          name: t,
          canNegotiate: {
            width: t === "left" || t === "right" || t === "tradingpanel" || t === "topleft",
            height: t === "top" || t === "bottom" || t === "topleft" || t === "extratop"
          },
          negotiations: {
            width: [],
            height: []
          },
          remove: () => {
            for (const e in this._areas) {
              if (this._areas[e] === s) {
                this.free(e);
              }
            }
          },
          negotiateWidth: e => {
            if (!s.canNegotiate.width) {
              return;
            }
            const t = je(e);
            if (!Ge(s.negotiations.width, t)) {
              s.negotiations.width = t;
              this.recalculate();
            }
          },
          negotiateHeight: e => {
            if (!s.canNegotiate.height) {
              return;
            }
            const t = je(e);
            if (!Ge(s.negotiations.height, t)) {
              s.negotiations.height = t;
              this.recalculate();
            }
          },
          requestFullscreen: () => {
            if (!this._fullscreenArea) {
              if (t === "right" || t === "center") {
                this._fullscreenArea = t;
              }
              if (t === "center") {
                this._bridge.requestFullscreen();
              }
              this._updateFullscreen();
            }
          },
          exitFullscreen: () => {
            if (t === this._fullscreenArea) {
              this._fullscreenArea = undefined;
              if (t === "center") {
                this._bridge.exitFullscreen();
              }
              this._updateFullscreen();
            }
          },
          width: new F.WatchedValue(),
          height: new F.WatchedValue(),
          availWidth: new F.WatchedValue(),
          availHeight: new F.WatchedValue(),
          alive: new F.WatchedValue(true),
          container: new F.WatchedValue(i),
          visible: new F.WatchedValue(true),
          fullscreen: new F.WatchedValue(false),
          fullscreenable: new F.WatchedValue(t === "right" || t === "center"),
          rdState: new Ne()
        };
        s.rdState.pushOwner(s);
        this._areas[t] = s;
        s.rdState.owner.subscribe(e => {
          const i = s.container.value();
          if (e !== s) {
            if (i) {
              i.innerHTML = "";
              if (i.parentElement) {
                i.parentElement.removeChild(i);
              }
            }
          } else {
            let e = null;
            for (let i = this._availableAreas.indexOf(t); i--;) {
              const t = this._availableAreas[i];
              if (this.affectsLayout(t)) {
                e = this._areas[t].container.value();
                break;
              }
            }
            if (i) {
              if (e && i.parentElement) {
                i.insertAdjacentElement("afterend", e);
              } else {
                this._container.appendChild(i);
              }
            }
          }
          this.recalculate();
        }, {
          callWithLast: true
        });
        return s.rdState.bridge();
      }
      free(e) {
        const t = this._areas[e];
        if (!t) {
          return;
        }
        this._areas[e] = undefined;
        const i = t.container.value();
        if (i && i.parentElement) {
          i.parentElement.removeChild(i);
        }
        t.alive.setValue(false);
      }
      recalculate() {
        const e = {};
        this._recalcSingleRunToken = e;
        const t = this._areas.topleft;
        const i = this._areas.left;
        const s = this._areas.tradingpanel;
        const o = this._areas.right;
        const n = this._areas.top;
        const r = this._areas.bottom;
        const a = this._areas.center;
        const l = this._areas.extratop;
        const c = this._width.value();
        const h = this._height.value();
        let d = 0;
        let u = 0;
        let _ = 0;
        let p = 0;
        let m = 0;
        let g = 0;
        let f = 0;
        let y = 0;
        if (e === this._recalcSingleRunToken && l) {
          const e = this._processVisibility(l);
          y = this._setHeight(l, e, h);
          this._setWidth(l, e, c);
        }
        if (e === this._recalcSingleRunToken && t) {
          const e = this._processVisibility(t);
          f = this._setHeight(t, e, h);
          g = this._setWidth(t, e, c);
          const i = t.container.value();
          if (e && i) {
            i.style.top = y + "px";
          }
        }
        let v = 0;
        if (e === this._recalcSingleRunToken && n) {
          const e = this._processVisibility(n);
          const t = n.container.value();
          if (e && t) {
            t.style.left = g + "px";
            t.style.top = y + "px";
          }
          const i = c - g;
          this._setWidth(n, e, i);
          d = this._setHeight(n, e, h);
          if (d) {
            v = 1;
          }
        }
        if (e === this._recalcSingleRunToken && i) {
          const e = this._processVisibility(i);
          const t = Math.max(f, d);
          _ = this._setWidth(i, e, c);
          if (_) {
            _ += 4;
          }
          if (_ && v === 1) {
            v = 4;
          }
          const s = i.container.value();
          if (e && s) {
            s.style.top = t + y + v + "px";
          }
          this._setHeight(i, e, h - t - y);
        }
        if (e === this._recalcSingleRunToken && s) {
          const e = this._processVisibility(s);
          let t = c - _;
          if (!qe) {
            t -= 300;
          }
          m = this._setWidth(s, e, t);
          if (m && v === 1) {
            v = 4;
          }
          this._setHeight(s, e, h - y - d - v);
        }
        if (e === this._recalcSingleRunToken && o) {
          const e = this._processVisibility(o);
          let t = c - _ - m;
          if (!qe) {
            t -= 300;
          }
          p = this._setWidth(o, e, t);
          if (p && v === 1) {
            v = 4;
          }
          this._setHeight(o, e, h - y - d - v);
          const i = o.container.value();
          if (e && i) {
            i.style.top = d + y + v + "px";
          }
        }
        const S = m + p;
        let b = 0;
        let w = c - _ - m - p - (S ? 4 : 0);
        const C = Boolean(m || !S);
        if (!p && m) {
          w += 4;
        }
        if (e === this._recalcSingleRunToken && r) {
          const e = this._processVisibility(r);
          const t = r.container.value();
          if (e && t) {
            t.style.left = _ + "px";
            t.classList.toggle("no-border-top-left-radius", !_);
            t.classList.toggle("no-border-top-right-radius", C);
          }
          this._setWidth(r, e, w);
          const i = h - y;
          b = Math.min(300, i - 0);
          u = this._setHeight(r, e, i) + 4;
        }
        const P = Boolean(d && (_ || S));
        this._container.classList.toggle("layout-with-border-radius", P);
        if (e === this._recalcSingleRunToken && a) {
          const e = this._processVisibility(a);
          const t = a.container.value();
          if (e && t) {
            t.style.left = _ + "px";
            t.style.top = d + y + v + "px";
            t.classList.toggle("no-border-bottom-left-radius", !u || !_);
            t.classList.toggle("no-border-bottom-right-radius", C || !u);
            t.classList.toggle("no-border-top-left-radius", Boolean(!_ && S));
            t.classList.toggle("no-border-top-right-radius", C);
          }
          this._setWidth(a, e, w);
          const i = h - d - u - y - v;
          this._setHeight(a, e, Math.max(i, b));
        }
        if (e === this._recalcSingleRunToken && s && this.affectsLayout("tradingpanel")) {
          const e = s.container.value();
          if (e) {
            e.style.right = m && p ? `${p + 4}px` : `${p}px`;
            e.style.top = y + d + v + "px";
            e.style.borderTopRightRadius = P && p ? "4px" : "0px";
          }
        }
        if (e === this._recalcSingleRunToken) {
          this._updateVisibility();
        }
      }
      affectsLayout(e) {
        const t = this._areas[e];
        if (!t) {
          return false;
        }
        if (t.rdState.owner.value() !== t) {
          return false;
        }
        if (this._fullscreenArea && this._fullscreenArea !== e) {
          return Ye(e);
        }
        if (this._width.value() <= 567 || this._height.value() <= 445 && !Ke) {
          if (!["center", "top", "left", "topleft", "extratop"].includes(e)) {
            return false;
          }
        }
        return true;
      }
      _updateVisibility() {
        const e = this._bridge.visible.value();
        for (let t = 0; t < this._availableAreas.length; t++) {
          const i = this._availableAreas[t];
          const s = this._areas[i];
          if (s) {
            if (e && this.affectsLayout(i)) {
              s.visible.setValue(true);
            } else {
              s.visible.setValue(false);
            }
          }
        }
      }
      _onParentFullscreenChange() {
        if (!this._bridge.fullscreen.value()) {
          this._fullscreenArea = undefined;
          this._updateFullscreen();
        }
      }
      _updateFullscreen() {
        const e = this._fullscreenArea !== undefined;
        for (let t = 0; t < this._availableAreas.length; t++) {
          const i = this._availableAreas[t];
          const s = this._areas[i];
          if (!s) {
            continue;
          }
          if (i === this._fullscreenArea) {
            s.fullscreen.setValue(true);
            continue;
          }
          s.fullscreen.setValue(false);
          const o = s.container.value();
          if (o) {
            o.classList.toggle("js-hidden", e && !Ye(i));
          }
        }
        this._updateVisibility();
        this.recalculate();
      }
      _createDOM(e) {
        const t = document.createElement("div");
        t.classList.add("layout__area--" + e);
        t.style.position = "absolute";
        if (e === "tradingpanel") {
          t.style.borderTopRightRadius = "4px";
        }
        if (e === "bottom") {
          t.style.bottom = "0";
        } else {
          t.style.top = "0";
        }
        if (e === "right" || e === "tradingpanel") {
          t.style.right = "0";
        } else {
          t.style.left = "0";
        }
        return t;
      }
    }(Wy.allocate());
    Fy.brokerFactory;
    const zy = Boolean(false);
    const Uy = Oy.urlParams;
    Oy.DEFAULT_SYMBOL = Uy.symbol ?? "";
    const jy = new AbortController();
    const Gy = Fy.getCustomIndicators;
    const qy = (0, me.createDeferredPromise)();
    const $y = (0, me.createDeferredPromise)();
    const Ky = (0, me.createDeferredPromise)();
    const Yy = l.enabled("left_toolbar");
    const Zy = l.enabled("library_custom_color_themes");
    const Xy = JSON.parse(Uy.widgetbar);
    const Jy = l.enabled("right_toolbar") && (Xy.watchlist || Xy.details || Xy.news || Xy.datawindow || l.enabled("dom_widget") || l.enabled("order_panel") || l.enabled("show_object_tree") || l.enabled("bugreport_button"));
    const Qy = l.enabled("header_widget") ? Hy.allocate({
      areaName: "top"
    }) : null;
    const ev = Yy ? Hy.allocate({
      areaName: "left"
    }) : null;
    const tv = Hy.allocate({
      areaName: "center"
    });
    if (Jy) {
      Hy.allocate({
        areaName: "right"
      });
    }
    const iv = null;
    if (Fy.contextMenu !== undefined) {
      jf.setContextMenuOptions(Fy.contextMenu);
    }
    Promise.all([qy.promise, $y.promise, Ky.promise]).then(() => {
      Oy.ChartApiInstance.start();
    });
    if (typeof Gy == "function") {
      const e = Gy({
        Std: qf.Std
      });
      if (e && e.then) {
        e.then(e => {
          if (!Array.isArray(e)) {
            console.warn("custom_indicators_getter should be a function that returns a Promise object which result is an array of custom indicators");
            qy.resolve();
            return;
          }
          const t = Oy.JSServer;
          t.studyLibrary.push.apply(t.studyLibrary, e);
          qy.resolve();
          console.log("{0} custom indicators loaded.".format(e.length));
        }).catch(e => {
          console.warn("Error loading custom indicators " + e);
          qy.resolve();
        });
      } else {
        console.warn("custom_indicators_getter should be a function that returns a Promise object");
        qy.resolve();
      }
    } else {
      qy.resolve();
    }
    Oy.widgetReady = e => {
      W.subscribe("onChartReady", e, null);
    };
    const sv = Uy.theme?.toLowerCase() ?? oo.StdTheme.Light;
    var ov;
    function nv(e) {
      Oy.__defaultsOverrides = Oy.__defaultsOverrides || {};
      (0, ge.deepExtend)(Oy.__defaultsOverrides, e);
      if (TradingView.defaultProperties !== undefined && TradingView.defaultProperties.chartproperties !== undefined) {
        (0, h.applyDefaultsOverrides)(TradingView.defaultProperties.chartproperties);
        (0, h.applyDefaultOverridesToLinetools)();
      }
    }
    ov = sv;
    if (k.themes[ov]) {
      (0, D.setTheme)(ov);
    }
    (async function (e) {
      if (!Zy || e === undefined) {
        return;
      }
      try {
        const {
          overrideStandardThemes: t
        } = await i.e(2413).then(i.bind(i, 57626));
        t(e);
      } catch (e) {
        console.error("Error applying custom themes", e);
      }
    })(Fy.customThemes).then(Ky.resolve).catch(Ky.resolve);
    Oy.applyStudiesOverrides = e => {
      if (e) {
        if (Oy.chartWidgetCollection) {
          Oy.chartWidgetCollection.applyStudiesOverrides?.(e);
        } else {
          is.StudyMetaInfo.mergeDefaultsOverrides(e);
        }
      }
    };
    Oy.applyOverrides = e => {
      nv(e);
      if (Oy.chartWidgetCollection) {
        Oy.chartWidgetCollection.applyOverrides(e);
      }
    };
    Oy.doWhenApiIsReady = e => {
      if (Oy.tradingViewApi) {
        e();
      } else {
        $y.promise.then(e);
      }
    };
    Oy.applyTradingCustomization = e => {
      if (e.order) {
        for (const t in e.order) {
          TradingView.defaultProperties.linetoolorder[t] = e.order[t];
        }
      }
      if (e.position) {
        for (const t in e.position) {
          TradingView.defaultProperties.linetoolposition[t] = e.position[t];
        }
      }
      if (iv !== null) {
        iv.then(t => {
          function i(e) {
            const t = {};
            for (const i of Object.keys(e ?? {})) {
              const s = i.split(".");
              let o = t;
              for (const e of s.slice(0, s.length - 1)) {
                if (!o.hasOwnProperty(e)) {
                  o[e] = {};
                }
                o = o[e];
              }
              o[s[s.length - 1]] = e[i];
            }
            return t;
          }
          if (t === null) {
            return;
          }
          const s = i(e.brokerOrder);
          const o = i(e.brokerPosition);
          t?.overrideTradedGroupStyles({
            order: {
              lightTheme: s,
              darkTheme: s
            },
            position: {
              lightTheme: o,
              darkTheme: o
            }
          });
        });
      }
    };
    Oy.changeTheme = (e, t) => {
      const i = k.themes[e.toLowerCase()];
      if (i) {
        return Oy.tradingViewApi.themes().setStdTheme(i.name, true, t && t.disableUndo);
      } else {
        return Promise.resolve();
      }
    };
    Oy.getTheme = () => Oy.tradingViewApi.themes().getCurrentThemeName();
    Oy.customThemes = async () => {
      if (!Zy) {
        return Promise.reject(new Error("The library_custom_color_themes feature must be enabled to use the custom themes API"));
      }
      return new (await i.e(2413).then(i.bind(i, 20688))).CustomThemesApi();
    };
    Oy.is_authenticated = false;
    JSON.parse(Oy.urlParams.brokerConfig);
    a.t(null, undefined, i(94566));
    a.t(null, undefined, i(92800));
    a.t(null, undefined, i(44676));
    let rv = null;
    const av = (0, me.createDeferredPromise)();
    let lv;
    const cv = () => {
      l.setEnabled("charting_library_export_chart_data", !Oy.configurationData.is_tradingview_data);
      l.setEnabled("charting_library_debug_mode", Uy.debug === "true" || l.enabled("charting_library_debug_mode"));
      l.setEnabled("chart_property_page_trading", false);
      if (l.enabled("remove_library_container_border")) {
        const e = document.querySelector("#library-container");
        if (e !== null) {
          e.style.border = "0px";
          e.style.padding = "1px";
        }
      }
      if (l.enabled("no_min_chart_width")) {
        document.body.style.minWidth = "0px";
      }
      if (Uy.studiesOverrides != null) {
        is.StudyMetaInfo.mergeDefaultsOverrides(JSON.parse(Uy.studiesOverrides));
      }
      (0, n.assert)(TradingView.defaultProperties === undefined, "Default properties are inited before applying overrides");
      nv(JSON.parse(Uy.overrides));
      const e = Uy.numeric_formatting ? JSON.parse(Uy.numeric_formatting) : undefined;
      if (e) {
        if (typeof e.decimal_sign == "string") {
          ue.formatterOptionsLibraryOverrides.decimalSign = e.decimal_sign[0];
        }
        if (typeof e.grouping_separator == "string") {
          ue.formatterOptionsLibraryOverrides.groupingSeparator = e.grouping_separator[0];
        }
      }
      Oy.ChartApiInstance = new (sf())(Fy.datafeed);
      const t = Fy.customFormatters;
      if (t) {
        if (t.timeFormatter) {
          _e.customFormatters.timeFormatter = t.timeFormatter;
        }
        if (t.dateFormatter) {
          _e.customFormatters.dateFormatter = t.dateFormatter;
        }
        if (t.tickMarkFormatter) {
          _e.customFormatters.tickMarkFormatter = t.tickMarkFormatter;
        }
        if (t.priceFormatterFactory) {
          _e.customFormatters.priceFormatterFactory = t.priceFormatterFactory;
        }
        if (t.studyFormatterFactory) {
          _e.customFormatters.studyFormatterFactory = t.studyFormatterFactory;
        }
      }
      if (Fy.customTimezones) {
        Ee.instance().addTimezones(Fy.customTimezones);
      }
      Oy.ChartApiInstance.setStudiesAccessController(Oy.ChartApiInstance.createStudiesAccessController(Uy.studiesAccess));
      const s = Uy.chartContent ? JSON.parse(Uy.chartContent).json : undefined;
      const r = Uy.chartContentExtendedData ? JSON.parse(Uy.chartContentExtendedData) : s ? s.extendedData : undefined;
      const c = Uy.interval || "D";
      const h = function (e) {
        const t = /(\d+)(\w+)/;
        return e.map(e => {
          const s = (0, n.ensureNotNull)(t.exec(e.text));
          const o = s[2].toLowerCase();
          const r = parseInt(s[1]);
          const l = o === "y" ? r * 12 + "M" : r + o;
          const c = Re.Interval.parse(e.resolution);
          return {
            text: e.title || {
              y: a.t(null, {
                plural: "{count}y",
                count: r,
                context: "short_N_year"
              }, i(46766)),
              m: a.t(null, {
                plural: "{count}m",
                count: r,
                context: "short_N_month"
              }, i(58590)),
              d: a.t(null, {
                plural: "{count}d",
                count: r,
                context: "short_N_day"
              }, i(47801))
            }[o] || `${r}${o}`,
            description: e.description || "",
            value: {
              value: l.toUpperCase(),
              type: "period-back"
            },
            targetResolution: c.value(),
            requiresIntraday: c.isIntraday()
          };
        });
      }(JSON.parse(Uy.timeFrames));
      const d = {
        resizerBridge: tv,
        padding: l.enabled("border_around_the_chart") ? 2 : 0,
        content: s,
        widgetOptions: {
          addToWatchlistEnabled: false,
          hideIdeas: true,
          addVolume: (0, n.ensureDefined)(Oy.ChartApiInstance.studiesAccessController).isToolEnabled("Volume"),
          muteSessionErrors: true,
          timezone: Uy.timezone,
          defSymbol: Uy.symbol ?? "",
          defInterval: s ? "" : c,
          compareSymbols: Uy.compareSymbols && JSON.parse(Uy.compareSymbols),
          defTimeframe: (u = Fy.timeframe, u ? typeof u == "string" ? u : {
            ...u,
            type: "time-range"
          } : u),
          paneContextMenuEnabled: l.enabled("pane_context_menu"),
          paneContextMenu: {
            mainSeriesTrade: zy
          },
          priceScaleContextMenuEnabled: l.enabled("scales_context_menu"),
          currencyConversionEnabled: l.enabled("pricescale_currency"),
          unitConversionEnabled: l.enabled("pricescale_unit"),
          legendWidgetEnabled: l.enabled("legend_widget"),
          legendWidget: {
            contextMenu: {
              settings: l.enabled("show_chart_property_page"),
              showOpenMarketStatus: l.enabled("display_market_status")
            }
          },
          sourceStatusesWidget: {
            errorSolution: false
          },
          marketStatusWidgetEnabled: l.enabled("display_market_status"),
          chartWarningWidget: {
            subscriptionFullInfo: false
          },
          timeScaleWidget: {
            contextMenuEnabled: l.enabled("scales_context_menu"),
            timezoneMenuEnabled: l.enabled("timezone_menu"),
            priceAxisLabelsOptions: {
              showLabels: l.enabled("main_series_scale_menu")
            }
          },
          timeScale: {
            preserveBarSpacing: false,
            lockVisibleTimeRangeOnResize: l.enabled("lock_visible_time_range_on_resize"),
            rightBarStaysOnScroll: l.enabled("right_bar_stays_on_scroll"),
            minBarSpacing: Uy.time_scale && JSON.parse(Uy.time_scale).min_bar_spacing
          },
          goToDateEnabled: l.enabled("go_to_date"),
          crossHair: {
            menuEnabled: l.enabled("chart_crosshair_menu")
          },
          handleScale: {
            mouseWheel: l.enabled("mouse_wheel_scale"),
            pinch: l.enabled("pinch_scale"),
            axisPressedMouseMove: {
              time: l.enabled("axis_pressed_mouse_move_scale"),
              price: l.enabled("axis_pressed_mouse_move_scale")
            }
          },
          handleScroll: {
            mouseWheel: l.enabled("mouse_wheel_scroll"),
            pressedMouseMove: l.enabled("pressed_mouse_move_scroll"),
            horzTouchDrag: l.enabled("horz_touch_drag_scroll"),
            vertTouchDrag: l.enabled("vert_touch_drag_scroll")
          },
          shiftVisibleRangeOnNewBar: l.enabled("shift_visible_range_on_new_bar"),
          croppedTickMarks: l.enabled("cropped_tick_marks"),
          countdownEnabled: l.enabled("countdown"),
          indicatorsDialogShortcutEnabled: l.enabled("insert_indicator_dialog_shortcut")
        },
        seriesControlBarEnabled: l.enabled("timeframes_toolbar"),
        seriesControlBar: {
          timeFramesWidgetEnabled: true,
          timeFramesWidget: {
            goToDateEnabled: l.enabled("go_to_date"),
            availableTimeFrames: (e, t) => {
              if (!e) {
                return [];
              }
              if (t !== _t.STATUS_DELAYED && t !== _t.STATUS_DELAYED_STREAMING && t !== _t.STATUS_EOD && t !== _t.STATUS_READY) {
                return [];
              }
              return h.filter(t => (!t.requiresIntraday || !!e.has_intraday) && (!e.supported_resolutions || !!e.supported_resolutions.includes(t.targetResolution)));
            }
          },
          timeWidgetEnabled: true,
          timeWidget: {
            timezoneMenuEnabled: l.enabled("timezone_menu")
          },
          adjustForDividendsButtonEnabled: false,
          sessionIdButtonEnabled: l.enabled("pre_post_market_sessions"),
          backAdjustmentButtonEnabled: false,
          settlementAsCloseButtonEnabled: false,
          percentageScaleButtonEnabled: true,
          logScaleButtonEnabled: true,
          autoScaleButtonEnabled: true,
          fullscreenButtonEnabled: true,
          mobileChangeLayoutEnabled: false
        },
        globalEvents: true,
        snapshotUrl: Uy.snapshotUrl,
        mobileForceChartMaximizeEnabled: false,
        saveChartEnabled: l.enabled("save_shortcut")
      };
      var u;
      if (Yy) {
        (0, Jg.createFavoriteDrawingToolbar)();
        d.widgetOptions.isDrawingToolbarVisible = x.isDrawingToolbarVisible;
      }
      if (r) {
        d.metaInfo = {
          id: r.uid,
          name: r.name,
          description: r.description,
          uid: r.uid,
          username: ""
        };
      }
      if (Fy.additionalSymbolInfoFields) {
        (0, Iy.setAdditionalSymbolInfoFields)(Fy.additionalSymbolInfoFields);
      }
      const _ = Fy.symbolSearchComplete;
      if (_) {
        (0, My.setSymbolSearchCompleteOverrideFunction)(_);
      }
      const p = Oy.chartWidgetCollection = new Xg(d);
      let m = false;
      p.onAboutToBeDestroyed.subscribe(null, () => {
        m = true;
      }, true);
      (function (e) {
        e.addCustomSource("branding", (t, i) => {
          const s = (0, Ji.combine)((e, t) => {
            const s = e ?? t;
            return s !== null && s.hasModel() && s.model().model() === i;
          }, e.maximizedChartWidget().weakReference(), e.leftBottomChartWidget().weakReference());
          return new vy(t, i, s.ownership());
        }, Eo.CustomSourceLayer.Topmost);
      })(p);
      Oy.studyMarket = new pe(p);
      Je.registerService(Xe.CHART_WIDGET_COLLECTION_SERVICE, p);
      p.activeChartWidget.subscribe(e => {
        W.emit("activeChartChanged", p.getAll().indexOf(e));
      });
      Oy.saver = new O.ChartSaver(p);
      const g = new J(p, Oy.saver);
      p.setSaveChartService(g);
      const f = new oe(p);
      Oy.chartWidget = p.activeChartWidget.value();
      Oy.pro = new TradingView.Pro();
      const y = function (e) {
        if (!Qy) {
          return null;
        }
        const t = new A.ChartChangesWatcher(e.chartWidgetCollection, Oy.saver, W);
        const s = JSON.parse(Uy.favorites);
        s.intervals = s.intervals.map(e => {
          let t = "" + e;
          if (t.match(/1[DWMYdwmy]/)) {
            t = t.slice(1);
          }
          return t;
        });
        if (l.enabled("study_templates")) {
          lv = new he({
            chartWidgetCollection: e.chartWidgetCollection
          });
        }
        let o;
        const n = Uy.header_widget_buttons_mode;
        if (n === "fullsize") {
          o = ["full"];
        }
        if (n === "compact") {
          o = ["small"];
        }
        const r = (0, Vy.shouldShowQuickSearchOnLib)() ? function (e) {
          const t = t => Promise.all([i.e(4211), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(2564), i.e(7384), i.e(2197), i.e(5323), i.e(1072), i.e(9325), i.e(2736), i.e(4066), i.e(116), i.e(8985), i.e(6489), i.e(4106), i.e(7444), i.e(7001), i.e(6262), i.e(1906), i.e(2227), i.e(4931), i.e(9418), i.e(3202), i.e(2751), i.e(1890), i.e(2157), i.e(9754)]).then(i.bind(i, 46350)).then(i => {
            const s = new (0, i.GlobalSearchDialogRenderer)(e);
            if (Ve !== null) {
              Ve.hide();
            }
            s.show(t);
            Ve = s;
            return s;
          });
          (0, B.createGroup)({
            desc: "GlobalSearch"
          }).add({
            desc: "Open",
            hotkey: B.Modifiers.Mod + 75,
            handler: () => t()
          });
          return t;
        }(e.loadChartService) : undefined;
        return new T(new v(), {
          chartSaver: Oy.saver,
          chartApiInstance: Oy.ChartApiInstance,
          chartWidgetCollection: e.chartWidgetCollection,
          defaultFavoriteStyles: s.chartTypes,
          defaultFavoriteIntervals: s.intervals,
          resizerBridge: Qy,
          studyMarket: Oy.studyMarket,
          studyTemplates: lv,
          allowedModes: o,
          saveChartService: e.saveChartService,
          loadChartService: e.loadChartService,
          chartChangesWatcher: t,
          onClick: pv,
          snapshotUrl: e.snapshotUrl,
          openGlobalSearch: r
        });
      }({
        chartWidgetCollection: p,
        saveChartService: g,
        loadChartService: f,
        snapshotUrl: Uy.snapshotUrl
      });
      if (y !== null) {
        y.load().then(e => {
          rv = e.getComponent();
          av.resolve();
        });
      } else {
        av.promise.catch(() => { });
        av.reject("header widget is not loaded");
      }
      const S = function (e) {
        if (ev) {
          const t = Uy.toolbarbg && /^[0-9a-f]+$/i.test(Uy.toolbarbg) ? String(Uy.toolbarbg) : undefined;
          if (t) {
            const e = document.createElement("style");
            e.textContent = "body,.chart-controls-bar,#footer-chart-panel{background-color:#" + t + " !important}";
            document.head.appendChild(e);
          }
          return new M({
            bgColor: t,
            chartWidgetCollection: e,
            drawingsAccess: Uy.drawingsAccess ? JSON.parse(Uy.drawingsAccess) : undefined,
            resizerBridge: ev,
            onClick: pv
          });
        }
        return null;
      }(p);
      const b = null;
      Oy.tradingViewApi = new jf({
        chartWidgetCollection: p,
        chartApiInstance: Oy.ChartApiInstance,
        saveChartService: g,
        loadChartService: f,
        studyMarket: null
      });
      de.linking.bindToChartWidgetCollection(p);
      if (!isNaN(Uy.studyCountLimit)) {
        TradingView.STUDY_COUNT_LIMIT = Math.max(2, +(0, n.ensureDefined)(Uy.studyCountLimit));
      }
      if (!isNaN(Uy.ssreqdelay)) {
        const e = Math.max(0, +(0, n.ensureDefined)(Uy.ssreqdelay));
        (0, Gf.setSearchRequestDelay)(e);
      }
      Oy.ChartApiInstance.connect();
      (async () => {
        const {
          default: e
        } = await Promise.all([i.e(7827), i.e(3703), i.e(3953), i.e(4178), i.e(5826), i.e(9481), i.e(4600), i.e(6445), i.e(7384), i.e(5323), i.e(2736), i.e(4066), i.e(6489), i.e(4353), i.e(2440), i.e(9255), i.e(7001), i.e(3745), i.e(6262), i.e(6842), i.e(5099), i.e(2227), i.e(2544), i.e(1890), i.e(2157), i.e(7843), i.e(2306)]).then(i.t.bind(i, 36074, 23));
        if (!m) {
          Oy.lineToolPropertiesToolbar = new e(p);
        }
      })();
      const w = document.querySelector(".tv-content");
      if (w !== null) {
        w.addEventListener("contextmenu", e => {
          if (e.target instanceof Element && e.target.tagName.toLowerCase() !== "input" && e.target.tagName.toLowerCase() !== "textarea") {
            e.preventDefault();
          }
        });
      }
      $y.resolve();
      p.undoHistory.undoStack().onChange().subscribe(null, (0, o.default)(e => {
        if (e?.affectsState()) {
          W.emit("onAutoSaveNeeded");
        }
      }, (Number(Uy.autoSaveDelay) || 5) * 1000, {
        leading: false,
        trailing: true
      }));
      let C = false;
      function P() {
        if (S) {
          S.load(jy.signal);
        }
        if (b) {
          b.load(jy.signal).then(e => {
            Oy.footerWidget = e.getComponent();
          });
        }
      }
      Oy.chartWidget.withModel(null, () => {
        Oy.ChartApiInstance.on("realtime_tick", e => {
          W.emit("onTick", e);
        });
        if (!k.savedThemeName() && sv) {
          const e = k.getStdTheme(sv);
          if (e && e.content && s === undefined) {
            p.applyTheme({
              theme: e.content,
              onlyActiveChart: false,
              restoreNonThemeDefaults: false,
              themeName: sv,
              standardTheme: true,
              syncState: true,
              noUndo: true
            }).then(() => Oy.applyOverrides(Oy.__defaultsOverrides));
          }
        }
        if (l.enabled("charting_library_debug_mode")) {
          W.subscribeToAll((...e) => {
            console.log(`${new Date().toISOString()} Event "${e[0]}", arguments: ${JSON.stringify(e.slice(1))}`);
          });
        }
        if (C) {
          return;
        }
        C = true;
        ef(p);
        (function (e, t) {
          const s = a.t(null, undefined, i(37367)).format({
            emoji: "👍"
          });
          const o = a.t(null, undefined, i(69804)).format({
            emoji: "👍"
          });
          const r = a.t(null, undefined, i(6655)).format({
            emoji: "👍"
          });
          W.on("onServerScreenshotCopiedToClipboard", () => h(s), null);
          W.on("onClientScreenshotCopiedToClipboard", () => h(o), null);
          W.on("onServerScreenshotEmbedCodeCopiedToClipboard", () => h(r), null);
          let l = null;
          const c = e.getContainer();
          function h(e) {
            if (l) {
              l.show(e);
            } else {
              Promise.all([i.e(4524), i.e(4052), i.e(2227), i.e(92)]).then(i.bind(i, 1524)).then(i => {
                if (!l) {
                  l = new i.ChartScreenshotHintRenderer((0, n.ensureNotNull)(c), {
                    bottomPadding: t.seriesControlBarEnabled
                  });
                  l.show(e);
                }
              });
            }
          }
        })(p, {
          seriesControlBarEnabled: l.enabled("timeframes_toolbar")
        });
        i_.getInstance().setWidgetCollection(Oy.chartWidgetCollection);
      });
      if (p.getAll().some(e => e.isInitialized())) {
        P();
      } else {
        (function (e, t) {
          const i = e.getAll();
          const s = () => {
            t();
            i.forEach(e => {
              e.chartWidgetInitialized().unsubscribe(null, s);
            });
          };
          i.forEach(e => {
            e.chartWidgetInitialized().subscribe(null, s, true);
          });
        })(p, P);
      }
      W.subscribe("chart_load_requested", e => {
        Oy.tradingViewApi.loadChart({
          json: JSON.parse(e.content),
          extendedData: e
        });
      }, null);
    };
    window.addEventListener("unload", () => {
      jy.abort();
      if (Oy.widgetbar) {
        Oy.widgetbar.destroy();
        Oy.widgetbar = null;
      }
      if (Oy.chartWidgetCollection) {
        Oy.chartWidgetCollection.destroy();
        Oy.chartWidgetCollection = null;
      }
      if (Oy.ChartApiInstance) {
        Oy.ChartApiInstance.disconnect();
      }
      (0, Ze.destroyQuoteSessions)();
      if (Oy.ChartApiInstance) {
        Oy.ChartApiInstance.destroy();
        Oy.ChartApiInstance = null;
      }
    });
    if (l.enabled("saveload_storage_customization")) {
      if (Fy.saveLoadAdapter) {
        E.setCustomAdapter(Fy.saveLoadAdapter);
      } else if (Oy.urlParams.chartsStorageUrl && Oy.urlParams.clientId) {
        E.initialize(Oy.urlParams.clientId, Oy.urlParams.userId, Oy.urlParams.chartsStorageUrl, Oy.urlParams.chartsStorageVer || "1.0");
      } else {
        l.setEnabled("saveload_storage_customization", false);
        l.setEnabled("header_saveload", false);
      }
    }
    if (Fy.imageStorageAdapter !== undefined && l.enabled("image_drawingtool")) {
      (0, Ry.setImageStorageAdapter)(Fy.imageStorageAdapter);
    }
    const hv = (0, me.createDeferredPromise)();
    function dv() {
      hv.resolve();
    }
    if (Fy.loadLastChart && l.enabled("saveload_storage_customization")) {
      E.getCharts().then(e => {
        if (e.length === 0) {
          dv();
          return;
        }
        const t = e.sort((e, t) => t.modified_iso - e.modified_iso)[0];
        E.getChartContent(t).then(e => {
          const t = e;
          const i = JSON.parse(t.content);
          i.extendedData = e;
          Uy.chartContent = JSON.stringify({
            json: i
          });
          dv();
        }).catch(dv);
      }).catch(dv);
    } else {
      dv();
    }
    const uv = async function () {
      if (l.enabled("saveload_separate_drawings_storage")) {
        const e = await i.e(7129).then(i.bind(i, 40076));
        lm = e.LineToolsSynchronizer;
        return true;
      }
      return false;
    }();
    const _v = (0, me.createDeferredPromise)();
    function pv() {
      const e = TradingView.bottomWidgetBar;
      if (e) {
        e.turnOffMaximize();
      }
    }
    Promise.all([_v.promise, hv.promise, Oy.loadedCustomCss, uv, Ky.promise]).then(() => {
      const e = document.querySelector(".loading-indicator");
      if (e) {
        e.style.display = "none";
      }
      setTimeout(cv, 0);
      if (l.enabled("14851") && Math.random() <= 0.02) {
        t = window;
        i = document;
        s = "script";
        o = "ga";
        t.GoogleAnalyticsObject = o;
        t[o] = t[o] || function () {
          (t[o].q = t[o].q || []).push(arguments);
        };
        t[o].l = Number(new Date());
        r = i.createElement(s);
        a = i.getElementsByTagName(s)[0];
        r.async = 1;
        r.src = "//www.google-analytics.com/analytics.js";
        a.parentNode.insertBefore(r, a);
        const e = (0, n.ensureNotNull)(document.URL.match(new RegExp("(:?.*://)([^/]+)/.*")))[2];
        Oy.ga("create", "UA-112911840-1", "auto");
        Oy.ga("set", "anonymizeIp", true);
        Oy.ga("set", {
          hostname: e,
          page: e,
          referrer: e
        });
        Oy.ga("send", "pageview");
      }
      var t;
      var i;
      var s;
      var o;
      var r;
      var a;
    });
    (() => {
      let e = true;
      Fy.datafeed.onReady(t => {
        if (e) {
          console.warn("`onReady` should return result asynchronously. Use `setTimeout` with 0 interval to execute the callback function.");
        }
        Oy.configurationData = t;
        _v.resolve();
      });
      e = false;
    })();
    Oy.createShortcutAction = (() => {
      const e = B.createGroup({
        desc: "API",
        order: Ny.ACTION_API_GROUP_ORDER
      });
      return (t, i) => {
        var s;
        e.add({
          hotkey: (s = t, typeof s == "number" ? s : typeof s == "string" ? N(s.split("+")) : Array.isArray(s) ? N(s) : 0),
          handler: i
        });
      };
    })();
    Oy.initializationFinished = () => {
      Oy.chartWidgetCollection.undoHistory.clearStack();
    };
    Oy.headerReady = () => av.promise;
    (function e(t = 0, i = 10) {
      const s = {
        received: false
      };
      Oy.dispatchEvent(new CustomEvent("innerWindowLoad", {
        detail: s
      }));
      if (!s.received && t < i) {
        setTimeout(() => {
          e(t + 1, i);
        }, Math.pow(2, t) * 10);
      }
    })();
    Oy.createButton = e => {
      if (rv === null) {
        throw new Error("Cannot create button: header widget is not ready or is not loaded - use `headerReady` to wait until header is ready");
      }
      (e = e || {}).align = e.align || "left";
      e.useTradingViewStyle = e.useTradingViewStyle || false;
      const t = (0, fe.randomHash)();
      return rv.addButton(t, e) ?? t;
    };
    Oy.removeButton = e => {
      if (rv === null) {
        throw new Error("Cannot remove button: header widget is not ready or is not loaded - use `headerReady` to wait until header is ready");
      }
      return rv.removeButton(e);
    };
    Oy.createDropdown = e => {
      if (e === undefined) {
        throw new Error("Cannot create dropdown without any parameters. Please refer to the documentation");
      }
      if (e.align === undefined) {
        e.align = "left";
      }
      const t = (0, fe.randomHash)();
      if (rv) {
        rv.addDropdown(t, e);
        return Promise.resolve(new Ay(rv, t));
      } else {
        return av.promise.then(() => {
          (0, n.ensureNotNull)(rv).addDropdown(t, e);
          return new Ay((0, n.ensureNotNull)(rv), t);
        });
      }
    };
    Oy.getAllFeatures = () => {
      const e = l.getAllFeatures();
      Object.keys(e).forEach(t => {
        if (!isNaN(parseFloat(t))) {
          delete e[t];
        }
      });
      return e;
    };
    Oy.getNavigationButtonsVisibility = (0, s.default)(() => (0, ye.convertPropertyToWatchedValue)((0, ve.property)()));
    Oy.getPaneButtonsVisibility = (0, s.default)(() => (0, ye.convertPropertyToWatchedValue)((0, Se.property)()));
    Oy.getDateFormat = (0, s.default)(() => (0, ye.convertPropertyToWatchedValue)(be.dateFormatProperty));
    Oy.getTimeHoursFormat = (0, s.default)(() => (0, ye.convertPropertyToWatchedValue)(we.timeHoursFormatProperty));
    Oy.getCurrencyAndUnitVisibility = (0, s.default)(() => (0, ye.convertPropertyToWatchedValue)((0, Be.currencyUnitVisibilityProperty)()));
    Oy.customSymbolStatus = () => Dy.getInstance();
    Oy.urlParams.debugBroker;
    new Set(["connectionStatus"]);
    const mv = Uy.locale || "en";
    const gv = xt.getInstance();
    gv.createElement(document);
    gv.setLocale(mv);
    if (Oy.customChartDescriptionFunction) {
      gv.setCustomProvider(Oy.customChartDescriptionFunction);
    }
    const fv = $p.getInstance();
    fv.createElement(document);
    fv.setLocale(mv);
    (function () {
      const e = l.enabled("accessible_keyboard_shortcuts") ? (0, V.humanReadableHash)(9) : `${(0, V.humanReadableModifiers)(V.Modifiers.Alt, false)} + ${(0, V.humanReadableHash)(90)}`;
      const t = `${(0, V.humanReadableModifiers)(V.Modifiers.Mod, false)} + ${(0, V.humanReadableHash)(75)}`;
      const s = a.t(null, undefined, i(7697));
      const o = [a.t(null, {
        replace: {
          shortcut: e
        }
      }, i(85166)), a.t(null, {
        replace: {
          shortcut: t
        }
      }, i(57959)), a.t(null, undefined, i(36332)), a.t(null, undefined, i(9687)), a.t(null, undefined, i(40490)), a.t(null, undefined, i(27884))];
      const n = document.createElement("p");
      n.innerText = s;
      const r = document.createElement("ul");
      o.forEach(e => {
        const t = document.createElement("li");
        t.innerText = e;
        r.appendChild(t);
      });
      const c = document.createElement("div");
      c.setAttribute("role", "contentinfo");
      c.setAttribute("aria-hidden", "false");
      c.style.fontSize = "0";
      c.appendChild(n);
      c.appendChild(r);
      document.body.insertBefore(c, document.body.firstChild);
    })();
    window.addEventListener("keydown", e => {
      const t = (0, V.hashFromEvent)(e);
      if (t === 9 || t === B.Modifiers.Shift + 9) {
        (0, Ey.updateTabIndexes)();
      }
    });
    new Jo.Action({
      actionId: "UnknownAction",
      options: {
        label: "",
        onExecute: () => {
          (0, Ey.updateTabIndexes)();
          const [e] = Array.from(document.querySelectorAll("button:not([disabled]):not([aria-disabled]):not([tabindex=\"-1\"]), input:not([disabled]):not([aria-disabled]):not([tabindex=\"-1\"]), [tabindex]:not([disabled]):not([aria-disabled]):not([tabindex=\"-1\"])")).filter((0, By.createScopedVisibleElementFilter)(document.documentElement)).sort(Ey.navigationOrderComparator);
          if (e !== undefined) {
            e.focus();
          }
        },
        hotkeyHash: l.enabled("accessible_keyboard_shortcuts") ? 9 : B.Modifiers.Alt + 90,
        hotkeyGroup: (0, B.createGroup)({
          desc: "Global shortcuts"
        })
      }
    });
  },
  36986: (e, t, i) => {
    "use strict";

    function s() {
      return window;
    }
    function o() {
      const e = s();
      return e.parent[e.urlParams.uid];
    }
    i.d(t, {
      getChartingLibraryGlobalContext: () => s,
      getChartingLibraryOwner: () => o
    });
  },
  86129: (e, t, i) => {
    e = i.nmd(e);
    TradingView.cleanButAmpersand = function (e, t) {
      var i = t ? ["&amp;"] : ["&"];
      return TradingView.clean(e, t, i);
    };
    TradingView.strip_tags = function (e) {
      if (e && e.replace) {
        return e.replace(/(<([^>]+)>)/gi, "");
      } else {
        return e;
      }
    };
    TradingView.encodeSpread = function (e) {
      return encodeURIComponent(e);
    };
    TradingView.clean = function (e, t, i) {
      const s = [["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ["\"", "&quot;"], ["'", "&#039;"], ["'", "&#39;"]];
      if (t) {
        s.forEach(e => e.reverse());
      }
      let o = e;
      if (!e || !e.replace) {
        return o;
      }
      for (const e of s) {
        const [t, s] = e;
        if (!i || i.indexOf(t) === -1) {
          o = o.replace(new RegExp(t, "g"), s);
        }
      }
      return o;
    };
    if (e && e.exports) {
      e.exports = {
        clean: TradingView.clean,
        cleanButAmpersand: TradingView.cleanButAmpersand,
        stripTags: TradingView.strip_tags
      };
    }
  },
  55561: (e, t, i) => {
    "use strict";

    i.r(t);
    var s = i(21097);
    var o = i(51768);
    var n = i(76422);
    var r = i(38780);
    function a(e, t = false) {
      if (document.readyState !== "loading") {
        if (t) {
          setTimeout(() => e(), 1);
        } else {
          e();
        }
      } else {
        document.addEventListener("DOMContentLoaded", () => e());
      }
    }
    new Promise(e => {
      a(e);
    });
    function l(e, t = "x") {
      let i = false;
      if (t === "x" || t === "both") {
        i = i || e.offsetWidth < e.scrollWidth;
      }
      if (t === "y" || t === "both") {
        i = i || e.offsetHeight < e.scrollHeight;
      }
      return i;
    }
    function c(e, t = "x") {
      for (const i of Array.from(e.children)) {
        if (i instanceof HTMLElement && (l(i, t) || c(i, t))) {
          return true;
        }
      }
      return false;
    }
    function h(e) {
      let t = "x";
      if (e.matches(".apply-overflow-tooltip--direction_both")) {
        t = "both";
      } else if (e.matches(".apply-overflow-tooltip--direction_y")) {
        t = "y";
      }
      return t;
    }
    function d(e) {
      const t = e.getAttribute("data-overflow-tooltip-html");
      if (t) {
        return {
          type: "html",
          data: t
        };
      }
      const i = e.getAttribute("data-overflow-tooltip-text");
      if (i) {
        return {
          type: "text",
          data: i
        };
      }
      if (e.matches?.(".apply-overflow-tooltip--allow-text")) {
        return {
          type: "text",
          data: e.textContent || ""
        };
      }
      const s = Array.from(e.childNodes).reduce((e, t) => {
        if (t.nodeType === Node.TEXT_NODE) {
          e.push(t.textContent || "");
        }
        return e;
      }, []).join("").trim();
      if (s) {
        return {
          type: "text",
          data: s
        };
      } else {
        return {
          type: "none"
        };
      }
    }
    function u(e, t) {
      let i = false;
      const s = e.children;
      for (let e = 0; e < s.length; e++) {
        const o = s[e];
        if (o instanceof HTMLElement && l(o, t)) {
          i = true;
          break;
        }
      }
      return i;
    }
    function _(e) {
      const t = e.target;
      if (t instanceof HTMLElement && (t.matches(".apply-overflow-tooltip-focus") || t.querySelector(".apply-overflow-tooltip-focus"))) {
        const e = t.matches(".apply-overflow-tooltip") ? t : t.querySelector(".apply-overflow-tooltip");
        const i = h(e);
        if (e.matches(".apply-overflow-tooltip--check-children-recursively")) {
          if (!c(e, i)) {
            return;
          }
        } else if (e.matches(".apply-overflow-tooltip--check-children")) {
          if (!u(e, i)) {
            return;
          }
        } else if (!l(e, i)) {
          return;
        }
        (0, r.showOnElement)(t, {
          content: d(e)
        });
        const s = () => {
          (0, r.hide)();
          t.removeEventListener("blur", s);
          t.removeEventListener("active-descendant-blur", s);
        };
        t.addEventListener("blur", s);
        t.addEventListener("active-descendant-blur", s);
      }
    }
    a(() => {
      document.addEventListener("mouseenter", e => {
        const t = e.target;
        if (t instanceof HTMLElement && t.matches(".apply-overflow-tooltip")) {
          const e = h(t);
          if (t.matches(".apply-overflow-tooltip--check-children-recursively")) {
            if (!c(t, e)) {
              return;
            }
          } else if (t.matches(".apply-overflow-tooltip--check-children")) {
            if (!u(t, e)) {
              return;
            }
          } else if (!l(t, e)) {
            return;
          }
          (0, r.showOnElement)(t, {
            content: d(t)
          });
          const i = () => {
            (0, r.hide)();
            ["mouseleave", "mousedown"].forEach(e => t.removeEventListener(e, i));
          };
          ["mouseleave", "mousedown"].forEach(e => t.addEventListener(e, i));
        }
      }, true);
      document.addEventListener("focus", _, true);
      document.addEventListener("active-descendant-focus", _, true);
    });
    var p = i(52033);
    var m = i(11417);
    var g = i(31054);
    function f(e) {
      return () => {
        e();
      };
    }
    var y = i(3343);
    var v = i(34811);
    var S = i(15754);
    const b = (e = document.documentElement, t) => document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, (e => t => {
      if (t.nodeType !== 1) {
        return NodeFilter.FILTER_SKIP;
      }
      const i = t;
      if ((0, S.isInertRoot)(i)) {
        return NodeFilter.FILTER_REJECT;
      } else if ((0, S.isVisibilityVisible)(i) && i.matches(e)) {
        return NodeFilter.FILTER_ACCEPT;
      } else {
        return NodeFilter.FILTER_SKIP;
      }
    })(t));
    const w = (e = document.documentElement) => b(e, S.FOCUSABLE_SELECTOR);
    const C = `[${v.FOCUS_TRAP_DATA_ATTRIBUTE}="true"]`;
    class P {
      constructor() {
        this._handleMouseDown = () => {
          this._forwardTab = undefined;
        };
        this._handleKeyDown = e => {
          this._forwardTab = undefined;
          if ([9, y.Modifiers.Shift + 9].includes((0, y.hashFromEvent)(e))) {
            this._forwardTab = !e.shiftKey;
          }
        };
        this._handleFocus = e => {
          const t = e.target;
          if (this._forwardTab === undefined || !(t instanceof HTMLElement)) {
            return;
          }
          const i = this._findDeepestFocusTrapElement(document.documentElement);
          if (!(i instanceof HTMLElement) || !i || i.contains(t)) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          t.blur();
          const s = i.compareDocumentPosition(t);
          if (s & Node.DOCUMENT_POSITION_PRECEDING || s & Node.DOCUMENT_POSITION_FOLLOWING) {
            const e = this._forwardTab ? x(i) : x(i, true);
            if (e instanceof HTMLElement) {
              e.focus();
            }
          }
        };
        document.documentElement.addEventListener("focus", this._handleFocus, {
          capture: true
        });
        document.documentElement.addEventListener("keydown", this._handleKeyDown, {
          capture: true
        });
        document.documentElement.addEventListener("mousedown", this._handleMouseDown, {
          capture: true
        });
      }
      destroy() {
        document.documentElement.removeEventListener("focus", this._handleFocus, {
          capture: true
        });
        document.documentElement.removeEventListener("keydown", this._handleKeyDown, {
          capture: true
        });
        document.documentElement.removeEventListener("mousedown", this._handleMouseDown, {
          capture: true
        });
      }
      _findDeepestFocusTrapElement(e) {
        const t = e.querySelectorAll(C);
        let i = null;
        let s = -1;
        t.forEach(t => {
          const o = this._calculateParentCount(t, e);
          if (o > s) {
            s = o;
            i = t;
          }
        });
        return i;
      }
      _calculateParentCount(e, t) {
        let i = 0;
        let s = e.parentElement;
        while (s && s !== t) {
          if (s.getAttribute(v.FOCUS_TRAP_DATA_ATTRIBUTE) === "true") {
            i++;
          }
          s = s.parentElement;
        }
        return i;
      }
    }
    const T = f(() => new P());
    function x(e, t) {
      if (t) {
        return function (e) {
          return function (e) {
            for (e.currentNode = e.root; e.lastChild() !== null;);
            if (e.currentNode === e.root) {
              return null;
            } else {
              return e.currentNode;
            }
          }(w(e));
        }(e);
      } else {
        return function (e) {
          t = w(e);
          t.currentNode = t.root;
          return t.nextNode();
          var t;
        }(e);
      }
    }
    const I = f(() => {
      T();
    });
    var M = i(7047);
    let A;
    function L(e) {
      const t = window.user.available_offers || {};
      if (window.TVSettings) {
        window.TVSettings.sync(window.user.settings);
      }
      if (window.is_authenticated) {
        if (!e) {
          initOfferLoginStateChangeButton();
          if (onGoPro()) {
            window.location.reload();
          }
        }
        if (window.user.profile_data_filled === false) {
          (0, o.trackEvent)("Conversion", "First login");
          delete window.user.profile_data_filled;
        }
      } else {
        Object.keys(t).forEach(e => {
          const i = e;
          if (!t[i].available_for_anons) {
            delete t[i];
          }
        });
        window.user = {
          username: "Guest",
          following: "0",
          followers: "0",
          ignore_list: [],
          available_offers: t
        };
        m.TVLocalStorage.removeItem("trial_availiable");
      }
    }
    A = window.loginStateChange ? window.loginStateChange : window.loginStateChange = new p.Delegate();
    A.subscribe(null, L);
    s.TVXWindowEvents.on("loginStateChange", e => {
      const t = JSON.parse(e);
      window.user = t.user;
      window.is_authenticated = !!t.is_authenticated;
      A.fire();
    });
    s.TVXWindowEvents.on("signOut", () => {
      (function () {
        if (window.initData.lfs) {
          const e = document.getElementsByClassName("js-admin-warning")[0];
          document.body.removeChild(e);
        }
        let e = true;
        [/^\/chart\//, /^\/share-your-love\//, /^\/pine\//].forEach(t => {
          if (t.test(window.location.pathname)) {
            e = false;
          }
        });
        if (e) {
          window.location.reload();
        }
      })();
    });
    (() => {
      const e = "user-obj-changed";
      const t = {};
      window.crossTabSyncUserAttr = t => {
        const i = {};
        if (t instanceof Array) {
          t.forEach(e => {
            i[e] = window.user[e];
          });
        } else {
          i[t] = window.user[t];
        }
        s.TVXWindowEvents.emit(e, JSON.stringify(i));
      };
      s.TVXWindowEvents.on(e, e => {
        const i = JSON.parse(e);
        let s;
        for (s in i) {
          if (i.hasOwnProperty(s)) {
            window.user[s] = i[s];
            (t[s] || []).forEach(e => {
              e.fire(i[s]);
            });
          }
        }
      });
    })();
    window.TradingView.changeLoginState = e => {
      window.is_authenticated = !!e;
      s.TVXWindowEvents.emit("loginStateChange", JSON.stringify({
        is_authenticated: window.is_authenticated,
        user: window.user
      }));
      if (window.is_authenticated) {
        n.emit("GLOBAL_EVENT_SIGN_IN_SUCCESS");
      }
      A.fire();
    };
    window.loginUser = function (e) {
      window.user = (0, g.deepExtend)({}, e);
      window.TradingView.changeLoginState(true);
    };
    window.loginRequiredDelegate = new p.Delegate();
    window.runOrSignIn = (e, t) => {
      t ||= {};
      e();
    };
    window.onLoginStateChange = L;
    window.TradingView.setTrialAvailiable = e => {
      m.TVLocalStorage.setItem("trial_availiable", e ? "1" : "0");
    };
    window.TradingView.notificationsChanged = new p.Delegate();
    I();
    (0, M.initMouseClickAutoBlurHandler)();
  },
  19063: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      alphaToTransparency: () => a,
      applyAlpha: () => r,
      applyTransparency: () => c,
      colorFromBackground: () => _,
      colorToInteger: () => y,
      generateColor: () => n,
      getLuminance: () => d,
      gradientColorAtPercent: () => p,
      isColorDark: () => m,
      isHexColor: () => u,
      resetTransparency: () => h,
      rgbaFromInteger: () => g,
      rgbaToInteger: () => f,
      transparencyToAlpha: () => l
    });
    var s;
    var o = i(24377);
    function n(e, t, i) {
      t = t || 0;
      if (!u(e)) {
        if (i) {
          return (0, o.rgbaToString)((0, o.rgba)((0, o.parseRgb)(e), (0, o.normalizeAlphaComponent)(l(t))));
        } else {
          return e;
        }
      }
      const [s, n, r] = (0, o.parseRgb)(e);
      const a = (0, o.normalizeAlphaComponent)(l(t));
      return (0, o.rgbaToString)([s, n, r, a]);
    }
    function r(e, t, i) {
      const s = (0, o.tryParseRgba)(e);
      if (s === null) {
        throw new Error(`Invalid color: ${e}`);
      }
      const [n, r, a, l] = s;
      const c = (0, o.normalizeAlphaComponent)(t * (i ? l : 1));
      return (0, o.rgbaToString)((0, o.rgba)([n, r, a], c));
    }
    function a(e) {
      return (1 - e) * 100;
    }
    function l(e) {
      if (e < 0 || e > 100) {
        throw new Error("invalid transparency");
      }
      return 1 - e / 100;
    }
    function c(e, t) {
      if (e === "transparent") {
        return e;
      }
      const i = (0, o.parseRgba)(e);
      const s = i[3];
      return (0, o.rgbaToString)((0, o.rgba)(i[0], i[1], i[2], l(t) * s));
    }
    function h(e) {
      if (e === "transparent") {
        return e;
      } else if (u(e)) {
        return e.slice(0, 7);
      } else {
        return (0, o.rgbaToString)((0, o.rgba)((0, o.parseRgb)(e), (0, o.normalizeAlphaComponent)(1)));
      }
    }
    function d(e) {
      const t = (0, o.parseRgb)(e).map(e => (e /= 255) <= 0.03928 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4));
      return Number((t[0] * 0.2126 + t[1] * 0.7152 + t[2] * 0.0722).toFixed(3));
    }
    function u(e) {
      return e.indexOf("#") === 0;
    }
    function _(e) {
      if ((0, o.rgbToBlackWhiteString)((0, o.parseRgb)(e), 150) === "black") {
        return "#ffffff";
      } else {
        return "#000000";
      }
    }
    function p(e, t, i) {
      const [s, n, r, a] = (0, o.parseRgba)(e);
      const [l, c, h, d] = (0, o.parseRgba)(t);
      const u = (0, o.rgba)(Math.round(s + i * (l - s)), Math.round(n + i * (c - n)), Math.round(r + i * (h - r)), a + i * (d - a));
      return (0, o.rgbaToString)(u);
    }
    function m(e) {
      return d(h(e)) < 0.5;
    }
    function g(e) {
      const t = (e = Math.round(e)) % 256;
      e -= t;
      const i = (e /= 256) % 256;
      e -= i;
      const s = (e /= 256) % 256;
      e -= s;
      return `rgba(${t},${i},${s},${(e /= 256) / 255})`;
    }
    function f(e) {
      const t = Math.round(e[3] * 255);
      return e[0] + e[1] * 256 + e[2] * 65536 + t * 16777216;
    }
    function y(e) {
      const t = (0, o.tryParseRgba)(e);
      if (t === null) {
        return 0;
      } else {
        return f(t);
      }
    }
    (function (e) {
      e[e.BgLuminanceThreshold = 0.5] = "BgLuminanceThreshold";
    })(s ||= {});
  },
  61119: (e, t, i) => {
    "use strict";

    function s(e, t, i) {
      return e * (1 - i) + t * i;
    }
    i.d(t, {
      doAnimate: () => r,
      lerp: () => s
    });
    const o = {
      from: 0,
      duration: 250,
      easing: i(78871).easingFunc.easeOutCubic
    };
    class n {
      constructor(e) {
        this._doing = true;
        this._completed = false;
        this._options = {
          ...o,
          ...e
        };
        const t = performance.now();
        window.requestAnimationFrame(e => {
          this._animation(t, this._options.from, e);
        });
      }
      stop() {
        this._doing = false;
      }
      completed() {
        return this._completed;
      }
      _animation(e, t, i) {
        if (!this._doing) {
          this._finishAnimation();
          return;
        }
        const o = (i = !i || i < 1000000000000 ? performance.now() : i) - e;
        const n = o >= this._options.duration || t === this._options.to;
        const r = s(this._options.from, this._options.to, this._options.easing(o / this._options.duration));
        const a = n ? this._options.to : r;
        const l = a - t;
        this._options.onStep(l, a);
        if (n) {
          this._finishAnimation();
        } else {
          window.requestAnimationFrame(t => {
            this._animation(e, a, t);
          });
        }
      }
      _finishAnimation() {
        if (this._options.onComplete) {
          this._options.onComplete();
        }
        this._completed = true;
      }
    }
    function r(e) {
      return new n(e);
    }
  },
  84906: (e, t, i) => {
    "use strict";

    i.d(t, {
      fetch: () => o
    });
    var s = i(9343);
    new class {
      constructor(e, t) {
        this._test = e[t] = {};
      }
      provide(e, t) {
        this._test[e] = t;
      }
    }(window, "qaGlobals");
    (0, s.getLogger)("Fetch");
    function o(e, t, i = {}) {
      return window.fetch(e, t);
    }
  },
  94784: (e, t, i) => {
    "use strict";

    i.d(t, {
      generateColorCached: () => r
    });
    var s = i(59332);
    var o = i(19063);
    var n = i(5201);
    function r(e = 1000) {
      const t = s.default.Cache;
      s.default.Cache = n.CircularCacheBuffer.bind(n.CircularCacheBuffer, e);
      const i = (0, s.default)(o.generateColor, (e, t, i) => `${e}_${t}_${i}`);
      s.default.Cache = t;
      return i;
    }
  },
  39772: (e, t, i) => {
    "use strict";

    i.d(t, {
      GradientColorCache: () => o
    });
    var s = i(19063);
    class o {
      constructor() {
        this._color1 = "";
        this._color2 = "";
        this._colors = new Map();
      }
      gradientColor(e, t, i) {
        if (t === e) {
          return t;
        }
        i = Math.max(0, Math.min(100, Math.round(i * 100)));
        if (this._color1 !== e || this._color2 !== t) {
          this._colors.clear();
          this._color1 = e;
          this._color2 = t;
        }
        let o = this._colors.get(i);
        if (o === undefined) {
          o = (0, s.gradientColorAtPercent)(e, t, i / 100);
          this._colors.set(i, o);
        }
        return o;
      }
    }
  },
  68979: (e, t, i) => {
    "use strict";

    function s(e, t, i, s) {
      return `${s ? s + " " : ""}${i ? i + " " : ""}${e}px ${t}`;
    }
    i.d(t, {
      makeFont: () => s,
      parseFont: () => n
    });
    const o = /(bold )?(italic )?(\d+)(px|pt) (.*)$/;
    function n(e) {
      const t = o.exec(e);
      if (t === null) {
        return null;
      } else {
        return {
          family: t[5],
          size: parseInt(t[3]) * (t[4] === "pt" ? 0.75 : 1),
          bold: Boolean(t[1]),
          italic: Boolean(t[2])
        };
      }
    }
  },
  18112: (e, t, i) => {
    "use strict";

    i.d(t, {
      getPersistentLogger: () => o
    });
    let s = null;
    function o() {
      return s;
    }
  },
  66800: (e, t, i) => {
    "use strict";

    function s(e) {
      return e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    i.d(t, {
      regExpEscape: () => s
    });
  },
  31599: (e, t, i) => {
    "use strict";

    i.d(t, {
      rgbaFromIntegerCached: () => r
    });
    var s = i(59332);
    var o = i(19063);
    var n = i(5201);
    function r(e = 1000) {
      const t = s.default.Cache;
      s.default.Cache = n.CircularCacheBuffer.bind(n.CircularCacheBuffer, e);
      const i = (0, s.default)(o.rgbaFromInteger);
      s.default.Cache = t;
      return i;
    }
  },
  63273: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      detectAutoDirection: () => b,
      forceLTRStr: () => u,
      forceLTRStrSsr: () => _,
      forceRTLStr: () => m,
      getLTRScrollLeft: () => g,
      getLTRScrollLeftOffset: () => f,
      isRtl: () => o,
      startWithLTR: () => d,
      stripLTRMarks: () => h,
      stripLTRStrSsr: () => p
    });
    var s = i(64531);
    const o = () => window.document.dir === "rtl";
    const n = "‎";
    const r = "‪";
    const a = "‫";
    const l = "‬";
    const c = new RegExp(n + "|" + r + "|" + a + "|" + l, "g");
    function h(e) {
      if (e !== "" && o() && e != null) {
        return e.replace(c, "");
      } else {
        return e;
      }
    }
    function d(e) {
      if (e !== "" && o() && e != null) {
        return n + e;
      } else {
        return e;
      }
    }
    function u(e) {
      if (e !== "" && o() && e != null) {
        return r + e + l;
      } else {
        return e;
      }
    }
    function _(e) {
      return r + e + l;
    }
    function p(e) {
      if (e.startsWith(r) && e.endsWith(l)) {
        return e.slice(1, -1);
      } else {
        return e;
      }
    }
    function m(e) {
      if (e !== "" && o() && e != null) {
        return a + e + l;
      } else {
        return e;
      }
    }
    function g(e) {
      return (0, s.getNormalizedScrollLeft)(e, "rtl");
    }
    function f(e, t) {
      const i = (0, s.detectScrollType)();
      if (i === "indeterminate") {
        return 0;
      }
      switch (i) {
        case "negative":
          t = e.clientWidth - e.scrollWidth + t;
          break;
        case "reverse":
          t = e.scrollWidth - e.clientWidth - t;
      }
      return t;
    }
    var y;
    (function (e) {
      e.LTR = "ltr";
      e.RTL = "rtl";
      e.UNKNOWN = "";
    })(y ||= {});
    const v = /[^\u0000-\u0040\u005B-\u0060\u007B-\u00BF\u00D7\u00F7\u02B9-\u02FF\u2000-\u200E\u2010-\u2029\u202C\u202F-\u2BFF]/;
    const S = /[\u0590-\u07FF\u200F\u202B\u202E\uFB1D-\uFDFD\uFE70-\uFEFC]/;
    function b(e) {
      const t = v.exec(e);
      if (t) {
        if (S.test(t[0])) {
          return "rtl";
        } else {
          return "ltr";
        }
      } else {
        return "";
      }
    }
  },
  78871: (e, t, i) => {
    "use strict";

    i.d(t, {
      CubicBezier: () => s.CubicBezier,
      dur: () => s.dur,
      easingFunc: () => s.easingFunc
    });
    var s = i(74991);
  },
  86001: (e, t, i) => {
    "use strict";

    function s() {
      return Promise.all([i.e(6342), i.e(3703), i.e(7939), i.e(3799), i.e(5480), i.e(1390), i.e(2227), i.e(2077)]).then(i.bind(i, 71090));
    }
    i.d(t, {
      loadChangeIntervalDialog: () => s
    });
  },
  86235: (e, t, i) => {
    "use strict";

    i.d(t, {
      showChangeIntervalDialogAsync: () => n
    });
    var s = i(86001);
    let o = null;
    function n(e) {
      const t = o = (0, s.loadChangeIntervalDialog)().then(i => {
        if (t === o) {
          i.showChangeIntervalDialog(e);
        }
      });
      return t;
    }
  },
  62400: (e, t, i) => {
    "use strict";

    function s(e) {
      return Promise.all([i.e(5683), i.e(3703), i.e(3953), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(4178), i.e(9481), i.e(2564), i.e(6445), i.e(3799), i.e(5480), i.e(8222), i.e(9296), i.e(7935), i.e(3828), i.e(5579), i.e(2227), i.e(9418), i.e(2544), i.e(3202), i.e(9928), i.e(7223), i.e(1859)]).then(i.bind(i, 84828)).then(t => t.showGoToDateDialog(e));
    }
    i.d(t, {
      showGoToDateDialog: () => s
    });
  },
  22980: (e, t, i) => {
    "use strict";

    i.d(t, {
      runOrSigninWithFeature: () => s
    });
    const s = (e, t) => {
      e();
    };
    window.TradingView.runOrSigninWithFeature = s;
  },
  55744: (e, t, i) => {
    "use strict";

    i.d(t, {
      DeleteLockedLineToolReason: () => d,
      confirmRemovingLockedLineTools: () => m,
      showDeleteLockedLineToolsConfirm: () => p
    });
    var s = i(11542);
    var o = i(3615);
    var n = i(69293);
    var r = i(56840);
    var a = i(17625);
    const l = "delete_locked_linetools";
    function c() {
      return r.getBool(l, true);
    }
    const h = (0, a.createPrimitiveProperty)(c());
    var d;
    h.subscribe(null, () => r.setValue(l, h.value()));
    r.onSync.subscribe(null, () => h.setValue(c()));
    (function (e) {
      e[e.RemoveSelected = 0] = "RemoveSelected";
      e[e.RemoveAll = 1] = "RemoveAll";
    })(d ||= {});
    const u = s.t(null, undefined, i(41019));
    const _ = s.t(null, undefined, i(41019));
    async function p(e, t) {
      if (n.doNotShowDeleteLockedLineConfirmProperty.value()) {
        t(h.value());
        return;
      }
      const {
        getContent: r
      } = await Promise.all([i.e(7328), i.e(5323), i.e(5083), i.e(9608), i.e(4598)]).then(i.bind(i, 20307));
      (0, o.showConfirm)({
        title: s.t(null, undefined, i(71692)),
        content: r(e === d.RemoveSelected ? u : _),
        id: `${n.doNotShowDeleteLockedLineKey}-confirm`,
        mainButtonText: s.t(null, undefined, i(93123)),
        mainButtonIntent: "danger",
        cancelButtonText: s.t(null, undefined, i(99024)),
        onConfirm: ({
          dialogClose: e
        }) => {
          h.setValue(true);
          t(true);
          e();
        },
        onCancel: ({
          dialogClose: e
        }) => {
          h.setValue(false);
          t(false);
          e();
        }
      });
    }
    function m(e) {
      return new Promise(t => {
        p(e, t);
      });
    }
  },
  48341: (e, t, i) => {
    "use strict";

    i.d(t, {
      showDeleteStudyTreeConfirm: () => n
    });
    var s = i(11542);
    var o = i(3615);
    function n(e) {
      (0, o.showConfirm)({
        title: s.t(null, undefined, i(81605)),
        text: s.t(null, undefined, i(77174)),
        onConfirm: ({
          dialogClose: t
        }) => {
          e();
          t();
        }
      });
    }
  },
  71885: (e, t, i) => {
    "use strict";

    i.d(t, {
      showTooManyStudiesNotice: () => n
    });
    var s = i(11542);
    var o = i(3615);
    function n(e) {
      (0, o.showWarning)({
        title: s.t(null, undefined, i(66719)),
        text: s.t(null, {
          replace: {
            number: `${e}`
          }
        }, i(86146))
      });
    }
  },
  4454: (e, t, i) => {
    "use strict";

    i.d(t, {
      getAdditionalSymbolInfoFields: () => n,
      setAdditionalSymbolInfoFields: () => o
    });
    let s = [];
    function o(e) {
      s = e;
    }
    function n() {
      return s;
    }
  },
  80387: (e, t, i) => {
    "use strict";

    function s(e) {
      Promise.all([i.e(8622), i.e(3703), i.e(4524), i.e(7939), i.e(9258), i.e(5387), i.e(7384), i.e(4106), i.e(9753), i.e(9276), i.e(2227), i.e(9418), i.e(7973), i.e(9374)]).then(i.bind(i, 30995)).then(({
        SymbolInfoDialogImpl: t
      }) => {
        t.getInstance().show(e);
      });
    }
    i.d(t, {
      showSymbolInfoDialog: () => s
    });
  },
  28153: (e, t, i) => {
    "use strict";

    i.d(t, {
      ChartSaverBase: () => u
    });
    var s = i(50279);
    var o = i(50151);
    i(11542);
    var n = i(97990);
    var r = i(23024);
    var a = i(37265);
    var l = i(52033);
    var c = i(56570);
    var h = i(39076);
    function d(e, t) {
      e.content = JSON.stringify(t);
    }
    new WeakMap();
    new TextEncoder();
    class u {
      constructor(e) {
        this._prevChartState = null;
        this._chartSavedDelegate = new l.Delegate();
        this._chartAboutToBeSavedDelegate = new l.Delegate();
        this._chartSizeLimitExceededDelegate = new l.Delegate();
        this._isSaveInProcess = false;
        this._savingToken = null;
        this._chartWidgetCollection = e;
      }
      async saveChartLineTools(e, t, s, o) {
        if (c.enabled("saveload_separate_drawings_storage")) {
          const n = await (0, r.getChartStorage)();
          const a = this.layoutId();
          const l = i => n.saveLineToolsAndGroups(i, e, t, s, o);
          if (!a) {
            this._chartSavedDelegate.subscribe(null, e => {
              if (e) {
                const e = this._chartWidgetCollection.metaInfo.uid.value();
                l(e);
              }
            }, true);
            const {
              SavingLineToolsLibraryError: e
            } = await i.e(5565).then(i.bind(i, 98653));
            throw new e("Layout ID not yet created.", true);
          }
          return l(a);
        }
        return Promise.reject("Line tools storage is not supported");
      }
      layoutId() {
        return this._chartWidgetCollection.metaInfo.uid.value();
      }
      saveChartSilently(e, t, i) {
        const s = i || {};
        this._isSaveInProcess = true;
        this._chartAboutToBeSavedDelegate.fire();
        this._saveChart(e => {
          const t = e && c.enabled("saveload_separate_drawings_storage");
          const i = this._getChartWidgetCollectionState(false, undefined, undefined, undefined, t);
          const o = this._getCommonSavingInfo(false);
          d(o, i);
          if (s.chartName) {
            o.name = s.chartName;
          }
          if ((!o.name || o.name.length === 0) && !!s.defaultChartName) {
            o.name = s.defaultChartName;
          }
          if (s.autoSave) {
            o.autoSave = true;
          }
          return o;
        }, (t, i) => {
          (0, o.assert)(!this._chartWidgetCollection.readOnly(), "Trying to save layout in read-only mode");
          if (i && this.layoutId() === t.uid) {
            this._chartWidgetCollection.metaInfo.name.setValue(i.name ?? "");
          }
          this._prevChartState = i;
          this._chartSavedDelegate.fire(true);
          this._isSaveInProcess = false;
          if (e) {
            e({
              uid: t.uid,
              data: i
            });
          }
          if (this._prevChartState) {
            delete this._prevChartState.savingToken;
          }
        }, e => {
          this._chartSavedDelegate.fire(false);
          this._isSaveInProcess = false;
          if (t) {
            t(e);
          }
        }, s);
      }
      saveToJSON(e) {
        const t = e && e.includeDrawings === false || undefined;
        const i = this._getCommonSavingInfo(false);
        d(i, this._getChartWidgetCollectionState(false, true, t, undefined, t));
        return i;
      }
      isSaveInProcess() {
        return this._isSaveInProcess;
      }
      _getChartWidgetCollectionState(e, t, i, s, o) {
        if (!e) {
          t = true;
          s = false;
        }
        return this._chartWidgetCollection.state(!!e, !!i, !!s, o, !t);
      }
      _getCommonSavingInfo(e) {
        const t = this._chartWidgetCollection;
        const i = this._chartWidgetCollection.chartsSymbols();
        const s = i[t.activeChartWidget.value().id()];
        const o = {
          ...(n = s, {
            ...n,
            legs: JSON.stringify(n.legs ?? [])
          })
        };
        var n;
        const r = t.metaInfo;
        const a = r.id.value();
        if (a !== null) {
          o.id = a;
        }
        o.name = r.name.value() || "";
        o.description = r.description.value() || "";
        o.charts_symbols = function (e) {
          const t = {};
          for (const i of Object.keys(e)) {
            t[i] = {
              symbol: e[i].symbol
            };
          }
          return JSON.stringify(t);
        }(i);
        o.is_realtime = o.is_realtime = e ? "0" : "1";
        return o;
      }
      async _saveLineToolsToStorage() {
        if (!c.enabled("saveload_separate_drawings_storage")) {
          return Promise.resolve();
        }
        {
          this.layoutId();
          0;
          const e = this._chartWidgetCollection.getAll().map(e => e.lineToolsSynchronizer()?.flushPendingSavings() ?? null).filter(a.notNull);
          if (e.length) {
            await Promise.all(e);
          }
        }
      }
      _invalidateAllLineTools() {
        this._chartWidgetCollection.getAll().forEach(e => e.lineToolsSynchronizer()?.invalidateAll());
      }
      _saveChartImpl(e, t, i, s, o, n) {
        let r;
        r = s => {
          if (!t.uid && t.uid === this.layoutId()) {
            t.id = s.result;
            t.uid = `${s.result}`;
            this._chartWidgetCollection.metaInfo.id.setValue(t.id);
            this._chartWidgetCollection.metaInfo.uid.setValue(t.uid);
          }
          i(t, e);
        };
        if (e.name) {
          h.backend.saveChart(e.name, e.short_name, e.resolution, e, t).then(r).catch(async e => {
            const t = e instanceof Response ? e : undefined;
            const i = e instanceof Error ? e : undefined;
            this._savingToken = null;
            const o = s.bind(null, {
              status: t?.status,
              message: t?.statusText ?? i?.message ?? "Unknown error"
            });
            o();
          });
        } else {
          s({
            status: -1,
            message: "Saving chart with empty name is not allowed"
          });
        }
      }
      async _saveChart(e, t, o, r) {
        const a = this._chartWidgetCollection.metaInfo;
        const l = {
          name: a.name.value(),
          description: a.description.value(),
          uid: a.uid.value(),
          id: a.id.value(),
          lastModified: a.lastModified.value(),
          username: a.username.value()
        };
        let h = r.changes ?? n.changedAll;
        if (c.enabled("saveload_separate_drawings_storage")) {
          this._invalidateAllLineTools();
        }
        let d = true;
        if (h & 2 || c.enabled("saveload_separate_drawings_storage")) {
          try {
            await this._saveLineToolsToStorage();
          } catch (e) {
            h |= 1;
            const {
              SavingLineToolsLibraryError: t
            } = await i.e(5565).then(i.bind(i, 98653));
            if (!(e instanceof t) || !e.safe) {
              d = false;
            }
          }
        }
        if (h & 1) {
          const i = e(d);
          if ((0, s.default)(this._prevChartState, i) && l.id !== null) {
            this._chartSavedDelegate.fire(true);
            t(l, i);
            return;
          }
          0;
          const n = (e, i) => {
            if (!d) {
              this._chartWidgetCollection.getAll().forEach(e => e.lineToolsSynchronizer()?.markAsValidatedBecauseOfSavingToContent(true));
            }
            return t(e, i);
          };
          return this._saveChartImpl(i, l, n, o, r, e);
        }
        this._chartSavedDelegate.fire(true);
        t(l, e(d));
      }
    }
  },
  97488: (e, t, i) => {
    "use strict";

    var s = i(28153).ChartSaverBase;
    i.i18next(null, undefined, i(49947));
    t.ChartSaver = class extends s {
      constructor(e) {
        super(e);
      }
      chartSizeLimitExceeded() {
        return this._chartSizeLimitExceededDelegate;
      }
      chartAboutToBeSaved() {
        return this._chartAboutToBeSavedDelegate;
      }
      chartSaved() {
        return this._chartSavedDelegate;
      }
      publishChart(e) { }
      publishScript(e, t, i) { }
      isScriptNameValid(e) {
        return e.trim() !== "" && e.length <= 64;
      }
      isScriptDescriptionValid(e) {
        return e.trim() !== "" && e.length <= 70000;
      }
      isScriptDescribersValid(e, t) {
        return this.isScriptNameValid(e) && this.isScriptDescriptionValid(t);
      }
      openInNewTab(e, t, i) {
        e.publishInProgress = true;
        if (!i) {
          if (this.isScriptDescribersValid(t.name, t.description)) {
            undefined(new Promise(function (t) {
              e.setPopupUrl = t;
            }));
          }
        }
      }
      onPublish(e, t) { }
    };
  },
  22365: (e, t, i) => {
    "use strict";

    i.d(t, {
      getTranslatedSymbolDescription: () => s
    });
    i(11542);
    function s(e) {
      return e.description || "";
    }
  },
  34585: (e, t, i) => {
    "use strict";

    function s(e) {
      return e + "…";
    }
    i.d(t, {
      appendEllipsis: () => s
    });
  },
  14051: (e, t, i) => {
    "use strict";

    function s(e) {
      if (!r(e)) {
        throw e;
      }
    }
    function o(e) {
      if (e?.aborted) {
        return Promise.reject(n());
      } else {
        return new Promise((t, i) => {
          e?.addEventListener("abort", () => i(n()), {
            once: true
          });
        });
      }
    }
    function n() {
      return new DOMException("Aborted", "AbortError");
    }
    function r(e) {
      return e instanceof Error && e.name === "AbortError";
    }
    function a(e, t) {
      return Promise.race([o(e), t]);
    }
    async function l(e, t) {
      let i;
      try {
        await a(e, new Promise(e => {
          i = setTimeout(e, t);
        }));
      } finally {
        clearTimeout(i);
      }
    }
    i.d(t, {
      delay: () => l,
      isAbortError: () => r,
      respectAbort: () => a,
      skipAbortError: () => s
    });
  },
  18832: (e, t, i) => {
    "use strict";

    function s(e) {
      let t;
      if (typeof e != "object" || e == null || typeof e.nodeType == "number") {
        t = e;
      } else if (e instanceof Date) {
        t = new Date(e.valueOf());
      } else if (Array.isArray(e)) {
        t = [];
        let i = 0;
        const o = e.length;
        for (; i < o; i++) {
          if (Object.prototype.hasOwnProperty.call(e, i)) {
            t[i] = s(e[i]);
          }
        }
      } else {
        t = {};
        for (const i in e) {
          if (Object.prototype.hasOwnProperty.call(e, i)) {
            t[i] = s(e[i]);
          }
        }
      }
      return t;
    }
    i.d(t, {
      deepCopy: () => s
    });
  },
  31054: (e, t, i) => {
    "use strict";

    function s(e, ...t) {
      if (e && typeof e == "object") {
        if (t.length !== 0) {
          t.forEach(t => {
            if (t != null && typeof t == "object") {
              Object.keys(t).forEach(i => {
                const n = e[i];
                const r = t[i];
                if (r === e) {
                  return;
                }
                const a = Array.isArray(r);
                if (r && (o(r) || a)) {
                  let t;
                  t = a ? n && Array.isArray(n) ? n : [] : n && o(n) ? n : {};
                  e[i] = s(t, r);
                } else if (r !== undefined) {
                  e[i] = r;
                }
              });
            }
          });
        }
        return e;
      } else {
        return e;
      }
    }
    function o(e) {
      if (!e || Object.prototype.toString.call(e) !== "[object Object]") {
        return false;
      }
      const t = Object.getPrototypeOf(e);
      if (!t) {
        return true;
      }
      const i = Object.hasOwnProperty.toString;
      const s = t.hasOwnProperty("constructor") && t.constructor;
      return typeof s == "function" && i.call(s) === i.call(Object);
    }
    i.d(t, {
      deepExtend: () => s
    });
  },
  14426: (e, t, i) => {
    "use strict";

    function s() {
      let e;
      let t;
      return {
        promise: new Promise((i, s) => {
          e = i;
          t = s;
        }),
        reject: t,
        resolve: e
      };
    }
    i.d(t, {
      createDeferredPromise: () => s
    });
  },
  14712: (e, t, i) => {
    "use strict";

    function s(e) {
      if (e === undefined) {
        return "";
      }
      if (e instanceof Error) {
        let t = e.message;
        if (e.stack) {
          t += " " + e.stack;
        }
        return t;
      }
      if (typeof e == "string") {
        return e.toString();
      } else {
        return JSON.stringify(e);
      }
    }
    i.d(t, {
      errorToString: () => s
    });
  },
  92184: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      guid: () => n,
      randomHash: () => r,
      randomHashN: () => a
    });
    const s = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
    const o = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    function n() {
      return s.replace(/[xy]/g, e => {
        const t = Math.random() * 16 | 0;
        return (e === "x" ? t : t & 3 | 8).toString(16);
      });
    }
    function r() {
      return a(12);
    }
    function a(e) {
      let t = "";
      for (let i = 0; i < e; ++i) {
        const e = Math.floor(Math.random() * o.length);
        t += o[e];
      }
      return t;
    }
  },
  49481: (e, t, i) => {
    "use strict";

    i.d(t, {
      parseHtml: () => n,
      parseHtmlElement: () => r
    });
    const s = new WeakMap();
    var o;
    function n(e, t) {
      let i;
      let o;
      i = t == null ? document.documentElement : t.nodeType === 9 ? t.documentElement : t;
      if (s) {
        o = s.get(i);
      }
      if (!o) {
        o = i.ownerDocument.createRange();
        o.selectNodeContents(i);
        if (s) {
          s.set(i, o);
        }
      }
      return o.createContextualFragment(e);
    }
    function r(e, t) {
      const i = n(e, t);
      const s = i.firstElementChild;
      if (s !== null) {
        i.removeChild(s);
      }
      return s;
    }
    (function (e) {
      e[e.Element = 1] = "Element";
      e[e.Document = 9] = "Document";
    })(o ||= {});
  },
  14729: (e, t, i) => {
    "use strict";

    function s(e) {
      e.preventDefault();
    }
    i.d(t, {
      preventDefault: () => s,
      preventDefaultForContextMenu: () => n
    });
    const o = ["input:not([type])", "input[type=\"text\"]", "input[type=\"email\"]", "input[type=\"password\"]", "input[type=\"search\"]", "input[type=\"number\"]", "input[type=\"url\"]", "textarea", "a[href]", "*[contenteditable=\"true\"]", "[data-allow-context-menu]"];
    function n(e) {
      const t = e.target;
      if (t && !t.closest(o.join(", "))) {
        e.preventDefault();
      }
    }
  },
  97144: (e, t, i) => {
    "use strict";

    function s(e) {
      return e.reduce(function (e, t, i) {
        if (!~e.indexOf(t)) {
          e.push(t);
        }
        return e;
      }, []);
    }
    i.r(t);
    i.d(t, {
      uniq: () => s
    });
  },
  34369: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 28 28\" width=\"28\" height=\"28\" fill=\"currentColor\"><path fill-rule=\"evenodd\" d=\"M18 14a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-1 0a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z\"/><path fill-rule=\"evenodd\" d=\"M8.5 5h11l5 9-5 9h-11l-5-9 5-9Zm-3.86 9L9.1 6h9.82l4.45 8-4.45 8H9.1l-4.45-8Z\"/></svg>";
  },
  93544: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 28 28\" width=\"28\" height=\"28\"><path fill=\"currentColor\" d=\"M18 7h5v1h-2.01l-1.33 14.64a1.5 1.5 0 0 1-1.5 1.36H9.84a1.5 1.5 0 0 1-1.49-1.36L7.01 8H5V7h5V6c0-1.1.9-2 2-2h4a2 2 0 0 1 2 2v1Zm-6-2a1 1 0 0 0-1 1v1h6V6a1 1 0 0 0-1-1h-4ZM8.02 8l1.32 14.54a.5.5 0 0 0 .5.46h8.33a.5.5 0 0 0 .5-.46L19.99 8H8.02Z\"/></svg>";
  },
  53573: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 28 28\" width=\"28\" height=\"28\" fill=\"none\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"m17.13 9.74 7.37.9-5.44 5.06L20.4 23 14 19.38 7.6 23l1.34-7.3-5.44-5.06 7.37-.9L14 3l3.13 6.74Zm5.11 1.63-4.26 3.97 1.04 5.74L14 18.24l-5.02 2.84 1.04-5.74-4.26-3.97 5.79-.7L14 5.37l2.45 5.3 5.8.7Z\"/></svg>";
  },
  5845: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 28 28\" width=\"28\" height=\"28\"><path fill=\"currentColor\" d=\"M6 5h1v18H6V5ZM16 14V9h1v5h5v1h-5v5h-1v-5h-5v-1h5Z\"/></svg>";
  },
  94839: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 28 28\" width=\"28\" height=\"28\"><path fill=\"currentColor\" d=\"M23 6v1H5V6h18ZM14 16v-5h1v5h5v1h-5v5h-1v-5H9v-1h5Z\"/></svg>";
  },
  29453: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 28 28\" width=\"28\" height=\"28\"><path fill=\"currentColor\" d=\"M17.5 7A3 3 0 0 1 15 9.96V14h5v1h-5v7.98a6.97 6.97 0 0 0 3.57-1.32A4.5 4.5 0 0 0 20.5 18h1a5.5 5.5 0 0 1-2.32 4.46A7.98 7.98 0 0 1 14.5 24c-1.6 0-3.33-.53-4.68-1.54A5.5 5.5 0 0 1 7.5 18h1c0 1.56.78 2.8 1.93 3.66A6.97 6.97 0 0 0 14 22.98V15H9v-1h5V9.96A3 3 0 1 1 17.5 7Zm-3 2a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z\"/></svg>";
  },
  50946: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 22 19\" width=\"22\" height=\"19\"><path fill=\"#ffffff\" d=\"M9 4H0v4h5v7h4V4Zm8 11h-5l4.5-11h5L17 15Zm-5-7a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z\"/></svg>";
  },
  70893: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"28 0 136 19\" width=\"136\" height=\"19\"><path fill=\"#ffffff\" d=\"M28.52 9.03c0 2.84 2.3 5.14 5.14 5.14a5.12 5.12 0 0 0 4.59-2.65l-1.77-.98a3.14 3.14 0 0 1-5.92-1.51 3.14 3.14 0 0 1 5.92-1.51l1.77-.98a5.12 5.12 0 0 0-4.6-2.65 5.13 5.13 0 0 0-5.13 5.14ZM39.05 14h1.91v-3.42c0-1.34.68-1.98 1.56-1.98.8 0 1.23.61 1.23 1.62V14h1.92V9.9c0-1.82-1.01-3.05-2.7-3.05-.91 0-1.64.39-2 .95V3.5h-1.92V14Zm7.51-3.5c0 1.99 1.43 3.65 3.29 3.65.96 0 1.7-.49 2.01-.93V14h1.92V7h-1.92v.78a2.5 2.5 0 0 0-2.01-.93c-1.86 0-3.3 1.66-3.3 3.65Zm5.46 0c0 1.1-.72 1.9-1.77 1.9s-1.76-.8-1.76-1.9c0-1.1.71-1.9 1.76-1.9s1.77.8 1.77 1.9Zm3.21 3.5h1.91v-3.35c0-1.14.6-1.86 1.52-1.86.3 0 .57.06.86.16V7a2.2 2.2 0 0 0-.64-.08c-.78 0-1.5.51-1.74 1.2V7h-1.91v7Zm9.71-.07v-1.7a2.2 2.2 0 0 1-.79.13c-.82 0-1.19-.33-1.19-1.19V8.68h1.98V7h-1.98V5.05h-1.92V7h-1.41v1.68h1.41v2.87c0 1.7 1.2 2.53 2.68 2.53a4 4 0 0 0 1.22-.15Zm5.63-.71c.32.44 1.06.93 2.03.93 1.86 0 3.29-1.66 3.29-3.65s-1.43-3.65-3.3-3.65c-.96 0-1.7.49-2.02.93V3.5h-1.92V14h1.92v-.78Zm3.37-2.72c0 1.1-.71 1.9-1.76 1.9s-1.77-.8-1.77-1.9c0-1.1.72-1.9 1.77-1.9s1.76.8 1.76 1.9Zm5.39 6.43L83.73 7H81.6l-1.86 4.54L77.87 7h-2.1l2.94 6.6-1.47 3.33h2.09ZM88.27 14h2.05V6h2.67V4.05h-7.36v1.93h2.64V14Zm4.44 0h1.92v-3.35c0-1.14.6-1.86 1.51-1.86.31 0 .58.06.87.16V7a2.2 2.2 0 0 0-.64-.08c-.79 0-1.5.51-1.74 1.2V7h-1.92v7Zm4.41-3.5c0 1.99 1.43 3.65 3.3 3.65.96 0 1.7-.49 2.01-.93V14h1.92V7h-1.92v.78a2.5 2.5 0 0 0-2.02-.93c-1.86 0-3.29 1.66-3.29 3.65Zm5.46 0c0 1.1-.71 1.9-1.76 1.9s-1.76-.8-1.76-1.9c0-1.1.71-1.9 1.76-1.9s1.76.8 1.76 1.9Zm2.76 0c0 1.99 1.43 3.65 3.3 3.65.96 0 1.7-.49 2.01-.93V14h1.92V3.5h-1.92v4.28a2.5 2.5 0 0 0-2.02-.93c-1.86 0-3.29 1.66-3.29 3.65Zm5.46 0c0 1.1-.71 1.9-1.76 1.9s-1.76-.8-1.76-1.9c0-1.1.71-1.9 1.76-1.9s1.76.8 1.76 1.9Zm5.4-5.87c0-.67-.55-1.21-1.23-1.21-.66 0-1.22.54-1.22 1.21a1.23 1.23 0 0 0 2.45 0ZM114 14h1.92V7H114v7Zm3.35 0h1.92v-3.42c0-1.34.67-1.98 1.56-1.98.8 0 1.23.61 1.23 1.62V14h1.91V9.9c0-1.82-1-3.05-2.7-3.05-.9 0-1.63.39-2 .95V7h-1.92v7Zm14.77-.55V7h-1.92v.78a2.48 2.48 0 0 0-2.03-.93c-1.82 0-3.3 1.56-3.3 3.54 0 1.96 1.48 3.53 3.3 3.53.9 0 1.67-.41 2.03-.93v.48c0 1.12-.74 1.92-1.88 1.92-.77 0-1.56-.28-2.18-.87l-1.05 1.43c.8.75 2.06 1.12 3.26 1.12 2.14 0 3.77-1.08 3.77-3.62Zm-5.32-3.06c0-1.08.81-1.8 1.78-1.8.96 0 1.77.72 1.77 1.8 0 1.06-.8 1.79-1.77 1.79s-1.78-.73-1.78-1.8Zm9.1 3.61h1.8l4.12-9.94h-2.25l-2.77 6.9-2.81-6.9h-2.2l4.1 9.94Zm8.63-9.37c0-.67-.55-1.21-1.24-1.21-.65 0-1.21.54-1.21 1.21a1.23 1.23 0 0 0 2.45 0ZM142.34 14h1.92V7h-1.92v7Zm2.89-3.5c0 2.21 1.63 3.65 3.71 3.65 1.47 0 2.6-.63 3.25-1.56l-1.43-1.07c-.3.48-.93.88-1.8.88-.93 0-1.75-.51-1.86-1.45h5.23c.03-.3.03-.5.03-.66 0-2.27-1.61-3.44-3.44-3.44a3.58 3.58 0 0 0-3.69 3.65Zm3.63-2.07c.71 0 1.41.39 1.58 1.22h-3.27c.18-.86.98-1.22 1.69-1.22ZM159.27 14h1.9l2.31-7h-2.06l-1.31 4.48L158.68 7h-1.47l-1.42 4.48L154.46 7h-2.04l2.32 7h1.9l1.31-3.99 1.32 3.99Z\"/></svg>";
  },
  1457: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\"><g fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\"><path d=\"M13.111 18.5H10.5a1 1 0 0 1-1-1v-11a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1h-8.389z\"/><path d=\"M18.5 20v1.5a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1v-11a1 1 0 0 1 1-1H8\"/></g></svg>";
  },
  55824: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 7 5\" width=\"7\" height=\"5\" fill=\"none\"><path stroke=\"currentColor\" stroke-width=\"1.2\" d=\"M1 1.5l2.5 2 2.5-2\"/></svg>";
  },
  37924: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\"><g fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(4 5)\"><circle stroke=\"currentColor\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><path stroke=\"currentColor\" d=\"M7 14.5h2.5v-5H7\"/><path stroke=\"currentColor\" stroke-linecap=\"square\" d=\"M9.5 14.5h2\"/><path fill=\"currentColor\" d=\"M9.5 7a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z\"/></g></svg>";
  },
  99875: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 18 18\" width=\"18\" height=\"18\"><path fill=\"backgroundColor\" d=\"M5 7V6a4 4 0 1 1 8 0v1a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9c0-1.1.9-2 2-2Z\"/><path fill=\"lineColor\" fill-rule=\"evenodd\" d=\"M9 3a3 3 0 0 0-3 3v1h6V6a3 3 0 0 0-3-3ZM5 6v1a2 2 0 0 0-2 2v5c0 1.1.9 2 2 2h8a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2V6a4 4 0 0 0-8 0Zm0 2a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H5Zm4 2a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0v-1a1 1 0 0 0-1-1Z\"/></svg>";
  },
  2872: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\"><g fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\" transform=\"translate(6 3)\"><rect width=\"15\" height=\"12\" rx=\"2\" x=\".5\" y=\"8.5\"/><path stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 15v2\"/><path d=\"M11.5 4a3.5 3.5 0 0 0-7 0v4.5\"/></g></svg>";
  },
  7983: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 15 13\" width=\"15\" height=\"13\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M4.1 1 1.14 6.5 4.1 12h6.8l2.96-5.5L10.9 1H4.1ZM15 6.5 11.5 0h-8L0 6.5 3.5 13h8L15 6.5ZM7.5 8a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Zm0 1a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z\"/></svg>";
  },
  39267: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\"><g fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\"><path d=\"M6.5 15A8.5 8.5 0 1 0 15 6.5H8.5\"/><path d=\"M12 10L8.5 6.5 12 3\"/></g></svg>";
  },
  16911: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\"><g fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\" transform=\"translate(3 6)\"><path d=\"M.964 8C3 4 6.679.5 11 .5 15.32.5 19 4 21.036 8 19 12 15.32 15.5 11 15.5 6.679 15.5 3 12 .964 8z\"/><circle cx=\"11\" cy=\"8\" r=\"3.5\"/></g></svg>";
  },
  6862: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\"><g fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\"><path stroke-linecap=\"square\" d=\"M11.5 21.5v-7m3 7v-5m3 5v-3m-9 3v-5\"/><path d=\"M5.5 22v-3\"/><path stroke-linecap=\"square\" d=\"M5.5 13.5l4.297-4.297a2.406 2.406 0 0 1 3.406 0l2.594 2.594c.94.94 2.463.943 3.406 0L23.5 7.5M22.5 12.5v6m-3-3h6\"/></g></svg>";
  },
  54190: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\"><path fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\" stroke-linecap=\"square\" d=\"M6.145 11.968L14 5.5l7.855 6.468a.3.3 0 0 1-.191.532H6.336a.3.3 0 0 1-.19-.532zm0 4.064L14 22.5l7.855-6.468a.3.3 0 0 0-.191-.532H6.336a.3.3 0 0 0-.19.532z\"/></svg>";
  },
  25191: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\"><g fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(4 5)\"><path fill=\"currentColor\" d=\"M3 1h1v13.5H3z\"/><circle stroke=\"currentColor\" cx=\"3.5\" cy=\"16.5\" r=\"2\"/><path fill=\"currentColor\" d=\"M5.5 16H18v1H5.5z\"/><path stroke=\"currentColor\" d=\"M0 4L3.5.5 7 4m8 9l3.5 3.5L15 20\"/></g></svg>";
  },
  93379: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 28 28\" width=\"28\" height=\"28\"><g fill=\"currentColor\" fill-rule=\"nonzero\"><path d=\"M4 15h8.5v-1h-8.5zM16.5 15h8.5v-1h-8.5z\"/><path d=\"M14.5 16c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z\"/></g></svg>";
  },
  84959: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\"><path fill=\"currentColor\" d=\"M18.15 7.02A9.05 9.05 0 0014 6c-3.45 0-6.08 2-7.8 3.92a18.18 18.18 0 00-2.64 3.84v.02h-.01L4 14l-.45-.21-.1.21.1.21L4 14l-.45.21.01.03a5.85 5.85 0 00.16.32c.11.2.28.51.5.87a18.18 18.18 0 002.4 3.12l.71-.71A17.18 17.18 0 014.56 14a10.05 10.05 0 01.52-.91c.41-.69 1.04-1.6 1.85-2.5C8.58 8.75 10.95 7 14 7a8 8 0 013.4.77l.75-.75zm-3.11 3.12a4 4 0 00-4.9 4.9l.86-.87V14a3 3 0 013.17-3l.87-.86zm1.96 3.7l.86-.88a4 4 0 01-4.9 4.9l.87-.86A3 3 0 0017 13.83zm-6.4 6.4A8 8 0 0014 21c3.05 0 5.42-1.76 7.07-3.58A17.18 17.18 0 0023.44 14a9.47 9.47 0 00-.52-.91 17.18 17.18 0 00-2.25-2.93l.7-.7a18.18 18.18 0 013.06 4.3l.02.02L24 14l.45.21-.01.03a7.03 7.03 0 01-.16.32c-.11.2-.28.51-.5.87-.44.72-1.1 1.69-1.97 2.65C20.08 20.01 17.45 22 14 22c-1.55 0-2.94-.4-4.15-1.02l.75-.75zM24 14l.45-.21.1.21-.1.21L24 14zM22.2 6.5L6.5 22.2l-.7-.7L21.5 5.8l.7.7z\"/></svg>";
  },
  97874: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"28\" height=\"28\"><g fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\" transform=\"translate(6 4)\"><rect width=\"15\" height=\"12\" rx=\"2\" x=\".5\" y=\"7.5\"/><path stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 14v2\"/><path d=\"M11.5 7.5V4a3.5 3.5 0 0 0-7 0v3.5\"/></g></svg>";
  },
  77067: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 28 28\" width=\"28\" height=\"28\"><path fill=\"currentColor\" d=\"M13.39 3.84a1 1 0 0 1 1.22 0l8.19 6.37a1 1 0 0 1 0 1.58l-8.19 6.37a1 1 0 0 1-1.22 0L5.2 11.79a1 1 0 0 1 0-1.58l8.19-6.37zm.61.8L5.81 11 14 17.37 22.19 11 14 4.63zM5.3 13.6l8.7 6.76 8.7-6.76.6.78-8.69 6.77a1 1 0 0 1-1.22 0l-8.7-6.77.62-.78zm8.09 10.55l-8.7-6.77.62-.78L14 23.37l8.7-6.76.6.78-8.69 6.77a1 1 0 0 1-1.22 0z\"/></svg>";
  },
  76351: e => {
    e.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 36 28\" width=\"36\" height=\"28\"><path fill=\"currentColor\" d=\"M14 22H7V11H0V4h14v18zM28 22h-8l7.5-18h8L28 22z\"/><circle fill=\"currentColor\" cx=\"20\" cy=\"8\" r=\"4\"/></svg>";
  },
  9343: (e, t, i) => {
    "use strict";

    i.r(t);
    i.d(t, {
      LOGLEVEL: () => n,
      getLogHistory: () => b,
      getLogLevel: () => g,
      getLogger: () => C,
      getRawLogHistory: () => v,
      isHighRateEnabled: () => f,
      loggingOff: () => x,
      loggingOn: () => T,
      serializeLogHistoryEntry: () => S,
      setLogLevel: () => y
    });
    const s = typeof window != "undefined" ? window : {};
    let o = false;
    try {
      localStorage.getItem("");
      o = true;
    } catch (e) { }
    var n;
    (function (e) {
      e[e.ERROR = 1] = "ERROR";
      e[e.WARNING = 2] = "WARNING";
      e[e.INFO = 3] = "INFO";
      e[e.NORMAL = 4] = "NORMAL";
      e[e.DEBUG = 5] = "DEBUG";
    })(n ||= {});
    let r = 0;
    const a = "tv.logger.loglevel";
    const l = "tv.logger.logHighRate";
    const c = [];
    let h = null;
    let d = null;
    let u = null;
    let _ = null;
    let p = n.WARNING;
    let m = false;
    function g() {
      return p;
    }
    function f() {
      return m;
    }
    function y(e) {
      e = Math.max(n.ERROR, Math.min(n.DEBUG, e));
      p = e;
      I();
    }
    function v(e, t) {
      let i = c.reduce((e, t) => e.concat(t), []);
      i.sort((e, t) => e.id - t.id);
      if (t !== undefined) {
        i = i.filter(e => e.subSystemId === t);
      }
      if (typeof e == "number") {
        i = i.slice(-e);
      }
      return i;
    }
    function S(e) {
      return new Date(e.timestamp).toISOString() + ":" + e.subSystemId + ":" + e.message.replace(/"/g, "'");
    }
    const b = (e, t) => function (e, t) {
      let i;
      let s = 0;
      let o = 0;
      for (i = e.length - 1; i >= 1 && (s += (1 + encodeURIComponent(e[i]).length) * 8, !(i - 1 > 0) || !(o = (1 + encodeURIComponent(e[i - 1]).length) * 8, s + o > t)); i--);
      return e.slice(i);
    }(v(e, t).map(S), 75497472);
    function w(e, t, i, s) {
      if (t === d && s.id === u) {
        return;
      }
      const o = new Date();
      if (e <= n.NORMAL) {
        (function (e, t, i, s, o) {
          if (typeof structuredClone == "function") {
            t = structuredClone(t);
          }
          const n = {
            id: r,
            message: t,
            subSystemId: s,
            timestamp: Number(e)
          };
          r += 1;
          i.push(n);
          if (o !== undefined && i.length > o) {
            i.splice(0, 1);
          }
        })(o, t, i, s.id, s.maxCount);
      }
      if (e <= p && (!s.highRate || f()) && (!h || s.id.match(h))) {
        const i = o.toISOString() + ":" + s.id + ":" + t;
        switch (e) {
          case n.DEBUG:
            console.debug(i);
            break;
          case n.INFO:
          case n.NORMAL:
            if (s.color) {
              console.log("%c" + i, "color: " + s.color);
            } else {
              console.log(i);
            }
            break;
          case n.WARNING:
            console.warn(i);
            break;
          case n.ERROR:
            console.error(i);
        }
        d = t;
        u = s.id;
        if (_ !== null) {
          clearTimeout(_);
        }
        _ = setTimeout(() => {
          d = null;
          u = null;
          _ = null;
        }, 1000);
      }
    }
    function C(e, t = {}) {
      const i = [];
      c.push(i);
      const s = Object.assign(t, {
        id: e
      });
      function o(e) {
        return t => w(e, String(t), i, s);
      }
      return {
        logDebug: o(n.DEBUG),
        logError: o(n.ERROR),
        logInfo: o(n.INFO),
        logNormal: o(n.NORMAL),
        logWarn: o(n.WARNING)
      };
    }
    const P = C("logger");
    const T = (e, t) => {
      y(n.DEBUG);
      P.logNormal("Debug logging enabled");
      m = Boolean(e);
      h = t || null;
      I();
    };
    const x = () => {
      y(n.INFO);
      P.logInfo("Debug logging disabled");
    };
    function I() {
      try {
        if (o) {
          localStorage.setItem(l, String(m));
          localStorage.setItem(a, String(p));
        }
      } catch (e) {
        P.logWarn(`Cannot save logger state (level: ${p}, high-rate: ${m}) to localStorage: ${e.message}`);
      }
    }
    s.lget = b;
    s.lon = T;
    s.loff = x;
    (function () {
      m = !!o && localStorage.getItem(l) === "true";
      let e = parseInt(o && localStorage.getItem(a) || "");
      if (Number.isNaN(e)) {
        e = n.WARNING;
      }
      y(e);
      P.logNormal(`Init with settings - level: ${p}, high-rate: ${m}`);
    })();
    if (s.performance && s.performance.now) {
      P.logNormal(`Sync logger and perf times, now is ${s.performance.now()}`);
    } else {
      P.logWarn("Perf time is not available");
    }
  },
  75774: (e, t, i) => {
    "use strict";

    i.d(t, {
      isAndroid: () => p,
      isAnyMobile: () => v,
      isBlackBerry: () => m,
      isChrome: () => a,
      isEdge: () => c,
      isFF: () => l,
      isIOS: () => g,
      isIPad: () => y,
      isLinux: () => _,
      isMac: () => d,
      isOperaMini: () => f,
      isSafari: () => h,
      isWindows: () => u,
      mobiletouch: () => n,
      touch: () => r
    });
    const s = typeof window != "undefined" && typeof navigator != "undefined";
    const o = s && "ontouchstart" in window;
    const n = s && o && "onorientationchange" in window;
    const r = s && (o || !!navigator.maxTouchPoints);
    const a = s && window.chrome && window.chrome.runtime;
    const l = s && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
    const c = s && /\sEdge\/\d\d\b/.test(navigator.userAgent);
    const h = s && Boolean(navigator.vendor) && navigator.vendor.indexOf("Apple") > -1 && navigator.userAgent.indexOf("CriOS") === -1 && navigator.userAgent.indexOf("FxiOS") === -1;
    const d = s && /mac/i.test(navigator.platform);
    const u = s && /Win32|Win64/i.test(navigator.platform);
    const _ = s && /Linux/i.test(navigator.platform);
    const p = s && /Android/i.test(navigator.userAgent);
    const m = s && /BlackBerry/i.test(navigator.userAgent);
    const g = s && /iPhone|iPad|iPod/.test(navigator.platform);
    const f = s && /Opera Mini/i.test(navigator.userAgent);
    const y = s && (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1 || /iPad/.test(navigator.platform));
    const v = p || m || g || f;
  },
  87489: e => {
    "use strict";

    e.exports = {
      "4": ["v", ["h", 0, 2], ["h", 1, 3]],
      "6": ["v", ["h", 0, 2, 4], ["h", 1, 3, 5]],
      "8": ["v", ["h", 0, 2, 4, 6], ["h", 1, 3, 5, 7]],
      "2h": ["h", 0, 1],
      "2v": ["v", 0, 1],
      "2-1": ["v", ["h", 0, 2], 1],
      "3s": ["h", 0, ["v", 1, 2]],
      "3h": ["h", 0, 1, 2],
      "3v": ["v", 0, 1, 2],
      "1-2": ["v", 0, ["h", 1, 2]],
      "3r": ["h", ["v", 0, 1], 2],
      "4h": ["h", 0, 1, 2, 3],
      "4v": ["v", 0, 1, 2, 3],
      "4s": ["h", 0, ["v", 1, 2, 3]],
      "4s-l": ["h", ["v", 1, 2, 3], 0],
      "5h": ["h", 0, 1, 2, 3, 4],
      "5v": ["v", 0, 1, 2, 3, 4],
      "6h": ["h", 0, 1, 2, 3, 4, 5],
      "6v": ["v", 0, 1, 2, 3, 4, 5],
      "7h": ["h", 0, 1, 2, 3, 4, 5, 6],
      "8h": ["h", 0, 1, 2, 3, 4, 5, 6, 7],
      "8v": ["v", 0, 1, 2, 3, 4, 5, 6, 7],
      "9h": ["h", 0, 1, 2, 3, 4, 5, 6, 7, 8],
      "9v": ["v", 0, 1, 2, 3, 4, 5, 6, 7, 8],
      "10h": ["h", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      "10v": ["v", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      "1-3": ["v", 0, ["h", 1, 2, 3]],
      "2-2": ["v", ["h", 0, 1], ["v", 2, 3]],
      "2-2-l": ["h", 0, 1, ["v", 2, 3]],
      "2-3": ["v", ["h", 0, 1], ["h", 2, 3, 4]],
      "3-2": ["v", ["h", 0, 1, 2], ["h", 3, 4]],
      "1-4": ["v", 0, ["h", 1, 2, 3, 4]],
      "2-4": ["v", ["h", 0, 1], ["h", 2, 3, 4, 5]],
      "5s": ["h", 0, ["v", 1, 2, 3, 4]],
      "6c": ["v", ["h", 0, 1], ["h", 2, 3], ["h", 4, 5]],
      "8c": ["v", ["h", 0, 1], ["h", 2, 3], ["h", 4, 5], ["h", 6, 7]],
      "9s": ["v", ["h", 0, 1, 2], ["h", 3, 4, 5], ["h", 6, 7, 8]],
      "10c5": ["v", ["h", 0, 2, 4, 6, 8], ["h", 1, 3, 5, 7, 9]],
      "12c6": ["v", ["h", 0, 2, 4, 6, 8, 10], ["h", 1, 3, 5, 7, 9, 11]],
      "12c4": ["v", ["h", 0, 4, 8], ["h", 1, 5, 9], ["h", 2, 6, 10], ["h", 3, 7, 11]],
      "14c7": ["v", ["h", 0, 2, 4, 6, 8, 10, 12], ["h", 1, 3, 5, 7, 9, 11, 13]],
      "16c8": ["v", ["h", 0, 2, 4, 6, 8, 10, 12, 14], ["h", 1, 3, 5, 7, 9, 11, 13, 15]],
      "16c4": ["v", ["h", 0, 4, 8, 12], ["h", 1, 5, 9, 13], ["h", 2, 6, 10, 14], ["h", 3, 7, 11, 15]],
      s: 0
    };
  },
  23420: e => {
    "use strict";

    e.exports = {
      "color-white": "#ffffff",
      "color-black": "#000000",
      "color-transparent": "#00000000",
      "color-transparent-80": "#000000CC",
      "color-cold-gray-50": "#F9F9F9",
      "color-cold-gray-100": "#F2F2F2",
      "color-cold-gray-150": "#EBEBEB",
      "color-cold-gray-200": "#DBDBDB",
      "color-cold-gray-250": "#C9C9C9",
      "color-cold-gray-300": "#B8B8B8",
      "color-cold-gray-350": "#A8A8A8",
      "color-cold-gray-400": "#9C9C9C",
      "color-cold-gray-450": "#8C8C8C",
      "color-cold-gray-500": "#808080",
      "color-cold-gray-550": "#707070",
      "color-cold-gray-600": "#636363",
      "color-cold-gray-650": "#575757",
      "color-cold-gray-700": "#4A4A4A",
      "color-cold-gray-750": "#3D3D3D",
      "color-cold-gray-800": "#303030",
      "color-cold-gray-850": "#262626",
      "color-cold-gray-900": "#1A1A1A",
      "color-cold-gray-950": "#0F0F0F",
      "color-ripe-red-50": "#FFEBEC",
      "color-ripe-red-100": "#FCCBCD",
      "color-ripe-red-200": "#FAA1A4",
      "color-ripe-red-300": "#F77C80",
      "color-ripe-red-400": "#F7525F",
      "color-ripe-red-500": "#F23645",
      "color-ripe-red-600": "#CC2F3C",
      "color-ripe-red-700": "#B22833",
      "color-ripe-red-800": "#991F29",
      "color-ripe-red-900": "#801922",
      "color-ripe-red-a100": "#FF8080",
      "color-ripe-red-a200": "#FF5252",
      "color-ripe-red-a400": "#FF3333",
      "color-ripe-red-a600": "#CC2929",
      "color-ripe-red-a700": "#802028",
      "color-ripe-red-a800": "#4D191D",
      "color-ripe-red-a900": "#331F20",
      "color-tan-orange-50": "#FFF3E0",
      "color-tan-orange-100": "#FFE0B2",
      "color-tan-orange-200": "#FFCC80",
      "color-tan-orange-300": "#ffb74d",
      "color-tan-orange-400": "#FFA726",
      "color-tan-orange-500": "#FF9800",
      "color-tan-orange-600": "#FB8C00",
      "color-tan-orange-700": "#F57C00",
      "color-tan-orange-800": "#EF6C00",
      "color-tan-orange-900": "#e65100",
      "color-tan-orange-a100": "#FFD180",
      "color-tan-orange-a200": "#ffab40",
      "color-tan-orange-a400": "#FF9100",
      "color-tan-orange-a500": "#E57E17",
      "color-tan-orange-a600": "#CC7014",
      "color-tan-orange-a700": "#8C541C",
      "color-tan-orange-a800": "#593A1B",
      "color-tan-orange-a900": "#33261A",
      "color-iguana-green-50": "#E8F5E9",
      "color-iguana-green-100": "#C8E6C9",
      "color-iguana-green-200": "#A5D6A7",
      "color-iguana-green-300": "#81c784",
      "color-iguana-green-400": "#66BB6A",
      "color-iguana-green-500": "#4caf50",
      "color-iguana-green-600": "#43a047",
      "color-iguana-green-700": "#388e3c",
      "color-iguana-green-800": "#2E7D32",
      "color-iguana-green-900": "#1B5E20",
      "color-iguana-green-a100": "#B9F6CA",
      "color-iguana-green-a200": "#69F0AE",
      "color-iguana-green-a400": "#00E676",
      "color-iguana-green-a700": "#00c853",
      "color-banana-yellow-50": "#FFFDE7",
      "color-banana-yellow-100": "#FFF9C4",
      "color-banana-yellow-200": "#FFF59D",
      "color-banana-yellow-300": "#FFF176",
      "color-banana-yellow-400": "#ffee58",
      "color-banana-yellow-500": "#ffeb3b",
      "color-banana-yellow-600": "#fdd835",
      "color-banana-yellow-700": "#fbc02d",
      "color-banana-yellow-800": "#f9a825",
      "color-banana-yellow-900": "#F57F17",
      "color-banana-yellow-a100": "#FFFF8D",
      "color-banana-yellow-a200": "#FFFF00",
      "color-banana-yellow-a400": "#ffea00",
      "color-banana-yellow-a700": "#EEDA01",
      "color-tv-blue-50": "#E3EFFD",
      "color-tv-blue-100": "#BBD9FB",
      "color-tv-blue-200": "#90BFF9",
      "color-tv-blue-300": "#5B9CF6",
      "color-tv-blue-400": "#3179F5",
      "color-tv-blue-500": "#2962FF",
      "color-tv-blue-600": "#1E53E5",
      "color-tv-blue-700": "#1848CC",
      "color-tv-blue-800": "#143EB2",
      "color-tv-blue-900": "#0C3299",
      "color-tv-blue-a100": "#82b1ff",
      "color-tv-blue-a200": "#448aff",
      "color-tv-blue-a400": "#2979ff",
      "color-tv-blue-a600": "#2962FF",
      "color-tv-blue-a700": "#143A87",
      "color-tv-blue-a800": "#142E61",
      "color-tv-blue-a900": "#132042",
      "color-deep-blue-50": "#EDE7F6",
      "color-deep-blue-100": "#D1C4E9",
      "color-deep-blue-200": "#B39DDB",
      "color-deep-blue-300": "#9575cd",
      "color-deep-blue-400": "#7e57c2",
      "color-deep-blue-500": "#673ab7",
      "color-deep-blue-600": "#5E35B1",
      "color-deep-blue-700": "#512da8",
      "color-deep-blue-800": "#4527A0",
      "color-deep-blue-900": "#311B92",
      "color-deep-blue-a100": "#b388ff",
      "color-deep-blue-a200": "#7C4DFF",
      "color-deep-blue-a400": "#651FFF",
      "color-deep-blue-a700": "#6200EA",
      "color-minty-green-50": "#DAF2EE",
      "color-minty-green-100": "#ACE5DC",
      "color-minty-green-200": "#70CCBD",
      "color-minty-green-300": "#42BDA8",
      "color-minty-green-400": "#22AB94",
      "color-minty-green-500": "#089981",
      "color-minty-green-600": "#06806B",
      "color-minty-green-700": "#056656",
      "color-minty-green-800": "#004D40",
      "color-minty-green-900": "#00332A",
      "color-minty-green-a100": "#A7FFF0",
      "color-minty-green-a200": "#45E5CB",
      "color-minty-green-a400": "#2BD9BC",
      "color-minty-green-a600": "#24B29B",
      "color-minty-green-a700": "#1B7667",
      "color-minty-green-a800": "#10443B",
      "color-minty-green-a900": "#082621",
      "color-grapes-purple-50": "#F3E5F5",
      "color-grapes-purple-100": "#E1BEE7",
      "color-grapes-purple-200": "#CE93D8",
      "color-grapes-purple-300": "#ba68c8",
      "color-grapes-purple-400": "#ab47bc",
      "color-grapes-purple-500": "#9c27b0",
      "color-grapes-purple-600": "#8e24aa",
      "color-grapes-purple-700": "#7b1fa2",
      "color-grapes-purple-800": "#6A1B9A",
      "color-grapes-purple-900": "#4A148C",
      "color-grapes-purple-a100": "#EA80FC",
      "color-grapes-purple-a200": "#E040FB",
      "color-grapes-purple-a400": "#D500F9",
      "color-grapes-purple-a700": "#aa00ff",
      "color-berry-pink-50": "#FCE4EC",
      "color-berry-pink-100": "#F8BBD0",
      "color-berry-pink-200": "#f48fb1",
      "color-berry-pink-300": "#f06292",
      "color-berry-pink-400": "#ec407a",
      "color-berry-pink-500": "#e91e63",
      "color-berry-pink-600": "#D81B60",
      "color-berry-pink-700": "#C2185B",
      "color-berry-pink-800": "#AD1457",
      "color-berry-pink-900": "#880E4F",
      "color-berry-pink-a100": "#ff80ab",
      "color-berry-pink-a200": "#ff4081",
      "color-berry-pink-a400": "#f50057",
      "color-berry-pink-a700": "#c51162",
      "color-sky-blue-50": "#E0F7FA",
      "color-sky-blue-100": "#B2EBF2",
      "color-sky-blue-200": "#80DEEA",
      "color-sky-blue-300": "#4dd0e1",
      "color-sky-blue-400": "#26c6da",
      "color-sky-blue-500": "#00bcd4",
      "color-sky-blue-600": "#00acc1",
      "color-sky-blue-700": "#0097A7",
      "color-sky-blue-800": "#00838F",
      "color-sky-blue-900": "#006064",
      "color-sky-blue-a100": "#84FFFF",
      "color-sky-blue-a200": "#18FFFF",
      "color-sky-blue-a400": "#00e5ff",
      "color-sky-blue-a700": "#00B8D4",
      "color-forest-green-50": "#DAF2E6",
      "color-forest-green-100": "#ACE5C9",
      "color-forest-green-200": "#70CC9E",
      "color-forest-green-300": "#42BD7F",
      "color-forest-green-400": "#22AB67",
      "color-forest-green-500": "#089950",
      "color-forest-green-600": "#068043",
      "color-forest-green-700": "#056636",
      "color-forest-green-800": "#004D27",
      "color-forest-green-900": "#1A3326",
      "color-facebook": "#1877F2",
      "color-deep-facebook": "#1564CA",
      "color-twitter": "#1DA1F2",
      "color-deep-twitter": "#188CD3",
      "color-youtube": "#FF0000",
      "color-linkedin": "#007BB5",
      "color-seeking-alpha-brand": "#ff7200"
    };
  },
  20913: e => {
    "use strict";

    e.exports = {
      "color-header-bg": "color-black",
      "color-body-bg": "color-black",
      "color-body-secondary-bg": "color-cold-gray-900",
      "color-bg-primary": "color-cold-gray-850",
      "color-bg-primary-hover": "color-cold-gray-800",
      "color-bg-secondary": "color-cold-gray-900",
      "color-bg-highlight": "color-cold-gray-900",
      "color-bg-scroll-buttons": "color-cold-gray-800",
      "color-legacy-bg-scroll-buttons": "color-cold-gray-550",
      "color-legacy-bg-widget": "color-cold-gray-900",
      "color-text-primary": "color-cold-gray-200",
      "color-text-secondary": "color-cold-gray-450",
      "color-text-tertiary": "color-cold-gray-400",
      "color-text-disabled": "color-cold-gray-650",
      "color-accent-content": "color-white",
      "color-divider": "color-cold-gray-700",
      "color-divider-hover": "color-cold-gray-800",
      "color-divider-secondary": "color-cold-gray-800",
      "color-box-shadow": "color-cold-gray-900",
      "color-active-hover-text": "color-cold-gray-200",
      "color-alert-text": "color-cold-gray-200",
      "color-border": "color-cold-gray-750",
      "color-border-chat-fields": "color-cold-gray-750",
      "color-border-hover": "color-cold-gray-650",
      "color-border-table": "color-cold-gray-800",
      "color-brand": "color-tv-blue-500",
      "color-brand-hover": "color-tv-blue-600",
      "color-brand-active": "color-tv-blue-700",
      "color-button-hover-bg": "color-cold-gray-850",
      "color-chart-page-bg": "color-cold-gray-800",
      "color-common-tooltip-bg": "color-cold-gray-750",
      "color-danger": "color-ripe-red-600",
      "color-danger-hover": "color-ripe-red-500",
      "color-danger-active": "color-ripe-red-400",
      "color-depthrenderer-fill-style": "color-cold-gray-150",
      "color-depthrenderer-stroke-style": "color-cold-gray-650",
      "color-disabled-border-and-color": "color-cold-gray-800",
      "color-disabled-input": "color-cold-gray-750",
      "color-empty-container-message": "color-cold-gray-450",
      "color-halal": "color-iguana-green-400",
      "color-continuous": "color-cold-gray-500",
      "color-highlight-new": "color-tv-blue-a800",
      "color-icons": "color-cold-gray-450",
      "color-input-bg": "color-cold-gray-800",
      "color-input-textarea-readonly": "color-cold-gray-650",
      "color-input-placeholder-text": "color-cold-gray-700",
      "color-input-publish-bg": "color-cold-gray-900",
      "color-item-active-blue": "color-tv-blue-a900",
      "color-item-hover-active-bg": "color-cold-gray-800",
      "color-item-hover-bg": "color-cold-gray-800",
      "color-item-hover-blue": "color-tv-blue-a800",
      "color-item-selected-blue": "color-tv-blue-a800",
      "color-item-active-text": "color-cold-gray-200",
      "color-item-active-bg": "color-tv-blue-500",
      "color-link": "color-tv-blue-500",
      "color-link-hover": "color-tv-blue-600",
      "color-link-active": "color-tv-blue-700",
      "color-list-item": "color-cold-gray-450",
      "color-list-nth-child-bg": "color-cold-gray-850",
      "color-news-highlight": "color-cold-gray-800",
      "color-pane-bg": "color-cold-gray-900",
      "color-pane-secondary-bg": "color-cold-gray-850",
      "color-placeholder": "color-cold-gray-650",
      "color-popup-menu-item-hover-bg": "color-cold-gray-800",
      "color-popup-menu-separator": "color-cold-gray-700",
      "color-primary-symbol": "color-sky-blue-500",
      "color-row-hover-active-bg": "color-cold-gray-800",
      "color-sb-scrollbar-body-bg": "color-cold-gray-650",
      "color-screener-description": "color-cold-gray-200",
      "color-section-separator-border": "color-cold-gray-750",
      "color-search-button-hover": "color-cold-gray-700",
      "color-separator-table-chat": "color-cold-gray-750",
      "color-success": "color-minty-green-700",
      "color-success-hover": "color-minty-green-600",
      "color-success-active": "color-minty-green-500",
      "color-tag-active-bg": "color-cold-gray-750",
      "color-tag-hover-bg": "color-cold-gray-800",
      "color-text-regular": "color-cold-gray-200",
      "color-toolbar-button-text": "color-cold-gray-200",
      "color-toolbar-button-text-hover": "color-cold-gray-200",
      "color-toolbar-button-text-active": "color-tv-blue-500",
      "color-toolbar-button-text-active-hover": "color-tv-blue-600",
      "color-toolbar-button-background-hover": "color-cold-gray-800",
      "color-toolbar-button-background-secondary-hover": "color-cold-gray-750",
      "color-toolbar-button-background-active": "color-tv-blue-a900",
      "color-toolbar-button-background-active-hover": "color-tv-blue-a800",
      "color-toolbar-toggle-button-background-active": "color-tv-blue-500",
      "color-toolbar-toggle-button-background-active-hover": "color-tv-blue-600",
      "color-toolbar-toggle-button-icon": "color-cold-gray-650",
      "color-toolbar-interactive-element-text-normal": "color-cold-gray-200",
      "color-toolbar-opened-element-bg": "color-cold-gray-800",
      "color-toolbar-divider-background": "color-cold-gray-700",
      "color-popup-background": "color-cold-gray-850",
      "color-popup-element-text": "color-cold-gray-200",
      "color-popup-element-text-hover": "color-cold-gray-250",
      "color-popup-element-background-hover": "color-cold-gray-800",
      "color-popup-element-secondary-text": "color-cold-gray-500",
      "color-popup-element-hint-text": "color-cold-gray-600",
      "color-popup-element-text-active": "color-cold-gray-200",
      "color-popup-element-background-active": "color-tv-blue-500",
      "color-popup-element-toolbox-text": "color-cold-gray-500",
      "color-popup-element-toolbox-text-hover": "color-cold-gray-200",
      "color-popup-element-toolbox-text-active-hover": "color-tv-blue-200",
      "color-popup-element-toolbox-background-hover": "color-cold-gray-750",
      "color-popup-element-toolbox-background-active-hover": "color-tv-blue-700",
      "color-tooltip-bg": "color-cold-gray-750",
      "color-tv-button-checked": "color-cold-gray-450",
      "color-tv-dialog-caption": "color-cold-gray-50",
      "color-tv-dropdown-item-hover-bg": "color-cold-gray-800",
      "color-underlined-text": "color-cold-gray-450",
      "color-widget-pages-bg": "color-cold-gray-900",
      "color-warning": "color-tan-orange-700",
      "color-forex-icon": "color-white",
      "color-list-item-active-bg": "color-tv-blue-500",
      "color-list-item-hover-bg": "color-cold-gray-800",
      "color-list-item-text": "color-cold-gray-200",
      "color-price-axis-label-back": "color-cold-gray-800",
      "color-price-axis-label-text": "color-cold-gray-500",
      "color-price-axis-gear": "color-cold-gray-200",
      "color-price-axis-gear-hover": "color-cold-gray-400",
      "color-price-axis-highlight": "color-cold-gray-800",
      "color-bid": "color-tv-blue-500",
      "color-scroll-bg": "color-cold-gray-750",
      "color-scroll-border": "color-cold-gray-850",
      "color-widget-border": "color-cold-gray-800",
      "color-scroll-buttons-arrow": "color-white",
      "color-control-intent-default": "color-cold-gray-650",
      "color-control-intent-success": "color-minty-green-500",
      "color-control-intent-primary": "color-tv-blue-500",
      "color-control-intent-warning": "color-tan-orange-500",
      "color-control-intent-danger": "color-ripe-red-500",
      "color-growing": "color-minty-green-500",
      "color-falling": "color-ripe-red-500",
      "color-goto-label-background": "color-cold-gray-650",
      "color-pre-market": "color-tan-orange-600",
      "color-pre-market-bg": "color-tan-orange-400",
      "color-post-market": "color-tv-blue-500",
      "color-post-market-bg": "color-tv-blue-400",
      "color-market-open": "color-minty-green-500",
      "color-market-open-bg": "color-minty-green-400",
      "color-market-closed": "color-cold-gray-400",
      "color-market-holiday": "color-cold-gray-400",
      "color-market-expired": "color-ripe-red-500",
      "color-invalid-symbol": "color-ripe-red-400",
      "color-invalid-symbol-hover": "color-ripe-red-500",
      "color-delisted-symbol": "color-ripe-red-600",
      "color-delisted-symbol-hover": "color-ripe-red-800",
      "color-replay-mode": "color-tv-blue-500",
      "color-replay-mode-point-select": "color-cold-gray-250",
      "color-replay-mode-icon": "color-tv-blue-50",
      "color-replay-mode-hover": "color-tv-blue-600",
      "color-notaccurate-mode": "color-berry-pink-600",
      "color-delay-mode": "color-tan-orange-700",
      "color-delay-mode-bg": "color-tan-orange-400",
      "color-eod-mode": "color-grapes-purple-700",
      "color-eod-mode-bg": "color-grapes-purple-400",
      "color-data-problem": "color-ripe-red-600",
      "color-data-problem-bg": "color-ripe-red-400",
      "color-data-problem-hover": "color-ripe-red-500",
      "color-list-item-bg-highlighted": "color-tv-blue-a900",
      "color-list-item-bg-selected": "color-tv-blue-a800",
      "color-list-item-bg-highlighted-hover": "color-tv-blue-a800",
      "color-list-item-bg-selected-hover": "color-tv-blue-a700",
      "color-screener-header-bg": "color-cold-gray-850",
      "color-screener-header-bg-hover": "color-cold-gray-800",
      "color-overlay": "color-cold-gray-950",
      "color-boost-button-content-selected": "color-tv-blue-100",
      "color-boost-button-content-hover": "color-white",
      "color-boost-button-bg-hover": "color-cold-gray-750",
      "color-boost-button-border-hover": "color-cold-gray-750",
      "color-boost-button-border-default": "color-cold-gray-700",
      "color-x-twitter-content": "color-white",
      "color-card-border": "color-cold-gray-700",
      "color-card-border-hover": "color-cold-gray-600",
      "color-background-special-primary": "color-black",
      "color-stroke-special-primary": "color-cold-gray-800",
      "color-selection-bg": "color-tv-blue-a700",
      "color-default-gray": "color-cold-gray-450",
      "color-featured-broker-badge-bg": "color-white",
      "color-featured-broker-badge-bg-hover": "color-cold-gray-100",
      "color-featured-broker-badge-text": "color-cold-gray-900"
    };
  },
  579: e => {
    "use strict";

    e.exports = {
      "color-header-bg": "color-white",
      "color-body-bg": "color-white",
      "color-body-secondary-bg": "color-cold-gray-100",
      "color-bg-primary": "color-white",
      "color-bg-primary-hover": "color-cold-gray-100",
      "color-bg-secondary": "color-white",
      "color-bg-highlight": "color-cold-gray-50",
      "color-bg-scroll-buttons": "color-cold-gray-100",
      "color-legacy-bg-scroll-buttons": "color-cold-gray-850",
      "color-legacy-bg-widget": "color-white",
      "color-text-primary": "color-cold-gray-900",
      "color-text-secondary": "color-cold-gray-550",
      "color-text-tertiary": "color-cold-gray-400",
      "color-text-disabled": "color-cold-gray-300",
      "color-accent-content": "color-cold-gray-900",
      "color-box-shadow": "color-cold-gray-300",
      "color-divider": "color-cold-gray-150",
      "color-divider-hover": "color-cold-gray-100",
      "color-divider-secondary": "color-cold-gray-100",
      "color-active-hover-text": "color-cold-gray-900",
      "color-alert-text": "color-cold-gray-900",
      "color-border-table": "color-cold-gray-100",
      "color-brand": "color-tv-blue-500",
      "color-brand-active": "color-tv-blue-700",
      "color-brand-hover": "color-tv-blue-600",
      "color-chart-page-bg": "color-cold-gray-150",
      "color-common-tooltip-bg": "color-cold-gray-800",
      "color-danger": "color-ripe-red-400",
      "color-danger-hover": "color-ripe-red-500",
      "color-danger-active": "color-ripe-red-600",
      "color-depthrenderer-stroke-style": "color-cold-gray-100",
      "color-halal": "color-iguana-green-400",
      "color-continuous": "color-cold-gray-500",
      "color-tv-calculated-pair": "color-grapes-purple-400",
      "color-highlight-new": "color-tan-orange-50",
      "color-input-bg": "color-white",
      "color-input-publish-bg": "color-white",
      "color-link": "color-tv-blue-500",
      "color-link-hover": "color-tv-blue-600",
      "color-link-active": "color-tv-blue-700",
      "color-list-nth-child-bg": "color-cold-gray-50",
      "color-pane-bg": "color-white",
      "color-pane-secondary-bg": "color-cold-gray-100",
      "color-popup-menu-item-hover-bg": "color-cold-gray-100",
      "color-popup-menu-separator": "color-cold-gray-150",
      "color-primary-symbol": "color-sky-blue-500",
      "color-screener-description": "color-cold-gray-650",
      "color-success": "color-minty-green-500",
      "color-success-hover": "color-minty-green-600",
      "color-success-active": "color-minty-green-700",
      "color-toolbar-button-text": "color-cold-gray-900",
      "color-toolbar-button-text-hover": "color-cold-gray-900",
      "color-toolbar-button-text-active": "color-tv-blue-500",
      "color-toolbar-button-text-active-hover": "color-tv-blue-600",
      "color-toolbar-button-background-hover": "color-cold-gray-100",
      "color-toolbar-button-background-secondary-hover": "color-cold-gray-150",
      "color-toolbar-button-background-active": "color-tv-blue-50",
      "color-toolbar-button-background-active-hover": "color-tv-blue-100",
      "color-toolbar-toggle-button-background-active": "color-tv-blue-500",
      "color-toolbar-toggle-button-background-active-hover": "color-tv-blue-600",
      "color-toolbar-toggle-button-icon": "color-cold-gray-200",
      "color-toolbar-interactive-element-text-normal": "color-cold-gray-900",
      "color-toolbar-opened-element-bg": "color-cold-gray-100",
      "color-toolbar-divider-background": "color-cold-gray-150",
      "color-popup-background": "color-white",
      "color-popup-element-text": "color-cold-gray-900",
      "color-popup-element-text-hover": "color-cold-gray-900",
      "color-popup-element-background-hover": "color-cold-gray-100",
      "color-popup-element-secondary-text": "color-cold-gray-500",
      "color-popup-element-hint-text": "color-cold-gray-400",
      "color-popup-element-text-active": "color-white",
      "color-popup-element-background-active": "color-tv-blue-500",
      "color-popup-element-toolbox-text": "color-cold-gray-500",
      "color-popup-element-toolbox-text-hover": "color-cold-gray-900",
      "color-popup-element-toolbox-text-active-hover": "color-tv-blue-200",
      "color-popup-element-toolbox-background-hover": "color-cold-gray-150",
      "color-popup-element-toolbox-background-active-hover": "color-tv-blue-700",
      "color-tooltip-bg": "color-cold-gray-800",
      "color-tv-dialog-caption": "color-cold-gray-650",
      "color-tv-dropdown-item-hover-bg": "color-cold-gray-100",
      "color-underlined-text": "color-cold-gray-550",
      "color-widget-pages-bg": "color-white",
      "color-warning": "color-tan-orange-500",
      "color-growing": "color-minty-green-500",
      "color-falling": "color-ripe-red-500",
      "color-forex-icon": "color-cold-gray-750",
      "color-list-item-active-bg": "color-tv-blue-400",
      "color-list-item-hover-bg": "color-tv-blue-50",
      "color-list-item-text": "color-cold-gray-800",
      "color-price-axis-label-back": "color-cold-gray-150",
      "color-price-axis-label-text": "color-cold-gray-650",
      "color-price-axis-gear": "color-cold-gray-900",
      "color-price-axis-gear-hover": "color-black",
      "color-price-axis-highlight": "color-cold-gray-150",
      "color-bid": "color-tv-blue-500",
      "color-border": "color-cold-gray-150",
      "color-border-chat-fields": "color-cold-gray-250",
      "color-border-hover": "color-cold-gray-250",
      "color-button-hover-bg": "color-cold-gray-150",
      "color-depthrenderer-fill-style": "color-cold-gray-650",
      "color-disabled-border-and-color": "color-cold-gray-150",
      "color-disabled-input": "color-cold-gray-150",
      "color-empty-container-message": "color-cold-gray-550",
      "color-icons": "color-cold-gray-550",
      "color-input-textarea-readonly": "color-cold-gray-650",
      "color-input-placeholder-text": "color-cold-gray-350",
      "color-item-active-blue": "color-tv-blue-50",
      "color-item-hover-active-bg": "color-tv-blue-100",
      "color-item-hover-bg": "color-tv-blue-100",
      "color-item-hover-blue": "color-tv-blue-100",
      "color-item-selected-blue": "color-tv-blue-50",
      "color-item-active-text": "color-white",
      "color-item-active-bg": "color-tv-blue-500",
      "color-list-item": "color-cold-gray-550",
      "color-news-highlight": "color-tv-blue-100",
      "color-placeholder": "color-cold-gray-350",
      "color-row-hover-active-bg": "color-cold-gray-100",
      "color-sb-scrollbar-body-bg": "color-cold-gray-200",
      "color-section-separator-border": "color-cold-gray-300",
      "color-separator-table-chat": "color-cold-gray-150",
      "color-tag-active-bg": "color-cold-gray-200",
      "color-tag-hover-bg": "color-cold-gray-150",
      "color-text-regular": "color-cold-gray-700",
      "color-tv-button-checked": "color-cold-gray-550",
      "color-scroll-bg": "color-cold-gray-400",
      "color-scroll-border": "color-cold-gray-100",
      "color-widget-border": "color-cold-gray-100",
      "color-scroll-buttons-arrow": "color-white",
      "color-control-intent-default": "color-cold-gray-200",
      "color-control-intent-success": "color-minty-green-500",
      "color-control-intent-primary": "color-tv-blue-500",
      "color-control-intent-warning": "color-tan-orange-500",
      "color-control-intent-danger": "color-ripe-red-500",
      "color-goto-label-background": "color-cold-gray-800",
      "color-pre-market": "color-tan-orange-600",
      "color-pre-market-bg": "color-tan-orange-400",
      "color-post-market": "color-tv-blue-500",
      "color-post-market-bg": "color-tv-blue-400",
      "color-market-open": "color-minty-green-500",
      "color-market-open-bg": "color-minty-green-400",
      "color-market-closed": "color-cold-gray-400",
      "color-market-holiday": "color-cold-gray-400",
      "color-market-expired": "color-ripe-red-500",
      "color-invalid-symbol": "color-ripe-red-400",
      "color-invalid-symbol-hover": "color-ripe-red-700",
      "color-delisted-symbol": "color-ripe-red-600",
      "color-delisted-symbol-hover": "color-ripe-red-800",
      "color-replay-mode": "color-tv-blue-500",
      "color-replay-mode-point-select": "color-cold-gray-350",
      "color-replay-mode-icon": "color-white",
      "color-replay-mode-hover": "color-tv-blue-600",
      "color-notaccurate-mode": "color-berry-pink-600",
      "color-delay-mode": "color-tan-orange-700",
      "color-delay-mode-bg": "color-tan-orange-400",
      "color-eod-mode": "color-grapes-purple-700",
      "color-eod-mode-bg": "color-grapes-purple-400",
      "color-data-problem": "color-ripe-red-600",
      "color-data-problem-bg": "color-ripe-red-400",
      "color-data-problem-hover": "color-ripe-red-700",
      "color-list-item-bg-highlighted": "color-tv-blue-50",
      "color-list-item-bg-selected": "color-tv-blue-100",
      "color-list-item-bg-highlighted-hover": "color-tv-blue-100",
      "color-list-item-bg-selected-hover": "color-tv-blue-200",
      "color-screener-header-bg": "color-white",
      "color-screener-header-bg-hover": "color-cold-gray-100",
      "color-marker-flagged": "color-ripe-red-400",
      "color-marker-flagged-hovered": "color-ripe-red-600",
      "color-ask": "color-ripe-red-400",
      "color-sell": "color-ripe-red-400",
      "color-buy": "color-tv-blue-500",
      "color-neutral": "color-cold-gray-550",
      "color-pro": "color-minty-green-400",
      "color-pro-hover": "color-minty-green-600",
      "color-pro-plus": "color-tv-blue-500",
      "color-pro-plus-hover": "color-tv-blue-600",
      "color-pro-premium": "color-tan-orange-500",
      "color-pro-premium-hover": "color-tan-orange-700",
      "color-trial": "color-cold-gray-550",
      "color-trial-hover": "color-cold-gray-550",
      "color-mod": "color-ripe-red-400",
      "color-mod-hover": "color-ripe-red-600",
      "color-ad": "color-tan-orange-500",
      "color-broker-featured": "color-minty-green-400",
      "color-broker-featured-hover": "color-minty-green-600",
      "color-alert-status-active": "color-minty-green-400",
      "color-alert-status-stopped": "color-ripe-red-500",
      "color-alert-status-triggered": "color-tan-orange-500",
      "color-overlay": "color-cold-gray-400",
      "color-search-button-hover": "color-cold-gray-150",
      "color-boost-button-content-selected": "color-tv-blue-600",
      "color-boost-button-content-hover": "color-cold-gray-900",
      "color-boost-button-bg-hover": "color-cold-gray-150",
      "color-boost-button-border-hover": "color-cold-gray-150",
      "color-boost-button-border-default": "color-cold-gray-150",
      "color-common-tooltip-text": "color-cold-gray-100",
      "color-replay-data-mode": "color-ripe-red-400",
      "color-legacy-success": "color-minty-green-300",
      "color-collapse-tabs-border": "color-cold-gray-100",
      "color-site-widget-hover": "color-cold-gray-50",
      "color-attention": "color-banana-yellow-700",
      "color-x-twitter-content": "color-cold-gray-900",
      "color-card-border": "color-cold-gray-150",
      "color-card-border-hover": "color-cold-gray-300",
      "color-background-special-primary": "color-white",
      "color-stroke-special-primary": "color-cold-gray-150",
      "color-selection-bg": "color-tv-blue-100",
      "color-default-gray": "color-cold-gray-550",
      "color-featured-broker-badge-bg": "color-cold-gray-900",
      "color-featured-broker-badge-bg-hover": "color-cold-gray-800",
      "color-featured-broker-badge-text": "color-white"
    };
  }
}, e => {
  e.O(0, [9488, 1996, 207], () => {
    t = 23291;
    return e(e.s = t);
    var t;
  });
  e.O();
}]);